
TRACES_NonSecure.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000001f4  08040000  08040000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         0000df58  080401f8  080401f8  000011f8  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       000008bc  0804e150  0804e150  0000f150  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  0804ea0c  0804ea0c  000101a0  2**0
                  CONTENTS
  4 .ARM          00000000  0804ea0c  0804ea0c  000101a0  2**0
                  CONTENTS
  5 .preinit_array 00000000  0804ea0c  0804ea0c  000101a0  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  0804ea0c  0804ea0c  0000fa0c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000004  0804ea10  0804ea10  0000fa10  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         000001a0  20018000  0804ea14  00010000  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          000002fc  200181a0  0804ebb4  000101a0  2**2
                  ALLOC
 10 ._user_heap_stack 00020004  2001849c  0804ebb4  0001049c  2**0
                  ALLOC
 11 .ARM.attributes 00000036  00000000  00000000  000101a0  2**0
                  CONTENTS, READONLY
 12 .debug_info   0001c66e  00000000  00000000  000101d6  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_abbrev 0000273f  00000000  00000000  0002c844  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_aranges 00000a00  00000000  00000000  0002ef88  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_rnglists 000031fd  00000000  00000000  0002f988  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_macro  00029b0d  00000000  00000000  00032b85  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_line   0001b89f  00000000  00000000  0005c692  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_str    00105ddf  00000000  00000000  00077f31  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .comment      00000043  00000000  00000000  0017dd10  2**0
                  CONTENTS, READONLY
 20 .debug_frame  000038f4  00000000  00000000  0017dd54  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .debug_loclists 00018689  00000000  00000000  00181648  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 22 .debug_line_str 0000006f  00000000  00000000  00199cd1  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

080401f8 <__do_global_dtors_aux>:
 80401f8:	b510      	push	{r4, lr}
 80401fa:	4c05      	ldr	r4, [pc, #20]	@ (8040210 <__do_global_dtors_aux+0x18>)
 80401fc:	7823      	ldrb	r3, [r4, #0]
 80401fe:	b933      	cbnz	r3, 804020e <__do_global_dtors_aux+0x16>
 8040200:	4b04      	ldr	r3, [pc, #16]	@ (8040214 <__do_global_dtors_aux+0x1c>)
 8040202:	b113      	cbz	r3, 804020a <__do_global_dtors_aux+0x12>
 8040204:	4804      	ldr	r0, [pc, #16]	@ (8040218 <__do_global_dtors_aux+0x20>)
 8040206:	f3af 8000 	nop.w
 804020a:	2301      	movs	r3, #1
 804020c:	7023      	strb	r3, [r4, #0]
 804020e:	bd10      	pop	{r4, pc}
 8040210:	200181a0 	.word	0x200181a0
 8040214:	00000000 	.word	0x00000000
 8040218:	0804e0fc 	.word	0x0804e0fc

0804021c <frame_dummy>:
 804021c:	b508      	push	{r3, lr}
 804021e:	4b03      	ldr	r3, [pc, #12]	@ (804022c <frame_dummy+0x10>)
 8040220:	b11b      	cbz	r3, 804022a <frame_dummy+0xe>
 8040222:	4903      	ldr	r1, [pc, #12]	@ (8040230 <frame_dummy+0x14>)
 8040224:	4803      	ldr	r0, [pc, #12]	@ (8040234 <frame_dummy+0x18>)
 8040226:	f3af 8000 	nop.w
 804022a:	bd08      	pop	{r3, pc}
 804022c:	00000000 	.word	0x00000000
 8040230:	200181a4 	.word	0x200181a4
 8040234:	0804e0fc 	.word	0x0804e0fc

08040238 <__aeabi_drsub>:
 8040238:	f081 4100 	eor.w	r1, r1, #2147483648	@ 0x80000000
 804023c:	e002      	b.n	8040244 <__adddf3>
 804023e:	bf00      	nop

08040240 <__aeabi_dsub>:
 8040240:	f083 4300 	eor.w	r3, r3, #2147483648	@ 0x80000000

08040244 <__adddf3>:
 8040244:	b530      	push	{r4, r5, lr}
 8040246:	ea4f 0441 	mov.w	r4, r1, lsl #1
 804024a:	ea4f 0543 	mov.w	r5, r3, lsl #1
 804024e:	ea94 0f05 	teq	r4, r5
 8040252:	bf08      	it	eq
 8040254:	ea90 0f02 	teqeq	r0, r2
 8040258:	bf1f      	itttt	ne
 804025a:	ea54 0c00 	orrsne.w	ip, r4, r0
 804025e:	ea55 0c02 	orrsne.w	ip, r5, r2
 8040262:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 8040266:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 804026a:	f000 80e2 	beq.w	8040432 <__adddf3+0x1ee>
 804026e:	ea4f 5454 	mov.w	r4, r4, lsr #21
 8040272:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 8040276:	bfb8      	it	lt
 8040278:	426d      	neglt	r5, r5
 804027a:	dd0c      	ble.n	8040296 <__adddf3+0x52>
 804027c:	442c      	add	r4, r5
 804027e:	ea80 0202 	eor.w	r2, r0, r2
 8040282:	ea81 0303 	eor.w	r3, r1, r3
 8040286:	ea82 0000 	eor.w	r0, r2, r0
 804028a:	ea83 0101 	eor.w	r1, r3, r1
 804028e:	ea80 0202 	eor.w	r2, r0, r2
 8040292:	ea81 0303 	eor.w	r3, r1, r3
 8040296:	2d36      	cmp	r5, #54	@ 0x36
 8040298:	bf88      	it	hi
 804029a:	bd30      	pophi	{r4, r5, pc}
 804029c:	f011 4f00 	tst.w	r1, #2147483648	@ 0x80000000
 80402a0:	ea4f 3101 	mov.w	r1, r1, lsl #12
 80402a4:	f44f 1c80 	mov.w	ip, #1048576	@ 0x100000
 80402a8:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 80402ac:	d002      	beq.n	80402b4 <__adddf3+0x70>
 80402ae:	4240      	negs	r0, r0
 80402b0:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 80402b4:	f013 4f00 	tst.w	r3, #2147483648	@ 0x80000000
 80402b8:	ea4f 3303 	mov.w	r3, r3, lsl #12
 80402bc:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 80402c0:	d002      	beq.n	80402c8 <__adddf3+0x84>
 80402c2:	4252      	negs	r2, r2
 80402c4:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 80402c8:	ea94 0f05 	teq	r4, r5
 80402cc:	f000 80a7 	beq.w	804041e <__adddf3+0x1da>
 80402d0:	f1a4 0401 	sub.w	r4, r4, #1
 80402d4:	f1d5 0e20 	rsbs	lr, r5, #32
 80402d8:	db0d      	blt.n	80402f6 <__adddf3+0xb2>
 80402da:	fa02 fc0e 	lsl.w	ip, r2, lr
 80402de:	fa22 f205 	lsr.w	r2, r2, r5
 80402e2:	1880      	adds	r0, r0, r2
 80402e4:	f141 0100 	adc.w	r1, r1, #0
 80402e8:	fa03 f20e 	lsl.w	r2, r3, lr
 80402ec:	1880      	adds	r0, r0, r2
 80402ee:	fa43 f305 	asr.w	r3, r3, r5
 80402f2:	4159      	adcs	r1, r3
 80402f4:	e00e      	b.n	8040314 <__adddf3+0xd0>
 80402f6:	f1a5 0520 	sub.w	r5, r5, #32
 80402fa:	f10e 0e20 	add.w	lr, lr, #32
 80402fe:	2a01      	cmp	r2, #1
 8040300:	fa03 fc0e 	lsl.w	ip, r3, lr
 8040304:	bf28      	it	cs
 8040306:	f04c 0c02 	orrcs.w	ip, ip, #2
 804030a:	fa43 f305 	asr.w	r3, r3, r5
 804030e:	18c0      	adds	r0, r0, r3
 8040310:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 8040314:	f001 4500 	and.w	r5, r1, #2147483648	@ 0x80000000
 8040318:	d507      	bpl.n	804032a <__adddf3+0xe6>
 804031a:	f04f 0e00 	mov.w	lr, #0
 804031e:	f1dc 0c00 	rsbs	ip, ip, #0
 8040322:	eb7e 0000 	sbcs.w	r0, lr, r0
 8040326:	eb6e 0101 	sbc.w	r1, lr, r1
 804032a:	f5b1 1f80 	cmp.w	r1, #1048576	@ 0x100000
 804032e:	d31b      	bcc.n	8040368 <__adddf3+0x124>
 8040330:	f5b1 1f00 	cmp.w	r1, #2097152	@ 0x200000
 8040334:	d30c      	bcc.n	8040350 <__adddf3+0x10c>
 8040336:	0849      	lsrs	r1, r1, #1
 8040338:	ea5f 0030 	movs.w	r0, r0, rrx
 804033c:	ea4f 0c3c 	mov.w	ip, ip, rrx
 8040340:	f104 0401 	add.w	r4, r4, #1
 8040344:	ea4f 5244 	mov.w	r2, r4, lsl #21
 8040348:	f512 0f80 	cmn.w	r2, #4194304	@ 0x400000
 804034c:	f080 809a 	bcs.w	8040484 <__adddf3+0x240>
 8040350:	f1bc 4f00 	cmp.w	ip, #2147483648	@ 0x80000000
 8040354:	bf08      	it	eq
 8040356:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 804035a:	f150 0000 	adcs.w	r0, r0, #0
 804035e:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 8040362:	ea41 0105 	orr.w	r1, r1, r5
 8040366:	bd30      	pop	{r4, r5, pc}
 8040368:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 804036c:	4140      	adcs	r0, r0
 804036e:	eb41 0101 	adc.w	r1, r1, r1
 8040372:	3c01      	subs	r4, #1
 8040374:	bf28      	it	cs
 8040376:	f5b1 1f80 	cmpcs.w	r1, #1048576	@ 0x100000
 804037a:	d2e9      	bcs.n	8040350 <__adddf3+0x10c>
 804037c:	f091 0f00 	teq	r1, #0
 8040380:	bf04      	itt	eq
 8040382:	4601      	moveq	r1, r0
 8040384:	2000      	moveq	r0, #0
 8040386:	fab1 f381 	clz	r3, r1
 804038a:	bf08      	it	eq
 804038c:	3320      	addeq	r3, #32
 804038e:	f1a3 030b 	sub.w	r3, r3, #11
 8040392:	f1b3 0220 	subs.w	r2, r3, #32
 8040396:	da0c      	bge.n	80403b2 <__adddf3+0x16e>
 8040398:	320c      	adds	r2, #12
 804039a:	dd08      	ble.n	80403ae <__adddf3+0x16a>
 804039c:	f102 0c14 	add.w	ip, r2, #20
 80403a0:	f1c2 020c 	rsb	r2, r2, #12
 80403a4:	fa01 f00c 	lsl.w	r0, r1, ip
 80403a8:	fa21 f102 	lsr.w	r1, r1, r2
 80403ac:	e00c      	b.n	80403c8 <__adddf3+0x184>
 80403ae:	f102 0214 	add.w	r2, r2, #20
 80403b2:	bfd8      	it	le
 80403b4:	f1c2 0c20 	rsble	ip, r2, #32
 80403b8:	fa01 f102 	lsl.w	r1, r1, r2
 80403bc:	fa20 fc0c 	lsr.w	ip, r0, ip
 80403c0:	bfdc      	itt	le
 80403c2:	ea41 010c 	orrle.w	r1, r1, ip
 80403c6:	4090      	lslle	r0, r2
 80403c8:	1ae4      	subs	r4, r4, r3
 80403ca:	bfa2      	ittt	ge
 80403cc:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 80403d0:	4329      	orrge	r1, r5
 80403d2:	bd30      	popge	{r4, r5, pc}
 80403d4:	ea6f 0404 	mvn.w	r4, r4
 80403d8:	3c1f      	subs	r4, #31
 80403da:	da1c      	bge.n	8040416 <__adddf3+0x1d2>
 80403dc:	340c      	adds	r4, #12
 80403de:	dc0e      	bgt.n	80403fe <__adddf3+0x1ba>
 80403e0:	f104 0414 	add.w	r4, r4, #20
 80403e4:	f1c4 0220 	rsb	r2, r4, #32
 80403e8:	fa20 f004 	lsr.w	r0, r0, r4
 80403ec:	fa01 f302 	lsl.w	r3, r1, r2
 80403f0:	ea40 0003 	orr.w	r0, r0, r3
 80403f4:	fa21 f304 	lsr.w	r3, r1, r4
 80403f8:	ea45 0103 	orr.w	r1, r5, r3
 80403fc:	bd30      	pop	{r4, r5, pc}
 80403fe:	f1c4 040c 	rsb	r4, r4, #12
 8040402:	f1c4 0220 	rsb	r2, r4, #32
 8040406:	fa20 f002 	lsr.w	r0, r0, r2
 804040a:	fa01 f304 	lsl.w	r3, r1, r4
 804040e:	ea40 0003 	orr.w	r0, r0, r3
 8040412:	4629      	mov	r1, r5
 8040414:	bd30      	pop	{r4, r5, pc}
 8040416:	fa21 f004 	lsr.w	r0, r1, r4
 804041a:	4629      	mov	r1, r5
 804041c:	bd30      	pop	{r4, r5, pc}
 804041e:	f094 0f00 	teq	r4, #0
 8040422:	f483 1380 	eor.w	r3, r3, #1048576	@ 0x100000
 8040426:	bf06      	itte	eq
 8040428:	f481 1180 	eoreq.w	r1, r1, #1048576	@ 0x100000
 804042c:	3401      	addeq	r4, #1
 804042e:	3d01      	subne	r5, #1
 8040430:	e74e      	b.n	80402d0 <__adddf3+0x8c>
 8040432:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 8040436:	bf18      	it	ne
 8040438:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 804043c:	d029      	beq.n	8040492 <__adddf3+0x24e>
 804043e:	ea94 0f05 	teq	r4, r5
 8040442:	bf08      	it	eq
 8040444:	ea90 0f02 	teqeq	r0, r2
 8040448:	d005      	beq.n	8040456 <__adddf3+0x212>
 804044a:	ea54 0c00 	orrs.w	ip, r4, r0
 804044e:	bf04      	itt	eq
 8040450:	4619      	moveq	r1, r3
 8040452:	4610      	moveq	r0, r2
 8040454:	bd30      	pop	{r4, r5, pc}
 8040456:	ea91 0f03 	teq	r1, r3
 804045a:	bf1e      	ittt	ne
 804045c:	2100      	movne	r1, #0
 804045e:	2000      	movne	r0, #0
 8040460:	bd30      	popne	{r4, r5, pc}
 8040462:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 8040466:	d105      	bne.n	8040474 <__adddf3+0x230>
 8040468:	0040      	lsls	r0, r0, #1
 804046a:	4149      	adcs	r1, r1
 804046c:	bf28      	it	cs
 804046e:	f041 4100 	orrcs.w	r1, r1, #2147483648	@ 0x80000000
 8040472:	bd30      	pop	{r4, r5, pc}
 8040474:	f514 0480 	adds.w	r4, r4, #4194304	@ 0x400000
 8040478:	bf3c      	itt	cc
 804047a:	f501 1180 	addcc.w	r1, r1, #1048576	@ 0x100000
 804047e:	bd30      	popcc	{r4, r5, pc}
 8040480:	f001 4500 	and.w	r5, r1, #2147483648	@ 0x80000000
 8040484:	f045 41fe 	orr.w	r1, r5, #2130706432	@ 0x7f000000
 8040488:	f441 0170 	orr.w	r1, r1, #15728640	@ 0xf00000
 804048c:	f04f 0000 	mov.w	r0, #0
 8040490:	bd30      	pop	{r4, r5, pc}
 8040492:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 8040496:	bf1a      	itte	ne
 8040498:	4619      	movne	r1, r3
 804049a:	4610      	movne	r0, r2
 804049c:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 80404a0:	bf1c      	itt	ne
 80404a2:	460b      	movne	r3, r1
 80404a4:	4602      	movne	r2, r0
 80404a6:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 80404aa:	bf06      	itte	eq
 80404ac:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 80404b0:	ea91 0f03 	teqeq	r1, r3
 80404b4:	f441 2100 	orrne.w	r1, r1, #524288	@ 0x80000
 80404b8:	bd30      	pop	{r4, r5, pc}
 80404ba:	bf00      	nop

080404bc <__aeabi_ui2d>:
 80404bc:	f090 0f00 	teq	r0, #0
 80404c0:	bf04      	itt	eq
 80404c2:	2100      	moveq	r1, #0
 80404c4:	4770      	bxeq	lr
 80404c6:	b530      	push	{r4, r5, lr}
 80404c8:	f44f 6480 	mov.w	r4, #1024	@ 0x400
 80404cc:	f104 0432 	add.w	r4, r4, #50	@ 0x32
 80404d0:	f04f 0500 	mov.w	r5, #0
 80404d4:	f04f 0100 	mov.w	r1, #0
 80404d8:	e750      	b.n	804037c <__adddf3+0x138>
 80404da:	bf00      	nop

080404dc <__aeabi_i2d>:
 80404dc:	f090 0f00 	teq	r0, #0
 80404e0:	bf04      	itt	eq
 80404e2:	2100      	moveq	r1, #0
 80404e4:	4770      	bxeq	lr
 80404e6:	b530      	push	{r4, r5, lr}
 80404e8:	f44f 6480 	mov.w	r4, #1024	@ 0x400
 80404ec:	f104 0432 	add.w	r4, r4, #50	@ 0x32
 80404f0:	f010 4500 	ands.w	r5, r0, #2147483648	@ 0x80000000
 80404f4:	bf48      	it	mi
 80404f6:	4240      	negmi	r0, r0
 80404f8:	f04f 0100 	mov.w	r1, #0
 80404fc:	e73e      	b.n	804037c <__adddf3+0x138>
 80404fe:	bf00      	nop

08040500 <__aeabi_f2d>:
 8040500:	0042      	lsls	r2, r0, #1
 8040502:	ea4f 01e2 	mov.w	r1, r2, asr #3
 8040506:	ea4f 0131 	mov.w	r1, r1, rrx
 804050a:	ea4f 7002 	mov.w	r0, r2, lsl #28
 804050e:	bf1f      	itttt	ne
 8040510:	f012 437f 	andsne.w	r3, r2, #4278190080	@ 0xff000000
 8040514:	f093 4f7f 	teqne	r3, #4278190080	@ 0xff000000
 8040518:	f081 5160 	eorne.w	r1, r1, #939524096	@ 0x38000000
 804051c:	4770      	bxne	lr
 804051e:	f032 427f 	bics.w	r2, r2, #4278190080	@ 0xff000000
 8040522:	bf08      	it	eq
 8040524:	4770      	bxeq	lr
 8040526:	f093 4f7f 	teq	r3, #4278190080	@ 0xff000000
 804052a:	bf04      	itt	eq
 804052c:	f441 2100 	orreq.w	r1, r1, #524288	@ 0x80000
 8040530:	4770      	bxeq	lr
 8040532:	b530      	push	{r4, r5, lr}
 8040534:	f44f 7460 	mov.w	r4, #896	@ 0x380
 8040538:	f001 4500 	and.w	r5, r1, #2147483648	@ 0x80000000
 804053c:	f021 4100 	bic.w	r1, r1, #2147483648	@ 0x80000000
 8040540:	e71c      	b.n	804037c <__adddf3+0x138>
 8040542:	bf00      	nop

08040544 <__aeabi_ul2d>:
 8040544:	ea50 0201 	orrs.w	r2, r0, r1
 8040548:	bf08      	it	eq
 804054a:	4770      	bxeq	lr
 804054c:	b530      	push	{r4, r5, lr}
 804054e:	f04f 0500 	mov.w	r5, #0
 8040552:	e00a      	b.n	804056a <__aeabi_l2d+0x16>

08040554 <__aeabi_l2d>:
 8040554:	ea50 0201 	orrs.w	r2, r0, r1
 8040558:	bf08      	it	eq
 804055a:	4770      	bxeq	lr
 804055c:	b530      	push	{r4, r5, lr}
 804055e:	f011 4500 	ands.w	r5, r1, #2147483648	@ 0x80000000
 8040562:	d502      	bpl.n	804056a <__aeabi_l2d+0x16>
 8040564:	4240      	negs	r0, r0
 8040566:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 804056a:	f44f 6480 	mov.w	r4, #1024	@ 0x400
 804056e:	f104 0432 	add.w	r4, r4, #50	@ 0x32
 8040572:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 8040576:	f43f aed8 	beq.w	804032a <__adddf3+0xe6>
 804057a:	f04f 0203 	mov.w	r2, #3
 804057e:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 8040582:	bf18      	it	ne
 8040584:	3203      	addne	r2, #3
 8040586:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 804058a:	bf18      	it	ne
 804058c:	3203      	addne	r2, #3
 804058e:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 8040592:	f1c2 0320 	rsb	r3, r2, #32
 8040596:	fa00 fc03 	lsl.w	ip, r0, r3
 804059a:	fa20 f002 	lsr.w	r0, r0, r2
 804059e:	fa01 fe03 	lsl.w	lr, r1, r3
 80405a2:	ea40 000e 	orr.w	r0, r0, lr
 80405a6:	fa21 f102 	lsr.w	r1, r1, r2
 80405aa:	4414      	add	r4, r2
 80405ac:	e6bd      	b.n	804032a <__adddf3+0xe6>
 80405ae:	bf00      	nop

080405b0 <__aeabi_dmul>:
 80405b0:	b570      	push	{r4, r5, r6, lr}
 80405b2:	f04f 0cff 	mov.w	ip, #255	@ 0xff
 80405b6:	f44c 6ce0 	orr.w	ip, ip, #1792	@ 0x700
 80405ba:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 80405be:	bf1d      	ittte	ne
 80405c0:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 80405c4:	ea94 0f0c 	teqne	r4, ip
 80405c8:	ea95 0f0c 	teqne	r5, ip
 80405cc:	f000 f8de 	bleq	804078c <__aeabi_dmul+0x1dc>
 80405d0:	442c      	add	r4, r5
 80405d2:	ea81 0603 	eor.w	r6, r1, r3
 80405d6:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
 80405da:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
 80405de:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
 80405e2:	bf18      	it	ne
 80405e4:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
 80405e8:	f441 1180 	orr.w	r1, r1, #1048576	@ 0x100000
 80405ec:	f443 1380 	orr.w	r3, r3, #1048576	@ 0x100000
 80405f0:	d038      	beq.n	8040664 <__aeabi_dmul+0xb4>
 80405f2:	fba0 ce02 	umull	ip, lr, r0, r2
 80405f6:	f04f 0500 	mov.w	r5, #0
 80405fa:	fbe1 e502 	umlal	lr, r5, r1, r2
 80405fe:	f006 4200 	and.w	r2, r6, #2147483648	@ 0x80000000
 8040602:	fbe0 e503 	umlal	lr, r5, r0, r3
 8040606:	f04f 0600 	mov.w	r6, #0
 804060a:	fbe1 5603 	umlal	r5, r6, r1, r3
 804060e:	f09c 0f00 	teq	ip, #0
 8040612:	bf18      	it	ne
 8040614:	f04e 0e01 	orrne.w	lr, lr, #1
 8040618:	f1a4 04ff 	sub.w	r4, r4, #255	@ 0xff
 804061c:	f5b6 7f00 	cmp.w	r6, #512	@ 0x200
 8040620:	f564 7440 	sbc.w	r4, r4, #768	@ 0x300
 8040624:	d204      	bcs.n	8040630 <__aeabi_dmul+0x80>
 8040626:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
 804062a:	416d      	adcs	r5, r5
 804062c:	eb46 0606 	adc.w	r6, r6, r6
 8040630:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
 8040634:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
 8040638:	ea4f 20c5 	mov.w	r0, r5, lsl #11
 804063c:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
 8040640:	ea4f 2ece 	mov.w	lr, lr, lsl #11
 8040644:	f1b4 0cfd 	subs.w	ip, r4, #253	@ 0xfd
 8040648:	bf88      	it	hi
 804064a:	f5bc 6fe0 	cmphi.w	ip, #1792	@ 0x700
 804064e:	d81e      	bhi.n	804068e <__aeabi_dmul+0xde>
 8040650:	f1be 4f00 	cmp.w	lr, #2147483648	@ 0x80000000
 8040654:	bf08      	it	eq
 8040656:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
 804065a:	f150 0000 	adcs.w	r0, r0, #0
 804065e:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 8040662:	bd70      	pop	{r4, r5, r6, pc}
 8040664:	f006 4600 	and.w	r6, r6, #2147483648	@ 0x80000000
 8040668:	ea46 0101 	orr.w	r1, r6, r1
 804066c:	ea40 0002 	orr.w	r0, r0, r2
 8040670:	ea81 0103 	eor.w	r1, r1, r3
 8040674:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
 8040678:	bfc2      	ittt	gt
 804067a:	ebd4 050c 	rsbsgt	r5, r4, ip
 804067e:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 8040682:	bd70      	popgt	{r4, r5, r6, pc}
 8040684:	f441 1180 	orr.w	r1, r1, #1048576	@ 0x100000
 8040688:	f04f 0e00 	mov.w	lr, #0
 804068c:	3c01      	subs	r4, #1
 804068e:	f300 80ab 	bgt.w	80407e8 <__aeabi_dmul+0x238>
 8040692:	f114 0f36 	cmn.w	r4, #54	@ 0x36
 8040696:	bfde      	ittt	le
 8040698:	2000      	movle	r0, #0
 804069a:	f001 4100 	andle.w	r1, r1, #2147483648	@ 0x80000000
 804069e:	bd70      	pople	{r4, r5, r6, pc}
 80406a0:	f1c4 0400 	rsb	r4, r4, #0
 80406a4:	3c20      	subs	r4, #32
 80406a6:	da35      	bge.n	8040714 <__aeabi_dmul+0x164>
 80406a8:	340c      	adds	r4, #12
 80406aa:	dc1b      	bgt.n	80406e4 <__aeabi_dmul+0x134>
 80406ac:	f104 0414 	add.w	r4, r4, #20
 80406b0:	f1c4 0520 	rsb	r5, r4, #32
 80406b4:	fa00 f305 	lsl.w	r3, r0, r5
 80406b8:	fa20 f004 	lsr.w	r0, r0, r4
 80406bc:	fa01 f205 	lsl.w	r2, r1, r5
 80406c0:	ea40 0002 	orr.w	r0, r0, r2
 80406c4:	f001 4200 	and.w	r2, r1, #2147483648	@ 0x80000000
 80406c8:	f021 4100 	bic.w	r1, r1, #2147483648	@ 0x80000000
 80406cc:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 80406d0:	fa21 f604 	lsr.w	r6, r1, r4
 80406d4:	eb42 0106 	adc.w	r1, r2, r6
 80406d8:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 80406dc:	bf08      	it	eq
 80406de:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 80406e2:	bd70      	pop	{r4, r5, r6, pc}
 80406e4:	f1c4 040c 	rsb	r4, r4, #12
 80406e8:	f1c4 0520 	rsb	r5, r4, #32
 80406ec:	fa00 f304 	lsl.w	r3, r0, r4
 80406f0:	fa20 f005 	lsr.w	r0, r0, r5
 80406f4:	fa01 f204 	lsl.w	r2, r1, r4
 80406f8:	ea40 0002 	orr.w	r0, r0, r2
 80406fc:	f001 4100 	and.w	r1, r1, #2147483648	@ 0x80000000
 8040700:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 8040704:	f141 0100 	adc.w	r1, r1, #0
 8040708:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 804070c:	bf08      	it	eq
 804070e:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 8040712:	bd70      	pop	{r4, r5, r6, pc}
 8040714:	f1c4 0520 	rsb	r5, r4, #32
 8040718:	fa00 f205 	lsl.w	r2, r0, r5
 804071c:	ea4e 0e02 	orr.w	lr, lr, r2
 8040720:	fa20 f304 	lsr.w	r3, r0, r4
 8040724:	fa01 f205 	lsl.w	r2, r1, r5
 8040728:	ea43 0302 	orr.w	r3, r3, r2
 804072c:	fa21 f004 	lsr.w	r0, r1, r4
 8040730:	f001 4100 	and.w	r1, r1, #2147483648	@ 0x80000000
 8040734:	fa21 f204 	lsr.w	r2, r1, r4
 8040738:	ea20 0002 	bic.w	r0, r0, r2
 804073c:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
 8040740:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8040744:	bf08      	it	eq
 8040746:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 804074a:	bd70      	pop	{r4, r5, r6, pc}
 804074c:	f094 0f00 	teq	r4, #0
 8040750:	d10f      	bne.n	8040772 <__aeabi_dmul+0x1c2>
 8040752:	f001 4600 	and.w	r6, r1, #2147483648	@ 0x80000000
 8040756:	0040      	lsls	r0, r0, #1
 8040758:	eb41 0101 	adc.w	r1, r1, r1
 804075c:	f411 1f80 	tst.w	r1, #1048576	@ 0x100000
 8040760:	bf08      	it	eq
 8040762:	3c01      	subeq	r4, #1
 8040764:	d0f7      	beq.n	8040756 <__aeabi_dmul+0x1a6>
 8040766:	ea41 0106 	orr.w	r1, r1, r6
 804076a:	f095 0f00 	teq	r5, #0
 804076e:	bf18      	it	ne
 8040770:	4770      	bxne	lr
 8040772:	f003 4600 	and.w	r6, r3, #2147483648	@ 0x80000000
 8040776:	0052      	lsls	r2, r2, #1
 8040778:	eb43 0303 	adc.w	r3, r3, r3
 804077c:	f413 1f80 	tst.w	r3, #1048576	@ 0x100000
 8040780:	bf08      	it	eq
 8040782:	3d01      	subeq	r5, #1
 8040784:	d0f7      	beq.n	8040776 <__aeabi_dmul+0x1c6>
 8040786:	ea43 0306 	orr.w	r3, r3, r6
 804078a:	4770      	bx	lr
 804078c:	ea94 0f0c 	teq	r4, ip
 8040790:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 8040794:	bf18      	it	ne
 8040796:	ea95 0f0c 	teqne	r5, ip
 804079a:	d00c      	beq.n	80407b6 <__aeabi_dmul+0x206>
 804079c:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 80407a0:	bf18      	it	ne
 80407a2:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 80407a6:	d1d1      	bne.n	804074c <__aeabi_dmul+0x19c>
 80407a8:	ea81 0103 	eor.w	r1, r1, r3
 80407ac:	f001 4100 	and.w	r1, r1, #2147483648	@ 0x80000000
 80407b0:	f04f 0000 	mov.w	r0, #0
 80407b4:	bd70      	pop	{r4, r5, r6, pc}
 80407b6:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 80407ba:	bf06      	itte	eq
 80407bc:	4610      	moveq	r0, r2
 80407be:	4619      	moveq	r1, r3
 80407c0:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 80407c4:	d019      	beq.n	80407fa <__aeabi_dmul+0x24a>
 80407c6:	ea94 0f0c 	teq	r4, ip
 80407ca:	d102      	bne.n	80407d2 <__aeabi_dmul+0x222>
 80407cc:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
 80407d0:	d113      	bne.n	80407fa <__aeabi_dmul+0x24a>
 80407d2:	ea95 0f0c 	teq	r5, ip
 80407d6:	d105      	bne.n	80407e4 <__aeabi_dmul+0x234>
 80407d8:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
 80407dc:	bf1c      	itt	ne
 80407de:	4610      	movne	r0, r2
 80407e0:	4619      	movne	r1, r3
 80407e2:	d10a      	bne.n	80407fa <__aeabi_dmul+0x24a>
 80407e4:	ea81 0103 	eor.w	r1, r1, r3
 80407e8:	f001 4100 	and.w	r1, r1, #2147483648	@ 0x80000000
 80407ec:	f041 41fe 	orr.w	r1, r1, #2130706432	@ 0x7f000000
 80407f0:	f441 0170 	orr.w	r1, r1, #15728640	@ 0xf00000
 80407f4:	f04f 0000 	mov.w	r0, #0
 80407f8:	bd70      	pop	{r4, r5, r6, pc}
 80407fa:	f041 41fe 	orr.w	r1, r1, #2130706432	@ 0x7f000000
 80407fe:	f441 0178 	orr.w	r1, r1, #16252928	@ 0xf80000
 8040802:	bd70      	pop	{r4, r5, r6, pc}

08040804 <__aeabi_ddiv>:
 8040804:	b570      	push	{r4, r5, r6, lr}
 8040806:	f04f 0cff 	mov.w	ip, #255	@ 0xff
 804080a:	f44c 6ce0 	orr.w	ip, ip, #1792	@ 0x700
 804080e:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 8040812:	bf1d      	ittte	ne
 8040814:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 8040818:	ea94 0f0c 	teqne	r4, ip
 804081c:	ea95 0f0c 	teqne	r5, ip
 8040820:	f000 f8a7 	bleq	8040972 <__aeabi_ddiv+0x16e>
 8040824:	eba4 0405 	sub.w	r4, r4, r5
 8040828:	ea81 0e03 	eor.w	lr, r1, r3
 804082c:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 8040830:	ea4f 3101 	mov.w	r1, r1, lsl #12
 8040834:	f000 8088 	beq.w	8040948 <__aeabi_ddiv+0x144>
 8040838:	ea4f 3303 	mov.w	r3, r3, lsl #12
 804083c:	f04f 5580 	mov.w	r5, #268435456	@ 0x10000000
 8040840:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
 8040844:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 8040848:	ea4f 2202 	mov.w	r2, r2, lsl #8
 804084c:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
 8040850:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
 8040854:	ea4f 2600 	mov.w	r6, r0, lsl #8
 8040858:	f00e 4100 	and.w	r1, lr, #2147483648	@ 0x80000000
 804085c:	429d      	cmp	r5, r3
 804085e:	bf08      	it	eq
 8040860:	4296      	cmpeq	r6, r2
 8040862:	f144 04fd 	adc.w	r4, r4, #253	@ 0xfd
 8040866:	f504 7440 	add.w	r4, r4, #768	@ 0x300
 804086a:	d202      	bcs.n	8040872 <__aeabi_ddiv+0x6e>
 804086c:	085b      	lsrs	r3, r3, #1
 804086e:	ea4f 0232 	mov.w	r2, r2, rrx
 8040872:	1ab6      	subs	r6, r6, r2
 8040874:	eb65 0503 	sbc.w	r5, r5, r3
 8040878:	085b      	lsrs	r3, r3, #1
 804087a:	ea4f 0232 	mov.w	r2, r2, rrx
 804087e:	f44f 1080 	mov.w	r0, #1048576	@ 0x100000
 8040882:	f44f 2c00 	mov.w	ip, #524288	@ 0x80000
 8040886:	ebb6 0e02 	subs.w	lr, r6, r2
 804088a:	eb75 0e03 	sbcs.w	lr, r5, r3
 804088e:	bf22      	ittt	cs
 8040890:	1ab6      	subcs	r6, r6, r2
 8040892:	4675      	movcs	r5, lr
 8040894:	ea40 000c 	orrcs.w	r0, r0, ip
 8040898:	085b      	lsrs	r3, r3, #1
 804089a:	ea4f 0232 	mov.w	r2, r2, rrx
 804089e:	ebb6 0e02 	subs.w	lr, r6, r2
 80408a2:	eb75 0e03 	sbcs.w	lr, r5, r3
 80408a6:	bf22      	ittt	cs
 80408a8:	1ab6      	subcs	r6, r6, r2
 80408aa:	4675      	movcs	r5, lr
 80408ac:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 80408b0:	085b      	lsrs	r3, r3, #1
 80408b2:	ea4f 0232 	mov.w	r2, r2, rrx
 80408b6:	ebb6 0e02 	subs.w	lr, r6, r2
 80408ba:	eb75 0e03 	sbcs.w	lr, r5, r3
 80408be:	bf22      	ittt	cs
 80408c0:	1ab6      	subcs	r6, r6, r2
 80408c2:	4675      	movcs	r5, lr
 80408c4:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 80408c8:	085b      	lsrs	r3, r3, #1
 80408ca:	ea4f 0232 	mov.w	r2, r2, rrx
 80408ce:	ebb6 0e02 	subs.w	lr, r6, r2
 80408d2:	eb75 0e03 	sbcs.w	lr, r5, r3
 80408d6:	bf22      	ittt	cs
 80408d8:	1ab6      	subcs	r6, r6, r2
 80408da:	4675      	movcs	r5, lr
 80408dc:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 80408e0:	ea55 0e06 	orrs.w	lr, r5, r6
 80408e4:	d018      	beq.n	8040918 <__aeabi_ddiv+0x114>
 80408e6:	ea4f 1505 	mov.w	r5, r5, lsl #4
 80408ea:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
 80408ee:	ea4f 1606 	mov.w	r6, r6, lsl #4
 80408f2:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 80408f6:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
 80408fa:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 80408fe:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
 8040902:	d1c0      	bne.n	8040886 <__aeabi_ddiv+0x82>
 8040904:	f411 1f80 	tst.w	r1, #1048576	@ 0x100000
 8040908:	d10b      	bne.n	8040922 <__aeabi_ddiv+0x11e>
 804090a:	ea41 0100 	orr.w	r1, r1, r0
 804090e:	f04f 0000 	mov.w	r0, #0
 8040912:	f04f 4c00 	mov.w	ip, #2147483648	@ 0x80000000
 8040916:	e7b6      	b.n	8040886 <__aeabi_ddiv+0x82>
 8040918:	f411 1f80 	tst.w	r1, #1048576	@ 0x100000
 804091c:	bf04      	itt	eq
 804091e:	4301      	orreq	r1, r0
 8040920:	2000      	moveq	r0, #0
 8040922:	f1b4 0cfd 	subs.w	ip, r4, #253	@ 0xfd
 8040926:	bf88      	it	hi
 8040928:	f5bc 6fe0 	cmphi.w	ip, #1792	@ 0x700
 804092c:	f63f aeaf 	bhi.w	804068e <__aeabi_dmul+0xde>
 8040930:	ebb5 0c03 	subs.w	ip, r5, r3
 8040934:	bf04      	itt	eq
 8040936:	ebb6 0c02 	subseq.w	ip, r6, r2
 804093a:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 804093e:	f150 0000 	adcs.w	r0, r0, #0
 8040942:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 8040946:	bd70      	pop	{r4, r5, r6, pc}
 8040948:	f00e 4e00 	and.w	lr, lr, #2147483648	@ 0x80000000
 804094c:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
 8040950:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
 8040954:	bfc2      	ittt	gt
 8040956:	ebd4 050c 	rsbsgt	r5, r4, ip
 804095a:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 804095e:	bd70      	popgt	{r4, r5, r6, pc}
 8040960:	f441 1180 	orr.w	r1, r1, #1048576	@ 0x100000
 8040964:	f04f 0e00 	mov.w	lr, #0
 8040968:	3c01      	subs	r4, #1
 804096a:	e690      	b.n	804068e <__aeabi_dmul+0xde>
 804096c:	ea45 0e06 	orr.w	lr, r5, r6
 8040970:	e68d      	b.n	804068e <__aeabi_dmul+0xde>
 8040972:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 8040976:	ea94 0f0c 	teq	r4, ip
 804097a:	bf08      	it	eq
 804097c:	ea95 0f0c 	teqeq	r5, ip
 8040980:	f43f af3b 	beq.w	80407fa <__aeabi_dmul+0x24a>
 8040984:	ea94 0f0c 	teq	r4, ip
 8040988:	d10a      	bne.n	80409a0 <__aeabi_ddiv+0x19c>
 804098a:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 804098e:	f47f af34 	bne.w	80407fa <__aeabi_dmul+0x24a>
 8040992:	ea95 0f0c 	teq	r5, ip
 8040996:	f47f af25 	bne.w	80407e4 <__aeabi_dmul+0x234>
 804099a:	4610      	mov	r0, r2
 804099c:	4619      	mov	r1, r3
 804099e:	e72c      	b.n	80407fa <__aeabi_dmul+0x24a>
 80409a0:	ea95 0f0c 	teq	r5, ip
 80409a4:	d106      	bne.n	80409b4 <__aeabi_ddiv+0x1b0>
 80409a6:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 80409aa:	f43f aefd 	beq.w	80407a8 <__aeabi_dmul+0x1f8>
 80409ae:	4610      	mov	r0, r2
 80409b0:	4619      	mov	r1, r3
 80409b2:	e722      	b.n	80407fa <__aeabi_dmul+0x24a>
 80409b4:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 80409b8:	bf18      	it	ne
 80409ba:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 80409be:	f47f aec5 	bne.w	804074c <__aeabi_dmul+0x19c>
 80409c2:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
 80409c6:	f47f af0d 	bne.w	80407e4 <__aeabi_dmul+0x234>
 80409ca:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
 80409ce:	f47f aeeb 	bne.w	80407a8 <__aeabi_dmul+0x1f8>
 80409d2:	e712      	b.n	80407fa <__aeabi_dmul+0x24a>

080409d4 <__gedf2>:
 80409d4:	f04f 3cff 	mov.w	ip, #4294967295
 80409d8:	e006      	b.n	80409e8 <__cmpdf2+0x4>
 80409da:	bf00      	nop

080409dc <__ledf2>:
 80409dc:	f04f 0c01 	mov.w	ip, #1
 80409e0:	e002      	b.n	80409e8 <__cmpdf2+0x4>
 80409e2:	bf00      	nop

080409e4 <__cmpdf2>:
 80409e4:	f04f 0c01 	mov.w	ip, #1
 80409e8:	f84d cd04 	str.w	ip, [sp, #-4]!
 80409ec:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 80409f0:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 80409f4:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 80409f8:	bf18      	it	ne
 80409fa:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
 80409fe:	d01b      	beq.n	8040a38 <__cmpdf2+0x54>
 8040a00:	b001      	add	sp, #4
 8040a02:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
 8040a06:	bf0c      	ite	eq
 8040a08:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
 8040a0c:	ea91 0f03 	teqne	r1, r3
 8040a10:	bf02      	ittt	eq
 8040a12:	ea90 0f02 	teqeq	r0, r2
 8040a16:	2000      	moveq	r0, #0
 8040a18:	4770      	bxeq	lr
 8040a1a:	f110 0f00 	cmn.w	r0, #0
 8040a1e:	ea91 0f03 	teq	r1, r3
 8040a22:	bf58      	it	pl
 8040a24:	4299      	cmppl	r1, r3
 8040a26:	bf08      	it	eq
 8040a28:	4290      	cmpeq	r0, r2
 8040a2a:	bf2c      	ite	cs
 8040a2c:	17d8      	asrcs	r0, r3, #31
 8040a2e:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
 8040a32:	f040 0001 	orr.w	r0, r0, #1
 8040a36:	4770      	bx	lr
 8040a38:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8040a3c:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8040a40:	d102      	bne.n	8040a48 <__cmpdf2+0x64>
 8040a42:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 8040a46:	d107      	bne.n	8040a58 <__cmpdf2+0x74>
 8040a48:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8040a4c:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8040a50:	d1d6      	bne.n	8040a00 <__cmpdf2+0x1c>
 8040a52:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 8040a56:	d0d3      	beq.n	8040a00 <__cmpdf2+0x1c>
 8040a58:	f85d 0b04 	ldr.w	r0, [sp], #4
 8040a5c:	4770      	bx	lr
 8040a5e:	bf00      	nop

08040a60 <__aeabi_cdrcmple>:
 8040a60:	4684      	mov	ip, r0
 8040a62:	4610      	mov	r0, r2
 8040a64:	4662      	mov	r2, ip
 8040a66:	468c      	mov	ip, r1
 8040a68:	4619      	mov	r1, r3
 8040a6a:	4663      	mov	r3, ip
 8040a6c:	e000      	b.n	8040a70 <__aeabi_cdcmpeq>
 8040a6e:	bf00      	nop

08040a70 <__aeabi_cdcmpeq>:
 8040a70:	b501      	push	{r0, lr}
 8040a72:	f7ff ffb7 	bl	80409e4 <__cmpdf2>
 8040a76:	2800      	cmp	r0, #0
 8040a78:	bf48      	it	mi
 8040a7a:	f110 0f00 	cmnmi.w	r0, #0
 8040a7e:	bd01      	pop	{r0, pc}

08040a80 <__aeabi_dcmpeq>:
 8040a80:	f84d ed08 	str.w	lr, [sp, #-8]!
 8040a84:	f7ff fff4 	bl	8040a70 <__aeabi_cdcmpeq>
 8040a88:	bf0c      	ite	eq
 8040a8a:	2001      	moveq	r0, #1
 8040a8c:	2000      	movne	r0, #0
 8040a8e:	f85d fb08 	ldr.w	pc, [sp], #8
 8040a92:	bf00      	nop

08040a94 <__aeabi_dcmplt>:
 8040a94:	f84d ed08 	str.w	lr, [sp, #-8]!
 8040a98:	f7ff ffea 	bl	8040a70 <__aeabi_cdcmpeq>
 8040a9c:	bf34      	ite	cc
 8040a9e:	2001      	movcc	r0, #1
 8040aa0:	2000      	movcs	r0, #0
 8040aa2:	f85d fb08 	ldr.w	pc, [sp], #8
 8040aa6:	bf00      	nop

08040aa8 <__aeabi_dcmple>:
 8040aa8:	f84d ed08 	str.w	lr, [sp, #-8]!
 8040aac:	f7ff ffe0 	bl	8040a70 <__aeabi_cdcmpeq>
 8040ab0:	bf94      	ite	ls
 8040ab2:	2001      	movls	r0, #1
 8040ab4:	2000      	movhi	r0, #0
 8040ab6:	f85d fb08 	ldr.w	pc, [sp], #8
 8040aba:	bf00      	nop

08040abc <__aeabi_dcmpge>:
 8040abc:	f84d ed08 	str.w	lr, [sp, #-8]!
 8040ac0:	f7ff ffce 	bl	8040a60 <__aeabi_cdrcmple>
 8040ac4:	bf94      	ite	ls
 8040ac6:	2001      	movls	r0, #1
 8040ac8:	2000      	movhi	r0, #0
 8040aca:	f85d fb08 	ldr.w	pc, [sp], #8
 8040ace:	bf00      	nop

08040ad0 <__aeabi_dcmpgt>:
 8040ad0:	f84d ed08 	str.w	lr, [sp, #-8]!
 8040ad4:	f7ff ffc4 	bl	8040a60 <__aeabi_cdrcmple>
 8040ad8:	bf34      	ite	cc
 8040ada:	2001      	movcc	r0, #1
 8040adc:	2000      	movcs	r0, #0
 8040ade:	f85d fb08 	ldr.w	pc, [sp], #8
 8040ae2:	bf00      	nop

08040ae4 <__aeabi_dcmpun>:
 8040ae4:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8040ae8:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8040aec:	d102      	bne.n	8040af4 <__aeabi_dcmpun+0x10>
 8040aee:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 8040af2:	d10a      	bne.n	8040b0a <__aeabi_dcmpun+0x26>
 8040af4:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8040af8:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8040afc:	d102      	bne.n	8040b04 <__aeabi_dcmpun+0x20>
 8040afe:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 8040b02:	d102      	bne.n	8040b0a <__aeabi_dcmpun+0x26>
 8040b04:	f04f 0000 	mov.w	r0, #0
 8040b08:	4770      	bx	lr
 8040b0a:	f04f 0001 	mov.w	r0, #1
 8040b0e:	4770      	bx	lr

08040b10 <__aeabi_d2iz>:
 8040b10:	ea4f 0241 	mov.w	r2, r1, lsl #1
 8040b14:	f512 1200 	adds.w	r2, r2, #2097152	@ 0x200000
 8040b18:	d215      	bcs.n	8040b46 <__aeabi_d2iz+0x36>
 8040b1a:	d511      	bpl.n	8040b40 <__aeabi_d2iz+0x30>
 8040b1c:	f46f 7378 	mvn.w	r3, #992	@ 0x3e0
 8040b20:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 8040b24:	d912      	bls.n	8040b4c <__aeabi_d2iz+0x3c>
 8040b26:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 8040b2a:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
 8040b2e:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 8040b32:	f011 4f00 	tst.w	r1, #2147483648	@ 0x80000000
 8040b36:	fa23 f002 	lsr.w	r0, r3, r2
 8040b3a:	bf18      	it	ne
 8040b3c:	4240      	negne	r0, r0
 8040b3e:	4770      	bx	lr
 8040b40:	f04f 0000 	mov.w	r0, #0
 8040b44:	4770      	bx	lr
 8040b46:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 8040b4a:	d105      	bne.n	8040b58 <__aeabi_d2iz+0x48>
 8040b4c:	f011 4000 	ands.w	r0, r1, #2147483648	@ 0x80000000
 8040b50:	bf08      	it	eq
 8040b52:	f06f 4000 	mvneq.w	r0, #2147483648	@ 0x80000000
 8040b56:	4770      	bx	lr
 8040b58:	f04f 0000 	mov.w	r0, #0
 8040b5c:	4770      	bx	lr
 8040b5e:	bf00      	nop

08040b60 <__aeabi_d2f>:
 8040b60:	ea4f 0241 	mov.w	r2, r1, lsl #1
 8040b64:	f1b2 43e0 	subs.w	r3, r2, #1879048192	@ 0x70000000
 8040b68:	bf24      	itt	cs
 8040b6a:	f5b3 1c00 	subscs.w	ip, r3, #2097152	@ 0x200000
 8040b6e:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	@ 0x1fc00000
 8040b72:	d90d      	bls.n	8040b90 <__aeabi_d2f+0x30>
 8040b74:	f001 4c00 	and.w	ip, r1, #2147483648	@ 0x80000000
 8040b78:	ea4f 02c0 	mov.w	r2, r0, lsl #3
 8040b7c:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
 8040b80:	f1b2 4f00 	cmp.w	r2, #2147483648	@ 0x80000000
 8040b84:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
 8040b88:	bf08      	it	eq
 8040b8a:	f020 0001 	biceq.w	r0, r0, #1
 8040b8e:	4770      	bx	lr
 8040b90:	f011 4f80 	tst.w	r1, #1073741824	@ 0x40000000
 8040b94:	d121      	bne.n	8040bda <__aeabi_d2f+0x7a>
 8040b96:	f113 7238 	adds.w	r2, r3, #48234496	@ 0x2e00000
 8040b9a:	bfbc      	itt	lt
 8040b9c:	f001 4000 	andlt.w	r0, r1, #2147483648	@ 0x80000000
 8040ba0:	4770      	bxlt	lr
 8040ba2:	f441 1180 	orr.w	r1, r1, #1048576	@ 0x100000
 8040ba6:	ea4f 5252 	mov.w	r2, r2, lsr #21
 8040baa:	f1c2 0218 	rsb	r2, r2, #24
 8040bae:	f1c2 0c20 	rsb	ip, r2, #32
 8040bb2:	fa10 f30c 	lsls.w	r3, r0, ip
 8040bb6:	fa20 f002 	lsr.w	r0, r0, r2
 8040bba:	bf18      	it	ne
 8040bbc:	f040 0001 	orrne.w	r0, r0, #1
 8040bc0:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 8040bc4:	ea4f 23d3 	mov.w	r3, r3, lsr #11
 8040bc8:	fa03 fc0c 	lsl.w	ip, r3, ip
 8040bcc:	ea40 000c 	orr.w	r0, r0, ip
 8040bd0:	fa23 f302 	lsr.w	r3, r3, r2
 8040bd4:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8040bd8:	e7cc      	b.n	8040b74 <__aeabi_d2f+0x14>
 8040bda:	ea7f 5362 	mvns.w	r3, r2, asr #21
 8040bde:	d107      	bne.n	8040bf0 <__aeabi_d2f+0x90>
 8040be0:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
 8040be4:	bf1e      	ittt	ne
 8040be6:	f04f 40fe 	movne.w	r0, #2130706432	@ 0x7f000000
 8040bea:	f440 0040 	orrne.w	r0, r0, #12582912	@ 0xc00000
 8040bee:	4770      	bxne	lr
 8040bf0:	f001 4000 	and.w	r0, r1, #2147483648	@ 0x80000000
 8040bf4:	f040 40fe 	orr.w	r0, r0, #2130706432	@ 0x7f000000
 8040bf8:	f440 0000 	orr.w	r0, r0, #8388608	@ 0x800000
 8040bfc:	4770      	bx	lr
 8040bfe:	bf00      	nop

08040c00 <MX_GPIO_Init>:
/* USER CODE END 1 */

/** Configure pins
*/
void MX_GPIO_Init(void)
{
 8040c00:	b5f0      	push	{r4, r5, r6, r7, lr}

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8040c02:	2400      	movs	r4, #0
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(BTN_BLUE_GPIO_Port, &GPIO_InitStruct);

  /*Configure GPIO pin : PtPin */
  GPIO_InitStruct.Pin = LED_GREEN_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8040c04:	2601      	movs	r6, #1
{
 8040c06:	b089      	sub	sp, #36	@ 0x24
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8040c08:	e9cd 4402 	strd	r4, r4, [sp, #8]
 8040c0c:	e9cd 4404 	strd	r4, r4, [sp, #16]
  __HAL_RCC_GPIOC_CLK_ENABLE();
 8040c10:	4b1e      	ldr	r3, [pc, #120]	@ (8040c8c <MX_GPIO_Init+0x8c>)
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8040c12:	9406      	str	r4, [sp, #24]
  __HAL_RCC_GPIOC_CLK_ENABLE();
 8040c14:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
  HAL_GPIO_WritePin(LED_GREEN_GPIO_Port, LED_GREEN_Pin, GPIO_PIN_RESET);
 8040c16:	4d1e      	ldr	r5, [pc, #120]	@ (8040c90 <MX_GPIO_Init+0x90>)
  __HAL_RCC_GPIOC_CLK_ENABLE();
 8040c18:	f042 0204 	orr.w	r2, r2, #4
 8040c1c:	64da      	str	r2, [r3, #76]	@ 0x4c
 8040c1e:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
  HAL_GPIO_WritePin(LED_RED_GPIO_Port, LED_RED_Pin, GPIO_PIN_RESET);
 8040c20:	4f1c      	ldr	r7, [pc, #112]	@ (8040c94 <MX_GPIO_Init+0x94>)
  __HAL_RCC_GPIOC_CLK_ENABLE();
 8040c22:	f002 0204 	and.w	r2, r2, #4
 8040c26:	9200      	str	r2, [sp, #0]
 8040c28:	9a00      	ldr	r2, [sp, #0]
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8040c2a:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
  HAL_GPIO_WritePin(LED_GREEN_GPIO_Port, LED_GREEN_Pin, GPIO_PIN_RESET);
 8040c2c:	4628      	mov	r0, r5
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8040c2e:	4332      	orrs	r2, r6
 8040c30:	64da      	str	r2, [r3, #76]	@ 0x4c
 8040c32:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
  HAL_GPIO_WritePin(LED_GREEN_GPIO_Port, LED_GREEN_Pin, GPIO_PIN_RESET);
 8040c34:	4622      	mov	r2, r4
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8040c36:	4033      	ands	r3, r6
 8040c38:	9301      	str	r3, [sp, #4]
  HAL_GPIO_WritePin(LED_GREEN_GPIO_Port, LED_GREEN_Pin, GPIO_PIN_RESET);
 8040c3a:	2180      	movs	r1, #128	@ 0x80
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8040c3c:	9b01      	ldr	r3, [sp, #4]
  HAL_GPIO_WritePin(LED_GREEN_GPIO_Port, LED_GREEN_Pin, GPIO_PIN_RESET);
 8040c3e:	f00a fd87 	bl	804b750 <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(LED_RED_GPIO_Port, LED_RED_Pin, GPIO_PIN_RESET);
 8040c42:	4622      	mov	r2, r4
 8040c44:	4638      	mov	r0, r7
 8040c46:	f44f 7100 	mov.w	r1, #512	@ 0x200
 8040c4a:	f00a fd81 	bl	804b750 <HAL_GPIO_WritePin>
  GPIO_InitStruct.Pin = BTN_BLUE_Pin;
 8040c4e:	f44f 5200 	mov.w	r2, #8192	@ 0x2000
 8040c52:	2300      	movs	r3, #0
  HAL_GPIO_Init(BTN_BLUE_GPIO_Port, &GPIO_InitStruct);
 8040c54:	4628      	mov	r0, r5
 8040c56:	a902      	add	r1, sp, #8
  GPIO_InitStruct.Pin = BTN_BLUE_Pin;
 8040c58:	e9cd 2302 	strd	r2, r3, [sp, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8040c5c:	9404      	str	r4, [sp, #16]
  HAL_GPIO_Init(BTN_BLUE_GPIO_Port, &GPIO_InitStruct);
 8040c5e:	f00a fc67 	bl	804b530 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = LED_GREEN_Pin;
 8040c62:	2380      	movs	r3, #128	@ 0x80
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(LED_GREEN_GPIO_Port, &GPIO_InitStruct);
 8040c64:	4628      	mov	r0, r5
 8040c66:	a902      	add	r1, sp, #8
  GPIO_InitStruct.Pin = LED_GREEN_Pin;
 8040c68:	9302      	str	r3, [sp, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8040c6a:	e9cd 6403 	strd	r6, r4, [sp, #12]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8040c6e:	9405      	str	r4, [sp, #20]
  HAL_GPIO_Init(LED_GREEN_GPIO_Port, &GPIO_InitStruct);
 8040c70:	f00a fc5e 	bl	804b530 <HAL_GPIO_Init>

  /*Configure GPIO pin : PtPin */
  GPIO_InitStruct.Pin = LED_RED_Pin;
 8040c74:	f44f 7300 	mov.w	r3, #512	@ 0x200
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(LED_RED_GPIO_Port, &GPIO_InitStruct);
 8040c78:	4638      	mov	r0, r7
 8040c7a:	a902      	add	r1, sp, #8
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8040c7c:	e9cd 6403 	strd	r6, r4, [sp, #12]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8040c80:	9405      	str	r4, [sp, #20]
  GPIO_InitStruct.Pin = LED_RED_Pin;
 8040c82:	9302      	str	r3, [sp, #8]
  HAL_GPIO_Init(LED_RED_GPIO_Port, &GPIO_InitStruct);
 8040c84:	f00a fc54 	bl	804b530 <HAL_GPIO_Init>

}
 8040c88:	b009      	add	sp, #36	@ 0x24
 8040c8a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8040c8c:	40021000 	.word	0x40021000
 8040c90:	42020800 	.word	0x42020800
 8040c94:	42020000 	.word	0x42020000

08040c98 <SecureFault_Callback>:
}

//secure fault generated by IDAU/SAU check */
void SecureFault_Callback(void)
{
  HAL_GPIO_WritePin(LED_RED_GPIO_Port, LED_RED_Pin, GPIO_PIN_SET);
 8040c98:	2201      	movs	r2, #1
 8040c9a:	f44f 7100 	mov.w	r1, #512	@ 0x200
{
 8040c9e:	b508      	push	{r3, lr}
  HAL_GPIO_WritePin(LED_RED_GPIO_Port, LED_RED_Pin, GPIO_PIN_SET);
 8040ca0:	4802      	ldr	r0, [pc, #8]	@ (8040cac <SecureFault_Callback+0x14>)
 8040ca2:	f00a fd55 	bl	804b750 <HAL_GPIO_WritePin>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8040ca6:	b672      	cpsid	i
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
 8040ca8:	e7fe      	b.n	8040ca8 <SecureFault_Callback+0x10>
 8040caa:	bf00      	nop
 8040cac:	42020000 	.word	0x42020000

08040cb0 <SecureError_Callback>:
void SecureError_Callback(void)
 8040cb0:	b508      	push	{r3, lr}
 8040cb2:	f7ff fff1 	bl	8040c98 <SecureFault_Callback>
 8040cb6:	bf00      	nop

08040cb8 <wrapper_init>:
void wrapper_init() {
 8040cb8:	b508      	push	{r3, lr}
	SECURE_checkState(&s, sizeof(State));
 8040cba:	4812      	ldr	r0, [pc, #72]	@ (8040d04 <wrapper_init+0x4c>)
 8040cbc:	217c      	movs	r1, #124	@ 0x7c
 8040cbe:	f00d fa33 	bl	804e128 <__SECURE_checkState_veneer>
	char current_char = start_char;
 8040cc2:	2341      	movs	r3, #65	@ 0x41
 8040cc4:	4a10      	ldr	r2, [pc, #64]	@ (8040d08 <wrapper_init+0x50>)
        s.input[j] = current_char;
 8040cc6:	469c      	mov	ip, r3
 8040cc8:	f102 0078 	add.w	r0, r2, #120	@ 0x78
 8040ccc:	e007      	b.n	8040cde <wrapper_init+0x26>
	for(int j=0; j<INPUT_SIZE; j++) {
 8040cce:	4288      	cmp	r0, r1
 8040cd0:	d00f      	beq.n	8040cf2 <wrapper_init+0x3a>
        s.input[j] = current_char;
 8040cd2:	f802 cf02 	strb.w	ip, [r2, #2]!
	for(int j=0; j<INPUT_SIZE; j++) {
 8040cd6:	4290      	cmp	r0, r2
        current_char++;
 8040cd8:	f04f 0342 	mov.w	r3, #66	@ 0x42
	for(int j=0; j<INPUT_SIZE; j++) {
 8040cdc:	d009      	beq.n	8040cf2 <wrapper_init+0x3a>
        current_char++;
 8040cde:	1c59      	adds	r1, r3, #1
        s.input[j] = current_char;
 8040ce0:	7053      	strb	r3, [r2, #1]
        current_char++;
 8040ce2:	b2cb      	uxtb	r3, r1
        if (current_char > start_char+num_unique) {
 8040ce4:	2b5a      	cmp	r3, #90	@ 0x5a
        s.input[j] = current_char;
 8040ce6:	f102 0101 	add.w	r1, r2, #1
        if (current_char > start_char+num_unique) {
 8040cea:	d0f0      	beq.n	8040cce <wrapper_init+0x16>
        s.input[j] = current_char;
 8040cec:	460a      	mov	r2, r1
	for(int j=0; j<INPUT_SIZE; j++) {
 8040cee:	4290      	cmp	r0, r2
 8040cf0:	d1f5      	bne.n	8040cde <wrapper_init+0x26>
	s.curIdx = 0;
 8040cf2:	2300      	movs	r3, #0
 8040cf4:	4803      	ldr	r0, [pc, #12]	@ (8040d04 <wrapper_init+0x4c>)
	SECURE_setState(&s, sizeof(State));
 8040cf6:	217c      	movs	r1, #124	@ 0x7c
	s.curIdx = 0;
 8040cf8:	6783      	str	r3, [r0, #120]	@ 0x78
}
 8040cfa:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	SECURE_setState(&s, sizeof(State));
 8040cfe:	f00d ba23 	b.w	804e148 <__SECURE_setState_veneer>
 8040d02:	bf00      	nop
 8040d04:	200181bc 	.word	0x200181bc
 8040d08:	200181bb 	.word	0x200181bb

08040d0c <wrapper_collect>:
void wrapper_collect() {
 8040d0c:	b510      	push	{r4, lr}
	SECURE_checkState(&s, sizeof(State));
 8040d0e:	4c0f      	ldr	r4, [pc, #60]	@ (8040d4c <wrapper_collect+0x40>)
 8040d10:	217c      	movs	r1, #124	@ 0x7c
 8040d12:	4620      	mov	r0, r4
 8040d14:	f00d fa08 	bl	804e128 <__SECURE_checkState_veneer>
	s.input[s.curIdx] = 15;
 8040d18:	f04f 0c0f 	mov.w	ip, #15
 8040d1c:	6fa0      	ldr	r0, [r4, #120]	@ 0x78
	s.curIdx = (s.curIdx+1)%INPUT_SIZE;
 8040d1e:	490c      	ldr	r1, [pc, #48]	@ (8040d50 <wrapper_collect+0x44>)
 8040d20:	1c43      	adds	r3, r0, #1
 8040d22:	fb81 2103 	smull	r2, r1, r1, r3
 8040d26:	17da      	asrs	r2, r3, #31
 8040d28:	ebc2 02a1 	rsb	r2, r2, r1, asr #2
 8040d2c:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 8040d30:	eba3 03c2 	sub.w	r3, r3, r2, lsl #3
	s.input[s.curIdx] = 15;
 8040d34:	f804 c000 	strb.w	ip, [r4, r0]
	s.curIdx = (s.curIdx+1)%INPUT_SIZE;
 8040d38:	eb03 0383 	add.w	r3, r3, r3, lsl #2
	SECURE_setState(&s, sizeof(State));
 8040d3c:	4620      	mov	r0, r4
	s.curIdx = (s.curIdx+1)%INPUT_SIZE;
 8040d3e:	67a3      	str	r3, [r4, #120]	@ 0x78
	SECURE_setState(&s, sizeof(State));
 8040d40:	217c      	movs	r1, #124	@ 0x7c
}
 8040d42:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	SECURE_setState(&s, sizeof(State));
 8040d46:	f00d b9ff 	b.w	804e148 <__SECURE_setState_veneer>
 8040d4a:	bf00      	nop
 8040d4c:	200181bc 	.word	0x200181bc
 8040d50:	2aaaaaab 	.word	0x2aaaaaab

08040d54 <sendline>:
	while(s[i] != '\n') i++;
 8040d54:	7803      	ldrb	r3, [r0, #0]
 8040d56:	2b0a      	cmp	r3, #10
 8040d58:	d009      	beq.n	8040d6e <sendline+0x1a>
 8040d5a:	4603      	mov	r3, r0
 8040d5c:	4619      	mov	r1, r3
 8040d5e:	f813 2f01 	ldrb.w	r2, [r3, #1]!
 8040d62:	2a0a      	cmp	r2, #10
 8040d64:	d1fa      	bne.n	8040d5c <sendline+0x8>
 8040d66:	1a09      	subs	r1, r1, r0
	SECURE_send((uint8_t*)s, (i+1));
 8040d68:	3102      	adds	r1, #2
 8040d6a:	f00d b9d5 	b.w	804e118 <__SECURE_send_veneer>
	while(s[i] != '\n') i++;
 8040d6e:	2101      	movs	r1, #1
	SECURE_send((uint8_t*)s, (i+1));
 8040d70:	f00d b9d2 	b.w	804e118 <__SECURE_send_veneer>

08040d74 <train>:
void train(float init_val, int epochs, float rate) {
 8040d74:	b5f0      	push	{r4, r5, r6, r7, lr}
 8040d76:	ed2d 8b02 	vpush	{d8}
	int i=0;
 8040d7a:	2300      	movs	r3, #0
void train(float init_val, int epochs, float rate) {
 8040d7c:	4606      	mov	r6, r0
 8040d7e:	eeb0 8a60 	vmov.f32	s16, s1
 8040d82:	4a33      	ldr	r2, [pc, #204]	@ (8040e50 <train+0xdc>)
 8040d84:	b087      	sub	sp, #28
	while(s[i] != '\n') i++;
 8040d86:	f812 0f01 	ldrb.w	r0, [r2, #1]!
 8040d8a:	4619      	mov	r1, r3
 8040d8c:	280a      	cmp	r0, #10
 8040d8e:	f103 0301 	add.w	r3, r3, #1
 8040d92:	d1f8      	bne.n	8040d86 <train+0x12>
	SECURE_send((uint8_t*)s, (i+1));
 8040d94:	482e      	ldr	r0, [pc, #184]	@ (8040e50 <train+0xdc>)
 8040d96:	3102      	adds	r1, #2
 8040d98:	f00d f9be 	bl	804e118 <__SECURE_send_veneer>
	tg = tg_init_with_data(s.input, INPUT_SIZE);
 8040d9c:	2178      	movs	r1, #120	@ 0x78
 8040d9e:	482d      	ldr	r0, [pc, #180]	@ (8040e54 <train+0xe0>)
 8040da0:	f000 fbaa 	bl	80414f8 <tg_init_with_data>
	int i=0;
 8040da4:	2300      	movs	r3, #0
	tg = tg_init_with_data(s.input, INPUT_SIZE);
 8040da6:	4605      	mov	r5, r0
	while(s[i] != '\n') i++;
 8040da8:	4a2b      	ldr	r2, [pc, #172]	@ (8040e58 <train+0xe4>)
 8040daa:	f812 0f01 	ldrb.w	r0, [r2, #1]!
 8040dae:	4619      	mov	r1, r3
 8040db0:	280a      	cmp	r0, #10
 8040db2:	f103 0301 	add.w	r3, r3, #1
 8040db6:	d1f8      	bne.n	8040daa <train+0x36>
	SECURE_send((uint8_t*)s, (i+1));
 8040db8:	4827      	ldr	r0, [pc, #156]	@ (8040e58 <train+0xe4>)
 8040dba:	3102      	adds	r1, #2
 8040dbc:	f00d f9ac 	bl	804e118 <__SECURE_send_veneer>
	ann = model_gen(model, tg->n_char, n_h_layers, n_h_neurons, h_dropout, use_norm);
 8040dc0:	2201      	movs	r2, #1
 8040dc2:	2308      	movs	r3, #8
 8040dc4:	6869      	ldr	r1, [r5, #4]
 8040dc6:	ed9f 0a25 	vldr	s0, [pc, #148]	@ 8040e5c <train+0xe8>
 8040dca:	9200      	str	r2, [sp, #0]
 8040dcc:	2002      	movs	r0, #2
 8040dce:	f000 fecb 	bl	8041b68 <model_gen>
	int i=0;
 8040dd2:	2300      	movs	r3, #0
	ann = model_gen(model, tg->n_char, n_h_layers, n_h_neurons, h_dropout, use_norm);
 8040dd4:	4607      	mov	r7, r0
	while(s[i] != '\n') i++;
 8040dd6:	4a22      	ldr	r2, [pc, #136]	@ (8040e60 <train+0xec>)
 8040dd8:	f812 4f01 	ldrb.w	r4, [r2, #1]!
 8040ddc:	4619      	mov	r1, r3
 8040dde:	2c0a      	cmp	r4, #10
 8040de0:	f103 0301 	add.w	r3, r3, #1
 8040de4:	d1f8      	bne.n	8040dd8 <train+0x64>
	SECURE_send((uint8_t*)s, (i+1));
 8040de6:	481e      	ldr	r0, [pc, #120]	@ (8040e60 <train+0xec>)
 8040de8:	3102      	adds	r1, #2
 8040dea:	f00d f995 	bl	804e118 <__SECURE_send_veneer>
	tg_train(ann, tg, lr, ulen, vlen, cs, mbs, max_epoch, grad_clip, batch_len, n_threads);
 8040dee:	2301      	movs	r3, #1
 8040df0:	2204      	movs	r2, #4
 8040df2:	9602      	str	r6, [sp, #8]
 8040df4:	f44f 767a 	mov.w	r6, #1000	@ 0x3e8
 8040df8:	9201      	str	r2, [sp, #4]
 8040dfa:	e9cd 6303 	strd	r6, r3, [sp, #12]
 8040dfe:	461a      	mov	r2, r3
 8040e00:	eddf 0a16 	vldr	s1, [pc, #88]	@ 8040e5c <train+0xe8>
 8040e04:	eeb0 0a48 	vmov.f32	s0, s16
 8040e08:	4638      	mov	r0, r7
 8040e0a:	4629      	mov	r1, r5
 8040e0c:	9400      	str	r4, [sp, #0]
 8040e0e:	f000 fc7b 	bl	8041708 <tg_train>
	int i=0;
 8040e12:	2300      	movs	r3, #0
 8040e14:	4a13      	ldr	r2, [pc, #76]	@ (8040e64 <train+0xf0>)
	while(s[i] != '\n') i++;
 8040e16:	f812 0f01 	ldrb.w	r0, [r2, #1]!
 8040e1a:	4619      	mov	r1, r3
 8040e1c:	280a      	cmp	r0, #10
 8040e1e:	f103 0301 	add.w	r3, r3, #1
 8040e22:	d1f8      	bne.n	8040e16 <train+0xa2>
	SECURE_send((uint8_t*)s, (i+1));
 8040e24:	3102      	adds	r1, #2
 8040e26:	480f      	ldr	r0, [pc, #60]	@ (8040e64 <train+0xf0>)
 8040e28:	f00d f976 	bl	804e118 <__SECURE_send_veneer>
	free(tg->data); free(tg);
 8040e2c:	68a8      	ldr	r0, [r5, #8]
 8040e2e:	f00a fcdf 	bl	804b7f0 <free>
 8040e32:	4628      	mov	r0, r5
 8040e34:	f00a fcdc 	bl	804b7f0 <free>
	memcpy(pox_output, tg->c2i, POX_OUTPUT_SIZE);
 8040e38:	f44f 7280 	mov.w	r2, #256	@ 0x100
 8040e3c:	f105 010c 	add.w	r1, r5, #12
 8040e40:	4809      	ldr	r0, [pc, #36]	@ (8040e68 <train+0xf4>)
 8040e42:	f00b f8b8 	bl	804bfb6 <memcpy>
}
 8040e46:	b007      	add	sp, #28
 8040e48:	ecbd 8b02 	vpop	{d8}
 8040e4c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8040e4e:	bf00      	nop
 8040e50:	0804e150 	.word	0x0804e150
 8040e54:	200181bc 	.word	0x200181bc
 8040e58:	0804e15c 	.word	0x0804e15c
 8040e5c:	00000000 	.word	0x00000000
 8040e60:	0804e168 	.word	0x0804e168
 8040e64:	0804e178 	.word	0x0804e178
 8040e68:	20018238 	.word	0x20018238

08040e6c <wrapper_train>:
void wrapper_train() {
 8040e6c:	b510      	push	{r4, lr}
	SECURE_checkState(&s, sizeof(State));
 8040e6e:	4c0c      	ldr	r4, [pc, #48]	@ (8040ea0 <wrapper_train+0x34>)
 8040e70:	217c      	movs	r1, #124	@ 0x7c
 8040e72:	4620      	mov	r0, r4
 8040e74:	f00d f958 	bl	804e128 <__SECURE_checkState_veneer>
	float lr = *(float*)(pox_input);
 8040e78:	4b0a      	ldr	r3, [pc, #40]	@ (8040ea4 <wrapper_train+0x38>)
	int numEpochs = (int) (*(float*)(pox_input+4));
 8040e7a:	edd3 7a01 	vldr	s15, [r3, #4]
	train(init_val, numEpochs, lr);
 8040e7e:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8040e82:	edd3 0a00 	vldr	s1, [r3]
 8040e86:	ee17 0a90 	vmov	r0, s15
 8040e8a:	ed93 0a02 	vldr	s0, [r3, #8]
 8040e8e:	f7ff ff71 	bl	8040d74 <train>
	SECURE_setState(&s, sizeof(State));
 8040e92:	4620      	mov	r0, r4
}
 8040e94:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	SECURE_setState(&s, sizeof(State));
 8040e98:	217c      	movs	r1, #124	@ 0x7c
 8040e9a:	f00d b955 	b.w	804e148 <__SECURE_setState_veneer>
 8040e9e:	bf00      	nop
 8040ea0:	200181bc 	.word	0x200181bc
 8040ea4:	20018338 	.word	0x20018338

08040ea8 <single>:
	for(volatile int i=0; i<10000; i++);
 8040ea8:	2300      	movs	r3, #0
 8040eaa:	f242 720f 	movw	r2, #9999	@ 0x270f
void single() {
 8040eae:	b5f0      	push	{r4, r5, r6, r7, lr}
 8040eb0:	b0c1      	sub	sp, #260	@ 0x104
	for(volatile int i=0; i<10000; i++);
 8040eb2:	9305      	str	r3, [sp, #20]
 8040eb4:	9b05      	ldr	r3, [sp, #20]
 8040eb6:	4293      	cmp	r3, r2
 8040eb8:	dc05      	bgt.n	8040ec6 <single+0x1e>
 8040eba:	9b05      	ldr	r3, [sp, #20]
 8040ebc:	3301      	adds	r3, #1
 8040ebe:	9305      	str	r3, [sp, #20]
 8040ec0:	9b05      	ldr	r3, [sp, #20]
 8040ec2:	4293      	cmp	r3, r2
 8040ec4:	ddf9      	ble.n	8040eba <single+0x12>
		uint8_t req[100]={};
 8040ec6:	2400      	movs	r4, #0
 8040ec8:	2260      	movs	r2, #96	@ 0x60
 8040eca:	4621      	mov	r1, r4
 8040ecc:	a80f      	add	r0, sp, #60	@ 0x3c
		SECURE_recv(req, REQUEST_SIZE);
 8040ece:	ad0e      	add	r5, sp, #56	@ 0x38
		uint8_t req[100]={};
 8040ed0:	940e      	str	r4, [sp, #56]	@ 0x38
 8040ed2:	f00a ff73 	bl	804bdbc <memset>
		uint8_t buff[100]={};
 8040ed6:	2260      	movs	r2, #96	@ 0x60
 8040ed8:	4621      	mov	r1, r4
 8040eda:	a828      	add	r0, sp, #160	@ 0xa0
 8040edc:	9427      	str	r4, [sp, #156]	@ 0x9c
 8040ede:	f00a ff6d 	bl	804bdbc <memset>
		SECURE_recv(req, REQUEST_SIZE);
 8040ee2:	2139      	movs	r1, #57	@ 0x39
 8040ee4:	4628      	mov	r0, r5
 8040ee6:	f00d f923 	bl	804e130 <__SECURE_recv_veneer>
		sprintf(buff, "wrapper_init=%p, wrapper_collect=%p, wrapper_train=%p\n",
 8040eea:	4aa0      	ldr	r2, [pc, #640]	@ (804116c <single+0x2c4>)
 8040eec:	4ba0      	ldr	r3, [pc, #640]	@ (8041170 <single+0x2c8>)
 8040eee:	49a1      	ldr	r1, [pc, #644]	@ (8041174 <single+0x2cc>)
 8040ef0:	9200      	str	r2, [sp, #0]
 8040ef2:	a827      	add	r0, sp, #156	@ 0x9c
 8040ef4:	4aa0      	ldr	r2, [pc, #640]	@ (8041178 <single+0x2d0>)
 8040ef6:	f00a fe69 	bl	804bbcc <siprintf>
	while(s[i] != '\n') i++;
 8040efa:	f89d 309c 	ldrb.w	r3, [sp, #156]	@ 0x9c
 8040efe:	2b0a      	cmp	r3, #10
 8040f00:	bf08      	it	eq
 8040f02:	2101      	moveq	r1, #1
 8040f04:	d009      	beq.n	8040f1a <single+0x72>
	int i=0;
 8040f06:	4621      	mov	r1, r4
 8040f08:	ab27      	add	r3, sp, #156	@ 0x9c
	while(s[i] != '\n') i++;
 8040f0a:	f813 2f01 	ldrb.w	r2, [r3, #1]!
 8040f0e:	4608      	mov	r0, r1
 8040f10:	2a0a      	cmp	r2, #10
 8040f12:	f101 0101 	add.w	r1, r1, #1
 8040f16:	d1f8      	bne.n	8040f0a <single+0x62>
	SECURE_send((uint8_t*)s, (i+1));
 8040f18:	1c81      	adds	r1, r0, #2
 8040f1a:	a827      	add	r0, sp, #156	@ 0x9c
 8040f1c:	f00d f8fc 	bl	804e118 <__SECURE_send_veneer>
		pc.command_size = 5; // assume to be fixed
 8040f20:	2105      	movs	r1, #5
		pc.input = pox_input;
 8040f22:	4a96      	ldr	r2, [pc, #600]	@ (804117c <single+0x2d4>)
		pc.output = pox_output;
 8040f24:	4b96      	ldr	r3, [pc, #600]	@ (8041180 <single+0x2d8>)
		pc.input = pox_input;
 8040f26:	9207      	str	r2, [sp, #28]
		pc.output = pox_output;
 8040f28:	9309      	str	r3, [sp, #36]	@ 0x24
		if(memcmp(pc.command, "[stp]", pc.command_size) == 0 ||
 8040f2a:	4a96      	ldr	r2, [pc, #600]	@ (8041184 <single+0x2dc>)
 8040f2c:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
		pc.command = req; // either [stp] or [clt]
 8040f2e:	950c      	str	r5, [sp, #48]	@ 0x30
		if(memcmp(pc.command, "[stp]", pc.command_size) == 0 ||
 8040f30:	4293      	cmp	r3, r2
		pc.command_size = 5; // assume to be fixed
 8040f32:	f88d 1034 	strb.w	r1, [sp, #52]	@ 0x34
		if(memcmp(pc.command, "[stp]", pc.command_size) == 0 ||
 8040f36:	d01e      	beq.n	8040f76 <single+0xce>
				memcmp(pc.command, "[clt]", pc.command_size) == 0) {
 8040f38:	4a93      	ldr	r2, [pc, #588]	@ (8041188 <single+0x2e0>)
 8040f3a:	4293      	cmp	r3, r2
 8040f3c:	d07a      	beq.n	8041034 <single+0x18c>
		} else if(memcmp(pc.command, "[trn]", pc.command_size) == 0) {
 8040f3e:	4a93      	ldr	r2, [pc, #588]	@ (804118c <single+0x2e4>)
 8040f40:	4293      	cmp	r3, r2
 8040f42:	d07d      	beq.n	8041040 <single+0x198>
			sprintf(buff, "failed to parse command: %s\n", req);
 8040f44:	462a      	mov	r2, r5
 8040f46:	4992      	ldr	r1, [pc, #584]	@ (8041190 <single+0x2e8>)
 8040f48:	a827      	add	r0, sp, #156	@ 0x9c
 8040f4a:	f00a fe3f 	bl	804bbcc <siprintf>
	while(s[i] != '\n') i++;
 8040f4e:	f89d 309c 	ldrb.w	r3, [sp, #156]	@ 0x9c
 8040f52:	2b0a      	cmp	r3, #10
 8040f54:	f000 8108 	beq.w	8041168 <single+0x2c0>
	int i=0;
 8040f58:	2300      	movs	r3, #0
 8040f5a:	aa27      	add	r2, sp, #156	@ 0x9c
	while(s[i] != '\n') i++;
 8040f5c:	f812 0f01 	ldrb.w	r0, [r2, #1]!
 8040f60:	4619      	mov	r1, r3
 8040f62:	280a      	cmp	r0, #10
 8040f64:	f103 0301 	add.w	r3, r3, #1
 8040f68:	d1f8      	bne.n	8040f5c <single+0xb4>
	SECURE_send((uint8_t*)s, (i+1));
 8040f6a:	3102      	adds	r1, #2
 8040f6c:	a827      	add	r0, sp, #156	@ 0x9c
 8040f6e:	f00d f8d3 	bl	804e118 <__SECURE_send_veneer>
}
 8040f72:	b041      	add	sp, #260	@ 0x104
 8040f74:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if(memcmp(pc.command, "[stp]", pc.command_size) == 0 ||
 8040f76:	792a      	ldrb	r2, [r5, #4]
 8040f78:	2a5d      	cmp	r2, #93	@ 0x5d
 8040f7a:	d1dd      	bne.n	8040f38 <single+0x90>
			uint32_t counter = *((uint32_t*)(req+5));
 8040f7c:	f8dd 503d 	ldr.w	r5, [sp, #61]	@ 0x3d
			uint32_t func = *((uint32_t*)(req+5+4));
 8040f80:	f8dd 4041 	ldr.w	r4, [sp, #65]	@ 0x41
			sprintf(buff, "[Test] Setup/collect: counter=%d, func=%x, done [/Test]\n", counter, func);
 8040f84:	462a      	mov	r2, r5
 8040f86:	4623      	mov	r3, r4
 8040f88:	4982      	ldr	r1, [pc, #520]	@ (8041194 <single+0x2ec>)
 8040f8a:	a827      	add	r0, sp, #156	@ 0x9c
 8040f8c:	f00a fe1e 	bl	804bbcc <siprintf>
	while(s[i] != '\n') i++;
 8040f90:	f89d 309c 	ldrb.w	r3, [sp, #156]	@ 0x9c
 8040f94:	2b0a      	cmp	r3, #10
 8040f96:	f000 80e1 	beq.w	804115c <single+0x2b4>
	int i=0;
 8040f9a:	2300      	movs	r3, #0
 8040f9c:	aa27      	add	r2, sp, #156	@ 0x9c
	while(s[i] != '\n') i++;
 8040f9e:	f812 0f01 	ldrb.w	r0, [r2, #1]!
 8040fa2:	4619      	mov	r1, r3
 8040fa4:	280a      	cmp	r0, #10
 8040fa6:	f103 0301 	add.w	r3, r3, #1
 8040faa:	d1f8      	bne.n	8040f9e <single+0xf6>
	SECURE_send((uint8_t*)s, (i+1));
 8040fac:	3102      	adds	r1, #2
			pc.output_size = 32;
 8040fae:	2620      	movs	r6, #32
			pc.input_size = 12;
 8040fb0:	270c      	movs	r7, #12
	SECURE_send((uint8_t*)s, (i+1));
 8040fb2:	a827      	add	r0, sp, #156	@ 0x9c
 8040fb4:	f00d f8b0 	bl	804e118 <__SECURE_send_veneer>
			memcpy(pox_input, req+5+4*2, 12);
 8040fb8:	f8dd 204d 	ldr.w	r2, [sp, #77]	@ 0x4d
 8040fbc:	f8dd 0045 	ldr.w	r0, [sp, #69]	@ 0x45
 8040fc0:	f8dd 1049 	ldr.w	r1, [sp, #73]	@ 0x49
 8040fc4:	4b6d      	ldr	r3, [pc, #436]	@ (804117c <single+0x2d4>)
			pc.counter = counter;
 8040fc6:	950b      	str	r5, [sp, #44]	@ 0x2c
			memcpy(pox_input, req+5+4*2, 12);
 8040fc8:	c307      	stmia	r3!, {r0, r1, r2}
			SECURE_pox(&pc, token);
 8040fca:	f10d 0151 	add.w	r1, sp, #81	@ 0x51
 8040fce:	a806      	add	r0, sp, #24
			pc.addr = func;
 8040fd0:	9406      	str	r4, [sp, #24]
			pc.output_size = 32;
 8040fd2:	960a      	str	r6, [sp, #40]	@ 0x28
			pc.input_size = 12;
 8040fd4:	9708      	str	r7, [sp, #32]
			SECURE_pox(&pc, token);
 8040fd6:	f00d f8a3 	bl	804e120 <__SECURE_pox_veneer>
			SECURE_send("[OS]", 4);
 8040fda:	2104      	movs	r1, #4
 8040fdc:	486e      	ldr	r0, [pc, #440]	@ (8041198 <single+0x2f0>)
 8040fde:	f00d f89b 	bl	804e118 <__SECURE_send_veneer>
			SECURE_send(pox_output, 32);
 8040fe2:	4631      	mov	r1, r6
 8040fe4:	4866      	ldr	r0, [pc, #408]	@ (8041180 <single+0x2d8>)
 8040fe6:	f00d f897 	bl	804e118 <__SECURE_send_veneer>
			SECURE_send(" ", 1);
 8040fea:	2101      	movs	r1, #1
 8040fec:	486b      	ldr	r0, [pc, #428]	@ (804119c <single+0x2f4>)
 8040fee:	f00d f893 	bl	804e118 <__SECURE_send_veneer>
			SECURE_send(token, 32);
 8040ff2:	4631      	mov	r1, r6
 8040ff4:	f10d 0051 	add.w	r0, sp, #81	@ 0x51
 8040ff8:	f00d f88e 	bl	804e118 <__SECURE_send_veneer>
	int i=0;
 8040ffc:	2300      	movs	r3, #0
 8040ffe:	4a68      	ldr	r2, [pc, #416]	@ (80411a0 <single+0x2f8>)
	while(s[i] != '\n') i++;
 8041000:	f812 0f01 	ldrb.w	r0, [r2, #1]!
 8041004:	4619      	mov	r1, r3
 8041006:	280a      	cmp	r0, #10
 8041008:	f103 0301 	add.w	r3, r3, #1
 804100c:	d1f8      	bne.n	8041000 <single+0x158>
	SECURE_send((uint8_t*)s, (i+1));
 804100e:	4864      	ldr	r0, [pc, #400]	@ (80411a0 <single+0x2f8>)
 8041010:	3102      	adds	r1, #2
 8041012:	f00d f881 	bl	804e118 <__SECURE_send_veneer>
	int i=0;
 8041016:	2300      	movs	r3, #0
 8041018:	4a62      	ldr	r2, [pc, #392]	@ (80411a4 <single+0x2fc>)
	while(s[i] != '\n') i++;
 804101a:	f812 0f01 	ldrb.w	r0, [r2, #1]!
 804101e:	4619      	mov	r1, r3
 8041020:	280a      	cmp	r0, #10
 8041022:	f103 0301 	add.w	r3, r3, #1
 8041026:	d1f8      	bne.n	804101a <single+0x172>
	SECURE_send((uint8_t*)s, (i+1));
 8041028:	485e      	ldr	r0, [pc, #376]	@ (80411a4 <single+0x2fc>)
 804102a:	3102      	adds	r1, #2
 804102c:	f00d f874 	bl	804e118 <__SECURE_send_veneer>
}
 8041030:	b041      	add	sp, #260	@ 0x104
 8041032:	bdf0      	pop	{r4, r5, r6, r7, pc}
				memcmp(pc.command, "[clt]", pc.command_size) == 0) {
 8041034:	792a      	ldrb	r2, [r5, #4]
 8041036:	2a5d      	cmp	r2, #93	@ 0x5d
 8041038:	d0a0      	beq.n	8040f7c <single+0xd4>
		} else if(memcmp(pc.command, "[trn]", pc.command_size) == 0) {
 804103a:	4a54      	ldr	r2, [pc, #336]	@ (804118c <single+0x2e4>)
 804103c:	4293      	cmp	r3, r2
 804103e:	d181      	bne.n	8040f44 <single+0x9c>
 8041040:	792b      	ldrb	r3, [r5, #4]
 8041042:	2b5d      	cmp	r3, #93	@ 0x5d
 8041044:	f47f af7e 	bne.w	8040f44 <single+0x9c>
			float lr = *((float*)(req+5+4*2));
 8041048:	f8dd 3045 	ldr.w	r3, [sp, #69]	@ 0x45
			float init_val = *((float*)(req+5+4*4));
 804104c:	f8dd 204d 	ldr.w	r2, [sp, #77]	@ 0x4d
					counter, func, (int) (lr*10000), numEpochs, (int) (init_val*10000));
 8041050:	eddf 6a55 	vldr	s13, [pc, #340]	@ 80411a8 <single+0x300>
			float lr = *((float*)(req+5+4*2));
 8041054:	ee07 3a90 	vmov	s15, r3
			float init_val = *((float*)(req+5+4*4));
 8041058:	ee07 2a10 	vmov	s14, r2
			int numEpochs = *((float*)(req+5+4*3));
 804105c:	f8dd 3049 	ldr.w	r3, [sp, #73]	@ 0x49
					counter, func, (int) (lr*10000), numEpochs, (int) (init_val*10000));
 8041060:	ee27 7a26 	vmul.f32	s14, s14, s13
			int numEpochs = *((float*)(req+5+4*3));
 8041064:	ee06 3a10 	vmov	s12, r3
					counter, func, (int) (lr*10000), numEpochs, (int) (init_val*10000));
 8041068:	ee67 7aa6 	vmul.f32	s15, s15, s13
			pc.input_size = 12;
 804106c:	200c      	movs	r0, #12
			int numEpochs = *((float*)(req+5+4*3));
 804106e:	eebd 6ac6 	vcvt.s32.f32	s12, s12
			pc.output_size = POX_OUTPUT_SIZE;
 8041072:	f44f 7180 	mov.w	r1, #256	@ 0x100
			sprintf(buff, "[Test] Training: counter=%d, func=%x, lr=%d, epoch=%d, init_val=%d done [/Test]\n",
 8041076:	eebd 7ac7 	vcvt.s32.f32	s14, s14
 804107a:	eefd 7ae7 	vcvt.s32.f32	s15, s15
			uint32_t func = *((uint32_t*)(req+5+4));
 804107e:	f8dd 3041 	ldr.w	r3, [sp, #65]	@ 0x41
			uint32_t counter = *((uint32_t*)(req+5));
 8041082:	f8dd 203d 	ldr.w	r2, [sp, #61]	@ 0x3d
			pc.input_size = 12;
 8041086:	9008      	str	r0, [sp, #32]
			pc.output_size = POX_OUTPUT_SIZE;
 8041088:	910a      	str	r1, [sp, #40]	@ 0x28
			sprintf(buff, "[Test] Training: counter=%d, func=%x, lr=%d, epoch=%d, init_val=%d done [/Test]\n",
 804108a:	ed8d 6a01 	vstr	s12, [sp, #4]
 804108e:	ed8d 7a02 	vstr	s14, [sp, #8]
 8041092:	edcd 7a00 	vstr	s15, [sp]
 8041096:	4945      	ldr	r1, [pc, #276]	@ (80411ac <single+0x304>)
 8041098:	a827      	add	r0, sp, #156	@ 0x9c
			pc.addr = func;
 804109a:	9306      	str	r3, [sp, #24]
			pc.counter = counter;
 804109c:	920b      	str	r2, [sp, #44]	@ 0x2c
			sprintf(buff, "[Test] Training: counter=%d, func=%x, lr=%d, epoch=%d, init_val=%d done [/Test]\n",
 804109e:	f00a fd95 	bl	804bbcc <siprintf>
	while(s[i] != '\n') i++;
 80410a2:	f89d 309c 	ldrb.w	r3, [sp, #156]	@ 0x9c
		} else if(memcmp(pc.command, "[trn]", pc.command_size) == 0) {
 80410a6:	2400      	movs	r4, #0
	while(s[i] != '\n') i++;
 80410a8:	2b0a      	cmp	r3, #10
 80410aa:	d05b      	beq.n	8041164 <single+0x2bc>
	int i=0;
 80410ac:	4623      	mov	r3, r4
 80410ae:	aa27      	add	r2, sp, #156	@ 0x9c
	while(s[i] != '\n') i++;
 80410b0:	f812 0f01 	ldrb.w	r0, [r2, #1]!
 80410b4:	4619      	mov	r1, r3
 80410b6:	280a      	cmp	r0, #10
 80410b8:	f103 0301 	add.w	r3, r3, #1
 80410bc:	d1f8      	bne.n	80410b0 <single+0x208>
	SECURE_send((uint8_t*)s, (i+1));
 80410be:	3102      	adds	r1, #2
 80410c0:	a827      	add	r0, sp, #156	@ 0x9c
 80410c2:	f00d f829 	bl	804e118 <__SECURE_send_veneer>
			memcpy(pox_input, req+5+4*2, 12);
 80410c6:	f8dd 0045 	ldr.w	r0, [sp, #69]	@ 0x45
 80410ca:	f8dd 1049 	ldr.w	r1, [sp, #73]	@ 0x49
 80410ce:	f8dd 204d 	ldr.w	r2, [sp, #77]	@ 0x4d
 80410d2:	4b2a      	ldr	r3, [pc, #168]	@ (804117c <single+0x2d4>)
 80410d4:	c307      	stmia	r3!, {r0, r1, r2}
			SECURE_pox(&pc, token);
 80410d6:	f10d 0151 	add.w	r1, sp, #81	@ 0x51
 80410da:	a806      	add	r0, sp, #24
 80410dc:	f00d f820 	bl	804e120 <__SECURE_pox_veneer>
			sprintf(buff, "Heap Usage: %d\n",heapSize);
 80410e0:	4b33      	ldr	r3, [pc, #204]	@ (80411b0 <single+0x308>)
 80410e2:	4934      	ldr	r1, [pc, #208]	@ (80411b4 <single+0x30c>)
 80410e4:	681a      	ldr	r2, [r3, #0]
 80410e6:	a827      	add	r0, sp, #156	@ 0x9c
 80410e8:	f00a fd70 	bl	804bbcc <siprintf>
	while(s[i] != '\n') i++;
 80410ec:	f89d 309c 	ldrb.w	r3, [sp, #156]	@ 0x9c
 80410f0:	2b0a      	cmp	r3, #10
 80410f2:	d035      	beq.n	8041160 <single+0x2b8>
	int i=0;
 80410f4:	2300      	movs	r3, #0
 80410f6:	aa27      	add	r2, sp, #156	@ 0x9c
	while(s[i] != '\n') i++;
 80410f8:	f812 0f01 	ldrb.w	r0, [r2, #1]!
 80410fc:	4619      	mov	r1, r3
 80410fe:	280a      	cmp	r0, #10
 8041100:	f103 0301 	add.w	r3, r3, #1
 8041104:	d1f8      	bne.n	80410f8 <single+0x250>
	SECURE_send((uint8_t*)s, (i+1));
 8041106:	3102      	adds	r1, #2
 8041108:	a827      	add	r0, sp, #156	@ 0x9c
 804110a:	f00d f805 	bl	804e118 <__SECURE_send_veneer>
			SECURE_send("[OS]", 4);
 804110e:	2104      	movs	r1, #4
 8041110:	4821      	ldr	r0, [pc, #132]	@ (8041198 <single+0x2f0>)
 8041112:	f00d f801 	bl	804e118 <__SECURE_send_veneer>
			SECURE_send(pc.output, pc.output_size);
 8041116:	e9dd 0109 	ldrd	r0, r1, [sp, #36]	@ 0x24
 804111a:	f00c fffd 	bl	804e118 <__SECURE_send_veneer>
			SECURE_send(" ", 1);
 804111e:	2101      	movs	r1, #1
 8041120:	481e      	ldr	r0, [pc, #120]	@ (804119c <single+0x2f4>)
 8041122:	f00c fff9 	bl	804e118 <__SECURE_send_veneer>
			SECURE_send(token, 32);
 8041126:	2120      	movs	r1, #32
 8041128:	f10d 0051 	add.w	r0, sp, #81	@ 0x51
 804112c:	f00c fff4 	bl	804e118 <__SECURE_send_veneer>
	int i=0;
 8041130:	2300      	movs	r3, #0
 8041132:	4a1b      	ldr	r2, [pc, #108]	@ (80411a0 <single+0x2f8>)
	while(s[i] != '\n') i++;
 8041134:	f812 0f01 	ldrb.w	r0, [r2, #1]!
 8041138:	4619      	mov	r1, r3
 804113a:	280a      	cmp	r0, #10
 804113c:	f103 0301 	add.w	r3, r3, #1
 8041140:	d1f8      	bne.n	8041134 <single+0x28c>
	SECURE_send((uint8_t*)s, (i+1));
 8041142:	4817      	ldr	r0, [pc, #92]	@ (80411a0 <single+0x2f8>)
 8041144:	3102      	adds	r1, #2
 8041146:	f00c ffe7 	bl	804e118 <__SECURE_send_veneer>
	while(s[i] != '\n') i++;
 804114a:	4b16      	ldr	r3, [pc, #88]	@ (80411a4 <single+0x2fc>)
 804114c:	f813 2f01 	ldrb.w	r2, [r3, #1]!
 8041150:	4621      	mov	r1, r4
 8041152:	2a0a      	cmp	r2, #10
 8041154:	f104 0401 	add.w	r4, r4, #1
 8041158:	d1f8      	bne.n	804114c <single+0x2a4>
 804115a:	e765      	b.n	8041028 <single+0x180>
 804115c:	2101      	movs	r1, #1
 804115e:	e726      	b.n	8040fae <single+0x106>
 8041160:	2101      	movs	r1, #1
 8041162:	e7d1      	b.n	8041108 <single+0x260>
 8041164:	2101      	movs	r1, #1
 8041166:	e7ab      	b.n	80410c0 <single+0x218>
 8041168:	2101      	movs	r1, #1
 804116a:	e6ff      	b.n	8040f6c <single+0xc4>
 804116c:	08040e6d 	.word	0x08040e6d
 8041170:	08040d0d 	.word	0x08040d0d
 8041174:	0804e188 	.word	0x0804e188
 8041178:	08040cb9 	.word	0x08040cb9
 804117c:	20018338 	.word	0x20018338
 8041180:	20018238 	.word	0x20018238
 8041184:	7074735b 	.word	0x7074735b
 8041188:	746c635b 	.word	0x746c635b
 804118c:	6e72745b 	.word	0x6e72745b
 8041190:	0804e294 	.word	0x0804e294
 8041194:	0804e1d0 	.word	0x0804e1d0
 8041198:	0804e20c 	.word	0x0804e20c
 804119c:	0804e214 	.word	0x0804e214
 80411a0:	0804e218 	.word	0x0804e218
 80411a4:	0804e220 	.word	0x0804e220
 80411a8:	461c4000 	.word	0x461c4000
 80411ac:	0804e230 	.word	0x0804e230
 80411b0:	20018344 	.word	0x20018344
 80411b4:	0804e284 	.word	0x0804e284

080411b8 <main>:
{
 80411b8:	b508      	push	{r3, lr}
  HAL_Init();
 80411ba:	f00a f933 	bl	804b424 <HAL_Init>
   MX_GPIO_Init();
 80411be:	f7ff fd1f 	bl	8040c00 <MX_GPIO_Init>
  SECURE_RegisterCallback(SECURE_FAULT_CB_ID, (void *)SecureFault_Callback);
 80411c2:	2000      	movs	r0, #0
 80411c4:	4907      	ldr	r1, [pc, #28]	@ (80411e4 <main+0x2c>)
 80411c6:	f00c ffbb 	bl	804e140 <__SECURE_RegisterCallback_veneer>
  SECURE_RegisterCallback(GTZC_ERROR_CB_ID, (void *)SecureError_Callback);
 80411ca:	2001      	movs	r0, #1
 80411cc:	4906      	ldr	r1, [pc, #24]	@ (80411e8 <main+0x30>)
 80411ce:	f00c ffb7 	bl	804e140 <__SECURE_RegisterCallback_veneer>
  srand(time(NULL));
 80411d2:	2000      	movs	r0, #0
 80411d4:	f00a fe2a 	bl	804be2c <time>
 80411d8:	f00a fbc0 	bl	804b95c <srand>
	single();
 80411dc:	f7ff fe64 	bl	8040ea8 <single>
  while (1)
 80411e0:	e7fc      	b.n	80411dc <main+0x24>
 80411e2:	bf00      	nop
 80411e4:	08040c99 	.word	0x08040c99
 80411e8:	08040cb1 	.word	0x08040cb1

080411ec <HAL_MspInit>:
{
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
 80411ec:	4b0a      	ldr	r3, [pc, #40]	@ (8041218 <HAL_MspInit+0x2c>)
{
 80411ee:	b082      	sub	sp, #8
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 80411f0:	6e1a      	ldr	r2, [r3, #96]	@ 0x60
 80411f2:	f042 0201 	orr.w	r2, r2, #1
 80411f6:	661a      	str	r2, [r3, #96]	@ 0x60
 80411f8:	6e1a      	ldr	r2, [r3, #96]	@ 0x60
 80411fa:	f002 0201 	and.w	r2, r2, #1
 80411fe:	9200      	str	r2, [sp, #0]
 8041200:	9a00      	ldr	r2, [sp, #0]
  __HAL_RCC_PWR_CLK_ENABLE();
 8041202:	6d9a      	ldr	r2, [r3, #88]	@ 0x58
 8041204:	f042 5280 	orr.w	r2, r2, #268435456	@ 0x10000000
 8041208:	659a      	str	r2, [r3, #88]	@ 0x58
 804120a:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 804120c:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
 8041210:	9301      	str	r3, [sp, #4]
 8041212:	9b01      	ldr	r3, [sp, #4]
  /* System interrupt init*/

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 8041214:	b002      	add	sp, #8
 8041216:	4770      	bx	lr
 8041218:	40021000 	.word	0x40021000

0804121c <MemManage_Handler>:
void MemManage_Handler(void)
{
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
 804121c:	e7fe      	b.n	804121c <MemManage_Handler>
 804121e:	bf00      	nop

08041220 <UsageFault_Handler>:
void UsageFault_Handler(void)
{
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
 8041220:	e7fe      	b.n	8041220 <UsageFault_Handler>
 8041222:	bf00      	nop

08041224 <SVC_Handler>:

  /* USER CODE END SVCall_IRQn 0 */
  /* USER CODE BEGIN SVCall_IRQn 1 */

  /* USER CODE END SVCall_IRQn 1 */
}
 8041224:	4770      	bx	lr
 8041226:	bf00      	nop

08041228 <PendSV_Handler>:

/**
  * @brief This function handles Pendable request for system service.
  */
void PendSV_Handler(void)
 8041228:	4770      	bx	lr
 804122a:	bf00      	nop

0804122c <SysTick_Handler>:
void SysTick_Handler(void)
{
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 804122c:	f00a b90c 	b.w	804b448 <HAL_IncTick>

08041230 <_getpid>:
}

int _getpid(void)
{
	return 1;
}
 8041230:	2001      	movs	r0, #1
 8041232:	4770      	bx	lr

08041234 <_kill>:

int _kill(int pid, int sig)
{
 8041234:	b508      	push	{r3, lr}
	errno = EINVAL;
 8041236:	f00a fe91 	bl	804bf5c <__errno>
 804123a:	2216      	movs	r2, #22
 804123c:	4603      	mov	r3, r0
	return -1;
}
 804123e:	f04f 30ff 	mov.w	r0, #4294967295
	errno = EINVAL;
 8041242:	601a      	str	r2, [r3, #0]
}
 8041244:	bd08      	pop	{r3, pc}
 8041246:	bf00      	nop

08041248 <_exit>:

void _exit (int status)
{
 8041248:	b508      	push	{r3, lr}
	errno = EINVAL;
 804124a:	f00a fe87 	bl	804bf5c <__errno>
 804124e:	2316      	movs	r3, #22
 8041250:	6003      	str	r3, [r0, #0]
	_kill(status, -1);
	while (1) {}		/* Make sure we hang here */
 8041252:	e7fe      	b.n	8041252 <_exit+0xa>

08041254 <_read>:
}

__attribute__((weak)) int _read(int file, char *ptr, int len)
{
 8041254:	b570      	push	{r4, r5, r6, lr}
	int DataIdx;

	for (DataIdx = 0; DataIdx < len; DataIdx++)
 8041256:	1e16      	subs	r6, r2, #0
 8041258:	dd07      	ble.n	804126a <_read+0x16>
 804125a:	460c      	mov	r4, r1
 804125c:	198d      	adds	r5, r1, r6
	{
		*ptr++ = __io_getchar();
 804125e:	f3af 8000 	nop.w
 8041262:	f804 0b01 	strb.w	r0, [r4], #1
	for (DataIdx = 0; DataIdx < len; DataIdx++)
 8041266:	42a5      	cmp	r5, r4
 8041268:	d1f9      	bne.n	804125e <_read+0xa>
	}

return len;
}
 804126a:	4630      	mov	r0, r6
 804126c:	bd70      	pop	{r4, r5, r6, pc}
 804126e:	bf00      	nop

08041270 <_write>:

__attribute__((weak)) int _write(int file, char *ptr, int len)
{
 8041270:	b570      	push	{r4, r5, r6, lr}
	int DataIdx;

	for (DataIdx = 0; DataIdx < len; DataIdx++)
 8041272:	1e16      	subs	r6, r2, #0
 8041274:	dd07      	ble.n	8041286 <_write+0x16>
 8041276:	460c      	mov	r4, r1
 8041278:	198d      	adds	r5, r1, r6
	{
		__io_putchar(*ptr++);
 804127a:	f814 0b01 	ldrb.w	r0, [r4], #1
 804127e:	f3af 8000 	nop.w
	for (DataIdx = 0; DataIdx < len; DataIdx++)
 8041282:	42ac      	cmp	r4, r5
 8041284:	d1f9      	bne.n	804127a <_write+0xa>
	}
	return len;
}
 8041286:	4630      	mov	r0, r6
 8041288:	bd70      	pop	{r4, r5, r6, pc}
 804128a:	bf00      	nop

0804128c <_close>:

int _close(int file)
{
	return -1;
}
 804128c:	f04f 30ff 	mov.w	r0, #4294967295
 8041290:	4770      	bx	lr
 8041292:	bf00      	nop

08041294 <_fstat>:


int _fstat(int file, struct stat *st)
{
	st->st_mode = S_IFCHR;
 8041294:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
	return 0;
}
 8041298:	2000      	movs	r0, #0
	st->st_mode = S_IFCHR;
 804129a:	604b      	str	r3, [r1, #4]
}
 804129c:	4770      	bx	lr
 804129e:	bf00      	nop

080412a0 <_isatty>:

int _isatty(int file)
{
	return 1;
}
 80412a0:	2001      	movs	r0, #1
 80412a2:	4770      	bx	lr

080412a4 <_lseek>:

int _lseek(int file, int ptr, int dir)
{
	return 0;
}
 80412a4:	2000      	movs	r0, #0
 80412a6:	4770      	bx	lr

080412a8 <_sbrk>:
  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;
  const uint8_t *max_heap = (uint8_t *)stack_limit;
  uint8_t *prev_heap_end;

  /* Initialize heap end at first call */
  if (NULL == __sbrk_heap_end)
 80412a8:	490d      	ldr	r1, [pc, #52]	@ (80412e0 <_sbrk+0x38>)
{
 80412aa:	4603      	mov	r3, r0
 80412ac:	b510      	push	{r4, lr}
  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;
 80412ae:	4a0d      	ldr	r2, [pc, #52]	@ (80412e4 <_sbrk+0x3c>)
 80412b0:	4c0d      	ldr	r4, [pc, #52]	@ (80412e8 <_sbrk+0x40>)
  if (NULL == __sbrk_heap_end)
 80412b2:	6808      	ldr	r0, [r1, #0]
  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;
 80412b4:	1b12      	subs	r2, r2, r4
  if (NULL == __sbrk_heap_end)
 80412b6:	b120      	cbz	r0, 80412c2 <_sbrk+0x1a>
  {
    __sbrk_heap_end = &_end;
  }

  /* Protect heap from growing into the reserved MSP stack */
  if (__sbrk_heap_end + incr > max_heap)
 80412b8:	4403      	add	r3, r0
 80412ba:	4293      	cmp	r3, r2
 80412bc:	d807      	bhi.n	80412ce <_sbrk+0x26>
    errno = ENOMEM;
    return (void *)-1;
  }

  prev_heap_end = __sbrk_heap_end;
  __sbrk_heap_end += incr;
 80412be:	600b      	str	r3, [r1, #0]

  return (void *)prev_heap_end;
}
 80412c0:	bd10      	pop	{r4, pc}
    __sbrk_heap_end = &_end;
 80412c2:	4c0a      	ldr	r4, [pc, #40]	@ (80412ec <_sbrk+0x44>)
 80412c4:	4620      	mov	r0, r4
  if (__sbrk_heap_end + incr > max_heap)
 80412c6:	4403      	add	r3, r0
 80412c8:	4293      	cmp	r3, r2
    __sbrk_heap_end = &_end;
 80412ca:	600c      	str	r4, [r1, #0]
  if (__sbrk_heap_end + incr > max_heap)
 80412cc:	d9f7      	bls.n	80412be <_sbrk+0x16>
    errno = ENOMEM;
 80412ce:	f00a fe45 	bl	804bf5c <__errno>
 80412d2:	220c      	movs	r2, #12
 80412d4:	4603      	mov	r3, r0
    return (void *)-1;
 80412d6:	f04f 30ff 	mov.w	r0, #4294967295
    errno = ENOMEM;
 80412da:	601a      	str	r2, [r3, #0]
}
 80412dc:	bd10      	pop	{r4, pc}
 80412de:	bf00      	nop
 80412e0:	20018348 	.word	0x20018348
 80412e4:	20040000 	.word	0x20040000
 80412e8:	00008000 	.word	0x00008000
 80412ec:	200184a0 	.word	0x200184a0

080412f0 <SystemInit>:
#endif

  /* Non-secure main application shall call SystemCoreClockUpdate() to update */
  /* the SystemCoreClock variable to insure non-secure application relies on  */
  /* the initial clock reference set by secure application.                   */
}
 80412f0:	4770      	bx	lr
 80412f2:	bf00      	nop

080412f4 <SystemCoreClockUpdate>:
  *           value for HSE crystal.
  *
  * @retval None
  */
void SystemCoreClockUpdate(void)
{
 80412f4:	b508      	push	{r3, lr}
  /* Get the SystemCoreClock value from the secure domain */
  SystemCoreClock = SECURE_SystemCoreClockUpdate();
 80412f6:	f00c ff1f 	bl	804e138 <__SECURE_SystemCoreClockUpdate_veneer>
 80412fa:	4b01      	ldr	r3, [pc, #4]	@ (8041300 <SystemCoreClockUpdate+0xc>)
 80412fc:	6018      	str	r0, [r3, #0]
}
 80412fe:	bd08      	pop	{r3, pc}
 8041300:	20018000 	.word	0x20018000

08041304 <tg_gen.constprop.0>:
	for (i = 0; i < tg->len; ++i)
		tg->data[i] = tg->c2i[tg->data[i]];
	return tg;
}

void tg_gen(kann_t *ann, float temp, int len, const int c2i[256])
 8041304:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8041308:	ed2d 8b02 	vpush	{d8}
 804130c:	f6ad 0d24 	subw	sp, sp, #2084	@ 0x824
{
	int i, c, n_char, i2c[256], i_temp;
	float x[256];
	memset(i2c, 0, 256 * sizeof(int));
 8041310:	f10d 0820 	add.w	r8, sp, #32
void tg_gen(kann_t *ann, float temp, int len, const int c2i[256])
 8041314:	468b      	mov	fp, r1
 8041316:	4682      	mov	sl, r0
	memset(i2c, 0, 256 * sizeof(int));
 8041318:	2100      	movs	r1, #0
 804131a:	f44f 6280 	mov.w	r2, #1024	@ 0x400
 804131e:	4640      	mov	r0, r8
 8041320:	f00a fd4c 	bl	804bdbc <memset>
	for (i = 0; i < 256; ++i)
 8041324:	2300      	movs	r3, #0
 8041326:	f1ab 0104 	sub.w	r1, fp, #4
		if (c2i[i] >= 0) i2c[c2i[i]] = i;
 804132a:	f851 2f04 	ldr.w	r2, [r1, #4]!
 804132e:	2a00      	cmp	r2, #0
 8041330:	bfa8      	it	ge
 8041332:	f848 3022 	strge.w	r3, [r8, r2, lsl #2]
	for (i = 0; i < 256; ++i)
 8041336:	3301      	adds	r3, #1
 8041338:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 804133c:	d1f5      	bne.n	804132a <tg_gen.constprop.0+0x26>
	n_char = kann_dim_in(ann);
 804133e:	2200      	movs	r2, #0
 8041340:	2101      	movs	r1, #1
 8041342:	4650      	mov	r0, sl
 8041344:	f000 feda 	bl	80420fc <kann_feed_dim>
	i_temp = kann_find(ann, 0, -1);
 8041348:	f04f 32ff 	mov.w	r2, #4294967295
	n_char = kann_dim_in(ann);
 804134c:	4604      	mov	r4, r0
	i_temp = kann_find(ann, 0, -1);
 804134e:	2100      	movs	r1, #0
 8041350:	4650      	mov	r0, sl
 8041352:	f000 fe0f 	bl	8041f74 <kann_find>
	if (i_temp >= 0) ann->v[i_temp]->x[0] = 1.0f / temp;
 8041356:	1e05      	subs	r5, r0, #0
 8041358:	db06      	blt.n	8041368 <tg_gen.constprop.0+0x64>
 804135a:	f8da 3004 	ldr.w	r3, [sl, #4]
 804135e:	4a63      	ldr	r2, [pc, #396]	@ (80414ec <tg_gen.constprop.0+0x1e8>)
 8041360:	f853 3025 	ldr.w	r3, [r3, r5, lsl #2]
 8041364:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8041366:	601a      	str	r2, [r3, #0]
	kann_rnn_start(ann);
 8041368:	4650      	mov	r0, sl
 804136a:	f000 ff11 	bl	8042190 <kann_rnn_start>
	for (c = 0; c < ann->n; ++c) {
 804136e:	f8da 2000 	ldr.w	r2, [sl]
 8041372:	2a00      	cmp	r2, #0
 8041374:	dd43      	ble.n	80413fe <tg_gen.constprop.0+0xfa>
 8041376:	f04f 0900 	mov.w	r9, #0
		kad_node_t *p = ann->v[c];
		if (p->pre) {
			int l = kad_len(p);
			for (i = 0; i < l; ++i)
				p->x[i] = 2.0 * kann_drand() - 1.0;
 804137a:	e9cd 4500 	strd	r4, r5, [sp]
 804137e:	e003      	b.n	8041388 <tg_gen.constprop.0+0x84>
	for (c = 0; c < ann->n; ++c) {
 8041380:	f109 0901 	add.w	r9, r9, #1
 8041384:	4591      	cmp	r9, r2
 8041386:	da38      	bge.n	80413fa <tg_gen.constprop.0+0xf6>
		kad_node_t *p = ann->v[c];
 8041388:	f8da 3004 	ldr.w	r3, [sl, #4]
 804138c:	f853 4029 	ldr.w	r4, [r3, r9, lsl #2]
		if (p->pre) {
 8041390:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
 8041392:	2b00      	cmp	r3, #0
 8041394:	d0f4      	beq.n	8041380 <tg_gen.constprop.0+0x7c>
extern char *kad_op_name[KAD_MAX_OP];

static inline int kad_len(const kad_node_t *p) /* calculate the size of p->x */
{
	int n = 1, i;
	for (i = 0; i < p->n_d; ++i) n *= p->d[i];
 8041396:	7820      	ldrb	r0, [r4, #0]
 8041398:	2800      	cmp	r0, #0
 804139a:	f000 808b 	beq.w	80414b4 <tg_gen.constprop.0+0x1b0>
 804139e:	2801      	cmp	r0, #1
 80413a0:	6925      	ldr	r5, [r4, #16]
 80413a2:	d00b      	beq.n	80413bc <tg_gen.constprop.0+0xb8>
 80413a4:	6963      	ldr	r3, [r4, #20]
 80413a6:	2802      	cmp	r0, #2
 80413a8:	fb03 f505 	mul.w	r5, r3, r5
 80413ac:	d006      	beq.n	80413bc <tg_gen.constprop.0+0xb8>
 80413ae:	69a3      	ldr	r3, [r4, #24]
 80413b0:	2803      	cmp	r0, #3
 80413b2:	fb03 f505 	mul.w	r5, r3, r5
 80413b6:	bf1c      	itt	ne
 80413b8:	69e3      	ldrne	r3, [r4, #28]
 80413ba:	435d      	mulne	r5, r3
			for (i = 0; i < l; ++i)
 80413bc:	2d00      	cmp	r5, #0
 80413be:	dddf      	ble.n	8041380 <tg_gen.constprop.0+0x7c>
 80413c0:	2600      	movs	r6, #0
				p->x[i] = 2.0 * kann_drand() - 1.0;
 80413c2:	2000      	movs	r0, #0
 80413c4:	f009 fe1a 	bl	804affc <kad_drand>
 80413c8:	ec53 2b10 	vmov	r2, r3, d0
 80413cc:	4610      	mov	r0, r2
 80413ce:	4619      	mov	r1, r3
 80413d0:	f7fe ff38 	bl	8040244 <__adddf3>
 80413d4:	2200      	movs	r2, #0
 80413d6:	4b46      	ldr	r3, [pc, #280]	@ (80414f0 <tg_gen.constprop.0+0x1ec>)
 80413d8:	f7fe ff32 	bl	8040240 <__aeabi_dsub>
 80413dc:	f7ff fbc0 	bl	8040b60 <__aeabi_d2f>
 80413e0:	6aa7      	ldr	r7, [r4, #40]	@ 0x28
 80413e2:	eb07 0786 	add.w	r7, r7, r6, lsl #2
			for (i = 0; i < l; ++i)
 80413e6:	3601      	adds	r6, #1
 80413e8:	42ae      	cmp	r6, r5
				p->x[i] = 2.0 * kann_drand() - 1.0;
 80413ea:	6038      	str	r0, [r7, #0]
			for (i = 0; i < l; ++i)
 80413ec:	dbe9      	blt.n	80413c2 <tg_gen.constprop.0+0xbe>
	for (c = 0; c < ann->n; ++c) {
 80413ee:	f8da 2000 	ldr.w	r2, [sl]
 80413f2:	f109 0901 	add.w	r9, r9, #1
 80413f6:	4591      	cmp	r9, r2
 80413f8:	dbc6      	blt.n	8041388 <tg_gen.constprop.0+0x84>
 80413fa:	e9dd 4500 	ldrd	r4, r5, [sp]
		}
	}
	c= c2i[(int)' '];

	char buffer[20] = {0};
 80413fe:	2300      	movs	r3, #0

	for (i = 0; i < len; ++i) {
		float s, r;
		const float *y;
		memset(x, 0, n_char * sizeof(float));
		x[c] = 1.0f;
 8041400:	eeb7 8a00 	vmov.f32	s16, #112	@ 0x3f800000  1.0
	char buffer[20] = {0};
 8041404:	e9cd 3303 	strd	r3, r3, [sp, #12]
 8041408:	e9cd 3305 	strd	r3, r3, [sp, #20]
	c= c2i[(int)' '];
 804140c:	f8db 6080 	ldr.w	r6, [fp, #128]	@ 0x80
		memset(x, 0, n_char * sizeof(float));
 8041410:	ea4f 0984 	mov.w	r9, r4, lsl #2
 8041414:	f10d 0b0b 	add.w	fp, sp, #11
 8041418:	f10d 071f 	add.w	r7, sp, #31
	char buffer[20] = {0};
 804141c:	9307      	str	r3, [sp, #28]
		memset(x, 0, n_char * sizeof(float));
 804141e:	464a      	mov	r2, r9
 8041420:	2100      	movs	r1, #0
 8041422:	f50d 6084 	add.w	r0, sp, #1056	@ 0x420
 8041426:	f00a fcc9 	bl	804bdbc <memset>
		y = kann_apply1(ann, x);
 804142a:	f50d 6184 	add.w	r1, sp, #1056	@ 0x420
		x[c] = 1.0f;
 804142e:	eb01 0686 	add.w	r6, r1, r6, lsl #2
		y = kann_apply1(ann, x);
 8041432:	4650      	mov	r0, sl
		x[c] = 1.0f;
 8041434:	ed86 8a00 	vstr	s16, [r6]
		y = kann_apply1(ann, x);
 8041438:	f001 fb72 	bl	8042b20 <kann_apply1>
 804143c:	4606      	mov	r6, r0
		r = kann_drand();
 804143e:	2000      	movs	r0, #0
 8041440:	f009 fddc 	bl	804affc <kad_drand>
 8041444:	ec51 0b10 	vmov	r0, r1, d0
 8041448:	f7ff fb8a 	bl	8040b60 <__aeabi_d2f>
		for (c = 0, s = 0.0f; c < n_char; ++c)
 804144c:	2c00      	cmp	r4, #0
		r = kann_drand();
 804144e:	ee06 0a90 	vmov	s13, r0
		for (c = 0, s = 0.0f; c < n_char; ++c)
 8041452:	dd42      	ble.n	80414da <tg_gen.constprop.0+0x1d6>
 8041454:	4630      	mov	r0, r6
 8041456:	eddf 7a27 	vldr	s15, [pc, #156]	@ 80414f4 <tg_gen.constprop.0+0x1f0>
 804145a:	2600      	movs	r6, #0
 804145c:	e002      	b.n	8041464 <tg_gen.constprop.0+0x160>
 804145e:	3601      	adds	r6, #1
 8041460:	42b4      	cmp	r4, r6
 8041462:	d008      	beq.n	8041476 <tg_gen.constprop.0+0x172>
			if (s + y[c] >= r) break;
 8041464:	ecb0 7a01 	vldmia	r0!, {s14}
 8041468:	ee77 7a87 	vadd.f32	s15, s15, s14
 804146c:	eef4 6ae7 	vcmpe.f32	s13, s15
 8041470:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8041474:	d8f3      	bhi.n	804145e <tg_gen.constprop.0+0x15a>
			else s += y[c];

		buffer[i] = i2c[c];
 8041476:	f858 3026 	ldr.w	r3, [r8, r6, lsl #2]
 804147a:	f80b 3f01 	strb.w	r3, [fp, #1]!
	for (i = 0; i < len; ++i) {
 804147e:	45bb      	cmp	fp, r7
 8041480:	d1cd      	bne.n	804141e <tg_gen.constprop.0+0x11a>
	}

	buffer[len] = '\n';
 8041482:	230a      	movs	r3, #10
	sendline(buffer);
 8041484:	a803      	add	r0, sp, #12
	buffer[len] = '\n';
 8041486:	f88d 3020 	strb.w	r3, [sp, #32]
	sendline(buffer);
 804148a:	f7ff fc63 	bl	8040d54 <sendline>

	kann_rnn_end(ann);
 804148e:	4650      	mov	r0, sl
 8041490:	f000 fed2 	bl	8042238 <kann_rnn_end>
	if (i_temp >= 0) ann->v[i_temp]->x[0] = 1.0f;
 8041494:	2d00      	cmp	r5, #0
 8041496:	db07      	blt.n	80414a8 <tg_gen.constprop.0+0x1a4>
 8041498:	f04f 527e 	mov.w	r2, #1065353216	@ 0x3f800000
 804149c:	f8da 3004 	ldr.w	r3, [sl, #4]
 80414a0:	f853 3025 	ldr.w	r3, [r3, r5, lsl #2]
 80414a4:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80414a6:	601a      	str	r2, [r3, #0]
}
 80414a8:	f60d 0d24 	addw	sp, sp, #2084	@ 0x824
 80414ac:	ecbd 8b02 	vpop	{d8}
 80414b0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				p->x[i] = 2.0 * kann_drand() - 1.0;
 80414b4:	f009 fda2 	bl	804affc <kad_drand>
 80414b8:	ec53 2b10 	vmov	r2, r3, d0
 80414bc:	4610      	mov	r0, r2
 80414be:	4619      	mov	r1, r3
 80414c0:	f7fe fec0 	bl	8040244 <__adddf3>
 80414c4:	2200      	movs	r2, #0
 80414c6:	4b0a      	ldr	r3, [pc, #40]	@ (80414f0 <tg_gen.constprop.0+0x1ec>)
 80414c8:	f7fe feba 	bl	8040240 <__aeabi_dsub>
 80414cc:	f7ff fb48 	bl	8040b60 <__aeabi_d2f>
 80414d0:	6aa6      	ldr	r6, [r4, #40]	@ 0x28
	for (c = 0; c < ann->n; ++c) {
 80414d2:	f8da 2000 	ldr.w	r2, [sl]
				p->x[i] = 2.0 * kann_drand() - 1.0;
 80414d6:	6030      	str	r0, [r6, #0]
			for (i = 0; i < l; ++i)
 80414d8:	e78b      	b.n	80413f2 <tg_gen.constprop.0+0xee>
		for (c = 0, s = 0.0f; c < n_char; ++c)
 80414da:	2600      	movs	r6, #0
		buffer[i] = i2c[c];
 80414dc:	f858 3026 	ldr.w	r3, [r8, r6, lsl #2]
 80414e0:	f80b 3f01 	strb.w	r3, [fp, #1]!
	for (i = 0; i < len; ++i) {
 80414e4:	45bb      	cmp	fp, r7
 80414e6:	d19a      	bne.n	804141e <tg_gen.constprop.0+0x11a>
 80414e8:	e7cb      	b.n	8041482 <tg_gen.constprop.0+0x17e>
 80414ea:	bf00      	nop
 80414ec:	40200000 	.word	0x40200000
 80414f0:	3ff00000 	.word	0x3ff00000
 80414f4:	00000000 	.word	0x00000000

080414f8 <tg_init_with_data>:
{
 80414f8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80414fc:	460e      	mov	r6, r1
 80414fe:	4680      	mov	r8, r0
	tg = (tg_data_t*)calloc(1, sizeof(tg_data_t));
 8041500:	f240 410c 	movw	r1, #1036	@ 0x40c
 8041504:	2001      	movs	r0, #1
 8041506:	f00a f94f 	bl	804b7a8 <calloc>
 804150a:	4604      	mov	r4, r0
	heapSize += 1* sizeof(tg_data_t);
 804150c:	4f22      	ldr	r7, [pc, #136]	@ (8041598 <tg_init_with_data+0xa0>)
	tg->data = calloc(tg->len, sizeof(uint8_t));
 804150e:	2101      	movs	r1, #1
	heapSize += 1* sizeof(tg_data_t);
 8041510:	683b      	ldr	r3, [r7, #0]
	tg->data = calloc(tg->len, sizeof(uint8_t));
 8041512:	4630      	mov	r0, r6
	heapSize += 1* sizeof(tg_data_t);
 8041514:	f203 430c 	addw	r3, r3, #1036	@ 0x40c
	tg->len = len;
 8041518:	6026      	str	r6, [r4, #0]
	heapSize += 1* sizeof(tg_data_t);
 804151a:	603b      	str	r3, [r7, #0]
	tg->data = calloc(tg->len, sizeof(uint8_t));
 804151c:	f00a f944 	bl	804b7a8 <calloc>
	heapSize += tg->len * sizeof(uint8_t);
 8041520:	683b      	ldr	r3, [r7, #0]
	memcpy(tg->data, input, len);
 8041522:	4641      	mov	r1, r8
	heapSize += tg->len * sizeof(uint8_t);
 8041524:	4433      	add	r3, r6
	memcpy(tg->data, input, len);
 8041526:	4632      	mov	r2, r6
	tg->data = calloc(tg->len, sizeof(uint8_t));
 8041528:	60a0      	str	r0, [r4, #8]
 804152a:	4605      	mov	r5, r0
	heapSize += tg->len * sizeof(uint8_t);
 804152c:	603b      	str	r3, [r7, #0]
	memcpy(tg->data, input, len);
 804152e:	f00a fd42 	bl	804bfb6 <memcpy>
	for (i = 0; i < tg->len; ++i)
 8041532:	2e00      	cmp	r6, #0
 8041534:	dd0a      	ble.n	804154c <tg_init_with_data+0x54>
		tg->c2i[tg->data[i]] = 1;
 8041536:	2001      	movs	r0, #1
 8041538:	1e71      	subs	r1, r6, #1
 804153a:	1e6a      	subs	r2, r5, #1
 804153c:	4429      	add	r1, r5
 804153e:	f812 3f01 	ldrb.w	r3, [r2, #1]!
 8041542:	eb04 0383 	add.w	r3, r4, r3, lsl #2
	for (i = 0; i < tg->len; ++i)
 8041546:	428a      	cmp	r2, r1
		tg->c2i[tg->data[i]] = 1;
 8041548:	60d8      	str	r0, [r3, #12]
	for (i = 0; i < tg->len; ++i)
 804154a:	d1f8      	bne.n	804153e <tg_init_with_data+0x46>
	for (i = j = 0; i < 256; ++i)
 804154c:	2000      	movs	r0, #0
 804154e:	f104 0308 	add.w	r3, r4, #8
 8041552:	f504 6c81 	add.w	ip, r4, #1032	@ 0x408
 8041556:	e005      	b.n	8041564 <tg_init_with_data+0x6c>
		else tg->c2i[i] = j++;
 8041558:	4601      	mov	r1, r0
	for (i = j = 0; i < 256; ++i)
 804155a:	4563      	cmp	r3, ip
		else tg->c2i[i] = j++;
 804155c:	f100 0001 	add.w	r0, r0, #1
 8041560:	6019      	str	r1, [r3, #0]
	for (i = j = 0; i < 256; ++i)
 8041562:	d008      	beq.n	8041576 <tg_init_with_data+0x7e>
		if (tg->c2i[i] == 0) tg->c2i[i] = -1;
 8041564:	f853 1f04 	ldr.w	r1, [r3, #4]!
 8041568:	2900      	cmp	r1, #0
 804156a:	d1f5      	bne.n	8041558 <tg_init_with_data+0x60>
 804156c:	f04f 31ff 	mov.w	r1, #4294967295
	for (i = j = 0; i < 256; ++i)
 8041570:	4563      	cmp	r3, ip
 8041572:	6019      	str	r1, [r3, #0]
 8041574:	d1f6      	bne.n	8041564 <tg_init_with_data+0x6c>
	for (i = 0; i < tg->len; ++i)
 8041576:	2e00      	cmp	r6, #0
	tg->n_char = j;
 8041578:	6060      	str	r0, [r4, #4]
	for (i = 0; i < tg->len; ++i)
 804157a:	dd0a      	ble.n	8041592 <tg_init_with_data+0x9a>
 804157c:	3e01      	subs	r6, #1
 804157e:	1e6b      	subs	r3, r5, #1
 8041580:	4435      	add	r5, r6
		tg->data[i] = tg->c2i[tg->data[i]];
 8041582:	f813 2f01 	ldrb.w	r2, [r3, #1]!
 8041586:	eb04 0282 	add.w	r2, r4, r2, lsl #2
 804158a:	68d2      	ldr	r2, [r2, #12]
	for (i = 0; i < tg->len; ++i)
 804158c:	42ab      	cmp	r3, r5
		tg->data[i] = tg->c2i[tg->data[i]];
 804158e:	701a      	strb	r2, [r3, #0]
	for (i = 0; i < tg->len; ++i)
 8041590:	d1f7      	bne.n	8041582 <tg_init_with_data+0x8a>
}
 8041592:	4620      	mov	r0, r4
 8041594:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8041598:	20018344 	.word	0x20018344

0804159c <tg_urnn_start>:

int tg_urnn_start(kann_t *ann, int batch_size)
{
 804159c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80415a0:	4607      	mov	r7, r0
	int i, j, n, cnt = 0;
	for (i = 0; i < ann->n; ++i) {
 80415a2:	6800      	ldr	r0, [r0, #0]
{
 80415a4:	4689      	mov	r9, r1
	for (i = 0; i < ann->n; ++i) {
 80415a6:	2800      	cmp	r0, #0
		kad_node_t *p = ann->v[i];
		if (p->pre && p->n_d >= 2 && p->pre->n_d == p->n_d && p->pre->n_child == 0 && kad_len(p)/p->d[0] == kad_len(p->pre)/p->pre->d[0])
			p->pre->flag = 0;
	}
	kann_set_batch_size(ann, batch_size);
 80415a8:	6879      	ldr	r1, [r7, #4]
	for (i = 0; i < ann->n; ++i) {
 80415aa:	dd39      	ble.n	8041620 <tg_urnn_start+0x84>
 80415ac:	1f0b      	subs	r3, r1, #4
 80415ae:	eb03 0c80 	add.w	ip, r3, r0, lsl #2
 80415b2:	e001      	b.n	80415b8 <tg_urnn_start+0x1c>
 80415b4:	4563      	cmp	r3, ip
 80415b6:	d033      	beq.n	8041620 <tg_urnn_start+0x84>
		kad_node_t *p = ann->v[i];
 80415b8:	f853 4f04 	ldr.w	r4, [r3, #4]!
		if (p->pre && p->n_d >= 2 && p->pre->n_d == p->n_d && p->pre->n_child == 0 && kad_len(p)/p->d[0] == kad_len(p->pre)/p->pre->d[0])
 80415bc:	6be5      	ldr	r5, [r4, #60]	@ 0x3c
 80415be:	2d00      	cmp	r5, #0
 80415c0:	d0f8      	beq.n	80415b4 <tg_urnn_start+0x18>
 80415c2:	7826      	ldrb	r6, [r4, #0]
 80415c4:	2e01      	cmp	r6, #1
 80415c6:	d9f5      	bls.n	80415b4 <tg_urnn_start+0x18>
 80415c8:	f895 e000 	ldrb.w	lr, [r5]
 80415cc:	4576      	cmp	r6, lr
 80415ce:	d1f1      	bne.n	80415b4 <tg_urnn_start+0x18>
 80415d0:	686a      	ldr	r2, [r5, #4]
 80415d2:	2a00      	cmp	r2, #0
 80415d4:	d1ee      	bne.n	80415b4 <tg_urnn_start+0x18>
 80415d6:	e9d4 8e04 	ldrd	r8, lr, [r4, #16]
 80415da:	2e02      	cmp	r6, #2
 80415dc:	d00b      	beq.n	80415f6 <tg_urnn_start+0x5a>
 80415de:	fb08 fe0e 	mul.w	lr, r8, lr
 80415e2:	69a2      	ldr	r2, [r4, #24]
 80415e4:	2e03      	cmp	r6, #3
 80415e6:	fb02 fe0e 	mul.w	lr, r2, lr
 80415ea:	bf1c      	itt	ne
 80415ec:	69e4      	ldrne	r4, [r4, #28]
 80415ee:	fb04 fe0e 	mulne.w	lr, r4, lr
 80415f2:	fb9e fef8 	sdiv	lr, lr, r8
 80415f6:	e9d5 8404 	ldrd	r8, r4, [r5, #16]
 80415fa:	2e02      	cmp	r6, #2
 80415fc:	fb04 f408 	mul.w	r4, r4, r8
 8041600:	d006      	beq.n	8041610 <tg_urnn_start+0x74>
 8041602:	69aa      	ldr	r2, [r5, #24]
 8041604:	2e03      	cmp	r6, #3
 8041606:	fb02 f404 	mul.w	r4, r2, r4
 804160a:	bf1c      	itt	ne
 804160c:	69ee      	ldrne	r6, [r5, #28]
 804160e:	4374      	mulne	r4, r6
 8041610:	fb94 f4f8 	sdiv	r4, r4, r8
 8041614:	4574      	cmp	r4, lr
			p->pre->flag = 0;
 8041616:	bf04      	itt	eq
 8041618:	2400      	moveq	r4, #0
 804161a:	706c      	strbeq	r4, [r5, #1]
	for (i = 0; i < ann->n; ++i) {
 804161c:	4563      	cmp	r3, ip
 804161e:	d1cb      	bne.n	80415b8 <tg_urnn_start+0x1c>
	int i, j, n, cnt = 0;
 8041620:	f04f 0800 	mov.w	r8, #0
	kann_set_batch_size(ann, batch_size);
 8041624:	464a      	mov	r2, r9
 8041626:	f008 fd87 	bl	804a138 <kad_sync_dim>
	for (i = 0; i < ann->n; ++i) {
 804162a:	683a      	ldr	r2, [r7, #0]
 804162c:	2a00      	cmp	r2, #0
 804162e:	bfc8      	it	gt
 8041630:	4644      	movgt	r4, r8
 8041632:	dc03      	bgt.n	804163c <tg_urnn_start+0xa0>
 8041634:	e04c      	b.n	80416d0 <tg_urnn_start+0x134>
 8041636:	3401      	adds	r4, #1
 8041638:	4294      	cmp	r4, r2
 804163a:	da49      	bge.n	80416d0 <tg_urnn_start+0x134>
		kad_node_t *p = ann->v[i];
 804163c:	687b      	ldr	r3, [r7, #4]
 804163e:	f853 5024 	ldr.w	r5, [r3, r4, lsl #2]
		if (p->pre && p->n_d >= 2 && p->pre->n_d == p->n_d && p->pre->n_child == 0 && kad_len(p) == kad_len(p->pre)) {
 8041642:	6bee      	ldr	r6, [r5, #60]	@ 0x3c
 8041644:	2e00      	cmp	r6, #0
 8041646:	d0f6      	beq.n	8041636 <tg_urnn_start+0x9a>
 8041648:	782b      	ldrb	r3, [r5, #0]
 804164a:	2b01      	cmp	r3, #1
 804164c:	d9f3      	bls.n	8041636 <tg_urnn_start+0x9a>
 804164e:	7831      	ldrb	r1, [r6, #0]
 8041650:	428b      	cmp	r3, r1
 8041652:	d1f0      	bne.n	8041636 <tg_urnn_start+0x9a>
 8041654:	f8d6 9004 	ldr.w	r9, [r6, #4]
 8041658:	f1b9 0f00 	cmp.w	r9, #0
 804165c:	d1eb      	bne.n	8041636 <tg_urnn_start+0x9a>
 804165e:	e9d5 c104 	ldrd	ip, r1, [r5, #16]
 8041662:	2b02      	cmp	r3, #2
 8041664:	fb01 fe0c 	mul.w	lr, r1, ip
 8041668:	d035      	beq.n	80416d6 <tg_urnn_start+0x13a>
 804166a:	69a9      	ldr	r1, [r5, #24]
 804166c:	2b03      	cmp	r3, #3
 804166e:	fb01 fb0e 	mul.w	fp, r1, lr
 8041672:	bf1c      	itt	ne
 8041674:	69e8      	ldrne	r0, [r5, #28]
 8041676:	fb00 fb0b 	mulne.w	fp, r0, fp
 804167a:	6930      	ldr	r0, [r6, #16]
 804167c:	6971      	ldr	r1, [r6, #20]
 804167e:	2b02      	cmp	r3, #2
 8041680:	fb01 fa00 	mul.w	sl, r1, r0
 8041684:	d007      	beq.n	8041696 <tg_urnn_start+0xfa>
 8041686:	69b0      	ldr	r0, [r6, #24]
 8041688:	2b03      	cmp	r3, #3
 804168a:	fb00 fa0a 	mul.w	sl, r0, sl
 804168e:	bf1c      	itt	ne
 8041690:	69f0      	ldrne	r0, [r6, #28]
 8041692:	fb00 fa0a 	mulne.w	sl, r0, sl
 8041696:	45d3      	cmp	fp, sl
 8041698:	d1cd      	bne.n	8041636 <tg_urnn_start+0x9a>
 804169a:	2b02      	cmp	r3, #2
 804169c:	d007      	beq.n	80416ae <tg_urnn_start+0x112>
 804169e:	69aa      	ldr	r2, [r5, #24]
 80416a0:	2b03      	cmp	r3, #3
 80416a2:	fb02 fe0e 	mul.w	lr, r2, lr
 80416a6:	bf1c      	itt	ne
 80416a8:	69eb      	ldrne	r3, [r5, #28]
 80416aa:	fb03 fe0e 	mulne.w	lr, r3, lr
			kad_node_t *q = p->pre;
			n = kad_len(p) / p->d[0];
 80416ae:	fb9e fbfc 	sdiv	fp, lr, ip
			memset(p->x, 0, p->d[0] * n * sizeof(float));
 80416b2:	fb0c f20b 	mul.w	r2, ip, fp
 80416b6:	2100      	movs	r1, #0
 80416b8:	6aa8      	ldr	r0, [r5, #40]	@ 0x28
 80416ba:	0092      	lsls	r2, r2, #2
 80416bc:	f00a fb7e 	bl	804bdbc <memset>
			if (q->x)
 80416c0:	6ab1      	ldr	r1, [r6, #40]	@ 0x28
 80416c2:	b959      	cbnz	r1, 80416dc <tg_urnn_start+0x140>
				for (j = 0; j < p->d[0]; ++j)
					memcpy(&p->x[j * n], q->x, n * sizeof(float));
			q->x = p->x;
 80416c4:	6aab      	ldr	r3, [r5, #40]	@ 0x28
	for (i = 0; i < ann->n; ++i) {
 80416c6:	683a      	ldr	r2, [r7, #0]
			++cnt;
 80416c8:	f108 0801 	add.w	r8, r8, #1
			q->x = p->x;
 80416cc:	62b3      	str	r3, [r6, #40]	@ 0x28
			++cnt;
 80416ce:	e7b2      	b.n	8041636 <tg_urnn_start+0x9a>
		}
	}
	return cnt;
}
 80416d0:	4640      	mov	r0, r8
 80416d2:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80416d6:	46f3      	mov	fp, lr
 80416d8:	6930      	ldr	r0, [r6, #16]
 80416da:	e7cf      	b.n	804167c <tg_urnn_start+0xe0>
				for (j = 0; j < p->d[0]; ++j)
 80416dc:	692b      	ldr	r3, [r5, #16]
 80416de:	2b00      	cmp	r3, #0
 80416e0:	ddf0      	ble.n	80416c4 <tg_urnn_start+0x128>
					memcpy(&p->x[j * n], q->x, n * sizeof(float));
 80416e2:	f04f 0a00 	mov.w	sl, #0
 80416e6:	ea4f 0b8b 	mov.w	fp, fp, lsl #2
 80416ea:	e000      	b.n	80416ee <tg_urnn_start+0x152>
 80416ec:	6ab1      	ldr	r1, [r6, #40]	@ 0x28
 80416ee:	6aa8      	ldr	r0, [r5, #40]	@ 0x28
 80416f0:	465a      	mov	r2, fp
 80416f2:	4450      	add	r0, sl
 80416f4:	f00a fc5f 	bl	804bfb6 <memcpy>
				for (j = 0; j < p->d[0]; ++j)
 80416f8:	692b      	ldr	r3, [r5, #16]
 80416fa:	f109 0901 	add.w	r9, r9, #1
 80416fe:	454b      	cmp	r3, r9
 8041700:	44da      	add	sl, fp
 8041702:	dcf3      	bgt.n	80416ec <tg_urnn_start+0x150>
 8041704:	e7de      	b.n	80416c4 <tg_urnn_start+0x128>
 8041706:	bf00      	nop

08041708 <tg_train>:

extern void sendline(char* s);

void tg_train(kann_t *ann, const tg_data_t *tg, float lr, int ulen, int vlen, int cs, int mbs, int max_epoch, float grad_clip, int batch_len, int n_threads)
{
 8041708:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 804170c:	ed2d 8b04 	vpush	{d8-d9}
 8041710:	460f      	mov	r7, r1
 8041712:	b09d      	sub	sp, #116	@ 0x74
 8041714:	9d2b      	ldr	r5, [sp, #172]	@ 0xac
 8041716:	4680      	mov	r8, r0
 8041718:	982a      	ldr	r0, [sp, #168]	@ 0xa8
 804171a:	9507      	str	r5, [sp, #28]
 804171c:	9d2c      	ldr	r5, [sp, #176]	@ 0xb0
 804171e:	900a      	str	r0, [sp, #40]	@ 0x28
	int i, epoch, u, n_var, n_char;
	float **x, **y, *r;
	const uint8_t **p;
	kann_t *ua;

	sendline("TG_TRAIN 1\n");
 8041720:	487e      	ldr	r0, [pc, #504]	@ (804191c <tg_train+0x214>)
{
 8041722:	9c2d      	ldr	r4, [sp, #180]	@ 0xb4
 8041724:	eef0 8a40 	vmov.f32	s17, s0
 8041728:	9513      	str	r5, [sp, #76]	@ 0x4c
 804172a:	9112      	str	r1, [sp, #72]	@ 0x48
 804172c:	4615      	mov	r5, r2
 804172e:	9305      	str	r3, [sp, #20]
	sendline("TG_TRAIN 1\n");
 8041730:	f7ff fb10 	bl	8040d54 <sendline>

	batch_len = batch_len < tg->len? batch_len : tg->len;
 8041734:	683b      	ldr	r3, [r7, #0]


	n_char = kann_dim_in(ann);
 8041736:	2200      	movs	r2, #0
	batch_len = batch_len < tg->len? batch_len : tg->len;
 8041738:	429c      	cmp	r4, r3
 804173a:	bfa8      	it	ge
 804173c:	461c      	movge	r4, r3
	n_char = kann_dim_in(ann);
 804173e:	2101      	movs	r1, #1
 8041740:	4640      	mov	r0, r8
	batch_len = batch_len < tg->len? batch_len : tg->len;
 8041742:	9410      	str	r4, [sp, #64]	@ 0x40
	n_char = kann_dim_in(ann);
 8041744:	f000 fcda 	bl	80420fc <kann_feed_dim>
 8041748:	4603      	mov	r3, r0
	x = (float**)calloc(ulen, sizeof(float*));
 804174a:	2104      	movs	r1, #4
	heapSize += ulen*sizeof(float*);
 804174c:	00ac      	lsls	r4, r5, #2
	x = (float**)calloc(ulen, sizeof(float*));
 804174e:	4628      	mov	r0, r5
	n_char = kann_dim_in(ann);
 8041750:	e9cd 430e 	strd	r4, r3, [sp, #56]	@ 0x38
	x = (float**)calloc(ulen, sizeof(float*));
 8041754:	f00a f828 	bl	804b7a8 <calloc>
 8041758:	4682      	mov	sl, r0
	heapSize += ulen*sizeof(float*);
 804175a:	4e71      	ldr	r6, [pc, #452]	@ (8041920 <tg_train+0x218>)
	y = (float**)calloc(ulen, sizeof(float*));
 804175c:	2104      	movs	r1, #4
	heapSize += ulen*sizeof(float*);
 804175e:	6833      	ldr	r3, [r6, #0]
	y = (float**)calloc(ulen, sizeof(float*));
 8041760:	4628      	mov	r0, r5
	heapSize += ulen*sizeof(float*);
 8041762:	eb03 0385 	add.w	r3, r3, r5, lsl #2
 8041766:	6033      	str	r3, [r6, #0]
	x = (float**)calloc(ulen, sizeof(float*));
 8041768:	f8cd a008 	str.w	sl, [sp, #8]
	y = (float**)calloc(ulen, sizeof(float*));
 804176c:	f00a f81c 	bl	804b7a8 <calloc>
	heapSize += ulen*sizeof(float*);
 8041770:	6833      	ldr	r3, [r6, #0]

	for (u = 0; u < ulen; ++u) {
 8041772:	2d00      	cmp	r5, #0
	heapSize += ulen*sizeof(float*);
 8041774:	4423      	add	r3, r4
 8041776:	6033      	str	r3, [r6, #0]
	y = (float**)calloc(ulen, sizeof(float*));
 8041778:	9003      	str	r0, [sp, #12]
	for (u = 0; u < ulen; ++u) {
 804177a:	dd22      	ble.n	80417c2 <tg_train+0xba>
		x[u] = (float*)calloc(n_char * mbs, sizeof(float));
 804177c:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
 804177e:	9a07      	ldr	r2, [sp, #28]
 8041780:	9902      	ldr	r1, [sp, #8]
 8041782:	fb02 f903 	mul.w	r9, r2, r3
 8041786:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
 8041788:	1f0f      	subs	r7, r1, #4
 804178a:	3b04      	subs	r3, #4
 804178c:	18ca      	adds	r2, r1, r3
 804178e:	4692      	mov	sl, r2
 8041790:	9b03      	ldr	r3, [sp, #12]
		heapSize += n_char * mbs * sizeof(float);
 8041792:	ea4f 0489 	mov.w	r4, r9, lsl #2
 8041796:	f1a3 0b04 	sub.w	fp, r3, #4
		x[u] = (float*)calloc(n_char * mbs, sizeof(float));
 804179a:	2104      	movs	r1, #4
 804179c:	4648      	mov	r0, r9
 804179e:	f00a f803 	bl	804b7a8 <calloc>
		heapSize += n_char * mbs * sizeof(float);
 80417a2:	6833      	ldr	r3, [r6, #0]
		x[u] = (float*)calloc(n_char * mbs, sizeof(float));
 80417a4:	f847 0f04 	str.w	r0, [r7, #4]!
		heapSize += n_char * mbs * sizeof(float);
 80417a8:	4423      	add	r3, r4
		y[u] = (float*)calloc(n_char * mbs, sizeof(float));
 80417aa:	2104      	movs	r1, #4
 80417ac:	4648      	mov	r0, r9
		heapSize += n_char * mbs * sizeof(float);
 80417ae:	6033      	str	r3, [r6, #0]
		y[u] = (float*)calloc(n_char * mbs, sizeof(float));
 80417b0:	f009 fffa 	bl	804b7a8 <calloc>
		heapSize += n_char * mbs * sizeof(float);
 80417b4:	6833      	ldr	r3, [r6, #0]
	for (u = 0; u < ulen; ++u) {
 80417b6:	4557      	cmp	r7, sl
		heapSize += n_char * mbs * sizeof(float);
 80417b8:	4423      	add	r3, r4
		y[u] = (float*)calloc(n_char * mbs, sizeof(float));
 80417ba:	f84b 0f04 	str.w	r0, [fp, #4]!
		heapSize += n_char * mbs * sizeof(float);
 80417be:	6033      	str	r3, [r6, #0]
	for (u = 0; u < ulen; ++u) {
 80417c0:	d1eb      	bne.n	804179a <tg_train+0x92>
	}
	n_var = kann_size_var(ann);
 80417c2:	e9d8 0100 	ldrd	r0, r1, [r8]
 80417c6:	f008 fe59 	bl	804a47c <kad_size_var>
	r = (float*)calloc(n_var, sizeof(float));
 80417ca:	2104      	movs	r1, #4
	heapSize += n_var* sizeof(float);
	p = (const uint8_t**)calloc(mbs, sizeof(const uint8_t*));
	heapSize += mbs* sizeof(const uint8_t*);
 80417cc:	9c07      	ldr	r4, [sp, #28]
	n_var = kann_size_var(ann);
 80417ce:	4607      	mov	r7, r0
 80417d0:	900c      	str	r0, [sp, #48]	@ 0x30
	r = (float*)calloc(n_var, sizeof(float));
 80417d2:	f009 ffe9 	bl	804b7a8 <calloc>
 80417d6:	4602      	mov	r2, r0
	heapSize += n_var* sizeof(float);
 80417d8:	6833      	ldr	r3, [r6, #0]
	p = (const uint8_t**)calloc(mbs, sizeof(const uint8_t*));
 80417da:	2104      	movs	r1, #4
	heapSize += n_var* sizeof(float);
 80417dc:	eb03 0387 	add.w	r3, r3, r7, lsl #2
	p = (const uint8_t**)calloc(mbs, sizeof(const uint8_t*));
 80417e0:	4620      	mov	r0, r4
	heapSize += n_var* sizeof(float);
 80417e2:	6033      	str	r3, [r6, #0]
	r = (float*)calloc(n_var, sizeof(float));
 80417e4:	920b      	str	r2, [sp, #44]	@ 0x2c
	p = (const uint8_t**)calloc(mbs, sizeof(const uint8_t*));
 80417e6:	f009 ffdf 	bl	804b7a8 <calloc>
 80417ea:	4602      	mov	r2, r0
	heapSize += mbs* sizeof(const uint8_t*);
 80417ec:	6833      	ldr	r3, [r6, #0]


	sendline("TG_TRAIN 2\n");
 80417ee:	484d      	ldr	r0, [pc, #308]	@ (8041924 <tg_train+0x21c>)
	heapSize += mbs* sizeof(const uint8_t*);
 80417f0:	eb03 0384 	add.w	r3, r3, r4, lsl #2
	p = (const uint8_t**)calloc(mbs, sizeof(const uint8_t*));
 80417f4:	9209      	str	r2, [sp, #36]	@ 0x24
	heapSize += mbs* sizeof(const uint8_t*);
 80417f6:	6033      	str	r3, [r6, #0]
	sendline("TG_TRAIN 2\n");
 80417f8:	f7ff faac 	bl	8040d54 <sendline>

	ua = kann_unroll(ann, ulen);
 80417fc:	4629      	mov	r1, r5
 80417fe:	4640      	mov	r0, r8
 8041800:	f000 fb70 	bl	8041ee4 <kann_unroll>
 8041804:	4603      	mov	r3, r0
 8041806:	461e      	mov	r6, r3

	sendline("TG_TRAIN 3\n");
 8041808:	4847      	ldr	r0, [pc, #284]	@ (8041928 <tg_train+0x220>)
	ua = kann_unroll(ann, ulen);
 804180a:	9308      	str	r3, [sp, #32]
	sendline("TG_TRAIN 3\n");
 804180c:	f7ff faa2 	bl	8040d54 <sendline>
	tg_urnn_start(ua, mbs);
 8041810:	4621      	mov	r1, r4
 8041812:	4630      	mov	r0, r6
 8041814:	f7ff fec2 	bl	804159c <tg_urnn_start>
	//kann_mt(ua, n_threads, mbs);
	//kann_switch(ua, 1);
	kann_feed_bind(ua, KANN_F_IN,  100, x);
 8041818:	2264      	movs	r2, #100	@ 0x64
 804181a:	2101      	movs	r1, #1
 804181c:	9b02      	ldr	r3, [sp, #8]
 804181e:	4630      	mov	r0, r6
 8041820:	f000 fc02 	bl	8042028 <kann_feed_bind>
	kann_feed_bind(ua, KANN_F_TRUTH, 0, y);
 8041824:	9b03      	ldr	r3, [sp, #12]
 8041826:	2200      	movs	r2, #0
 8041828:	2104      	movs	r1, #4
 804182a:	4630      	mov	r0, r6
 804182c:	f000 fbfc 	bl	8042028 <kann_feed_bind>

	sendline("TG_TRAIN 4\n");
 8041830:	483e      	ldr	r0, [pc, #248]	@ (804192c <tg_train+0x224>)
 8041832:	f7ff fa8f 	bl	8040d54 <sendline>

	for (epoch = 0; epoch < max_epoch; ++epoch) {
 8041836:	9b13      	ldr	r3, [sp, #76]	@ 0x4c
	heapSize += mbs* sizeof(const uint8_t*);
 8041838:	ea4f 0b84 	mov.w	fp, r4, lsl #2
	for (epoch = 0; epoch < max_epoch; ++epoch) {
 804183c:	2b00      	cmp	r3, #0
 804183e:	f340 811e 	ble.w	8041a7e <tg_train+0x376>
		double cost = 0.0;
		int c, j, b, tot = 0, ctot = 0, n_cerr = 0;

		//sendline("TG_TRAIN 5\n");
		for (i = 0; i < batch_len; i += mbs * cs * ulen) {
 8041842:	9a0a      	ldr	r2, [sp, #40]	@ 0x28
 8041844:	9b07      	ldr	r3, [sp, #28]
				if (ua->v[j]->pre)
					memset(ua->v[j]->x, 0, kad_len(ua->v[j]) * sizeof(float));
			for (c = 0; c < cs; ++c) {
				int ce_len = c? ulen : ulen - vlen;
				for (u = 0; u < ulen; ++u) {
					memset(x[u], 0, mbs * n_char * sizeof(float));
 8041846:	990f      	ldr	r1, [sp, #60]	@ 0x3c
		for (i = 0; i < batch_len; i += mbs * cs * ulen) {
 8041848:	fb02 f303 	mul.w	r3, r2, r3
 804184c:	fb05 f303 	mul.w	r3, r5, r3
 8041850:	9315      	str	r3, [sp, #84]	@ 0x54
 8041852:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
					memset(x[u], 0, mbs * n_char * sizeof(float));
 8041854:	fb01 f60b 	mul.w	r6, r1, fp
 8041858:	1f1c      	subs	r4, r3, #4
 804185a:	9b02      	ldr	r3, [sp, #8]
 804185c:	9909      	ldr	r1, [sp, #36]	@ 0x24
 804185e:	441c      	add	r4, r3
 8041860:	f1ab 0304 	sub.w	r3, fp, #4
 8041864:	18cb      	adds	r3, r1, r3
 8041866:	930d      	str	r3, [sp, #52]	@ 0x34
 8041868:	9b05      	ldr	r3, [sp, #20]
	for (epoch = 0; epoch < max_epoch; ++epoch) {
 804186a:	f04f 0a00 	mov.w	sl, #0
 804186e:	42ab      	cmp	r3, r5
 8041870:	bfa8      	it	ge
 8041872:	462b      	movge	r3, r5
 8041874:	4699      	mov	r9, r3
				p[b] = tg->data + (int)((tg->len - ulen * cs - 1) * kad_drand(0)) + 1;
 8041876:	fb02 f305 	mul.w	r3, r2, r5
 804187a:	9314      	str	r3, [sp, #80]	@ 0x50
		sprintf(buffer, "epoch: %d; error %d : error %d\n", epoch+1, (int) (100.0 * n_cerr / ctot));
		sendline(buffer);*/


		//fprintf(stderr, "epoch: %d; running cost: %g (class error: %.2f%%)\n", epoch+1, cost / tot, 100.0 * n_cerr / ctot);
		tg_gen(ann, 0.4f, 20, tg->c2i);
 804187c:	9b12      	ldr	r3, [sp, #72]	@ 0x48
				kann_RMSprop(n_var, lr, 0, 0.9f, ua->g, ua->x, r);
 804187e:	ed9f 9a2c 	vldr	s18, [pc, #176]	@ 8041930 <tg_train+0x228>
		tg_gen(ann, 0.4f, 20, tg->c2i);
 8041882:	330c      	adds	r3, #12
 8041884:	e9cd 3916 	strd	r3, r9, [sp, #88]	@ 0x58
						x[u][b * n_char + p[b][u-1]] = 1.0f;
 8041888:	eeb7 8a00 	vmov.f32	s16, #112	@ 0x3f800000  1.0
 804188c:	46d1      	mov	r9, sl
		for (i = 0; i < batch_len; i += mbs * cs * ulen) {
 804188e:	9b10      	ldr	r3, [sp, #64]	@ 0x40
 8041890:	2b00      	cmp	r3, #0
 8041892:	f340 80ea 	ble.w	8041a6a <tg_train+0x362>
 8041896:	2300      	movs	r3, #0
 8041898:	e9cd 9818 	strd	r9, r8, [sp, #96]	@ 0x60
 804189c:	f8dd b05c 	ldr.w	fp, [sp, #92]	@ 0x5c
 80418a0:	9311      	str	r3, [sp, #68]	@ 0x44
			for (b = 0; b < mbs; ++b)
 80418a2:	9b07      	ldr	r3, [sp, #28]
 80418a4:	2b00      	cmp	r3, #0
 80418a6:	dd31      	ble.n	804190c <tg_train+0x204>
 80418a8:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 80418aa:	951a      	str	r5, [sp, #104]	@ 0x68
 80418ac:	3b04      	subs	r3, #4
 80418ae:	f04f 0a00 	mov.w	sl, #0
 80418b2:	461d      	mov	r5, r3
 80418b4:	f8cd b06c 	str.w	fp, [sp, #108]	@ 0x6c
 80418b8:	f8dd 9050 	ldr.w	r9, [sp, #80]	@ 0x50
 80418bc:	f8dd 8048 	ldr.w	r8, [sp, #72]	@ 0x48
 80418c0:	f8dd b01c 	ldr.w	fp, [sp, #28]
 80418c4:	9604      	str	r6, [sp, #16]
 80418c6:	9406      	str	r4, [sp, #24]
				p[b] = tg->data + (int)((tg->len - ulen * cs - 1) * kad_drand(0)) + 1;
 80418c8:	f8d8 3000 	ldr.w	r3, [r8]
			for (b = 0; b < mbs; ++b)
 80418cc:	f10a 0a01 	add.w	sl, sl, #1
				p[b] = tg->data + (int)((tg->len - ulen * cs - 1) * kad_drand(0)) + 1;
 80418d0:	eba3 0309 	sub.w	r3, r3, r9
 80418d4:	1e58      	subs	r0, r3, #1
 80418d6:	f7fe fe01 	bl	80404dc <__aeabi_i2d>
 80418da:	4606      	mov	r6, r0
 80418dc:	2000      	movs	r0, #0
 80418de:	460f      	mov	r7, r1
 80418e0:	f8d8 4008 	ldr.w	r4, [r8, #8]
 80418e4:	f009 fb8a 	bl	804affc <kad_drand>
 80418e8:	4630      	mov	r0, r6
 80418ea:	ec53 2b10 	vmov	r2, r3, d0
 80418ee:	4639      	mov	r1, r7
 80418f0:	f7fe fe5e 	bl	80405b0 <__aeabi_dmul>
 80418f4:	f7ff f90c 	bl	8040b10 <__aeabi_d2iz>
 80418f8:	1c43      	adds	r3, r0, #1
 80418fa:	441c      	add	r4, r3
			for (b = 0; b < mbs; ++b)
 80418fc:	45d3      	cmp	fp, sl
				p[b] = tg->data + (int)((tg->len - ulen * cs - 1) * kad_drand(0)) + 1;
 80418fe:	f845 4f04 	str.w	r4, [r5, #4]!
			for (b = 0; b < mbs; ++b)
 8041902:	d1e1      	bne.n	80418c8 <tg_train+0x1c0>
 8041904:	e9dd 5b1a 	ldrd	r5, fp, [sp, #104]	@ 0x68
 8041908:	9e04      	ldr	r6, [sp, #16]
 804190a:	9c06      	ldr	r4, [sp, #24]
			for (j = 0; j < ua->n; ++j) // reset initial hidden values to zero
 804190c:	9b08      	ldr	r3, [sp, #32]
 804190e:	6819      	ldr	r1, [r3, #0]
 8041910:	2900      	cmp	r1, #0
 8041912:	dd37      	ble.n	8041984 <tg_train+0x27c>
 8041914:	4699      	mov	r9, r3
 8041916:	2700      	movs	r7, #0
 8041918:	46a0      	mov	r8, r4
 804191a:	e00e      	b.n	804193a <tg_train+0x232>
 804191c:	0804e2b4 	.word	0x0804e2b4
 8041920:	20018344 	.word	0x20018344
 8041924:	0804e2c0 	.word	0x0804e2c0
 8041928:	0804e2cc 	.word	0x0804e2cc
 804192c:	0804e2d8 	.word	0x0804e2d8
 8041930:	3f666666 	.word	0x3f666666
 8041934:	3701      	adds	r7, #1
 8041936:	428f      	cmp	r7, r1
 8041938:	da23      	bge.n	8041982 <tg_train+0x27a>
				if (ua->v[j]->pre)
 804193a:	f8d9 3004 	ldr.w	r3, [r9, #4]
 804193e:	f853 3027 	ldr.w	r3, [r3, r7, lsl #2]
 8041942:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
 8041944:	2a00      	cmp	r2, #0
 8041946:	d0f5      	beq.n	8041934 <tg_train+0x22c>
 8041948:	7819      	ldrb	r1, [r3, #0]
					memset(ua->v[j]->x, 0, kad_len(ua->v[j]) * sizeof(float));
 804194a:	6a98      	ldr	r0, [r3, #40]	@ 0x28
 804194c:	2900      	cmp	r1, #0
 804194e:	f000 8106 	beq.w	8041b5e <tg_train+0x456>
 8041952:	2901      	cmp	r1, #1
 8041954:	691a      	ldr	r2, [r3, #16]
 8041956:	d00b      	beq.n	8041970 <tg_train+0x268>
 8041958:	695c      	ldr	r4, [r3, #20]
 804195a:	2902      	cmp	r1, #2
 804195c:	fb04 f202 	mul.w	r2, r4, r2
 8041960:	d006      	beq.n	8041970 <tg_train+0x268>
 8041962:	699c      	ldr	r4, [r3, #24]
 8041964:	2903      	cmp	r1, #3
 8041966:	fb04 f202 	mul.w	r2, r4, r2
 804196a:	bf1c      	itt	ne
 804196c:	69db      	ldrne	r3, [r3, #28]
 804196e:	435a      	mulne	r2, r3
 8041970:	0092      	lsls	r2, r2, #2
 8041972:	2100      	movs	r1, #0
 8041974:	f00a fa22 	bl	804bdbc <memset>
			for (j = 0; j < ua->n; ++j) // reset initial hidden values to zero
 8041978:	f8d9 1000 	ldr.w	r1, [r9]
 804197c:	3701      	adds	r7, #1
 804197e:	428f      	cmp	r7, r1
 8041980:	dbdb      	blt.n	804193a <tg_train+0x232>
 8041982:	4644      	mov	r4, r8
			for (c = 0; c < cs; ++c) {
 8041984:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 8041986:	2b00      	cmp	r3, #0
 8041988:	dd65      	ble.n	8041a56 <tg_train+0x34e>
 804198a:	2700      	movs	r7, #0
 804198c:	f8dd a03c 	ldr.w	sl, [sp, #60]	@ 0x3c
				for (u = 0; u < ulen; ++u) {
 8041990:	2d00      	cmp	r5, #0
 8041992:	dd13      	ble.n	80419bc <tg_train+0x2b4>
 8041994:	9b02      	ldr	r3, [sp, #8]
 8041996:	f1a3 0904 	sub.w	r9, r3, #4
 804199a:	9b03      	ldr	r3, [sp, #12]
 804199c:	f1a3 0804 	sub.w	r8, r3, #4
					memset(x[u], 0, mbs * n_char * sizeof(float));
 80419a0:	2100      	movs	r1, #0
 80419a2:	4632      	mov	r2, r6
 80419a4:	f859 0f04 	ldr.w	r0, [r9, #4]!
 80419a8:	f00a fa08 	bl	804bdbc <memset>
					memset(y[u], 0, mbs * n_char * sizeof(float));
 80419ac:	4632      	mov	r2, r6
 80419ae:	2100      	movs	r1, #0
 80419b0:	f858 0f04 	ldr.w	r0, [r8, #4]!
 80419b4:	f00a fa02 	bl	804bdbc <memset>
				for (u = 0; u < ulen; ++u) {
 80419b8:	45a1      	cmp	r9, r4
 80419ba:	d1f1      	bne.n	80419a0 <tg_train+0x298>
				for (b = 0; b < mbs; ++b) {
 80419bc:	9b07      	ldr	r3, [sp, #28]
 80419be:	2b00      	cmp	r3, #0
 80419c0:	dd2f      	ble.n	8041a22 <tg_train+0x31a>
 80419c2:	2300      	movs	r3, #0
 80419c4:	4639      	mov	r1, r7
 80419c6:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 80419c8:	f8dd 9034 	ldr.w	r9, [sp, #52]	@ 0x34
 80419cc:	f1a2 0804 	sub.w	r8, r2, #4
 80419d0:	9606      	str	r6, [sp, #24]
					for (u = 0; u < ulen; ++u) {
 80419d2:	2d00      	cmp	r5, #0
					p[b] += ulen;
 80419d4:	f858 7f04 	ldr.w	r7, [r8, #4]!
					for (u = 0; u < ulen; ++u) {
 80419d8:	dd1b      	ble.n	8041a12 <tg_train+0x30a>
 80419da:	2900      	cmp	r1, #0
 80419dc:	d079      	beq.n	8041ad2 <tg_train+0x3ca>
 80419de:	9a02      	ldr	r2, [sp, #8]
 80419e0:	1e7e      	subs	r6, r7, #1
 80419e2:	f1a2 0c04 	sub.w	ip, r2, #4
 80419e6:	9a03      	ldr	r2, [sp, #12]
 80419e8:	f1a2 0e04 	sub.w	lr, r2, #4
						x[u][b * n_char + p[b][u-1]] = 1.0f;
 80419ec:	7830      	ldrb	r0, [r6, #0]
 80419ee:	f85c 2f04 	ldr.w	r2, [ip, #4]!
 80419f2:	4418      	add	r0, r3
 80419f4:	eb02 0280 	add.w	r2, r2, r0, lsl #2
 80419f8:	ed82 8a00 	vstr	s16, [r2]
							y[u][b * n_char + p[b][u]] = 1.0f;
 80419fc:	f816 0f01 	ldrb.w	r0, [r6, #1]!
 8041a00:	f85e 2f04 	ldr.w	r2, [lr, #4]!
 8041a04:	4418      	add	r0, r3
 8041a06:	eb02 0280 	add.w	r2, r2, r0, lsl #2
					for (u = 0; u < ulen; ++u) {
 8041a0a:	45a4      	cmp	ip, r4
							y[u][b * n_char + p[b][u]] = 1.0f;
 8041a0c:	ed82 8a00 	vstr	s16, [r2]
					for (u = 0; u < ulen; ++u) {
 8041a10:	d1ec      	bne.n	80419ec <tg_train+0x2e4>
					p[b] += ulen;
 8041a12:	442f      	add	r7, r5
				for (b = 0; b < mbs; ++b) {
 8041a14:	45c1      	cmp	r9, r8
					p[b] += ulen;
 8041a16:	f8c8 7000 	str.w	r7, [r8]
				for (b = 0; b < mbs; ++b) {
 8041a1a:	4453      	add	r3, sl
 8041a1c:	d1d9      	bne.n	80419d2 <tg_train+0x2ca>
 8041a1e:	460f      	mov	r7, r1
 8041a20:	9e06      	ldr	r6, [sp, #24]
				cost += kann_cost(ua, 0, 1) * ulen * mbs;
 8041a22:	f8dd 8020 	ldr.w	r8, [sp, #32]
 8041a26:	2201      	movs	r2, #1
 8041a28:	2100      	movs	r1, #0
 8041a2a:	4640      	mov	r0, r8
 8041a2c:	f000 fcb4 	bl	8042398 <kann_cost>
				kann_RMSprop(n_var, lr, 0, 0.9f, ua->g, ua->x, r);
 8041a30:	990b      	ldr	r1, [sp, #44]	@ 0x2c
 8041a32:	f8d8 3008 	ldr.w	r3, [r8, #8]
 8041a36:	f8d8 200c 	ldr.w	r2, [r8, #12]
 8041a3a:	eef0 0a49 	vmov.f32	s1, s18
 8041a3e:	9100      	str	r1, [sp, #0]
 8041a40:	eeb0 0a68 	vmov.f32	s0, s17
 8041a44:	2100      	movs	r1, #0
 8041a46:	980c      	ldr	r0, [sp, #48]	@ 0x30
 8041a48:	9304      	str	r3, [sp, #16]
 8041a4a:	f000 ffd3 	bl	80429f4 <kann_RMSprop>
			for (c = 0; c < cs; ++c) {
 8041a4e:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 8041a50:	3701      	adds	r7, #1
 8041a52:	42bb      	cmp	r3, r7
 8041a54:	d19c      	bne.n	8041990 <tg_train+0x288>
		for (i = 0; i < batch_len; i += mbs * cs * ulen) {
 8041a56:	9b11      	ldr	r3, [sp, #68]	@ 0x44
 8041a58:	9a15      	ldr	r2, [sp, #84]	@ 0x54
 8041a5a:	4413      	add	r3, r2
 8041a5c:	9a10      	ldr	r2, [sp, #64]	@ 0x40
 8041a5e:	9311      	str	r3, [sp, #68]	@ 0x44
 8041a60:	429a      	cmp	r2, r3
 8041a62:	f73f af1e 	bgt.w	80418a2 <tg_train+0x19a>
 8041a66:	e9dd 9818 	ldrd	r9, r8, [sp, #96]	@ 0x60
		tg_gen(ann, 0.4f, 20, tg->c2i);
 8041a6a:	4640      	mov	r0, r8
 8041a6c:	9916      	ldr	r1, [sp, #88]	@ 0x58
 8041a6e:	f7ff fc49 	bl	8041304 <tg_gen.constprop.0>
	for (epoch = 0; epoch < max_epoch; ++epoch) {
 8041a72:	9b13      	ldr	r3, [sp, #76]	@ 0x4c
 8041a74:	f109 0901 	add.w	r9, r9, #1
 8041a78:	454b      	cmp	r3, r9
 8041a7a:	f47f af08 	bne.w	804188e <tg_train+0x186>
		//if (fn) tg_save(fn, ann, tg->c2i);
	}
	kann_delete_unrolled(ua);
 8041a7e:	9808      	ldr	r0, [sp, #32]
 8041a80:	f000 fa6a 	bl	8041f58 <kann_delete_unrolled>

	sendline("DONE!\n");
 8041a84:	4837      	ldr	r0, [pc, #220]	@ (8041b64 <tg_train+0x45c>)
 8041a86:	f7ff f965 	bl	8040d54 <sendline>

	for (u = 0; u < ulen; ++u) {
 8041a8a:	2d00      	cmp	r5, #0
 8041a8c:	dd10      	ble.n	8041ab0 <tg_train+0x3a8>
 8041a8e:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
 8041a90:	1f1c      	subs	r4, r3, #4
 8041a92:	9b02      	ldr	r3, [sp, #8]
 8041a94:	441c      	add	r4, r3
 8041a96:	1f1d      	subs	r5, r3, #4
 8041a98:	9b03      	ldr	r3, [sp, #12]
 8041a9a:	1f1e      	subs	r6, r3, #4
		free(x[u]); free(y[u]);
 8041a9c:	f855 0f04 	ldr.w	r0, [r5, #4]!
 8041aa0:	f009 fea6 	bl	804b7f0 <free>
 8041aa4:	f856 0f04 	ldr.w	r0, [r6, #4]!
 8041aa8:	f009 fea2 	bl	804b7f0 <free>
	for (u = 0; u < ulen; ++u) {
 8041aac:	42a5      	cmp	r5, r4
 8041aae:	d1f5      	bne.n	8041a9c <tg_train+0x394>
	}

	free(r); free(y); free(x); free(p);
 8041ab0:	980b      	ldr	r0, [sp, #44]	@ 0x2c
 8041ab2:	f009 fe9d 	bl	804b7f0 <free>
 8041ab6:	9803      	ldr	r0, [sp, #12]
 8041ab8:	f009 fe9a 	bl	804b7f0 <free>
 8041abc:	9802      	ldr	r0, [sp, #8]
 8041abe:	f009 fe97 	bl	804b7f0 <free>
 8041ac2:	9809      	ldr	r0, [sp, #36]	@ 0x24
}
 8041ac4:	b01d      	add	sp, #116	@ 0x74
 8041ac6:	ecbd 8b04 	vpop	{d8-d9}
 8041aca:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	free(r); free(y); free(x); free(p);
 8041ace:	f009 be8f 	b.w	804b7f0 <free>
 8041ad2:	9a05      	ldr	r2, [sp, #20]
 8041ad4:	2a00      	cmp	r2, #0
						x[u][b * n_char + p[b][u-1]] = 1.0f;
 8041ad6:	460a      	mov	r2, r1
 8041ad8:	dd12      	ble.n	8041b00 <tg_train+0x3f8>
 8041ada:	9802      	ldr	r0, [sp, #8]
 8041adc:	f1a7 0c02 	sub.w	ip, r7, #2
 8041ae0:	f1a0 0e04 	sub.w	lr, r0, #4
 8041ae4:	f81c 6f01 	ldrb.w	r6, [ip, #1]!
 8041ae8:	f85e 0f04 	ldr.w	r0, [lr, #4]!
 8041aec:	441e      	add	r6, r3
					for (u = 0; u < ulen; ++u) {
 8041aee:	3201      	adds	r2, #1
						x[u][b * n_char + p[b][u-1]] = 1.0f;
 8041af0:	eb00 0086 	add.w	r0, r0, r6, lsl #2
					for (u = 0; u < ulen; ++u) {
 8041af4:	4593      	cmp	fp, r2
						x[u][b * n_char + p[b][u-1]] = 1.0f;
 8041af6:	ed80 8a00 	vstr	s16, [r0]
					for (u = 0; u < ulen; ++u) {
 8041afa:	dcf3      	bgt.n	8041ae4 <tg_train+0x3dc>
 8041afc:	4295      	cmp	r5, r2
 8041afe:	dd88      	ble.n	8041a12 <tg_train+0x30a>
 8041b00:	9802      	ldr	r0, [sp, #8]
 8041b02:	f102 4680 	add.w	r6, r2, #1073741824	@ 0x40000000
 8041b06:	3e01      	subs	r6, #1
 8041b08:	eb00 0c86 	add.w	ip, r0, r6, lsl #2
 8041b0c:	9803      	ldr	r0, [sp, #12]
 8041b0e:	3a01      	subs	r2, #1
 8041b10:	443a      	add	r2, r7
 8041b12:	eb00 0686 	add.w	r6, r0, r6, lsl #2
 8041b16:	f1c7 0e01 	rsb	lr, r7, #1
 8041b1a:	f8cd 9010 	str.w	r9, [sp, #16]
						x[u][b * n_char + p[b][u-1]] = 1.0f;
 8041b1e:	f892 9000 	ldrb.w	r9, [r2]
 8041b22:	f85c 0f04 	ldr.w	r0, [ip, #4]!
 8041b26:	4499      	add	r9, r3
 8041b28:	eb00 0089 	add.w	r0, r0, r9, lsl #2
 8041b2c:	ed80 8a00 	vstr	s16, [r0]
							y[u][b * n_char + p[b][u]] = 1.0f;
 8041b30:	f812 9f01 	ldrb.w	r9, [r2, #1]!
 8041b34:	f856 0f04 	ldr.w	r0, [r6, #4]!
 8041b38:	4499      	add	r9, r3
 8041b3a:	eb00 0089 	add.w	r0, r0, r9, lsl #2
 8041b3e:	ed80 8a00 	vstr	s16, [r0]
					for (u = 0; u < ulen; ++u) {
 8041b42:	eb0e 0002 	add.w	r0, lr, r2
 8041b46:	4285      	cmp	r5, r0
 8041b48:	dce9      	bgt.n	8041b1e <tg_train+0x416>
 8041b4a:	f8dd 9010 	ldr.w	r9, [sp, #16]
					p[b] += ulen;
 8041b4e:	442f      	add	r7, r5
				for (b = 0; b < mbs; ++b) {
 8041b50:	45c1      	cmp	r9, r8
					p[b] += ulen;
 8041b52:	f8c8 7000 	str.w	r7, [r8]
				for (b = 0; b < mbs; ++b) {
 8041b56:	4453      	add	r3, sl
 8041b58:	f47f af3b 	bne.w	80419d2 <tg_train+0x2ca>
 8041b5c:	e75f      	b.n	8041a1e <tg_train+0x316>
 8041b5e:	2204      	movs	r2, #4
 8041b60:	e707      	b.n	8041972 <tg_train+0x26a>
 8041b62:	bf00      	nop
 8041b64:	0804e2e4 	.word	0x0804e2e4

08041b68 <model_gen>:

kann_t *model_gen(int model, int n_char, int n_h_layers, int n_h_neurons, float h_dropout, int use_norm)
{
 8041b68:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8041b6c:	9d06      	ldr	r5, [sp, #24]
 8041b6e:	4617      	mov	r7, r2
	int i, flag = use_norm? KANN_RNN_NORM : 0;
 8041b70:	3d00      	subs	r5, #0
	kad_node_t *t, *t1;
	t = kann_layer_input(n_char), t->ext_label = 100;
 8041b72:	4608      	mov	r0, r1
	int i, flag = use_norm? KANN_RNN_NORM : 0;
 8041b74:	bf18      	it	ne
 8041b76:	2501      	movne	r5, #1
{
 8041b78:	4698      	mov	r8, r3
 8041b7a:	460e      	mov	r6, r1
	t = kann_layer_input(n_char), t->ext_label = 100;
 8041b7c:	f000 fdb0 	bl	80426e0 <kann_layer_input>
 8041b80:	2364      	movs	r3, #100	@ 0x64
	for (i = 0; i < n_h_layers; ++i) {
 8041b82:	2f00      	cmp	r7, #0
	t = kann_layer_input(n_char), t->ext_label = 100;
 8041b84:	6203      	str	r3, [r0, #32]
	for (i = 0; i < n_h_layers; ++i) {
 8041b86:	dd08      	ble.n	8041b9a <model_gen+0x32>
 8041b88:	2400      	movs	r4, #0
 8041b8a:	006d      	lsls	r5, r5, #1
		//if (model == 0) t = kann_layer_rnn(t, n_h_neurons, flag);
		//else if (model == 1) t = kann_layer_lstm(t, n_h_neurons, flag);
		//else if (model == 2) t = kann_layer_gru(t, n_h_neurons, flag);
		t = kann_layer_lstm(t, n_h_neurons, flag);
 8041b8c:	462a      	mov	r2, r5
 8041b8e:	4641      	mov	r1, r8
	for (i = 0; i < n_h_layers; ++i) {
 8041b90:	3401      	adds	r4, #1
		t = kann_layer_lstm(t, n_h_neurons, flag);
 8041b92:	f000 fdeb 	bl	804276c <kann_layer_lstm>
	for (i = 0; i < n_h_layers; ++i) {
 8041b96:	42a7      	cmp	r7, r4
 8041b98:	d1f8      	bne.n	8041b8c <model_gen+0x24>
		//t = kann_layer_dropout(t, h_dropout);
	}
	t = kann_layer_dense(t, n_char);
 8041b9a:	4631      	mov	r1, r6
 8041b9c:	f000 fdac 	bl	80426f8 <kann_layer_dense>
	t1 = kann_new_scalar(KAD_CONST, 1.0f), t1->ext_label = -1; // -1 is for backward compatibility
 8041ba0:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
	t = kann_layer_dense(t, n_char);
 8041ba4:	4604      	mov	r4, r0
	t1 = kann_new_scalar(KAD_CONST, 1.0f), t1->ext_label = -1; // -1 is for backward compatibility
 8041ba6:	2002      	movs	r0, #2
 8041ba8:	f000 fd94 	bl	80426d4 <kann_new_scalar>
 8041bac:	f04f 33ff 	mov.w	r3, #4294967295
 8041bb0:	4601      	mov	r1, r0
	t = kad_mul(t, t1); // t1 is the inverse of temperature
 8041bb2:	4620      	mov	r0, r4
	t1 = kann_new_scalar(KAD_CONST, 1.0f), t1->ext_label = -1; // -1 is for backward compatibility
 8041bb4:	620b      	str	r3, [r1, #32]
	t = kad_mul(t, t1); // t1 is the inverse of temperature
 8041bb6:	f008 f849 	bl	8049c4c <kad_mul>
	t = kad_softmax(t), t->ext_flag |= KANN_F_OUT;
 8041bba:	f008 f9cd 	bl	8049f58 <kad_softmax>
 8041bbe:	4604      	mov	r4, r0
	t1 = kad_feed(2, 1, n_char), t1->ext_flag |= KANN_F_TRUTH;
 8041bc0:	2002      	movs	r0, #2
	t = kad_softmax(t), t->ext_flag |= KANN_F_OUT;
 8041bc2:	6a63      	ldr	r3, [r4, #36]	@ 0x24
	t1 = kad_feed(2, 1, n_char), t1->ext_flag |= KANN_F_TRUTH;
 8041bc4:	4632      	mov	r2, r6
	t = kad_softmax(t), t->ext_flag |= KANN_F_OUT;
 8041bc6:	4303      	orrs	r3, r0
 8041bc8:	6263      	str	r3, [r4, #36]	@ 0x24
	t1 = kad_feed(2, 1, n_char), t1->ext_flag |= KANN_F_TRUTH;
 8041bca:	2101      	movs	r1, #1
 8041bcc:	f007 ff94 	bl	8049af8 <kad_feed>
 8041bd0:	4601      	mov	r1, r0
 8041bd2:	6a4b      	ldr	r3, [r1, #36]	@ 0x24
	t = kad_ce_multi(t, t1), t->ext_flag |= KANN_F_COST;
 8041bd4:	4620      	mov	r0, r4
	t1 = kad_feed(2, 1, n_char), t1->ext_flag |= KANN_F_TRUTH;
 8041bd6:	f043 0304 	orr.w	r3, r3, #4
 8041bda:	624b      	str	r3, [r1, #36]	@ 0x24
	t = kad_ce_multi(t, t1), t->ext_flag |= KANN_F_COST;
 8041bdc:	f008 f8d6 	bl	8049d8c <kad_ce_multi>
	return kann_new(t, 0);
}
 8041be0:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	t = kad_ce_multi(t, t1), t->ext_flag |= KANN_F_COST;
 8041be4:	6a42      	ldr	r2, [r0, #36]	@ 0x24
	return kann_new(t, 0);
 8041be6:	2100      	movs	r1, #0
	t = kad_ce_multi(t, t1), t->ext_flag |= KANN_F_COST;
 8041be8:	f042 0208 	orr.w	r2, r2, #8
 8041bec:	6242      	str	r2, [r0, #36]	@ 0x24
	return kann_new(t, 0);
 8041bee:	f000 b8ef 	b.w	8041dd0 <kann_new>
 8041bf2:	bf00      	nop

08041bf4 <kad_ext_collate>:
/******************************************
 *** @@BASIC: fundamental KANN routines ***
 ******************************************/

static void kad_ext_collate(int n, kad_node_t **a, float **_x, float **_g, float **_c)
{
 8041bf4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8041bf8:	b085      	sub	sp, #20
 8041bfa:	4617      	mov	r7, r2
 8041bfc:	4698      	mov	r8, r3
 8041bfe:	4606      	mov	r6, r0
 8041c00:	460d      	mov	r5, r1
 8041c02:	f8dd b038 	ldr.w	fp, [sp, #56]	@ 0x38
	int i, j, k, l, n_var;
	float *x, *g, *c;
	n_var = kad_size_var(n, a);
 8041c06:	f008 fc39 	bl	804a47c <kad_size_var>
	x = *_x = (float*)realloc(*_x, n_var * sizeof(float));
 8041c0a:	0084      	lsls	r4, r0, #2
 8041c0c:	4621      	mov	r1, r4
 8041c0e:	6838      	ldr	r0, [r7, #0]
 8041c10:	f009 fed2 	bl	804b9b8 <realloc>
 8041c14:	6038      	str	r0, [r7, #0]
	g = *_g = (float*)realloc(*_g, n_var * sizeof(float));
 8041c16:	4621      	mov	r1, r4
	x = *_x = (float*)realloc(*_x, n_var * sizeof(float));
 8041c18:	9001      	str	r0, [sp, #4]
	g = *_g = (float*)realloc(*_g, n_var * sizeof(float));
 8041c1a:	f8d8 0000 	ldr.w	r0, [r8]
 8041c1e:	f009 fecb 	bl	804b9b8 <realloc>
 8041c22:	4607      	mov	r7, r0
	c = *_c = (float*)realloc(*_c, kad_size_const(n, a) * sizeof(float));
 8041c24:	4629      	mov	r1, r5
	g = *_g = (float*)realloc(*_g, n_var * sizeof(float));
 8041c26:	f8c8 7000 	str.w	r7, [r8]
	c = *_c = (float*)realloc(*_c, kad_size_const(n, a) * sizeof(float));
 8041c2a:	4630      	mov	r0, r6
 8041c2c:	f8db 8000 	ldr.w	r8, [fp]
 8041c30:	f008 fc5e 	bl	804a4f0 <kad_size_const>
 8041c34:	4601      	mov	r1, r0
 8041c36:	4640      	mov	r0, r8
 8041c38:	0089      	lsls	r1, r1, #2
 8041c3a:	f009 febd 	bl	804b9b8 <realloc>
 8041c3e:	4682      	mov	sl, r0
	memset(g, 0, n_var * sizeof(float));
 8041c40:	4622      	mov	r2, r4
 8041c42:	2100      	movs	r1, #0
 8041c44:	4638      	mov	r0, r7
	c = *_c = (float*)realloc(*_c, kad_size_const(n, a) * sizeof(float));
 8041c46:	f8cb a000 	str.w	sl, [fp]
	memset(g, 0, n_var * sizeof(float));
 8041c4a:	f00a f8b7 	bl	804bdbc <memset>
	for (i = j = k = 0; i < n; ++i) {
 8041c4e:	2e00      	cmp	r6, #0
 8041c50:	dd3e      	ble.n	8041cd0 <kad_ext_collate+0xdc>
 8041c52:	f04f 0900 	mov.w	r9, #0
 8041c56:	3d04      	subs	r5, #4
 8041c58:	46c8      	mov	r8, r9
 8041c5a:	e9cd 7a02 	strd	r7, sl, [sp, #8]
 8041c5e:	eb05 0686 	add.w	r6, r5, r6, lsl #2
 8041c62:	e003      	b.n	8041c6c <kad_ext_collate+0x78>
			memcpy(&x[j], v->x, l * sizeof(float));
			free(v->x);
			v->x = &x[j];
			v->g = &g[j];
			j += l;
		} else if (kad_is_const(v)) {
 8041c64:	079b      	lsls	r3, r3, #30
 8041c66:	d436      	bmi.n	8041cd6 <kad_ext_collate+0xe2>
	for (i = j = k = 0; i < n; ++i) {
 8041c68:	42ae      	cmp	r6, r5
 8041c6a:	d031      	beq.n	8041cd0 <kad_ext_collate+0xdc>
		kad_node_t *v = a[i];
 8041c6c:	f855 4f04 	ldr.w	r4, [r5, #4]!
		if (kad_is_var(v)) {
 8041c70:	6863      	ldr	r3, [r4, #4]
 8041c72:	2b00      	cmp	r3, #0
 8041c74:	d1f8      	bne.n	8041c68 <kad_ext_collate+0x74>
 8041c76:	7863      	ldrb	r3, [r4, #1]
 8041c78:	07da      	lsls	r2, r3, #31
 8041c7a:	d5f3      	bpl.n	8041c64 <kad_ext_collate+0x70>
extern char *kad_op_name[KAD_MAX_OP];

static inline int kad_len(const kad_node_t *p) /* calculate the size of p->x */
{
	int n = 1, i;
	for (i = 0; i < p->n_d; ++i) n *= p->d[i];
 8041c7c:	7823      	ldrb	r3, [r4, #0]
 8041c7e:	2b00      	cmp	r3, #0
 8041c80:	d049      	beq.n	8041d16 <kad_ext_collate+0x122>
 8041c82:	2b01      	cmp	r3, #1
 8041c84:	f8d4 b010 	ldr.w	fp, [r4, #16]
 8041c88:	d00c      	beq.n	8041ca4 <kad_ext_collate+0xb0>
 8041c8a:	6962      	ldr	r2, [r4, #20]
 8041c8c:	2b02      	cmp	r3, #2
 8041c8e:	fb02 fb0b 	mul.w	fp, r2, fp
 8041c92:	d007      	beq.n	8041ca4 <kad_ext_collate+0xb0>
 8041c94:	69a2      	ldr	r2, [r4, #24]
 8041c96:	2b03      	cmp	r3, #3
 8041c98:	fb02 fb0b 	mul.w	fp, r2, fp
 8041c9c:	bf1c      	itt	ne
 8041c9e:	69e3      	ldrne	r3, [r4, #28]
 8041ca0:	fb03 fb0b 	mulne.w	fp, r3, fp
			memcpy(&x[j], v->x, l * sizeof(float));
 8041ca4:	ea4f 028b 	mov.w	r2, fp, lsl #2
 8041ca8:	9b01      	ldr	r3, [sp, #4]
 8041caa:	6aa1      	ldr	r1, [r4, #40]	@ 0x28
 8041cac:	eb03 0788 	add.w	r7, r3, r8, lsl #2
 8041cb0:	4638      	mov	r0, r7
 8041cb2:	f00a f980 	bl	804bfb6 <memcpy>
			free(v->x);
 8041cb6:	6aa0      	ldr	r0, [r4, #40]	@ 0x28
 8041cb8:	f009 fd9a 	bl	804b7f0 <free>
			v->g = &g[j];
 8041cbc:	9b02      	ldr	r3, [sp, #8]
			memcpy(&x[j], v->x, l * sizeof(float));
 8041cbe:	ea4f 0a88 	mov.w	sl, r8, lsl #2
			v->g = &g[j];
 8041cc2:	eb03 020a 	add.w	r2, r3, sl
	for (i = j = k = 0; i < n; ++i) {
 8041cc6:	42ae      	cmp	r6, r5
			j += l;
 8041cc8:	44d8      	add	r8, fp
			v->x = &x[j];
 8041cca:	62a7      	str	r7, [r4, #40]	@ 0x28
			v->g = &g[j];
 8041ccc:	62e2      	str	r2, [r4, #44]	@ 0x2c
	for (i = j = k = 0; i < n; ++i) {
 8041cce:	d1cd      	bne.n	8041c6c <kad_ext_collate+0x78>
			free(v->x);
			v->x = &c[k];
			k += l;
		}
	}
}
 8041cd0:	b005      	add	sp, #20
 8041cd2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8041cd6:	7822      	ldrb	r2, [r4, #0]
 8041cd8:	b30a      	cbz	r2, 8041d1e <kad_ext_collate+0x12a>
 8041cda:	2a01      	cmp	r2, #1
 8041cdc:	6923      	ldr	r3, [r4, #16]
 8041cde:	d00b      	beq.n	8041cf8 <kad_ext_collate+0x104>
 8041ce0:	6961      	ldr	r1, [r4, #20]
 8041ce2:	2a02      	cmp	r2, #2
 8041ce4:	fb01 f303 	mul.w	r3, r1, r3
 8041ce8:	d006      	beq.n	8041cf8 <kad_ext_collate+0x104>
 8041cea:	69a1      	ldr	r1, [r4, #24]
 8041cec:	2a03      	cmp	r2, #3
 8041cee:	fb01 f303 	mul.w	r3, r1, r3
 8041cf2:	bf1c      	itt	ne
 8041cf4:	69e2      	ldrne	r2, [r4, #28]
 8041cf6:	4353      	mulne	r3, r2
			memcpy(&c[k], v->x, l * sizeof(float));
 8041cf8:	009a      	lsls	r2, r3, #2
 8041cfa:	9903      	ldr	r1, [sp, #12]
 8041cfc:	eb01 0b89 	add.w	fp, r1, r9, lsl #2
 8041d00:	4658      	mov	r0, fp
 8041d02:	6aa1      	ldr	r1, [r4, #40]	@ 0x28
			k += l;
 8041d04:	4499      	add	r9, r3
			memcpy(&c[k], v->x, l * sizeof(float));
 8041d06:	f00a f956 	bl	804bfb6 <memcpy>
			free(v->x);
 8041d0a:	6aa0      	ldr	r0, [r4, #40]	@ 0x28
 8041d0c:	f009 fd70 	bl	804b7f0 <free>
			v->x = &c[k];
 8041d10:	f8c4 b028 	str.w	fp, [r4, #40]	@ 0x28
			k += l;
 8041d14:	e7a8      	b.n	8041c68 <kad_ext_collate+0x74>
 8041d16:	2204      	movs	r2, #4
	int n = 1, i;
 8041d18:	f04f 0b01 	mov.w	fp, #1
 8041d1c:	e7c4      	b.n	8041ca8 <kad_ext_collate+0xb4>
	for (i = 0; i < p->n_d; ++i) n *= p->d[i];
 8041d1e:	2204      	movs	r2, #4
	int n = 1, i;
 8041d20:	2301      	movs	r3, #1
 8041d22:	e7ea      	b.n	8041cfa <kad_ext_collate+0x106>

08041d24 <kann_new_leaf_array.constprop.0>:
 *** @@LAYER: layers and model generation ***
 **********************************************/

/********** General but more complex APIs **********/

kad_node_t *kann_new_leaf_array(int *offset, kad_node_p *par, uint8_t flag, float x0_01, int n_d, int32_t d[KAD_MAX_DIM])
 8041d24:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
{
	int i, len, off = offset && par? *offset : -1;
 8041d28:	4605      	mov	r5, r0
kad_node_t *kann_new_leaf_array(int *offset, kad_node_p *par, uint8_t flag, float x0_01, int n_d, int32_t d[KAD_MAX_DIM])
 8041d2a:	ed2d 8b02 	vpush	{d8}
 8041d2e:	460e      	mov	r6, r1
 8041d30:	4690      	mov	r8, r2
 8041d32:	eeb0 8a40 	vmov.f32	s16, s0
	int i, len, off = offset && par? *offset : -1;
 8041d36:	b180      	cbz	r0, 8041d5a <kann_new_leaf_array.constprop.0+0x36>
 8041d38:	b179      	cbz	r1, 8041d5a <kann_new_leaf_array.constprop.0+0x36>
 8041d3a:	f8d0 9000 	ldr.w	r9, [r0]
	kad_node_t *p;

	if (off >= 0 && par[off]) return par[(*offset)++];
 8041d3e:	f1b9 0f00 	cmp.w	r9, #0
 8041d42:	db0c      	blt.n	8041d5e <kann_new_leaf_array.constprop.0+0x3a>
 8041d44:	f851 4029 	ldr.w	r4, [r1, r9, lsl #2]
 8041d48:	b14c      	cbz	r4, 8041d5e <kann_new_leaf_array.constprop.0+0x3a>
 8041d4a:	f109 0301 	add.w	r3, r9, #1
 8041d4e:	6003      	str	r3, [r0, #0]
		for (i = 0; i < len; ++i)
			p->x[i] = (float)(kad_drand_normal(0) * sdev_inv);
	}
	if (off >= 0) par[off] = p, ++(*offset);
	return p;
}
 8041d50:	4620      	mov	r0, r4
 8041d52:	ecbd 8b02 	vpop	{d8}
 8041d56:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	int i, len, off = offset && par? *offset : -1;
 8041d5a:	f04f 39ff 	mov.w	r9, #4294967295
	p = (kad_node_t*)calloc(1, sizeof(kad_node_t));
 8041d5e:	2140      	movs	r1, #64	@ 0x40
 8041d60:	2001      	movs	r0, #1
 8041d62:	f009 fd21 	bl	804b7a8 <calloc>
	p->n_d = n_d, p->flag = flag;
 8041d66:	2200      	movs	r2, #0
	p = (kad_node_t*)calloc(1, sizeof(kad_node_t));
 8041d68:	4604      	mov	r4, r0
	heapSize += 1 * sizeof(kad_node_t);
 8041d6a:	4f0f      	ldr	r7, [pc, #60]	@ (8041da8 <kann_new_leaf_array.constprop.0+0x84>)
	p->x = (float*)calloc(len, sizeof(float));
 8041d6c:	2104      	movs	r1, #4
	heapSize += 1 * sizeof(kad_node_t);
 8041d6e:	683b      	ldr	r3, [r7, #0]
	p->x = (float*)calloc(len, sizeof(float));
 8041d70:	2001      	movs	r0, #1
	heapSize += 1 * sizeof(kad_node_t);
 8041d72:	3340      	adds	r3, #64	@ 0x40
	p->n_d = n_d, p->flag = flag;
 8041d74:	7022      	strb	r2, [r4, #0]
 8041d76:	f884 8001 	strb.w	r8, [r4, #1]
	heapSize += 1 * sizeof(kad_node_t);
 8041d7a:	603b      	str	r3, [r7, #0]
	p->x = (float*)calloc(len, sizeof(float));
 8041d7c:	f009 fd14 	bl	804b7a8 <calloc>
	heapSize += len*sizeof(float);
 8041d80:	683b      	ldr	r3, [r7, #0]
	if (off >= 0) par[off] = p, ++(*offset);
 8041d82:	f1b9 0f00 	cmp.w	r9, #0
	heapSize += len*sizeof(float);
 8041d86:	f103 0304 	add.w	r3, r3, #4
			p->x[i] = x0_01;
 8041d8a:	ed80 8a00 	vstr	s16, [r0]
	heapSize += len*sizeof(float);
 8041d8e:	603b      	str	r3, [r7, #0]
	p->x = (float*)calloc(len, sizeof(float));
 8041d90:	62a0      	str	r0, [r4, #40]	@ 0x28
	if (off >= 0) par[off] = p, ++(*offset);
 8041d92:	dbdd      	blt.n	8041d50 <kann_new_leaf_array.constprop.0+0x2c>
}
 8041d94:	ecbd 8b02 	vpop	{d8}
	if (off >= 0) par[off] = p, ++(*offset);
 8041d98:	682b      	ldr	r3, [r5, #0]
}
 8041d9a:	4620      	mov	r0, r4
	if (off >= 0) par[off] = p, ++(*offset);
 8041d9c:	3301      	adds	r3, #1
 8041d9e:	f846 4029 	str.w	r4, [r6, r9, lsl #2]
 8041da2:	602b      	str	r3, [r5, #0]
}
 8041da4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8041da8:	20018344 	.word	0x20018344

08041dac <kann_new_leaf.constprop.1>:
	return out;
}

/********** APIs without offset & par **********/

kad_node_t *kann_new_leaf(uint8_t flag, float x0_01, int n_d, ...)
 8041dac:	ee00 1a10 	vmov	s0, r1
{
	int32_t i, d[KAD_MAX_DIM];
	va_list ap;
	va_start(ap, n_d); for (i = 0; i < n_d; ++i) d[i] = va_arg(ap, int); va_end(ap);
	return kann_new_leaf_array(0, 0, flag, x0_01, n_d, d);
 8041db0:	2100      	movs	r1, #0
kad_node_t *kann_new_leaf(uint8_t flag, float x0_01, int n_d, ...)
 8041db2:	b40c      	push	{r2, r3}
 8041db4:	b500      	push	{lr}
 8041db6:	b087      	sub	sp, #28
 8041db8:	4602      	mov	r2, r0
	va_start(ap, n_d); for (i = 0; i < n_d; ++i) d[i] = va_arg(ap, int); va_end(ap);
 8041dba:	a809      	add	r0, sp, #36	@ 0x24
 8041dbc:	9001      	str	r0, [sp, #4]
	return kann_new_leaf_array(0, 0, flag, x0_01, n_d, d);
 8041dbe:	ab02      	add	r3, sp, #8
 8041dc0:	4608      	mov	r0, r1
 8041dc2:	f7ff ffaf 	bl	8041d24 <kann_new_leaf_array.constprop.0>
}
 8041dc6:	b007      	add	sp, #28
 8041dc8:	f85d eb04 	ldr.w	lr, [sp], #4
 8041dcc:	b002      	add	sp, #8
 8041dce:	4770      	bx	lr

08041dd0 <kann_new>:
{
 8041dd0:	b40e      	push	{r1, r2, r3}
 8041dd2:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8041dd6:	b086      	sub	sp, #24
 8041dd8:	9003      	str	r0, [sp, #12]
	if (cost->n_d != 0) return 0;
 8041dda:	7803      	ldrb	r3, [r0, #0]
{
 8041ddc:	9f0d      	ldr	r7, [sp, #52]	@ 0x34
	if (cost->n_d != 0) return 0;
 8041dde:	2b00      	cmp	r3, #0
 8041de0:	d15c      	bne.n	8041e9c <kann_new+0xcc>
	roots = (kad_node_t**)malloc((n_roots + 1) * sizeof(kad_node_t*));
 8041de2:	1cbe      	adds	r6, r7, #2
 8041de4:	00b6      	lsls	r6, r6, #2
	va_start(ap, n_rest);
 8041de6:	ab0e      	add	r3, sp, #56	@ 0x38
	roots = (kad_node_t**)malloc((n_roots + 1) * sizeof(kad_node_t*));
 8041de8:	4630      	mov	r0, r6
	va_start(ap, n_rest);
 8041dea:	9305      	str	r3, [sp, #20]
	roots = (kad_node_t**)malloc((n_roots + 1) * sizeof(kad_node_t*));
 8041dec:	f009 fcf8 	bl	804b7e0 <malloc>
	for (i = 0; i < n_rest; ++i)
 8041df0:	2f00      	cmp	r7, #0
	roots = (kad_node_t**)malloc((n_roots + 1) * sizeof(kad_node_t*));
 8041df2:	4605      	mov	r5, r0
	for (i = 0; i < n_rest; ++i)
 8041df4:	dd72      	ble.n	8041edc <kann_new+0x10c>
		roots[i] = va_arg(ap, kad_node_t*);
 8041df6:	9b05      	ldr	r3, [sp, #20]
 8041df8:	f1a6 0408 	sub.w	r4, r6, #8
 8041dfc:	1f02      	subs	r2, r0, #4
 8041dfe:	1918      	adds	r0, r3, r4
 8041e00:	f853 1b04 	ldr.w	r1, [r3], #4
	for (i = 0; i < n_rest; ++i)
 8041e04:	4283      	cmp	r3, r0
		roots[i] = va_arg(ap, kad_node_t*);
 8041e06:	f842 1f04 	str.w	r1, [r2, #4]!
	for (i = 0; i < n_rest; ++i)
 8041e0a:	d1f9      	bne.n	8041e00 <kann_new+0x30>
	roots[i++] = cost;
 8041e0c:	442c      	add	r4, r5
 8041e0e:	9b03      	ldr	r3, [sp, #12]
	a = (kann_t*)calloc(1, sizeof(kann_t));
 8041e10:	2118      	movs	r1, #24
	cost->ext_flag |= KANN_F_COST;
 8041e12:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
	roots[i++] = cost;
 8041e14:	6023      	str	r3, [r4, #0]
	cost->ext_flag |= KANN_F_COST;
 8041e16:	f042 0208 	orr.w	r2, r2, #8
 8041e1a:	625a      	str	r2, [r3, #36]	@ 0x24
	a = (kann_t*)calloc(1, sizeof(kann_t));
 8041e1c:	2001      	movs	r0, #1
 8041e1e:	f009 fcc3 	bl	804b7a8 <calloc>
	heapSize += 1 * sizeof(kann_t);
 8041e22:	492f      	ldr	r1, [pc, #188]	@ (8041ee0 <kann_new+0x110>)
	int i, n_roots = 1 + n_rest, has_pivot = 0, has_recur = 0;
 8041e24:	f107 0901 	add.w	r9, r7, #1
	heapSize += 1 * sizeof(kann_t);
 8041e28:	680b      	ldr	r3, [r1, #0]
	a->v = kad_compile_array(&a->n, n_roots, roots);
 8041e2a:	462a      	mov	r2, r5
	heapSize += 1 * sizeof(kann_t);
 8041e2c:	3318      	adds	r3, #24
 8041e2e:	600b      	str	r3, [r1, #0]
	a->v = kad_compile_array(&a->n, n_roots, roots);
 8041e30:	4649      	mov	r1, r9
	a = (kann_t*)calloc(1, sizeof(kann_t));
 8041e32:	4604      	mov	r4, r0
	a->v = kad_compile_array(&a->n, n_roots, roots);
 8041e34:	f008 f9ea 	bl	804a20c <kad_compile_array>
 8041e38:	4601      	mov	r1, r0
	for (i = 0; i < a->n; ++i) {
 8041e3a:	6820      	ldr	r0, [r4, #0]
	a->v = kad_compile_array(&a->n, n_roots, roots);
 8041e3c:	6061      	str	r1, [r4, #4]
	for (i = 0; i < a->n; ++i) {
 8041e3e:	2800      	cmp	r0, #0
 8041e40:	dd1a      	ble.n	8041e78 <kann_new+0xa8>
	int i, n_roots = 1 + n_rest, has_pivot = 0, has_recur = 0;
 8041e42:	2200      	movs	r2, #0
 8041e44:	4690      	mov	r8, r2
 8041e46:	f1a1 0c04 	sub.w	ip, r1, #4
 8041e4a:	eb0c 0e80 	add.w	lr, ip, r0, lsl #2
		if (a->v[i]->pre) has_recur = 1;
 8041e4e:	f85c 3f04 	ldr.w	r3, [ip, #4]!
 8041e52:	6bdf      	ldr	r7, [r3, #60]	@ 0x3c
 8041e54:	2f00      	cmp	r7, #0
		if (kad_is_pivot(a->v[i])) has_pivot = 1;
 8041e56:	685f      	ldr	r7, [r3, #4]
		if (a->v[i]->pre) has_recur = 1;
 8041e58:	bf18      	it	ne
 8041e5a:	2201      	movne	r2, #1
		if (kad_is_pivot(a->v[i])) has_pivot = 1;
 8041e5c:	2f01      	cmp	r7, #1
 8041e5e:	d105      	bne.n	8041e6c <kann_new+0x9c>
 8041e60:	785b      	ldrb	r3, [r3, #1]
 8041e62:	f013 0f04 	tst.w	r3, #4
 8041e66:	bf18      	it	ne
 8041e68:	f04f 0801 	movne.w	r8, #1
	for (i = 0; i < a->n; ++i) {
 8041e6c:	45e6      	cmp	lr, ip
 8041e6e:	d1ee      	bne.n	8041e4e <kann_new+0x7e>
	if (has_recur && !has_pivot) { /* an RNN that doesn't have a pivot; then add a pivot on top of cost and recompile */
 8041e70:	b112      	cbz	r2, 8041e78 <kann_new+0xa8>
 8041e72:	f1b8 0f00 	cmp.w	r8, #0
 8041e76:	d013      	beq.n	8041ea0 <kann_new+0xd0>
	kad_ext_collate(a->n, a->v, &a->x, &a->g, &a->c);
 8041e78:	f104 0310 	add.w	r3, r4, #16
 8041e7c:	9300      	str	r3, [sp, #0]
 8041e7e:	f104 0208 	add.w	r2, r4, #8
 8041e82:	f104 030c 	add.w	r3, r4, #12
 8041e86:	f7ff feb5 	bl	8041bf4 <kad_ext_collate>
	free(roots);
 8041e8a:	4628      	mov	r0, r5
 8041e8c:	f009 fcb0 	bl	804b7f0 <free>
}
 8041e90:	4620      	mov	r0, r4
 8041e92:	b006      	add	sp, #24
 8041e94:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8041e98:	b003      	add	sp, #12
 8041e9a:	4770      	bx	lr
	if (cost->n_d != 0) return 0;
 8041e9c:	2400      	movs	r4, #0
 8041e9e:	e7f7      	b.n	8041e90 <kann_new+0xc0>
		cost->ext_flag &= ~KANN_F_COST;
 8041ea0:	9a03      	ldr	r2, [sp, #12]
		roots[n_roots-1] = cost = kad_avg(1, &cost), cost->ext_flag |= KANN_F_COST;
 8041ea2:	a903      	add	r1, sp, #12
		cost->ext_flag &= ~KANN_F_COST;
 8041ea4:	6a53      	ldr	r3, [r2, #36]	@ 0x24
		roots[n_roots-1] = cost = kad_avg(1, &cost), cost->ext_flag |= KANN_F_COST;
 8041ea6:	2001      	movs	r0, #1
		cost->ext_flag &= ~KANN_F_COST;
 8041ea8:	f023 0308 	bic.w	r3, r3, #8
 8041eac:	6253      	str	r3, [r2, #36]	@ 0x24
		roots[n_roots-1] = cost = kad_avg(1, &cost), cost->ext_flag |= KANN_F_COST;
 8041eae:	f008 f8e9 	bl	804a084 <kad_avg>
 8041eb2:	4603      	mov	r3, r0
 8041eb4:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 8041eb6:	442e      	add	r6, r5
 8041eb8:	f042 0208 	orr.w	r2, r2, #8
		free(a->v);
 8041ebc:	6860      	ldr	r0, [r4, #4]
		roots[n_roots-1] = cost = kad_avg(1, &cost), cost->ext_flag |= KANN_F_COST;
 8041ebe:	f846 3c08 	str.w	r3, [r6, #-8]
 8041ec2:	625a      	str	r2, [r3, #36]	@ 0x24
 8041ec4:	9303      	str	r3, [sp, #12]
		free(a->v);
 8041ec6:	f009 fc93 	bl	804b7f0 <free>
		a->v = kad_compile_array(&a->n, n_roots, roots);
 8041eca:	4649      	mov	r1, r9
 8041ecc:	462a      	mov	r2, r5
 8041ece:	4620      	mov	r0, r4
 8041ed0:	f008 f99c 	bl	804a20c <kad_compile_array>
 8041ed4:	4601      	mov	r1, r0
	kad_ext_collate(a->n, a->v, &a->x, &a->g, &a->c);
 8041ed6:	6820      	ldr	r0, [r4, #0]
		a->v = kad_compile_array(&a->n, n_roots, roots);
 8041ed8:	6061      	str	r1, [r4, #4]
 8041eda:	e7cd      	b.n	8041e78 <kann_new+0xa8>
	for (i = 0; i < n_rest; ++i)
 8041edc:	4604      	mov	r4, r0
 8041ede:	e796      	b.n	8041e0e <kann_new+0x3e>
 8041ee0:	20018344 	.word	0x20018344

08041ee4 <kann_unroll>:
{
 8041ee4:	b40f      	push	{r0, r1, r2, r3}
 8041ee6:	b5f0      	push	{r4, r5, r6, r7, lr}
 8041ee8:	b083      	sub	sp, #12
 8041eea:	af08      	add	r7, sp, #32
 8041eec:	f857 5b04 	ldr.w	r5, [r7], #4
	n_pivots = kad_n_pivots(a->n, a->v);
 8041ef0:	e9d5 0100 	ldrd	r0, r1, [r5]
 8041ef4:	f008 fc12 	bl	804a71c <kad_n_pivots>
	len = (int*)calloc(n_pivots, sizeof(int));
 8041ef8:	2104      	movs	r1, #4
	n_pivots = kad_n_pivots(a->n, a->v);
 8041efa:	4604      	mov	r4, r0
	len = (int*)calloc(n_pivots, sizeof(int));
 8041efc:	f009 fc54 	bl	804b7a8 <calloc>
	for (i = 0; i < n_pivots; ++i) len[i] = va_arg(ap, int);
 8041f00:	2c00      	cmp	r4, #0
	len = (int*)calloc(n_pivots, sizeof(int));
 8041f02:	4606      	mov	r6, r0
	va_start(ap, a);
 8041f04:	9701      	str	r7, [sp, #4]
	for (i = 0; i < n_pivots; ++i) len[i] = va_arg(ap, int);
 8041f06:	dd03      	ble.n	8041f10 <kann_unroll+0x2c>
 8041f08:	4639      	mov	r1, r7
 8041f0a:	00a2      	lsls	r2, r4, #2
 8041f0c:	f00a f853 	bl	804bfb6 <memcpy>
	b = (kann_t*)calloc(1, sizeof(kann_t));
 8041f10:	2118      	movs	r1, #24
 8041f12:	2001      	movs	r0, #1
 8041f14:	f009 fc48 	bl	804b7a8 <calloc>
 8041f18:	4604      	mov	r4, r0
	b->v = kad_unroll(a->n, a->v, &b->n, len);
 8041f1a:	e9d5 0100 	ldrd	r0, r1, [r5]
	heapSize += 1 * sizeof(kann_t);
 8041f1e:	4a0d      	ldr	r2, [pc, #52]	@ (8041f54 <kann_unroll+0x70>)
	b->x = a->x, b->g = a->g, b->c = a->c; /* these arrays are shared */
 8041f20:	f8d5 c008 	ldr.w	ip, [r5, #8]
	heapSize += 1 * sizeof(kann_t);
 8041f24:	6813      	ldr	r3, [r2, #0]
 8041f26:	3318      	adds	r3, #24
 8041f28:	6013      	str	r3, [r2, #0]
	b->x = a->x, b->g = a->g, b->c = a->c; /* these arrays are shared */
 8041f2a:	e9d5 7203 	ldrd	r7, r2, [r5, #12]
	b->v = kad_unroll(a->n, a->v, &b->n, len);
 8041f2e:	4633      	mov	r3, r6
	b->x = a->x, b->g = a->g, b->c = a->c; /* these arrays are shared */
 8041f30:	e9c4 c702 	strd	ip, r7, [r4, #8]
 8041f34:	6122      	str	r2, [r4, #16]
	b->v = kad_unroll(a->n, a->v, &b->n, len);
 8041f36:	4622      	mov	r2, r4
 8041f38:	f008 fcbe 	bl	804a8b8 <kad_unroll>
 8041f3c:	4603      	mov	r3, r0
	free(len);
 8041f3e:	4630      	mov	r0, r6
	b->v = kad_unroll(a->n, a->v, &b->n, len);
 8041f40:	6063      	str	r3, [r4, #4]
	free(len);
 8041f42:	f009 fc55 	bl	804b7f0 <free>
}
 8041f46:	4620      	mov	r0, r4
 8041f48:	b003      	add	sp, #12
 8041f4a:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
 8041f4e:	b004      	add	sp, #16
 8041f50:	4770      	bx	lr
 8041f52:	bf00      	nop
 8041f54:	20018344 	.word	0x20018344

08041f58 <kann_delete_unrolled>:
{
 8041f58:	b510      	push	{r4, lr}
	if (a && a->mt) kann_mt(a, 0, 0);
 8041f5a:	4604      	mov	r4, r0
 8041f5c:	b120      	cbz	r0, 8041f68 <kann_delete_unrolled+0x10>
	if (a && a->v) kad_delete(a->n, a->v);
 8041f5e:	6841      	ldr	r1, [r0, #4]
 8041f60:	b111      	cbz	r1, 8041f68 <kann_delete_unrolled+0x10>
 8041f62:	6800      	ldr	r0, [r0, #0]
 8041f64:	f008 fa62 	bl	804a42c <kad_delete>
	free(a);
 8041f68:	4620      	mov	r0, r4
}
 8041f6a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	free(a);
 8041f6e:	f009 bc3f 	b.w	804b7f0 <free>
 8041f72:	bf00      	nop

08041f74 <kann_find>:
{
 8041f74:	b5f0      	push	{r4, r5, r6, r7, lr}
	for (i = k = 0; i < a->n; ++i)
 8041f76:	6804      	ldr	r4, [r0, #0]
 8041f78:	2c00      	cmp	r4, #0
 8041f7a:	dd51      	ble.n	8042020 <kann_find+0xac>
 8041f7c:	4603      	mov	r3, r0
 8041f7e:	b319      	cbz	r1, 8041fc8 <kann_find+0x54>
 8041f80:	2a00      	cmp	r2, #0
 8041f82:	d03b      	beq.n	8041ffc <kann_find+0x88>
		if (chk_flg(a->v[i]->ext_flag, ext_flag) && chk_lbl(a->v[i]->ext_label, ext_label))
 8041f84:	f04f 0e00 	mov.w	lr, #0
 8041f88:	6846      	ldr	r6, [r0, #4]
	for (i = k = 0; i < a->n; ++i)
 8041f8a:	46f4      	mov	ip, lr
	int i, k, r = -1;
 8041f8c:	f04f 30ff 	mov.w	r0, #4294967295
	for (i = k = 0; i < a->n; ++i)
 8041f90:	4673      	mov	r3, lr
		if (chk_flg(a->v[i]->ext_flag, ext_flag) && chk_lbl(a->v[i]->ext_label, ext_label))
 8041f92:	f856 500e 	ldr.w	r5, [r6, lr]
 8041f96:	6a6f      	ldr	r7, [r5, #36]	@ 0x24
 8041f98:	4239      	tst	r1, r7
 8041f9a:	d005      	beq.n	8041fa8 <kann_find+0x34>
 8041f9c:	6a2d      	ldr	r5, [r5, #32]
 8041f9e:	42aa      	cmp	r2, r5
 8041fa0:	d102      	bne.n	8041fa8 <kann_find+0x34>
			++k, r = i;
 8041fa2:	4618      	mov	r0, r3
 8041fa4:	f10c 0c01 	add.w	ip, ip, #1
	for (i = k = 0; i < a->n; ++i)
 8041fa8:	3301      	adds	r3, #1
 8041faa:	429c      	cmp	r4, r3
 8041fac:	f10e 0e04 	add.w	lr, lr, #4
 8041fb0:	d1ef      	bne.n	8041f92 <kann_find+0x1e>
	return k == 1? r : k == 0? -1 : -2;
 8041fb2:	f1bc 0f01 	cmp.w	ip, #1
 8041fb6:	d006      	beq.n	8041fc6 <kann_find+0x52>
 8041fb8:	f1bc 0f00 	cmp.w	ip, #0
 8041fbc:	bf14      	ite	ne
 8041fbe:	f06f 0001 	mvnne.w	r0, #1
 8041fc2:	f04f 30ff 	moveq.w	r0, #4294967295
}
 8041fc6:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8041fc8:	b192      	cbz	r2, 8041ff0 <kann_find+0x7c>
 8041fca:	685d      	ldr	r5, [r3, #4]
	for (i = k = 0; i < a->n; ++i)
 8041fcc:	468c      	mov	ip, r1
	int i, k, r = -1;
 8041fce:	f04f 30ff 	mov.w	r0, #4294967295
	for (i = k = 0; i < a->n; ++i)
 8041fd2:	460b      	mov	r3, r1
		if (chk_flg(a->v[i]->ext_flag, ext_flag) && chk_lbl(a->v[i]->ext_label, ext_label))
 8041fd4:	f855 1023 	ldr.w	r1, [r5, r3, lsl #2]
 8041fd8:	6a09      	ldr	r1, [r1, #32]
 8041fda:	428a      	cmp	r2, r1
			++k, r = i;
 8041fdc:	bf08      	it	eq
 8041fde:	4618      	moveq	r0, r3
	for (i = k = 0; i < a->n; ++i)
 8041fe0:	f103 0301 	add.w	r3, r3, #1
			++k, r = i;
 8041fe4:	bf08      	it	eq
 8041fe6:	f10c 0c01 	addeq.w	ip, ip, #1
	for (i = k = 0; i < a->n; ++i)
 8041fea:	429c      	cmp	r4, r3
 8041fec:	d1f2      	bne.n	8041fd4 <kann_find+0x60>
 8041fee:	e7e0      	b.n	8041fb2 <kann_find+0x3e>
	return k == 1? r : k == 0? -1 : -2;
 8041ff0:	2c01      	cmp	r4, #1
 8041ff2:	bf14      	ite	ne
 8041ff4:	f06f 0001 	mvnne.w	r0, #1
 8041ff8:	2000      	moveq	r0, #0
}
 8041ffa:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8041ffc:	6845      	ldr	r5, [r0, #4]
	for (i = k = 0; i < a->n; ++i)
 8041ffe:	4694      	mov	ip, r2
	int i, k, r = -1;
 8042000:	f04f 30ff 	mov.w	r0, #4294967295
		if (chk_flg(a->v[i]->ext_flag, ext_flag) && chk_lbl(a->v[i]->ext_label, ext_label))
 8042004:	f855 3022 	ldr.w	r3, [r5, r2, lsl #2]
 8042008:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 804200a:	4219      	tst	r1, r3
			++k, r = i;
 804200c:	bf18      	it	ne
 804200e:	4610      	movne	r0, r2
	for (i = k = 0; i < a->n; ++i)
 8042010:	f102 0201 	add.w	r2, r2, #1
			++k, r = i;
 8042014:	bf18      	it	ne
 8042016:	f10c 0c01 	addne.w	ip, ip, #1
	for (i = k = 0; i < a->n; ++i)
 804201a:	42a2      	cmp	r2, r4
 804201c:	d1f2      	bne.n	8042004 <kann_find+0x90>
 804201e:	e7c8      	b.n	8041fb2 <kann_find+0x3e>
	return k == 1? r : k == 0? -1 : -2;
 8042020:	f04f 30ff 	mov.w	r0, #4294967295
}
 8042024:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8042026:	bf00      	nop

08042028 <kann_feed_bind>:
	if (x == 0) return 0;
 8042028:	2b00      	cmp	r3, #0
 804202a:	d062      	beq.n	80420f2 <kann_feed_bind+0xca>
{
 804202c:	b570      	push	{r4, r5, r6, lr}
	for (i = k = 0; i < a->n; ++i)
 804202e:	6805      	ldr	r5, [r0, #0]
 8042030:	2d00      	cmp	r5, #0
 8042032:	dd60      	ble.n	80420f6 <kann_feed_bind+0xce>
		if (kad_is_feed(a->v[i]) && chk_flg(a->v[i]->ext_flag, ext_flag) && chk_lbl(a->v[i]->ext_label, ext_label))
 8042034:	6844      	ldr	r4, [r0, #4]
 8042036:	b1da      	cbz	r2, 8042070 <kann_feed_bind+0x48>
 8042038:	b391      	cbz	r1, 80420a0 <kann_feed_bind+0x78>
	for (i = k = 0; i < a->n; ++i)
 804203a:	2000      	movs	r0, #0
 804203c:	f1a4 0c04 	sub.w	ip, r4, #4
 8042040:	eb0c 0585 	add.w	r5, ip, r5, lsl #2
		if (kad_is_feed(a->v[i]) && chk_flg(a->v[i]->ext_flag, ext_flag) && chk_lbl(a->v[i]->ext_label, ext_label))
 8042044:	f85c 4f04 	ldr.w	r4, [ip, #4]!
 8042048:	6866      	ldr	r6, [r4, #4]
 804204a:	b976      	cbnz	r6, 804206a <kann_feed_bind+0x42>
 804204c:	f894 e001 	ldrb.w	lr, [r4, #1]
 8042050:	f01e 0f03 	tst.w	lr, #3
 8042054:	d109      	bne.n	804206a <kann_feed_bind+0x42>
 8042056:	6a66      	ldr	r6, [r4, #36]	@ 0x24
 8042058:	4231      	tst	r1, r6
 804205a:	d006      	beq.n	804206a <kann_feed_bind+0x42>
 804205c:	6a26      	ldr	r6, [r4, #32]
 804205e:	42b2      	cmp	r2, r6
 8042060:	d103      	bne.n	804206a <kann_feed_bind+0x42>
			a->v[i]->x = x[k++];
 8042062:	f853 6020 	ldr.w	r6, [r3, r0, lsl #2]
 8042066:	3001      	adds	r0, #1
 8042068:	62a6      	str	r6, [r4, #40]	@ 0x28
	for (i = k = 0; i < a->n; ++i)
 804206a:	4565      	cmp	r5, ip
 804206c:	d1ea      	bne.n	8042044 <kann_feed_bind+0x1c>
}
 804206e:	bd70      	pop	{r4, r5, r6, pc}
 8042070:	b369      	cbz	r1, 80420ce <kann_feed_bind+0xa6>
	for (i = k = 0; i < a->n; ++i)
 8042072:	4610      	mov	r0, r2
 8042074:	1f22      	subs	r2, r4, #4
 8042076:	eb02 0585 	add.w	r5, r2, r5, lsl #2
		if (kad_is_feed(a->v[i]) && chk_flg(a->v[i]->ext_flag, ext_flag) && chk_lbl(a->v[i]->ext_label, ext_label))
 804207a:	f852 4f04 	ldr.w	r4, [r2, #4]!
 804207e:	6866      	ldr	r6, [r4, #4]
 8042080:	b95e      	cbnz	r6, 804209a <kann_feed_bind+0x72>
 8042082:	f894 c001 	ldrb.w	ip, [r4, #1]
 8042086:	f01c 0f03 	tst.w	ip, #3
 804208a:	d106      	bne.n	804209a <kann_feed_bind+0x72>
 804208c:	6a66      	ldr	r6, [r4, #36]	@ 0x24
 804208e:	4231      	tst	r1, r6
 8042090:	d003      	beq.n	804209a <kann_feed_bind+0x72>
			a->v[i]->x = x[k++];
 8042092:	f853 6020 	ldr.w	r6, [r3, r0, lsl #2]
 8042096:	3001      	adds	r0, #1
 8042098:	62a6      	str	r6, [r4, #40]	@ 0x28
	for (i = k = 0; i < a->n; ++i)
 804209a:	4295      	cmp	r5, r2
 804209c:	d1ed      	bne.n	804207a <kann_feed_bind+0x52>
}
 804209e:	bd70      	pop	{r4, r5, r6, pc}
	for (i = k = 0; i < a->n; ++i)
 80420a0:	4608      	mov	r0, r1
 80420a2:	1f21      	subs	r1, r4, #4
 80420a4:	eb01 0585 	add.w	r5, r1, r5, lsl #2
		if (kad_is_feed(a->v[i]) && chk_flg(a->v[i]->ext_flag, ext_flag) && chk_lbl(a->v[i]->ext_label, ext_label))
 80420a8:	f851 4f04 	ldr.w	r4, [r1, #4]!
 80420ac:	6866      	ldr	r6, [r4, #4]
 80420ae:	b95e      	cbnz	r6, 80420c8 <kann_feed_bind+0xa0>
 80420b0:	f894 c001 	ldrb.w	ip, [r4, #1]
 80420b4:	f01c 0f03 	tst.w	ip, #3
 80420b8:	d106      	bne.n	80420c8 <kann_feed_bind+0xa0>
 80420ba:	6a26      	ldr	r6, [r4, #32]
 80420bc:	42b2      	cmp	r2, r6
 80420be:	d103      	bne.n	80420c8 <kann_feed_bind+0xa0>
			a->v[i]->x = x[k++];
 80420c0:	f853 6020 	ldr.w	r6, [r3, r0, lsl #2]
 80420c4:	3001      	adds	r0, #1
 80420c6:	62a6      	str	r6, [r4, #40]	@ 0x28
	for (i = k = 0; i < a->n; ++i)
 80420c8:	428d      	cmp	r5, r1
 80420ca:	d1ed      	bne.n	80420a8 <kann_feed_bind+0x80>
}
 80420cc:	bd70      	pop	{r4, r5, r6, pc}
	for (i = k = 0; i < a->n; ++i)
 80420ce:	4608      	mov	r0, r1
 80420d0:	1f22      	subs	r2, r4, #4
 80420d2:	eb02 0585 	add.w	r5, r2, r5, lsl #2
		if (kad_is_feed(a->v[i]) && chk_flg(a->v[i]->ext_flag, ext_flag) && chk_lbl(a->v[i]->ext_label, ext_label))
 80420d6:	f852 1f04 	ldr.w	r1, [r2, #4]!
 80420da:	684c      	ldr	r4, [r1, #4]
 80420dc:	b934      	cbnz	r4, 80420ec <kann_feed_bind+0xc4>
 80420de:	784c      	ldrb	r4, [r1, #1]
 80420e0:	07a4      	lsls	r4, r4, #30
 80420e2:	d103      	bne.n	80420ec <kann_feed_bind+0xc4>
			a->v[i]->x = x[k++];
 80420e4:	f853 4020 	ldr.w	r4, [r3, r0, lsl #2]
 80420e8:	3001      	adds	r0, #1
 80420ea:	628c      	str	r4, [r1, #40]	@ 0x28
	for (i = k = 0; i < a->n; ++i)
 80420ec:	42aa      	cmp	r2, r5
 80420ee:	d1f2      	bne.n	80420d6 <kann_feed_bind+0xae>
}
 80420f0:	bd70      	pop	{r4, r5, r6, pc}
	if (x == 0) return 0;
 80420f2:	4618      	mov	r0, r3
}
 80420f4:	4770      	bx	lr
	if (x == 0) return 0;
 80420f6:	2000      	movs	r0, #0
}
 80420f8:	bd70      	pop	{r4, r5, r6, pc}
 80420fa:	bf00      	nop

080420fc <kann_feed_dim>:
{
 80420fc:	b5f0      	push	{r4, r5, r6, r7, lr}
	for (i = k = 0; i < a->n; ++i)
 80420fe:	6804      	ldr	r4, [r0, #0]
 8042100:	2c00      	cmp	r4, #0
 8042102:	dd42      	ble.n	804218a <kann_feed_dim+0x8e>
 8042104:	4603      	mov	r3, r0
	int i, k, n = 0;
 8042106:	2000      	movs	r0, #0
	for (i = k = 0; i < a->n; ++i)
 8042108:	4605      	mov	r5, r0
		if (kad_is_feed(a->v[i]) && chk_flg(a->v[i]->ext_flag, ext_flag) && chk_lbl(a->v[i]->ext_label, ext_label))
 804210a:	685b      	ldr	r3, [r3, #4]
 804210c:	3b04      	subs	r3, #4
 804210e:	eb03 0c84 	add.w	ip, r3, r4, lsl #2
 8042112:	f853 4f04 	ldr.w	r4, [r3, #4]!
 8042116:	6866      	ldr	r6, [r4, #4]
 8042118:	b966      	cbnz	r6, 8042134 <kann_feed_dim+0x38>
 804211a:	f894 e001 	ldrb.w	lr, [r4, #1]
 804211e:	f01e 0f03 	tst.w	lr, #3
 8042122:	d107      	bne.n	8042134 <kann_feed_dim+0x38>
 8042124:	b111      	cbz	r1, 804212c <kann_feed_dim+0x30>
 8042126:	6a66      	ldr	r6, [r4, #36]	@ 0x24
 8042128:	4231      	tst	r1, r6
 804212a:	d003      	beq.n	8042134 <kann_feed_dim+0x38>
 804212c:	b16a      	cbz	r2, 804214a <kann_feed_dim+0x4e>
 804212e:	6a26      	ldr	r6, [r4, #32]
 8042130:	4296      	cmp	r6, r2
 8042132:	d00a      	beq.n	804214a <kann_feed_dim+0x4e>
	for (i = k = 0; i < a->n; ++i)
 8042134:	459c      	cmp	ip, r3
 8042136:	d1ec      	bne.n	8042112 <kann_feed_dim+0x16>
	return k == 1? n : k == 0? -1 : -2;
 8042138:	2d01      	cmp	r5, #1
 804213a:	d005      	beq.n	8042148 <kann_feed_dim+0x4c>
 804213c:	2d00      	cmp	r5, #0
 804213e:	bf14      	ite	ne
 8042140:	f06f 0001 	mvnne.w	r0, #1
 8042144:	f04f 30ff 	moveq.w	r0, #4294967295
}
 8042148:	bdf0      	pop	{r4, r5, r6, r7, pc}
			++k, n = a->v[i]->n_d > 1? kad_len(a->v[i]) / a->v[i]->d[0] : a->v[i]->n_d == 1? a->v[i]->d[0] : 1;
 804214a:	f894 e000 	ldrb.w	lr, [r4]
 804214e:	3501      	adds	r5, #1
 8042150:	f1be 0f01 	cmp.w	lr, #1
 8042154:	d805      	bhi.n	8042162 <kann_feed_dim+0x66>
 8042156:	bf14      	ite	ne
 8042158:	2001      	movne	r0, #1
 804215a:	6920      	ldreq	r0, [r4, #16]
	for (i = k = 0; i < a->n; ++i)
 804215c:	459c      	cmp	ip, r3
 804215e:	d1d8      	bne.n	8042112 <kann_feed_dim+0x16>
 8042160:	e7ea      	b.n	8042138 <kann_feed_dim+0x3c>
	for (i = 0; i < p->n_d; ++i) n *= p->d[i];
 8042162:	f1be 0f02 	cmp.w	lr, #2
 8042166:	e9d4 6004 	ldrd	r6, r0, [r4, #16]
 804216a:	fb06 f000 	mul.w	r0, r6, r0
 804216e:	d007      	beq.n	8042180 <kann_feed_dim+0x84>
 8042170:	69a7      	ldr	r7, [r4, #24]
 8042172:	f1be 0f03 	cmp.w	lr, #3
 8042176:	fb07 f000 	mul.w	r0, r7, r0
 804217a:	bf1c      	itt	ne
 804217c:	69e4      	ldrne	r4, [r4, #28]
 804217e:	4360      	mulne	r0, r4
 8042180:	459c      	cmp	ip, r3
			++k, n = a->v[i]->n_d > 1? kad_len(a->v[i]) / a->v[i]->d[0] : a->v[i]->n_d == 1? a->v[i]->d[0] : 1;
 8042182:	fb90 f0f6 	sdiv	r0, r0, r6
	for (i = k = 0; i < a->n; ++i)
 8042186:	d1c4      	bne.n	8042112 <kann_feed_dim+0x16>
 8042188:	e7d6      	b.n	8042138 <kann_feed_dim+0x3c>
	return k == 1? n : k == 0? -1 : -2;
 804218a:	f04f 30ff 	mov.w	r0, #4294967295
}
 804218e:	bdf0      	pop	{r4, r5, r6, r7, pc}

08042190 <kann_rnn_start>:
{
 8042190:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8042192:	4607      	mov	r7, r0
	kann_set_batch_size(a, 1);
 8042194:	e9d0 0100 	ldrd	r0, r1, [r0]
 8042198:	2201      	movs	r2, #1
 804219a:	f007 ffcd 	bl	804a138 <kad_sync_dim>
	for (i = 0; i < a->n; ++i) {
 804219e:	683a      	ldr	r2, [r7, #0]
 80421a0:	2a00      	cmp	r2, #0
 80421a2:	dd44      	ble.n	804222e <kann_rnn_start+0x9e>
 80421a4:	2600      	movs	r6, #0
 80421a6:	e020      	b.n	80421ea <kann_rnn_start+0x5a>
 80421a8:	2b00      	cmp	r3, #0
 80421aa:	d041      	beq.n	8042230 <kann_rnn_start+0xa0>
 80421ac:	2b01      	cmp	r3, #1
 80421ae:	6922      	ldr	r2, [r4, #16]
 80421b0:	d00b      	beq.n	80421ca <kann_rnn_start+0x3a>
 80421b2:	6960      	ldr	r0, [r4, #20]
 80421b4:	2b02      	cmp	r3, #2
 80421b6:	fb00 f202 	mul.w	r2, r0, r2
 80421ba:	d006      	beq.n	80421ca <kann_rnn_start+0x3a>
 80421bc:	69a0      	ldr	r0, [r4, #24]
 80421be:	2b03      	cmp	r3, #3
 80421c0:	fb00 f202 	mul.w	r2, r0, r2
 80421c4:	bf1c      	itt	ne
 80421c6:	69e3      	ldrne	r3, [r4, #28]
 80421c8:	435a      	mulne	r2, r3
			if (q->x) memcpy(p->x, q->x, kad_len(p) * sizeof(float));
 80421ca:	0092      	lsls	r2, r2, #2
 80421cc:	4660      	mov	r0, ip
 80421ce:	f009 fef2 	bl	804bfb6 <memcpy>
			if (q->n_child > 0) free(q->x);
 80421d2:	686b      	ldr	r3, [r5, #4]
 80421d4:	2b00      	cmp	r3, #0
 80421d6:	dd02      	ble.n	80421de <kann_rnn_start+0x4e>
 80421d8:	6aa8      	ldr	r0, [r5, #40]	@ 0x28
 80421da:	f009 fb09 	bl	804b7f0 <free>
			q->x = p->x;
 80421de:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
	for (i = 0; i < a->n; ++i) {
 80421e0:	683a      	ldr	r2, [r7, #0]
			q->x = p->x;
 80421e2:	62ab      	str	r3, [r5, #40]	@ 0x28
	for (i = 0; i < a->n; ++i) {
 80421e4:	3601      	adds	r6, #1
 80421e6:	4296      	cmp	r6, r2
 80421e8:	da21      	bge.n	804222e <kann_rnn_start+0x9e>
		kad_node_t *p = a->v[i];
 80421ea:	687b      	ldr	r3, [r7, #4]
 80421ec:	f853 4026 	ldr.w	r4, [r3, r6, lsl #2]
		if (p->pre) { /* NB: BE CAREFUL of the interaction between kann_rnn_start() and kann_set_batch_size() */
 80421f0:	6be5      	ldr	r5, [r4, #60]	@ 0x3c
 80421f2:	2d00      	cmp	r5, #0
 80421f4:	d0f6      	beq.n	80421e4 <kann_rnn_start+0x54>
			if (q->x) memcpy(p->x, q->x, kad_len(p) * sizeof(float));
 80421f6:	6aa9      	ldr	r1, [r5, #40]	@ 0x28
 80421f8:	f8d4 c028 	ldr.w	ip, [r4, #40]	@ 0x28
 80421fc:	7823      	ldrb	r3, [r4, #0]
 80421fe:	2900      	cmp	r1, #0
 8042200:	d1d2      	bne.n	80421a8 <kann_rnn_start+0x18>
 8042202:	b1bb      	cbz	r3, 8042234 <kann_rnn_start+0xa4>
 8042204:	2b01      	cmp	r3, #1
 8042206:	6922      	ldr	r2, [r4, #16]
 8042208:	d00b      	beq.n	8042222 <kann_rnn_start+0x92>
 804220a:	6961      	ldr	r1, [r4, #20]
 804220c:	2b02      	cmp	r3, #2
 804220e:	fb01 f202 	mul.w	r2, r1, r2
 8042212:	d006      	beq.n	8042222 <kann_rnn_start+0x92>
 8042214:	69a1      	ldr	r1, [r4, #24]
 8042216:	2b03      	cmp	r3, #3
 8042218:	fb01 f202 	mul.w	r2, r1, r2
 804221c:	bf1c      	itt	ne
 804221e:	69e3      	ldrne	r3, [r4, #28]
 8042220:	435a      	mulne	r2, r3
			else memset(p->x, 0, kad_len(p) * sizeof(float));
 8042222:	0092      	lsls	r2, r2, #2
 8042224:	2100      	movs	r1, #0
 8042226:	4660      	mov	r0, ip
 8042228:	f009 fdc8 	bl	804bdbc <memset>
 804222c:	e7d1      	b.n	80421d2 <kann_rnn_start+0x42>
}
 804222e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8042230:	2204      	movs	r2, #4
 8042232:	e7cb      	b.n	80421cc <kann_rnn_start+0x3c>
 8042234:	2204      	movs	r2, #4
 8042236:	e7f5      	b.n	8042224 <kann_rnn_start+0x94>

08042238 <kann_rnn_end>:
{
 8042238:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	kad_ext_sync(a->n, a->v, a->x, a->g, a->c);
 804223c:	e9d0 6500 	ldrd	r6, r5, [r0]
 8042240:	e9d0 8c02 	ldrd	r8, ip, [r0, #8]
	for (i = j = k = 0; i < n; ++i) {
 8042244:	2e00      	cmp	r6, #0
	kad_ext_sync(a->n, a->v, a->x, a->g, a->c);
 8042246:	f8d0 e010 	ldr.w	lr, [r0, #16]
	for (i = j = k = 0; i < n; ++i) {
 804224a:	dd6d      	ble.n	8042328 <kann_rnn_end+0xf0>
 804224c:	2400      	movs	r4, #0
 804224e:	3d04      	subs	r5, #4
 8042250:	462a      	mov	r2, r5
 8042252:	4620      	mov	r0, r4
 8042254:	eb05 0686 	add.w	r6, r5, r6, lsl #2
 8042258:	e003      	b.n	8042262 <kann_rnn_end+0x2a>
		} else if (kad_is_const(v)) {
 804225a:	0789      	lsls	r1, r1, #30
 804225c:	d466      	bmi.n	804232c <kann_rnn_end+0xf4>
	for (i = j = k = 0; i < n; ++i) {
 804225e:	4296      	cmp	r6, r2
 8042260:	d028      	beq.n	80422b4 <kann_rnn_end+0x7c>
		kad_node_t *v = a[i];
 8042262:	f852 3f04 	ldr.w	r3, [r2, #4]!
		if (kad_is_var(v)) {
 8042266:	6859      	ldr	r1, [r3, #4]
 8042268:	2900      	cmp	r1, #0
 804226a:	d1f8      	bne.n	804225e <kann_rnn_end+0x26>
 804226c:	7859      	ldrb	r1, [r3, #1]
 804226e:	07cf      	lsls	r7, r1, #31
 8042270:	d5f3      	bpl.n	804225a <kann_rnn_end+0x22>
			v->x = &x[j];
 8042272:	eb08 0180 	add.w	r1, r8, r0, lsl #2
 8042276:	f893 9000 	ldrb.w	r9, [r3]
 804227a:	6299      	str	r1, [r3, #40]	@ 0x28
			v->g = &g[j];
 804227c:	eb0c 0180 	add.w	r1, ip, r0, lsl #2
 8042280:	62d9      	str	r1, [r3, #44]	@ 0x2c
 8042282:	f1b9 0f00 	cmp.w	r9, #0
 8042286:	d07b      	beq.n	8042380 <kann_rnn_end+0x148>
 8042288:	f1b9 0f01 	cmp.w	r9, #1
 804228c:	6919      	ldr	r1, [r3, #16]
 804228e:	d00e      	beq.n	80422ae <kann_rnn_end+0x76>
 8042290:	695f      	ldr	r7, [r3, #20]
 8042292:	f1b9 0f02 	cmp.w	r9, #2
 8042296:	fb07 f101 	mul.w	r1, r7, r1
 804229a:	d008      	beq.n	80422ae <kann_rnn_end+0x76>
 804229c:	699f      	ldr	r7, [r3, #24]
 804229e:	f1b9 0f03 	cmp.w	r9, #3
 80422a2:	fb07 f101 	mul.w	r1, r7, r1
 80422a6:	d002      	beq.n	80422ae <kann_rnn_end+0x76>
 80422a8:	69db      	ldr	r3, [r3, #28]
 80422aa:	fb03 f101 	mul.w	r1, r3, r1
			j += kad_len(v);
 80422ae:	4408      	add	r0, r1
	for (i = j = k = 0; i < n; ++i) {
 80422b0:	4296      	cmp	r6, r2
 80422b2:	d1d6      	bne.n	8042262 <kann_rnn_end+0x2a>
			heapSize += kad_len(a->v[i]->pre) * sizeof(float);
 80422b4:	f8df 90dc 	ldr.w	r9, [pc, #220]	@ 8042394 <kann_rnn_end+0x15c>
 80422b8:	e001      	b.n	80422be <kann_rnn_end+0x86>
	for (i = 0; i < a->n; ++i)
 80422ba:	42b5      	cmp	r5, r6
 80422bc:	d034      	beq.n	8042328 <kann_rnn_end+0xf0>
		if (a->v[i]->pre && a->v[i]->pre->n_child > 0) {
 80422be:	f855 3f04 	ldr.w	r3, [r5, #4]!
 80422c2:	6bdc      	ldr	r4, [r3, #60]	@ 0x3c
 80422c4:	2c00      	cmp	r4, #0
 80422c6:	d0f8      	beq.n	80422ba <kann_rnn_end+0x82>
 80422c8:	6863      	ldr	r3, [r4, #4]
 80422ca:	2b00      	cmp	r3, #0
 80422cc:	ddf5      	ble.n	80422ba <kann_rnn_end+0x82>
 80422ce:	f894 8000 	ldrb.w	r8, [r4]
 80422d2:	f1b8 0f00 	cmp.w	r8, #0
 80422d6:	d04c      	beq.n	8042372 <kann_rnn_end+0x13a>
 80422d8:	f1b8 0f01 	cmp.w	r8, #1
 80422dc:	6927      	ldr	r7, [r4, #16]
 80422de:	d042      	beq.n	8042366 <kann_rnn_end+0x12e>
 80422e0:	6963      	ldr	r3, [r4, #20]
 80422e2:	f1b8 0f02 	cmp.w	r8, #2
 80422e6:	fb03 f707 	mul.w	r7, r3, r7
 80422ea:	d03c      	beq.n	8042366 <kann_rnn_end+0x12e>
 80422ec:	69a0      	ldr	r0, [r4, #24]
 80422ee:	f1b8 0f03 	cmp.w	r8, #3
 80422f2:	fb07 f000 	mul.w	r0, r7, r0
 80422f6:	d046      	beq.n	8042386 <kann_rnn_end+0x14e>
 80422f8:	69e3      	ldr	r3, [r4, #28]
			a->v[i]->pre->x = (float*)calloc(kad_len(a->v[i]->pre), sizeof(float));
 80422fa:	2104      	movs	r1, #4
 80422fc:	fb03 f000 	mul.w	r0, r3, r0
 8042300:	f009 fa52 	bl	804b7a8 <calloc>
 8042304:	69a3      	ldr	r3, [r4, #24]
 8042306:	f1b8 0f03 	cmp.w	r8, #3
 804230a:	fb03 f707 	mul.w	r7, r3, r7
 804230e:	bf18      	it	ne
 8042310:	69e3      	ldrne	r3, [r4, #28]
 8042312:	62a0      	str	r0, [r4, #40]	@ 0x28
 8042314:	bf18      	it	ne
 8042316:	435f      	mulne	r7, r3
			heapSize += kad_len(a->v[i]->pre) * sizeof(float);
 8042318:	00bf      	lsls	r7, r7, #2
 804231a:	f8d9 3000 	ldr.w	r3, [r9]
	for (i = 0; i < a->n; ++i)
 804231e:	42b5      	cmp	r5, r6
			heapSize += kad_len(a->v[i]->pre) * sizeof(float);
 8042320:	443b      	add	r3, r7
 8042322:	f8c9 3000 	str.w	r3, [r9]
	for (i = 0; i < a->n; ++i)
 8042326:	d1ca      	bne.n	80422be <kann_rnn_end+0x86>
}
 8042328:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 804232c:	f893 9000 	ldrb.w	r9, [r3]
			v->x = &c[k];
 8042330:	eb0e 0184 	add.w	r1, lr, r4, lsl #2
 8042334:	6299      	str	r1, [r3, #40]	@ 0x28
 8042336:	f1b9 0f00 	cmp.w	r9, #0
 804233a:	d028      	beq.n	804238e <kann_rnn_end+0x156>
 804233c:	f1b9 0f01 	cmp.w	r9, #1
 8042340:	6919      	ldr	r1, [r3, #16]
 8042342:	d00e      	beq.n	8042362 <kann_rnn_end+0x12a>
 8042344:	695f      	ldr	r7, [r3, #20]
 8042346:	f1b9 0f02 	cmp.w	r9, #2
 804234a:	fb07 f101 	mul.w	r1, r7, r1
 804234e:	d008      	beq.n	8042362 <kann_rnn_end+0x12a>
 8042350:	699f      	ldr	r7, [r3, #24]
 8042352:	f1b9 0f03 	cmp.w	r9, #3
 8042356:	fb07 f101 	mul.w	r1, r7, r1
 804235a:	d002      	beq.n	8042362 <kann_rnn_end+0x12a>
 804235c:	69db      	ldr	r3, [r3, #28]
 804235e:	fb03 f101 	mul.w	r1, r3, r1
			k += kad_len(v);
 8042362:	440c      	add	r4, r1
 8042364:	e77b      	b.n	804225e <kann_rnn_end+0x26>
			a->v[i]->pre->x = (float*)calloc(kad_len(a->v[i]->pre), sizeof(float));
 8042366:	2104      	movs	r1, #4
 8042368:	4638      	mov	r0, r7
 804236a:	f009 fa1d 	bl	804b7a8 <calloc>
 804236e:	62a0      	str	r0, [r4, #40]	@ 0x28
 8042370:	e7d2      	b.n	8042318 <kann_rnn_end+0xe0>
 8042372:	2104      	movs	r1, #4
 8042374:	2001      	movs	r0, #1
 8042376:	f009 fa17 	bl	804b7a8 <calloc>
 804237a:	2704      	movs	r7, #4
 804237c:	62a0      	str	r0, [r4, #40]	@ 0x28
 804237e:	e7cc      	b.n	804231a <kann_rnn_end+0xe2>
	int n = 1, i;
 8042380:	2101      	movs	r1, #1
			j += kad_len(v);
 8042382:	4408      	add	r0, r1
 8042384:	e794      	b.n	80422b0 <kann_rnn_end+0x78>
			a->v[i]->pre->x = (float*)calloc(kad_len(a->v[i]->pre), sizeof(float));
 8042386:	2104      	movs	r1, #4
 8042388:	f009 fa0e 	bl	804b7a8 <calloc>
	for (i = 0; i < p->n_d; ++i) n *= p->d[i];
 804238c:	e7ba      	b.n	8042304 <kann_rnn_end+0xcc>
	int n = 1, i;
 804238e:	2101      	movs	r1, #1
			k += kad_len(v);
 8042390:	440c      	add	r4, r1
 8042392:	e764      	b.n	804225e <kann_rnn_end+0x26>
 8042394:	20018344 	.word	0x20018344

08042398 <kann_cost>:
float kann_cost(kann_t *a, int cost_label, int cal_grad) {
 8042398:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 804239c:	4605      	mov	r5, r0
	for (i = k = 0; i < a->n; ++i)
 804239e:	6800      	ldr	r0, [r0, #0]
float kann_cost(kann_t *a, int cost_label, int cal_grad) {
 80423a0:	ed2d 8b02 	vpush	{d8}
	for (i = k = 0; i < a->n; ++i)
 80423a4:	2800      	cmp	r0, #0
 80423a6:	dd1c      	ble.n	80423e2 <kann_cost+0x4a>
 80423a8:	460b      	mov	r3, r1
 80423aa:	4616      	mov	r6, r2
		if (chk_flg(a->v[i]->ext_flag, ext_flag) && chk_lbl(a->v[i]->ext_label, ext_label))
 80423ac:	6869      	ldr	r1, [r5, #4]
 80423ae:	b1f3      	cbz	r3, 80423ee <kann_cost+0x56>
	for (i = k = 0; i < a->n; ++i)
 80423b0:	f04f 0800 	mov.w	r8, #0
	int i, k, r = -1;
 80423b4:	f04f 37ff 	mov.w	r7, #4294967295
	for (i = k = 0; i < a->n; ++i)
 80423b8:	46c4      	mov	ip, r8
 80423ba:	f1a1 0e04 	sub.w	lr, r1, #4
		if (chk_flg(a->v[i]->ext_flag, ext_flag) && chk_lbl(a->v[i]->ext_label, ext_label))
 80423be:	f85e 4f04 	ldr.w	r4, [lr, #4]!
 80423c2:	6a62      	ldr	r2, [r4, #36]	@ 0x24
 80423c4:	0712      	lsls	r2, r2, #28
 80423c6:	d505      	bpl.n	80423d4 <kann_cost+0x3c>
 80423c8:	6a22      	ldr	r2, [r4, #32]
 80423ca:	4293      	cmp	r3, r2
			++k, r = i;
 80423cc:	bf04      	itt	eq
 80423ce:	4667      	moveq	r7, ip
 80423d0:	f108 0801 	addeq.w	r8, r8, #1
	for (i = k = 0; i < a->n; ++i)
 80423d4:	f10c 0c01 	add.w	ip, ip, #1
 80423d8:	4560      	cmp	r0, ip
 80423da:	d1f0      	bne.n	80423be <kann_cost+0x26>
	return k == 1? r : k == 0? -1 : -2;
 80423dc:	f1b8 0f01 	cmp.w	r8, #1
 80423e0:	d019      	beq.n	8042416 <kann_cost+0x7e>
	assert(i_cost >= 0);
 80423e2:	21be      	movs	r1, #190	@ 0xbe
 80423e4:	4b18      	ldr	r3, [pc, #96]	@ (8042448 <kann_cost+0xb0>)
 80423e6:	4a19      	ldr	r2, [pc, #100]	@ (804244c <kann_cost+0xb4>)
 80423e8:	4819      	ldr	r0, [pc, #100]	@ (8042450 <kann_cost+0xb8>)
 80423ea:	f009 f9bf 	bl	804b76c <__assert_func>
	for (i = k = 0; i < a->n; ++i)
 80423ee:	4698      	mov	r8, r3
	int i, k, r = -1;
 80423f0:	f04f 37ff 	mov.w	r7, #4294967295
 80423f4:	1f0c      	subs	r4, r1, #4
		if (chk_flg(a->v[i]->ext_flag, ext_flag) && chk_lbl(a->v[i]->ext_label, ext_label))
 80423f6:	f854 2f04 	ldr.w	r2, [r4, #4]!
 80423fa:	6a52      	ldr	r2, [r2, #36]	@ 0x24
 80423fc:	0712      	lsls	r2, r2, #28
			++k, r = i;
 80423fe:	bf48      	it	mi
 8042400:	461f      	movmi	r7, r3
	for (i = k = 0; i < a->n; ++i)
 8042402:	f103 0301 	add.w	r3, r3, #1
			++k, r = i;
 8042406:	bf48      	it	mi
 8042408:	f108 0801 	addmi.w	r8, r8, #1
	for (i = k = 0; i < a->n; ++i)
 804240c:	4298      	cmp	r0, r3
 804240e:	d1f2      	bne.n	80423f6 <kann_cost+0x5e>
	return k == 1? r : k == 0? -1 : -2;
 8042410:	f1b8 0f01 	cmp.w	r8, #1
 8042414:	d1e5      	bne.n	80423e2 <kann_cost+0x4a>
	assert(i_cost >= 0);
 8042416:	2f00      	cmp	r7, #0
 8042418:	dbe3      	blt.n	80423e2 <kann_cost+0x4a>
	cost = *kad_eval_at(a->n, a->v, i_cost);
 804241a:	463a      	mov	r2, r7
 804241c:	f008 f8a2 	bl	804a564 <kad_eval_at>
 8042420:	ed90 8a00 	vldr	s16, [r0]
	if (cal_grad) kad_grad(a->n, a->v, i_cost);
 8042424:	b92e      	cbnz	r6, 8042432 <kann_cost+0x9a>
}
 8042426:	eeb0 0a48 	vmov.f32	s0, s16
 804242a:	ecbd 8b02 	vpop	{d8}
 804242e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (cal_grad) kad_grad(a->n, a->v, i_cost);
 8042432:	463a      	mov	r2, r7
 8042434:	e9d5 0100 	ldrd	r0, r1, [r5]
 8042438:	f008 f8e2 	bl	804a600 <kad_grad>
}
 804243c:	eeb0 0a48 	vmov.f32	s0, s16
 8042440:	ecbd 8b02 	vpop	{d8}
 8042444:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8042448:	0804e2ec 	.word	0x0804e2ec
 804244c:	0804e310 	.word	0x0804e310
 8042450:	0804e2f8 	.word	0x0804e2f8

08042454 <kann_new_leaf_array>:
{
 8042454:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8042458:	ed2d 8b02 	vpush	{d8}
	int i, len, off = offset && par? *offset : -1;
 804245c:	4607      	mov	r7, r0
{
 804245e:	468a      	mov	sl, r1
 8042460:	4616      	mov	r6, r2
 8042462:	eeb0 8a40 	vmov.f32	s16, s0
 8042466:	4699      	mov	r9, r3
 8042468:	b083      	sub	sp, #12
	int i, len, off = offset && par? *offset : -1;
 804246a:	b188      	cbz	r0, 8042490 <kann_new_leaf_array+0x3c>
 804246c:	b181      	cbz	r1, 8042490 <kann_new_leaf_array+0x3c>
 804246e:	f8d0 b000 	ldr.w	fp, [r0]
	if (off >= 0 && par[off]) return par[(*offset)++];
 8042472:	f1bb 0f00 	cmp.w	fp, #0
 8042476:	db0d      	blt.n	8042494 <kann_new_leaf_array+0x40>
 8042478:	f851 402b 	ldr.w	r4, [r1, fp, lsl #2]
 804247c:	b154      	cbz	r4, 8042494 <kann_new_leaf_array+0x40>
 804247e:	f10b 0301 	add.w	r3, fp, #1
 8042482:	6003      	str	r3, [r0, #0]
}
 8042484:	4620      	mov	r0, r4
 8042486:	b003      	add	sp, #12
 8042488:	ecbd 8b02 	vpop	{d8}
 804248c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	int i, len, off = offset && par? *offset : -1;
 8042490:	f04f 3bff 	mov.w	fp, #4294967295
	p = (kad_node_t*)calloc(1, sizeof(kad_node_t));
 8042494:	2140      	movs	r1, #64	@ 0x40
 8042496:	2001      	movs	r0, #1
 8042498:	f009 f986 	bl	804b7a8 <calloc>
	heapSize += 1 * sizeof(kad_node_t);
 804249c:	4d43      	ldr	r5, [pc, #268]	@ (80425ac <kann_new_leaf_array+0x158>)
	p->n_d = n_d, p->flag = flag;
 804249e:	fa5f f889 	uxtb.w	r8, r9
	heapSize += 1 * sizeof(kad_node_t);
 80424a2:	682b      	ldr	r3, [r5, #0]
	p = (kad_node_t*)calloc(1, sizeof(kad_node_t));
 80424a4:	4604      	mov	r4, r0
	heapSize += 1 * sizeof(kad_node_t);
 80424a6:	3340      	adds	r3, #64	@ 0x40
	p->n_d = n_d, p->flag = flag;
 80424a8:	7046      	strb	r6, [r0, #1]
 80424aa:	f880 8000 	strb.w	r8, [r0]
	memcpy(p->d, d, n_d * sizeof(int32_t));
 80424ae:	990e      	ldr	r1, [sp, #56]	@ 0x38
 80424b0:	ea4f 0289 	mov.w	r2, r9, lsl #2
 80424b4:	3010      	adds	r0, #16
	heapSize += 1 * sizeof(kad_node_t);
 80424b6:	602b      	str	r3, [r5, #0]
	memcpy(p->d, d, n_d * sizeof(int32_t));
 80424b8:	f009 fd7d 	bl	804bfb6 <memcpy>
	for (i = 0; i < p->n_d; ++i) n *= p->d[i];
 80424bc:	f1b8 0f00 	cmp.w	r8, #0
 80424c0:	d069      	beq.n	8042596 <kann_new_leaf_array+0x142>
 80424c2:	f019 0ffe 	tst.w	r9, #254	@ 0xfe
 80424c6:	6926      	ldr	r6, [r4, #16]
 80424c8:	d00d      	beq.n	80424e6 <kann_new_leaf_array+0x92>
 80424ca:	6963      	ldr	r3, [r4, #20]
 80424cc:	f1b8 0f02 	cmp.w	r8, #2
 80424d0:	fb03 f606 	mul.w	r6, r3, r6
 80424d4:	dd07      	ble.n	80424e6 <kann_new_leaf_array+0x92>
 80424d6:	69a3      	ldr	r3, [r4, #24]
 80424d8:	f019 0ffc 	tst.w	r9, #252	@ 0xfc
 80424dc:	fb03 f606 	mul.w	r6, r3, r6
 80424e0:	bf1c      	itt	ne
 80424e2:	69e3      	ldrne	r3, [r4, #28]
 80424e4:	435e      	mulne	r6, r3
	p->x = (float*)calloc(len, sizeof(float));
 80424e6:	2104      	movs	r1, #4
 80424e8:	4630      	mov	r0, r6
 80424ea:	f009 f95d 	bl	804b7a8 <calloc>
	heapSize += len*sizeof(float);
 80424ee:	682b      	ldr	r3, [r5, #0]
	if (p->n_d <= 1) {
 80424f0:	f1b8 0f01 	cmp.w	r8, #1
	heapSize += len*sizeof(float);
 80424f4:	eb03 0386 	add.w	r3, r3, r6, lsl #2
 80424f8:	602b      	str	r3, [r5, #0]
	p->x = (float*)calloc(len, sizeof(float));
 80424fa:	62a0      	str	r0, [r4, #40]	@ 0x28
	heapSize += len*sizeof(float);
 80424fc:	ea4f 0386 	mov.w	r3, r6, lsl #2
	if (p->n_d <= 1) {
 8042500:	d814      	bhi.n	804252c <kann_new_leaf_array+0xd8>
		for (i = 0; i < len; ++i)
 8042502:	2e00      	cmp	r6, #0
 8042504:	dd04      	ble.n	8042510 <kann_new_leaf_array+0xbc>
 8042506:	4403      	add	r3, r0
			p->x[i] = x0_01;
 8042508:	eca0 8a01 	vstmia	r0!, {s16}
		for (i = 0; i < len; ++i)
 804250c:	4283      	cmp	r3, r0
 804250e:	d1fb      	bne.n	8042508 <kann_new_leaf_array+0xb4>
	if (off >= 0) par[off] = p, ++(*offset);
 8042510:	f1bb 0f00 	cmp.w	fp, #0
 8042514:	db04      	blt.n	8042520 <kann_new_leaf_array+0xcc>
 8042516:	683b      	ldr	r3, [r7, #0]
 8042518:	f84a 402b 	str.w	r4, [sl, fp, lsl #2]
 804251c:	3301      	adds	r3, #1
 804251e:	603b      	str	r3, [r7, #0]
}
 8042520:	4620      	mov	r0, r4
 8042522:	b003      	add	sp, #12
 8042524:	ecbd 8b02 	vpop	{d8}
 8042528:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		sdev_inv = 1.0 / sqrt((double)len / p->d[0]);
 804252c:	4630      	mov	r0, r6
 804252e:	f7fd ffd5 	bl	80404dc <__aeabi_i2d>
 8042532:	4680      	mov	r8, r0
 8042534:	6920      	ldr	r0, [r4, #16]
 8042536:	4689      	mov	r9, r1
 8042538:	f7fd ffd0 	bl	80404dc <__aeabi_i2d>
 804253c:	4602      	mov	r2, r0
 804253e:	460b      	mov	r3, r1
 8042540:	4640      	mov	r0, r8
 8042542:	4649      	mov	r1, r9
 8042544:	f7fe f95e 	bl	8040804 <__aeabi_ddiv>
 8042548:	ec41 0b10 	vmov	d0, r0, r1
 804254c:	f00a fb62 	bl	804cc14 <sqrt>
 8042550:	2000      	movs	r0, #0
 8042552:	ec53 2b10 	vmov	r2, r3, d0
 8042556:	4916      	ldr	r1, [pc, #88]	@ (80425b0 <kann_new_leaf_array+0x15c>)
 8042558:	f7fe f954 	bl	8040804 <__aeabi_ddiv>
		for (i = 0; i < len; ++i)
 804255c:	2e00      	cmp	r6, #0
 804255e:	ddd7      	ble.n	8042510 <kann_new_leaf_array+0xbc>
 8042560:	f8cd a004 	str.w	sl, [sp, #4]
 8042564:	2500      	movs	r5, #0
 8042566:	4681      	mov	r9, r0
 8042568:	468a      	mov	sl, r1
			p->x[i] = (float)(kad_drand_normal(0) * sdev_inv);
 804256a:	2000      	movs	r0, #0
 804256c:	f008 fd8a 	bl	804b084 <kad_drand_normal>
 8042570:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
 8042572:	ec51 0b10 	vmov	r0, r1, d0
 8042576:	eb03 0885 	add.w	r8, r3, r5, lsl #2
 804257a:	464a      	mov	r2, r9
 804257c:	4653      	mov	r3, sl
 804257e:	f7fe f817 	bl	80405b0 <__aeabi_dmul>
 8042582:	f7fe faed 	bl	8040b60 <__aeabi_d2f>
		for (i = 0; i < len; ++i)
 8042586:	3501      	adds	r5, #1
 8042588:	42b5      	cmp	r5, r6
			p->x[i] = (float)(kad_drand_normal(0) * sdev_inv);
 804258a:	f8c8 0000 	str.w	r0, [r8]
		for (i = 0; i < len; ++i)
 804258e:	d1ec      	bne.n	804256a <kann_new_leaf_array+0x116>
 8042590:	f8dd a004 	ldr.w	sl, [sp, #4]
 8042594:	e7bc      	b.n	8042510 <kann_new_leaf_array+0xbc>
	p->x = (float*)calloc(len, sizeof(float));
 8042596:	2104      	movs	r1, #4
 8042598:	2001      	movs	r0, #1
 804259a:	f009 f905 	bl	804b7a8 <calloc>
	heapSize += len*sizeof(float);
 804259e:	682b      	ldr	r3, [r5, #0]
	p->x = (float*)calloc(len, sizeof(float));
 80425a0:	62a0      	str	r0, [r4, #40]	@ 0x28
	heapSize += len*sizeof(float);
 80425a2:	3304      	adds	r3, #4
 80425a4:	602b      	str	r3, [r5, #0]
 80425a6:	2304      	movs	r3, #4
 80425a8:	e7ad      	b.n	8042506 <kann_new_leaf_array+0xb2>
 80425aa:	bf00      	nop
 80425ac:	20018344 	.word	0x20018344
 80425b0:	3ff00000 	.word	0x3ff00000

080425b4 <kann_new_leaf.constprop.0>:
kad_node_t *kann_new_leaf(uint8_t flag, float x0_01, int n_d, ...)
 80425b4:	b40c      	push	{r2, r3}
 80425b6:	b530      	push	{r4, r5, lr}
 80425b8:	ed2d 8b02 	vpush	{d8}
 80425bc:	b089      	sub	sp, #36	@ 0x24
 80425be:	aa0e      	add	r2, sp, #56	@ 0x38
 80425c0:	f852 4b04 	ldr.w	r4, [r2], #4
 80425c4:	ee08 1a10 	vmov	s16, r1
	va_start(ap, n_d); for (i = 0; i < n_d; ++i) d[i] = va_arg(ap, int); va_end(ap);
 80425c8:	2c00      	cmp	r4, #0
 80425ca:	9203      	str	r2, [sp, #12]
 80425cc:	ad04      	add	r5, sp, #16
 80425ce:	dd04      	ble.n	80425da <kann_new_leaf.constprop.0+0x26>
 80425d0:	4611      	mov	r1, r2
 80425d2:	4628      	mov	r0, r5
 80425d4:	00a2      	lsls	r2, r4, #2
 80425d6:	f009 fcee 	bl	804bfb6 <memcpy>
	return kann_new_leaf_array(0, 0, flag, x0_01, n_d, d);
 80425da:	2100      	movs	r1, #0
 80425dc:	4623      	mov	r3, r4
 80425de:	eeb0 0a48 	vmov.f32	s0, s16
 80425e2:	2201      	movs	r2, #1
 80425e4:	4608      	mov	r0, r1
 80425e6:	9500      	str	r5, [sp, #0]
 80425e8:	f7ff ff34 	bl	8042454 <kann_new_leaf_array>
}
 80425ec:	b009      	add	sp, #36	@ 0x24
 80425ee:	ecbd 8b02 	vpop	{d8}
 80425f2:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
 80425f6:	b002      	add	sp, #8
 80425f8:	4770      	bx	lr
 80425fa:	bf00      	nop

080425fc <kann_new_leaf2.constprop.0>:
kad_node_t *kann_new_leaf2(int *offset, kad_node_p *par, uint8_t flag, float x0_01, int n_d, ...)
 80425fc:	b5f0      	push	{r4, r5, r6, r7, lr}
 80425fe:	ed2d 8b02 	vpush	{d8}
 8042602:	b089      	sub	sp, #36	@ 0x24
 8042604:	aa10      	add	r2, sp, #64	@ 0x40
 8042606:	f852 6b04 	ldr.w	r6, [r2], #4
 804260a:	4604      	mov	r4, r0
	va_start(ap, n_d); for (i = 0; i < n_d; ++i) d[i] = va_arg(ap, int); va_end(ap);
 804260c:	2e00      	cmp	r6, #0
kad_node_t *kann_new_leaf2(int *offset, kad_node_p *par, uint8_t flag, float x0_01, int n_d, ...)
 804260e:	460d      	mov	r5, r1
 8042610:	ee08 3a10 	vmov	s16, r3
	va_start(ap, n_d); for (i = 0; i < n_d; ++i) d[i] = va_arg(ap, int); va_end(ap);
 8042614:	9203      	str	r2, [sp, #12]
 8042616:	af04      	add	r7, sp, #16
 8042618:	dd04      	ble.n	8042624 <kann_new_leaf2.constprop.0+0x28>
 804261a:	4611      	mov	r1, r2
 804261c:	4638      	mov	r0, r7
 804261e:	00b2      	lsls	r2, r6, #2
 8042620:	f009 fcc9 	bl	804bfb6 <memcpy>
	return kann_new_leaf_array(offset, par, flag, x0_01, n_d, d);
 8042624:	4633      	mov	r3, r6
 8042626:	eeb0 0a48 	vmov.f32	s0, s16
 804262a:	2201      	movs	r2, #1
 804262c:	4629      	mov	r1, r5
 804262e:	4620      	mov	r0, r4
 8042630:	9700      	str	r7, [sp, #0]
 8042632:	f7ff ff0f 	bl	8042454 <kann_new_leaf_array>
}
 8042636:	b009      	add	sp, #36	@ 0x24
 8042638:	ecbd 8b02 	vpop	{d8}
 804263c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 804263e:	bf00      	nop

08042640 <kann_layer_layernorm2>:
{
 8042640:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	n0 = in->n_d >= 2? kad_len(in) / in->d[0] : kad_len(in);
 8042644:	7813      	ldrb	r3, [r2, #0]
{
 8042646:	4614      	mov	r4, r2
	n0 = in->n_d >= 2? kad_len(in) / in->d[0] : kad_len(in);
 8042648:	2b01      	cmp	r3, #1
{
 804264a:	4607      	mov	r7, r0
 804264c:	4688      	mov	r8, r1
 804264e:	b082      	sub	sp, #8
	n0 = in->n_d >= 2? kad_len(in) / in->d[0] : kad_len(in);
 8042650:	d930      	bls.n	80426b4 <kann_layer_layernorm2+0x74>
 8042652:	e9d2 2504 	ldrd	r2, r5, [r2, #16]
 8042656:	2b02      	cmp	r3, #2
 8042658:	fb02 f505 	mul.w	r5, r2, r5
 804265c:	d006      	beq.n	804266c <kann_layer_layernorm2+0x2c>
 804265e:	69a1      	ldr	r1, [r4, #24]
 8042660:	2b03      	cmp	r3, #3
 8042662:	fb01 f505 	mul.w	r5, r1, r5
 8042666:	bf1c      	itt	ne
 8042668:	69e3      	ldrne	r3, [r4, #28]
 804266a:	435d      	mulne	r5, r3
 804266c:	fb95 f5f2 	sdiv	r5, r5, r2
	alpha = kann_new_leaf2(offset, par, KAD_VAR, 1.0f, 1, n0);
 8042670:	2601      	movs	r6, #1
 8042672:	4641      	mov	r1, r8
 8042674:	4632      	mov	r2, r6
 8042676:	9501      	str	r5, [sp, #4]
 8042678:	f04f 537e 	mov.w	r3, #1065353216	@ 0x3f800000
 804267c:	4638      	mov	r0, r7
 804267e:	9600      	str	r6, [sp, #0]
 8042680:	f7ff ffbc 	bl	80425fc <kann_new_leaf2.constprop.0>
 8042684:	4684      	mov	ip, r0
	beta  = kann_new_leaf2(offset, par, KAD_VAR, 0.0f, 1, n0);
 8042686:	4641      	mov	r1, r8
 8042688:	4632      	mov	r2, r6
 804268a:	9501      	str	r5, [sp, #4]
 804268c:	4638      	mov	r0, r7
 804268e:	2300      	movs	r3, #0
 8042690:	9600      	str	r6, [sp, #0]
	alpha = kann_new_leaf2(offset, par, KAD_VAR, 1.0f, 1, n0);
 8042692:	4665      	mov	r5, ip
	beta  = kann_new_leaf2(offset, par, KAD_VAR, 0.0f, 1, n0);
 8042694:	f7ff ffb2 	bl	80425fc <kann_new_leaf2.constprop.0>
 8042698:	4603      	mov	r3, r0
	return kad_add(kad_mul(kad_stdnorm(in), alpha), beta);
 804269a:	4620      	mov	r0, r4
	beta  = kann_new_leaf2(offset, par, KAD_VAR, 0.0f, 1, n0);
 804269c:	461c      	mov	r4, r3
	return kad_add(kad_mul(kad_stdnorm(in), alpha), beta);
 804269e:	f007 fca5 	bl	8049fec <kad_stdnorm>
 80426a2:	4629      	mov	r1, r5
 80426a4:	f007 fad2 	bl	8049c4c <kad_mul>
 80426a8:	4621      	mov	r1, r4
}
 80426aa:	b002      	add	sp, #8
 80426ac:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	return kad_add(kad_mul(kad_stdnorm(in), alpha), beta);
 80426b0:	f007 ba7a 	b.w	8049ba8 <kad_add>
 80426b4:	b10b      	cbz	r3, 80426ba <kann_layer_layernorm2+0x7a>
 80426b6:	6925      	ldr	r5, [r4, #16]
 80426b8:	e7da      	b.n	8042670 <kann_layer_layernorm2+0x30>
	int n = 1, i;
 80426ba:	2501      	movs	r5, #1
 80426bc:	e7d8      	b.n	8042670 <kann_layer_layernorm2+0x30>
 80426be:	bf00      	nop

080426c0 <kann_cmul_norm>:
	heapSize += n1*sizeof(float);
	return kann_layer_gru2(0, 0, in, h0, rnn_flag);
}

static kad_node_t *kann_cmul_norm(kad_node_t *x, kad_node_t *w)
{
 80426c0:	b508      	push	{r3, lr}
	return kann_layer_layernorm(kad_cmul(x, w));
 80426c2:	f007 fb11 	bl	8049ce8 <kad_cmul>
}
 80426c6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
kad_node_t *kann_layer_layernorm(kad_node_t *in) { return kann_layer_layernorm2(0, 0, in); }
 80426ca:	2100      	movs	r1, #0
	return kann_layer_layernorm(kad_cmul(x, w));
 80426cc:	4602      	mov	r2, r0
kad_node_t *kann_layer_layernorm(kad_node_t *in) { return kann_layer_layernorm2(0, 0, in); }
 80426ce:	4608      	mov	r0, r1
 80426d0:	f7ff bfb6 	b.w	8042640 <kann_layer_layernorm2>

080426d4 <kann_new_scalar>:
kad_node_t *kann_new_scalar(uint8_t flag, float x) { return kann_new_leaf(flag, x, 0); }
 80426d4:	ee10 1a10 	vmov	r1, s0
 80426d8:	2200      	movs	r2, #0
 80426da:	f7ff bb67 	b.w	8041dac <kann_new_leaf.constprop.1>
 80426de:	bf00      	nop

080426e0 <kann_layer_input>:
{
 80426e0:	4602      	mov	r2, r0
	t = kad_feed(2, 1, n1), t->ext_flag |= KANN_F_IN;
 80426e2:	2101      	movs	r1, #1
{
 80426e4:	b508      	push	{r3, lr}
	t = kad_feed(2, 1, n1), t->ext_flag |= KANN_F_IN;
 80426e6:	2002      	movs	r0, #2
 80426e8:	f007 fa06 	bl	8049af8 <kad_feed>
 80426ec:	6a42      	ldr	r2, [r0, #36]	@ 0x24
 80426ee:	f042 0201 	orr.w	r2, r2, #1
 80426f2:	6242      	str	r2, [r0, #36]	@ 0x24
}
 80426f4:	bd08      	pop	{r3, pc}
 80426f6:	bf00      	nop

080426f8 <kann_layer_dense>:
kad_node_t *kann_layer_dense(kad_node_t *in, int n1) { return kann_layer_dense2(0, 0, in, n1); }
 80426f8:	b530      	push	{r4, r5, lr}
	n0 = in->n_d >= 2? kad_len(in) / in->d[0] : kad_len(in);
 80426fa:	7802      	ldrb	r2, [r0, #0]
kad_node_t *kann_layer_dense(kad_node_t *in, int n1) { return kann_layer_dense2(0, 0, in, n1); }
 80426fc:	4604      	mov	r4, r0
	n0 = in->n_d >= 2? kad_len(in) / in->d[0] : kad_len(in);
 80426fe:	2a01      	cmp	r2, #1
kad_node_t *kann_layer_dense(kad_node_t *in, int n1) { return kann_layer_dense2(0, 0, in, n1); }
 8042700:	460d      	mov	r5, r1
 8042702:	b085      	sub	sp, #20
	n0 = in->n_d >= 2? kad_len(in) / in->d[0] : kad_len(in);
 8042704:	d92d      	bls.n	8042762 <kann_layer_dense+0x6a>
	for (i = 0; i < p->n_d; ++i) n *= p->d[i];
 8042706:	e9d0 1304 	ldrd	r1, r3, [r0, #16]
 804270a:	2a02      	cmp	r2, #2
 804270c:	fb01 f303 	mul.w	r3, r1, r3
 8042710:	d006      	beq.n	8042720 <kann_layer_dense+0x28>
 8042712:	6980      	ldr	r0, [r0, #24]
 8042714:	2a03      	cmp	r2, #3
 8042716:	fb00 f303 	mul.w	r3, r0, r3
 804271a:	bf1c      	itt	ne
 804271c:	69e2      	ldrne	r2, [r4, #28]
 804271e:	4353      	mulne	r3, r2
 8042720:	fb93 f3f1 	sdiv	r3, r3, r1
	w = kann_new_leaf2(offset, par, KAD_VAR, 0.0f, 2, n1, n0);
 8042724:	2100      	movs	r1, #0
 8042726:	2002      	movs	r0, #2
 8042728:	9302      	str	r3, [sp, #8]
 804272a:	e9cd 0500 	strd	r0, r5, [sp]
 804272e:	2201      	movs	r2, #1
 8042730:	2300      	movs	r3, #0
 8042732:	4608      	mov	r0, r1
 8042734:	f7ff ff62 	bl	80425fc <kann_new_leaf2.constprop.0>
	b = kann_new_leaf2(offset, par, KAD_VAR, 0.0f, 1, n1);
 8042738:	2201      	movs	r2, #1
 804273a:	2100      	movs	r1, #0
 804273c:	9501      	str	r5, [sp, #4]
 804273e:	9200      	str	r2, [sp, #0]
	w = kann_new_leaf2(offset, par, KAD_VAR, 0.0f, 2, n1, n0);
 8042740:	4605      	mov	r5, r0
	b = kann_new_leaf2(offset, par, KAD_VAR, 0.0f, 1, n1);
 8042742:	2300      	movs	r3, #0
 8042744:	4608      	mov	r0, r1
 8042746:	f7ff ff59 	bl	80425fc <kann_new_leaf2.constprop.0>
 804274a:	4603      	mov	r3, r0
	return kad_add(kad_cmul(in, w), b);
 804274c:	4620      	mov	r0, r4
	b = kann_new_leaf2(offset, par, KAD_VAR, 0.0f, 1, n1);
 804274e:	461c      	mov	r4, r3
	return kad_add(kad_cmul(in, w), b);
 8042750:	4629      	mov	r1, r5
 8042752:	f007 fac9 	bl	8049ce8 <kad_cmul>
 8042756:	4621      	mov	r1, r4
kad_node_t *kann_layer_dense(kad_node_t *in, int n1) { return kann_layer_dense2(0, 0, in, n1); }
 8042758:	b005      	add	sp, #20
 804275a:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
	return kad_add(kad_cmul(in, w), b);
 804275e:	f007 ba23 	b.w	8049ba8 <kad_add>
 8042762:	b10a      	cbz	r2, 8042768 <kann_layer_dense+0x70>
 8042764:	6923      	ldr	r3, [r4, #16]
 8042766:	e7dd      	b.n	8042724 <kann_layer_dense+0x2c>
	int n = 1, i;
 8042768:	2301      	movs	r3, #1
 804276a:	e7db      	b.n	8042724 <kann_layer_dense+0x2c>

0804276c <kann_layer_lstm>:

kad_node_t *kann_layer_lstm(kad_node_t *in, int n1, int rnn_flag)
{
 804276c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	int n0;
	kad_node_t *i, *f, *o, *g, *w, *u, *b, *h0, *c0, *c, *out;
	kad_node_t *(*cmul)(kad_node_t*, kad_node_t*) = (rnn_flag & KANN_RNN_NORM)? kann_cmul_norm : kad_cmul;
 8042770:	4f9d      	ldr	r7, [pc, #628]	@ (80429e8 <kann_layer_lstm+0x27c>)

	n0 = in->n_d >= 2? kad_len(in) / in->d[0] : kad_len(in);
 8042772:	7803      	ldrb	r3, [r0, #0]
{
 8042774:	460c      	mov	r4, r1
	kad_node_t *(*cmul)(kad_node_t*, kad_node_t*) = (rnn_flag & KANN_RNN_NORM)? kann_cmul_norm : kad_cmul;
 8042776:	f012 0102 	ands.w	r1, r2, #2
 804277a:	4e9c      	ldr	r6, [pc, #624]	@ (80429ec <kann_layer_lstm+0x280>)
{
 804277c:	b087      	sub	sp, #28
	kad_node_t *(*cmul)(kad_node_t*, kad_node_t*) = (rnn_flag & KANN_RNN_NORM)? kann_cmul_norm : kad_cmul;
 804277e:	bf08      	it	eq
 8042780:	463e      	moveq	r6, r7
	n0 = in->n_d >= 2? kad_len(in) / in->d[0] : kad_len(in);
 8042782:	2b01      	cmp	r3, #1
{
 8042784:	4605      	mov	r5, r0
	kad_node_t *(*cmul)(kad_node_t*, kad_node_t*) = (rnn_flag & KANN_RNN_NORM)? kann_cmul_norm : kad_cmul;
 8042786:	9103      	str	r1, [sp, #12]
	n0 = in->n_d >= 2? kad_len(in) / in->d[0] : kad_len(in);
 8042788:	f240 8123 	bls.w	80429d2 <kann_layer_lstm+0x266>
	for (i = 0; i < p->n_d; ++i) n *= p->d[i];
 804278c:	e9d0 0704 	ldrd	r0, r7, [r0, #16]
 8042790:	2b02      	cmp	r3, #2
 8042792:	fb00 f707 	mul.w	r7, r0, r7
 8042796:	d006      	beq.n	80427a6 <kann_layer_lstm+0x3a>
 8042798:	69a9      	ldr	r1, [r5, #24]
 804279a:	2b03      	cmp	r3, #3
 804279c:	fb01 f707 	mul.w	r7, r1, r7
 80427a0:	bf1c      	itt	ne
 80427a2:	69eb      	ldrne	r3, [r5, #28]
 80427a4:	435f      	mulne	r7, r3
 80427a6:	fb97 f7f0 	sdiv	r7, r7, r0
	h0 = (rnn_flag & KANN_RNN_VAR_H0)? kad_var(0, 0, 2, 1, n1) : kad_const(0, 2, 1, n1);
 80427aa:	f012 0901 	ands.w	r9, r2, #1
	h0->x = (float*)calloc(n1, sizeof(float));
	heapSize += n1*sizeof(float);
 80427ae:	ea4f 0b84 	mov.w	fp, r4, lsl #2
	h0 = (rnn_flag & KANN_RNN_VAR_H0)? kad_var(0, 0, 2, 1, n1) : kad_const(0, 2, 1, n1);
 80427b2:	f000 80f1 	beq.w	8042998 <kann_layer_lstm+0x22c>
 80427b6:	2100      	movs	r1, #0
 80427b8:	2301      	movs	r3, #1
 80427ba:	2202      	movs	r2, #2
 80427bc:	4608      	mov	r0, r1
 80427be:	9400      	str	r4, [sp, #0]
 80427c0:	f007 f9c6 	bl	8049b50 <kad_var>
	h0->x = (float*)calloc(n1, sizeof(float));
 80427c4:	2104      	movs	r1, #4
	h0 = (rnn_flag & KANN_RNN_VAR_H0)? kad_var(0, 0, 2, 1, n1) : kad_const(0, 2, 1, n1);
 80427c6:	4680      	mov	r8, r0
	h0->x = (float*)calloc(n1, sizeof(float));
 80427c8:	4620      	mov	r0, r4
 80427ca:	f008 ffed 	bl	804b7a8 <calloc>
	c0 = (rnn_flag & KANN_RNN_VAR_H0)? kad_var(0, 0, 2, 1, n1) : kad_const(0, 2, 1, n1);
 80427ce:	2100      	movs	r1, #0
	heapSize += n1*sizeof(float);
 80427d0:	f8df a21c 	ldr.w	sl, [pc, #540]	@ 80429f0 <kann_layer_lstm+0x284>
	h0->x = (float*)calloc(n1, sizeof(float));
 80427d4:	f8c8 0028 	str.w	r0, [r8, #40]	@ 0x28
	c0 = (rnn_flag & KANN_RNN_VAR_H0)? kad_var(0, 0, 2, 1, n1) : kad_const(0, 2, 1, n1);
 80427d8:	9400      	str	r4, [sp, #0]
	heapSize += n1*sizeof(float);
 80427da:	f8da 3000 	ldr.w	r3, [sl]
	c0 = (rnn_flag & KANN_RNN_VAR_H0)? kad_var(0, 0, 2, 1, n1) : kad_const(0, 2, 1, n1);
 80427de:	2202      	movs	r2, #2
	heapSize += n1*sizeof(float);
 80427e0:	445b      	add	r3, fp
 80427e2:	f8ca 3000 	str.w	r3, [sl]
	c0 = (rnn_flag & KANN_RNN_VAR_H0)? kad_var(0, 0, 2, 1, n1) : kad_const(0, 2, 1, n1);
 80427e6:	4608      	mov	r0, r1
 80427e8:	2301      	movs	r3, #1
 80427ea:	f007 f9b1 	bl	8049b50 <kad_var>
 80427ee:	4681      	mov	r9, r0
	c0->x = (float*)calloc(n1, sizeof(float));
 80427f0:	2104      	movs	r1, #4
 80427f2:	4620      	mov	r0, r4
 80427f4:	f008 ffd8 	bl	804b7a8 <calloc>
 80427f8:	f8c9 0028 	str.w	r0, [r9, #40]	@ 0x28
kad_node_t *kann_new_weight(int n_row, int n_col) { return kann_new_leaf(KAD_VAR, 0.0f, 2, n_row, n_col); }
 80427fc:	9700      	str	r7, [sp, #0]
	heapSize += n1*sizeof(float);
 80427fe:	f8da 3000 	ldr.w	r3, [sl]
kad_node_t *kann_new_weight(int n_row, int n_col) { return kann_new_leaf(KAD_VAR, 0.0f, 2, n_row, n_col); }
 8042802:	2202      	movs	r2, #2
	heapSize += n1*sizeof(float);
 8042804:	445b      	add	r3, fp
 8042806:	f8ca 3000 	str.w	r3, [sl]
kad_node_t *kann_new_weight(int n_row, int n_col) { return kann_new_leaf(KAD_VAR, 0.0f, 2, n_row, n_col); }
 804280a:	2100      	movs	r1, #0
 804280c:	4623      	mov	r3, r4
 804280e:	2001      	movs	r0, #1
 8042810:	f7ff fed0 	bl	80425b4 <kann_new_leaf.constprop.0>
 8042814:	4623      	mov	r3, r4
 8042816:	4682      	mov	sl, r0
 8042818:	2202      	movs	r2, #2
 804281a:	2100      	movs	r1, #0
 804281c:	9400      	str	r4, [sp, #0]
 804281e:	2001      	movs	r0, #1
 8042820:	f7ff fec8 	bl	80425b4 <kann_new_leaf.constprop.0>
kad_node_t *kann_new_vec(int n, float x) { return kann_new_leaf(KAD_VAR, x, 1, n); }
 8042824:	2201      	movs	r2, #1
 8042826:	4623      	mov	r3, r4
kad_node_t *kann_new_weight(int n_row, int n_col) { return kann_new_leaf(KAD_VAR, 0.0f, 2, n_row, n_col); }
 8042828:	4683      	mov	fp, r0
kad_node_t *kann_new_vec(int n, float x) { return kann_new_leaf(KAD_VAR, x, 1, n); }
 804282a:	2100      	movs	r1, #0
 804282c:	4610      	mov	r0, r2
 804282e:	f7ff fec1 	bl	80425b4 <kann_new_leaf.constprop.0>
 8042832:	4603      	mov	r3, r0

	/* i = sigm(x_t * W_i + h_{t-1} * U_i + b_i) */
	w = kann_new_weight(n1, n0);
	u = kann_new_weight(n1, n1);
	b = kann_new_bias(n1);
	i = kad_sigm(kad_add(kad_add(cmul(in, w), cmul(h0, u)), b));
 8042834:	4651      	mov	r1, sl
 8042836:	4628      	mov	r0, r5
kad_node_t *kann_new_vec(int n, float x) { return kann_new_leaf(KAD_VAR, x, 1, n); }
 8042838:	469a      	mov	sl, r3
	i = kad_sigm(kad_add(kad_add(cmul(in, w), cmul(h0, u)), b));
 804283a:	47b0      	blx	r6
 804283c:	4603      	mov	r3, r0
 804283e:	4659      	mov	r1, fp
 8042840:	4640      	mov	r0, r8
 8042842:	469b      	mov	fp, r3
 8042844:	47b0      	blx	r6
 8042846:	4601      	mov	r1, r0
 8042848:	4658      	mov	r0, fp
 804284a:	f007 f9ad 	bl	8049ba8 <kad_add>
 804284e:	4651      	mov	r1, sl
 8042850:	f007 f9aa 	bl	8049ba8 <kad_add>
 8042854:	f007 faec 	bl	8049e30 <kad_sigm>
 8042858:	4684      	mov	ip, r0
kad_node_t *kann_new_weight(int n_row, int n_col) { return kann_new_leaf(KAD_VAR, 0.0f, 2, n_row, n_col); }
 804285a:	4623      	mov	r3, r4
 804285c:	2202      	movs	r2, #2
 804285e:	2100      	movs	r1, #0
 8042860:	9700      	str	r7, [sp, #0]
 8042862:	2001      	movs	r0, #1
	i = kad_sigm(kad_add(kad_add(cmul(in, w), cmul(h0, u)), b));
 8042864:	f8cd c010 	str.w	ip, [sp, #16]
kad_node_t *kann_new_weight(int n_row, int n_col) { return kann_new_leaf(KAD_VAR, 0.0f, 2, n_row, n_col); }
 8042868:	f7ff fea4 	bl	80425b4 <kann_new_leaf.constprop.0>
 804286c:	4623      	mov	r3, r4
 804286e:	4682      	mov	sl, r0
 8042870:	2202      	movs	r2, #2
 8042872:	2100      	movs	r1, #0
 8042874:	9400      	str	r4, [sp, #0]
 8042876:	2001      	movs	r0, #1
 8042878:	f7ff fe9c 	bl	80425b4 <kann_new_leaf.constprop.0>
kad_node_t *kann_new_vec(int n, float x) { return kann_new_leaf(KAD_VAR, x, 1, n); }
 804287c:	2201      	movs	r2, #1
 804287e:	4623      	mov	r3, r4
kad_node_t *kann_new_weight(int n_row, int n_col) { return kann_new_leaf(KAD_VAR, 0.0f, 2, n_row, n_col); }
 8042880:	4683      	mov	fp, r0
kad_node_t *kann_new_vec(int n, float x) { return kann_new_leaf(KAD_VAR, x, 1, n); }
 8042882:	f04f 517e 	mov.w	r1, #1065353216	@ 0x3f800000
 8042886:	4610      	mov	r0, r2
 8042888:	f7ff fe94 	bl	80425b4 <kann_new_leaf.constprop.0>
 804288c:	4603      	mov	r3, r0
	/* f = sigm(x_t * W_f + h_{t-1} * U_f + b_f) */
	w = kann_new_weight(n1, n0);
	u = kann_new_weight(n1, n1);
	b = kann_new_vec(n1, 1.0f); /* see Jozefowicz et al on using a large bias */
	f = kad_sigm(kad_add(kad_add(cmul(in, w), cmul(h0, u)), b));
 804288e:	4651      	mov	r1, sl
 8042890:	4628      	mov	r0, r5
kad_node_t *kann_new_vec(int n, float x) { return kann_new_leaf(KAD_VAR, x, 1, n); }
 8042892:	469a      	mov	sl, r3
	f = kad_sigm(kad_add(kad_add(cmul(in, w), cmul(h0, u)), b));
 8042894:	47b0      	blx	r6
 8042896:	4603      	mov	r3, r0
 8042898:	4659      	mov	r1, fp
 804289a:	4640      	mov	r0, r8
 804289c:	469b      	mov	fp, r3
 804289e:	47b0      	blx	r6
 80428a0:	4601      	mov	r1, r0
 80428a2:	4658      	mov	r0, fp
 80428a4:	f007 f980 	bl	8049ba8 <kad_add>
 80428a8:	4651      	mov	r1, sl
 80428aa:	f007 f97d 	bl	8049ba8 <kad_add>
 80428ae:	f007 fabf 	bl	8049e30 <kad_sigm>
 80428b2:	4684      	mov	ip, r0
kad_node_t *kann_new_weight(int n_row, int n_col) { return kann_new_leaf(KAD_VAR, 0.0f, 2, n_row, n_col); }
 80428b4:	4623      	mov	r3, r4
 80428b6:	2202      	movs	r2, #2
 80428b8:	2100      	movs	r1, #0
 80428ba:	9700      	str	r7, [sp, #0]
 80428bc:	2001      	movs	r0, #1
	f = kad_sigm(kad_add(kad_add(cmul(in, w), cmul(h0, u)), b));
 80428be:	f8cd c014 	str.w	ip, [sp, #20]
kad_node_t *kann_new_weight(int n_row, int n_col) { return kann_new_leaf(KAD_VAR, 0.0f, 2, n_row, n_col); }
 80428c2:	f7ff fe77 	bl	80425b4 <kann_new_leaf.constprop.0>
 80428c6:	4623      	mov	r3, r4
 80428c8:	4682      	mov	sl, r0
 80428ca:	2202      	movs	r2, #2
 80428cc:	2100      	movs	r1, #0
 80428ce:	9400      	str	r4, [sp, #0]
 80428d0:	2001      	movs	r0, #1
 80428d2:	f7ff fe6f 	bl	80425b4 <kann_new_leaf.constprop.0>
kad_node_t *kann_new_vec(int n, float x) { return kann_new_leaf(KAD_VAR, x, 1, n); }
 80428d6:	2201      	movs	r2, #1
 80428d8:	4623      	mov	r3, r4
kad_node_t *kann_new_weight(int n_row, int n_col) { return kann_new_leaf(KAD_VAR, 0.0f, 2, n_row, n_col); }
 80428da:	4683      	mov	fp, r0
kad_node_t *kann_new_vec(int n, float x) { return kann_new_leaf(KAD_VAR, x, 1, n); }
 80428dc:	2100      	movs	r1, #0
 80428de:	4610      	mov	r0, r2
 80428e0:	f7ff fe68 	bl	80425b4 <kann_new_leaf.constprop.0>
 80428e4:	4603      	mov	r3, r0
	/* o = sigm(x_t * W_o + h_{t-1} * U_o + b_o) */
	w = kann_new_weight(n1, n0);
	u = kann_new_weight(n1, n1);
	b = kann_new_bias(n1);
	o = kad_sigm(kad_add(kad_add(cmul(in, w), cmul(h0, u)), b));
 80428e6:	4651      	mov	r1, sl
 80428e8:	4628      	mov	r0, r5
kad_node_t *kann_new_vec(int n, float x) { return kann_new_leaf(KAD_VAR, x, 1, n); }
 80428ea:	469a      	mov	sl, r3
	o = kad_sigm(kad_add(kad_add(cmul(in, w), cmul(h0, u)), b));
 80428ec:	47b0      	blx	r6
 80428ee:	4603      	mov	r3, r0
 80428f0:	4659      	mov	r1, fp
 80428f2:	4640      	mov	r0, r8
 80428f4:	469b      	mov	fp, r3
 80428f6:	47b0      	blx	r6
 80428f8:	4601      	mov	r1, r0
 80428fa:	4658      	mov	r0, fp
 80428fc:	f007 f954 	bl	8049ba8 <kad_add>
 8042900:	4651      	mov	r1, sl
 8042902:	f007 f951 	bl	8049ba8 <kad_add>
 8042906:	f007 fa93 	bl	8049e30 <kad_sigm>
 804290a:	4684      	mov	ip, r0
kad_node_t *kann_new_weight(int n_row, int n_col) { return kann_new_leaf(KAD_VAR, 0.0f, 2, n_row, n_col); }
 804290c:	4623      	mov	r3, r4
 804290e:	2202      	movs	r2, #2
 8042910:	2100      	movs	r1, #0
 8042912:	9700      	str	r7, [sp, #0]
 8042914:	2001      	movs	r0, #1
	o = kad_sigm(kad_add(kad_add(cmul(in, w), cmul(h0, u)), b));
 8042916:	4667      	mov	r7, ip
kad_node_t *kann_new_weight(int n_row, int n_col) { return kann_new_leaf(KAD_VAR, 0.0f, 2, n_row, n_col); }
 8042918:	f7ff fe4c 	bl	80425b4 <kann_new_leaf.constprop.0>
 804291c:	4623      	mov	r3, r4
 804291e:	4682      	mov	sl, r0
 8042920:	2202      	movs	r2, #2
 8042922:	2100      	movs	r1, #0
 8042924:	9400      	str	r4, [sp, #0]
 8042926:	2001      	movs	r0, #1
 8042928:	f7ff fe44 	bl	80425b4 <kann_new_leaf.constprop.0>
kad_node_t *kann_new_vec(int n, float x) { return kann_new_leaf(KAD_VAR, x, 1, n); }
 804292c:	2201      	movs	r2, #1
 804292e:	4623      	mov	r3, r4
 8042930:	2100      	movs	r1, #0
kad_node_t *kann_new_weight(int n_row, int n_col) { return kann_new_leaf(KAD_VAR, 0.0f, 2, n_row, n_col); }
 8042932:	4604      	mov	r4, r0
kad_node_t *kann_new_vec(int n, float x) { return kann_new_leaf(KAD_VAR, x, 1, n); }
 8042934:	4610      	mov	r0, r2
 8042936:	f7ff fe3d 	bl	80425b4 <kann_new_leaf.constprop.0>
 804293a:	4603      	mov	r3, r0
	/* g = tanh(x_t * W_g + h_{t-1} * U_g + b_g) */
	w = kann_new_weight(n1, n0);
	u = kann_new_weight(n1, n1);
	b = kann_new_bias(n1);
	g = kad_tanh(kad_add(kad_add(cmul(in, w), cmul(h0, u)), b));
 804293c:	4651      	mov	r1, sl
 804293e:	4628      	mov	r0, r5
kad_node_t *kann_new_vec(int n, float x) { return kann_new_leaf(KAD_VAR, x, 1, n); }
 8042940:	461d      	mov	r5, r3
	g = kad_tanh(kad_add(kad_add(cmul(in, w), cmul(h0, u)), b));
 8042942:	47b0      	blx	r6
 8042944:	4603      	mov	r3, r0
 8042946:	4621      	mov	r1, r4
 8042948:	4640      	mov	r0, r8
 804294a:	461c      	mov	r4, r3
 804294c:	47b0      	blx	r6
 804294e:	4601      	mov	r1, r0
 8042950:	4620      	mov	r0, r4
 8042952:	f007 f929 	bl	8049ba8 <kad_add>
 8042956:	4629      	mov	r1, r5
 8042958:	f007 f926 	bl	8049ba8 <kad_add>
 804295c:	f007 fab2 	bl	8049ec4 <kad_tanh>
	/* c_t = c_{t-1} # f + g # i */
	c = kad_add(kad_mul(f, c0), kad_mul(g, i)); /* can't be kad_mul(c0, f)!!! */
 8042960:	4649      	mov	r1, r9
	g = kad_tanh(kad_add(kad_add(cmul(in, w), cmul(h0, u)), b));
 8042962:	4605      	mov	r5, r0
	c = kad_add(kad_mul(f, c0), kad_mul(g, i)); /* can't be kad_mul(c0, f)!!! */
 8042964:	9805      	ldr	r0, [sp, #20]
 8042966:	f007 f971 	bl	8049c4c <kad_mul>
 804296a:	9904      	ldr	r1, [sp, #16]
 804296c:	4604      	mov	r4, r0
 804296e:	4628      	mov	r0, r5
 8042970:	f007 f96c 	bl	8049c4c <kad_mul>
 8042974:	4601      	mov	r1, r0
 8042976:	4620      	mov	r0, r4
 8042978:	f007 f916 	bl	8049ba8 <kad_add>
	c->pre = c0;
	/* h_t = tanh(c_t) # o */
	if (rnn_flag & KANN_RNN_NORM) c = kann_layer_layernorm(c); /* see Ba et al (2016) about how to apply layer normalization to LSTM */
 804297c:	9b03      	ldr	r3, [sp, #12]
	c->pre = c0;
 804297e:	f8c0 903c 	str.w	r9, [r0, #60]	@ 0x3c
	if (rnn_flag & KANN_RNN_NORM) c = kann_layer_layernorm(c); /* see Ba et al (2016) about how to apply layer normalization to LSTM */
 8042982:	bb4b      	cbnz	r3, 80429d8 <kann_layer_lstm+0x26c>
	out = kad_mul(kad_tanh(c), o);
 8042984:	f007 fa9e 	bl	8049ec4 <kad_tanh>
 8042988:	4639      	mov	r1, r7
 804298a:	f007 f95f 	bl	8049c4c <kad_mul>
	out->pre = h0;
 804298e:	f8c0 803c 	str.w	r8, [r0, #60]	@ 0x3c
	return out;
}
 8042992:	b007      	add	sp, #28
 8042994:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	h0 = (rnn_flag & KANN_RNN_VAR_H0)? kad_var(0, 0, 2, 1, n1) : kad_const(0, 2, 1, n1);
 8042998:	4623      	mov	r3, r4
 804299a:	2201      	movs	r2, #1
 804299c:	2102      	movs	r1, #2
 804299e:	4648      	mov	r0, r9
 80429a0:	f007 f87e 	bl	8049aa0 <kad_const>
	h0->x = (float*)calloc(n1, sizeof(float));
 80429a4:	2104      	movs	r1, #4
	h0 = (rnn_flag & KANN_RNN_VAR_H0)? kad_var(0, 0, 2, 1, n1) : kad_const(0, 2, 1, n1);
 80429a6:	4680      	mov	r8, r0
	h0->x = (float*)calloc(n1, sizeof(float));
 80429a8:	4620      	mov	r0, r4
 80429aa:	f008 fefd 	bl	804b7a8 <calloc>
 80429ae:	4603      	mov	r3, r0
	heapSize += n1*sizeof(float);
 80429b0:	f8df a03c 	ldr.w	sl, [pc, #60]	@ 80429f0 <kann_layer_lstm+0x284>
	h0->x = (float*)calloc(n1, sizeof(float));
 80429b4:	f8c8 3028 	str.w	r3, [r8, #40]	@ 0x28
	heapSize += n1*sizeof(float);
 80429b8:	f8da 3000 	ldr.w	r3, [sl]
	c0 = (rnn_flag & KANN_RNN_VAR_H0)? kad_var(0, 0, 2, 1, n1) : kad_const(0, 2, 1, n1);
 80429bc:	4648      	mov	r0, r9
	heapSize += n1*sizeof(float);
 80429be:	445b      	add	r3, fp
 80429c0:	f8ca 3000 	str.w	r3, [sl]
	c0 = (rnn_flag & KANN_RNN_VAR_H0)? kad_var(0, 0, 2, 1, n1) : kad_const(0, 2, 1, n1);
 80429c4:	2201      	movs	r2, #1
 80429c6:	4623      	mov	r3, r4
 80429c8:	2102      	movs	r1, #2
 80429ca:	f007 f869 	bl	8049aa0 <kad_const>
 80429ce:	4681      	mov	r9, r0
 80429d0:	e70e      	b.n	80427f0 <kann_layer_lstm+0x84>
 80429d2:	b13b      	cbz	r3, 80429e4 <kann_layer_lstm+0x278>
 80429d4:	692f      	ldr	r7, [r5, #16]
 80429d6:	e6e8      	b.n	80427aa <kann_layer_lstm+0x3e>
kad_node_t *kann_layer_layernorm(kad_node_t *in) { return kann_layer_layernorm2(0, 0, in); }
 80429d8:	2100      	movs	r1, #0
 80429da:	4602      	mov	r2, r0
 80429dc:	4608      	mov	r0, r1
 80429de:	f7ff fe2f 	bl	8042640 <kann_layer_layernorm2>
 80429e2:	e7cf      	b.n	8042984 <kann_layer_lstm+0x218>
	int n = 1, i;
 80429e4:	2701      	movs	r7, #1
 80429e6:	e6e0      	b.n	80427aa <kann_layer_lstm+0x3e>
 80429e8:	08049ce9 	.word	0x08049ce9
 80429ec:	080426c1 	.word	0x080426c1
 80429f0:	20018344 	.word	0x20018344

080429f4 <kann_RMSprop>:
 ***************************/

void kann_RMSprop(int n, float h0, const float *h, float decay, const float *g, float *t, float *r)
{
	int i;
	for (i = 0; i < n; ++i) {
 80429f4:	2800      	cmp	r0, #0
 80429f6:	dd60      	ble.n	8042aba <kann_RMSprop+0xc6>
{
 80429f8:	b530      	push	{r4, r5, lr}
 80429fa:	ed2d 8b04 	vpush	{d8-d9}
		float lr = h? h[i] : h0;
		r[i] = (1.0f - decay) * g[i] * g[i] + decay * r[i];
 80429fe:	eef7 8a00 	vmov.f32	s17, #112	@ 0x3f800000  1.0
{
 8042a02:	b085      	sub	sp, #20
		r[i] = (1.0f - decay) * g[i] * g[i] + decay * r[i];
 8042a04:	ee78 8ae0 	vsub.f32	s17, s17, s1
 8042a08:	b359      	cbz	r1, 8042a62 <kann_RMSprop+0x6e>
		t[i] -= lr / sqrtf(1e-6f + r[i]) * g[i];
 8042a0a:	ed9f 9a44 	vldr	s18, [pc, #272]	@ 8042b1c <kann_RMSprop+0x128>
 8042a0e:	9c0c      	ldr	r4, [sp, #48]	@ 0x30
 8042a10:	eb01 0580 	add.w	r5, r1, r0, lsl #2
		r[i] = (1.0f - decay) * g[i] * g[i] + decay * r[i];
 8042a14:	ecb2 7a01 	vldmia	r2!, {s14}
 8042a18:	edd4 7a00 	vldr	s15, [r4]
 8042a1c:	ee67 6a28 	vmul.f32	s13, s14, s17
 8042a20:	ee67 7aa0 	vmul.f32	s15, s15, s1
 8042a24:	eee7 7a26 	vfma.f32	s15, s14, s13
		t[i] -= lr / sqrtf(1e-6f + r[i]) * g[i];
 8042a28:	ee37 0a89 	vadd.f32	s0, s15, s18
 8042a2c:	eeb5 0a40 	vcmp.f32	s0, #0.0
 8042a30:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
		float lr = h? h[i] : h0;
 8042a34:	ecb1 8a01 	vldmia	r1!, {s16}
		r[i] = (1.0f - decay) * g[i] * g[i] + decay * r[i];
 8042a38:	ece4 7a01 	vstmia	r4!, {s15}
		t[i] -= lr / sqrtf(1e-6f + r[i]) * g[i];
 8042a3c:	d43e      	bmi.n	8042abc <kann_RMSprop+0xc8>
 8042a3e:	eeb1 6ac0 	vsqrt.f32	s12, s0
 8042a42:	edd3 7a00 	vldr	s15, [r3]
 8042a46:	ed12 7a01 	vldr	s14, [r2, #-4]
 8042a4a:	eec8 6a06 	vdiv.f32	s13, s16, s12
 8042a4e:	eee6 7ac7 	vfms.f32	s15, s13, s14
	for (i = 0; i < n; ++i) {
 8042a52:	42a9      	cmp	r1, r5
		t[i] -= lr / sqrtf(1e-6f + r[i]) * g[i];
 8042a54:	ece3 7a01 	vstmia	r3!, {s15}
	for (i = 0; i < n; ++i) {
 8042a58:	d1dc      	bne.n	8042a14 <kann_RMSprop+0x20>
	}
}
 8042a5a:	b005      	add	sp, #20
 8042a5c:	ecbd 8b04 	vpop	{d8-d9}
 8042a60:	bd30      	pop	{r4, r5, pc}
 8042a62:	eeb0 8a40 	vmov.f32	s16, s0
		t[i] -= lr / sqrtf(1e-6f + r[i]) * g[i];
 8042a66:	ed9f 9a2d 	vldr	s18, [pc, #180]	@ 8042b1c <kann_RMSprop+0x128>
 8042a6a:	9d0c      	ldr	r5, [sp, #48]	@ 0x30
 8042a6c:	eb02 0480 	add.w	r4, r2, r0, lsl #2
		r[i] = (1.0f - decay) * g[i] * g[i] + decay * r[i];
 8042a70:	ecb2 7a01 	vldmia	r2!, {s14}
 8042a74:	edd5 7a00 	vldr	s15, [r5]
 8042a78:	ee67 6a28 	vmul.f32	s13, s14, s17
 8042a7c:	ee60 7aa7 	vmul.f32	s15, s1, s15
 8042a80:	eee6 7a87 	vfma.f32	s15, s13, s14
		t[i] -= lr / sqrtf(1e-6f + r[i]) * g[i];
 8042a84:	ee37 0a89 	vadd.f32	s0, s15, s18
 8042a88:	eeb5 0a40 	vcmp.f32	s0, #0.0
 8042a8c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
		r[i] = (1.0f - decay) * g[i] * g[i] + decay * r[i];
 8042a90:	ece5 7a01 	vstmia	r5!, {s15}
		t[i] -= lr / sqrtf(1e-6f + r[i]) * g[i];
 8042a94:	d42b      	bmi.n	8042aee <kann_RMSprop+0xfa>
 8042a96:	eeb1 6ac0 	vsqrt.f32	s12, s0
 8042a9a:	edd3 7a00 	vldr	s15, [r3]
 8042a9e:	ed52 6a01 	vldr	s13, [r2, #-4]
 8042aa2:	ee88 7a06 	vdiv.f32	s14, s16, s12
 8042aa6:	eee6 7ac7 	vfms.f32	s15, s13, s14
	for (i = 0; i < n; ++i) {
 8042aaa:	42a2      	cmp	r2, r4
		t[i] -= lr / sqrtf(1e-6f + r[i]) * g[i];
 8042aac:	ece3 7a01 	vstmia	r3!, {s15}
	for (i = 0; i < n; ++i) {
 8042ab0:	d1de      	bne.n	8042a70 <kann_RMSprop+0x7c>
}
 8042ab2:	b005      	add	sp, #20
 8042ab4:	ecbd 8b04 	vpop	{d8-d9}
 8042ab8:	bd30      	pop	{r4, r5, pc}
 8042aba:	4770      	bx	lr
 8042abc:	e9cd 2301 	strd	r2, r3, [sp, #4]
 8042ac0:	edcd 0a03 	vstr	s1, [sp, #12]
 8042ac4:	9100      	str	r1, [sp, #0]
		t[i] -= lr / sqrtf(1e-6f + r[i]) * g[i];
 8042ac6:	f00a f935 	bl	804cd34 <sqrtf>
 8042aca:	9b02      	ldr	r3, [sp, #8]
 8042acc:	9a01      	ldr	r2, [sp, #4]
 8042ace:	edd3 7a00 	vldr	s15, [r3]
 8042ad2:	ed12 7a01 	vldr	s14, [r2, #-4]
 8042ad6:	eec8 6a00 	vdiv.f32	s13, s16, s0
 8042ada:	eee6 7ac7 	vfms.f32	s15, s13, s14
	for (i = 0; i < n; ++i) {
 8042ade:	9900      	ldr	r1, [sp, #0]
		t[i] -= lr / sqrtf(1e-6f + r[i]) * g[i];
 8042ae0:	ece3 7a01 	vstmia	r3!, {s15}
	for (i = 0; i < n; ++i) {
 8042ae4:	42a9      	cmp	r1, r5
 8042ae6:	eddd 0a03 	vldr	s1, [sp, #12]
 8042aea:	d193      	bne.n	8042a14 <kann_RMSprop+0x20>
 8042aec:	e7b5      	b.n	8042a5a <kann_RMSprop+0x66>
 8042aee:	e9cd 2300 	strd	r2, r3, [sp]
 8042af2:	edcd 0a02 	vstr	s1, [sp, #8]
		t[i] -= lr / sqrtf(1e-6f + r[i]) * g[i];
 8042af6:	f00a f91d 	bl	804cd34 <sqrtf>
 8042afa:	9b01      	ldr	r3, [sp, #4]
 8042afc:	9a00      	ldr	r2, [sp, #0]
 8042afe:	edd3 7a00 	vldr	s15, [r3]
 8042b02:	ed12 7a01 	vldr	s14, [r2, #-4]
 8042b06:	eec8 6a00 	vdiv.f32	s13, s16, s0
 8042b0a:	eee6 7ac7 	vfms.f32	s15, s13, s14
	for (i = 0; i < n; ++i) {
 8042b0e:	42a2      	cmp	r2, r4
		t[i] -= lr / sqrtf(1e-6f + r[i]) * g[i];
 8042b10:	ece3 7a01 	vstmia	r3!, {s15}
	for (i = 0; i < n; ++i) {
 8042b14:	eddd 0a02 	vldr	s1, [sp, #8]
 8042b18:	d1aa      	bne.n	8042a70 <kann_RMSprop+0x7c>
 8042b1a:	e79e      	b.n	8042a5a <kann_RMSprop+0x66>
 8042b1c:	358637bd 	.word	0x358637bd

08042b20 <kann_apply1>:
	kad_eval_at(a->n, a->v, i_out);
	return a->v[i_out]->x;
}

const float *kann_apply1(kann_t *a, float *x)
{
 8042b20:	b5f0      	push	{r4, r5, r6, r7, lr}
 8042b22:	4605      	mov	r5, r0
	for (i = k = 0; i < a->n; ++i)
 8042b24:	6800      	ldr	r0, [r0, #0]
{
 8042b26:	b083      	sub	sp, #12
	for (i = k = 0; i < a->n; ++i)
 8042b28:	2800      	cmp	r0, #0
 8042b2a:	9101      	str	r1, [sp, #4]
 8042b2c:	dd14      	ble.n	8042b58 <kann_apply1+0x38>
 8042b2e:	2200      	movs	r2, #0
	int i, k, r = -1;
 8042b30:	f04f 34ff 	mov.w	r4, #4294967295
	for (i = k = 0; i < a->n; ++i)
 8042b34:	4613      	mov	r3, r2
		if (chk_flg(a->v[i]->ext_flag, ext_flag) && chk_lbl(a->v[i]->ext_label, ext_label))
 8042b36:	6869      	ldr	r1, [r5, #4]
 8042b38:	f1a1 0c04 	sub.w	ip, r1, #4
 8042b3c:	f85c 6f04 	ldr.w	r6, [ip, #4]!
 8042b40:	6a76      	ldr	r6, [r6, #36]	@ 0x24
 8042b42:	07b6      	lsls	r6, r6, #30
			++k, r = i;
 8042b44:	bf48      	it	mi
 8042b46:	461c      	movmi	r4, r3
	for (i = k = 0; i < a->n; ++i)
 8042b48:	f103 0301 	add.w	r3, r3, #1
			++k, r = i;
 8042b4c:	bf48      	it	mi
 8042b4e:	3201      	addmi	r2, #1
	for (i = k = 0; i < a->n; ++i)
 8042b50:	4298      	cmp	r0, r3
 8042b52:	d1f3      	bne.n	8042b3c <kann_apply1+0x1c>
	return k == 1? r : k == 0? -1 : -2;
 8042b54:	2a01      	cmp	r2, #1
 8042b56:	d002      	beq.n	8042b5e <kann_apply1+0x3e>
	if (i_out < 0) return 0;
 8042b58:	2000      	movs	r0, #0
	return kann_apply1_to(a, x, KANN_F_OUT, 0);
}
 8042b5a:	b003      	add	sp, #12
 8042b5c:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (i_out < 0) return 0;
 8042b5e:	2c00      	cmp	r4, #0
 8042b60:	dbfa      	blt.n	8042b58 <kann_apply1+0x38>
	kann_set_batch_size(a, 1);
 8042b62:	f007 fae9 	bl	804a138 <kad_sync_dim>
		if (kad_is_feed(a->v[i]) && chk_flg(a->v[i]->ext_flag, ext_flag) && chk_lbl(a->v[i]->ext_label, ext_label))
 8042b66:	e9d5 0100 	ldrd	r0, r1, [r5]
	for (i = k = 0; i < a->n; ++i)
 8042b6a:	2800      	cmp	r0, #0
 8042b6c:	dd1a      	ble.n	8042ba4 <kann_apply1+0x84>
 8042b6e:	f04f 0e00 	mov.w	lr, #0
 8042b72:	1f0b      	subs	r3, r1, #4
 8042b74:	eb03 0680 	add.w	r6, r3, r0, lsl #2
		if (kad_is_feed(a->v[i]) && chk_flg(a->v[i]->ext_flag, ext_flag) && chk_lbl(a->v[i]->ext_label, ext_label))
 8042b78:	f853 2f04 	ldr.w	r2, [r3, #4]!
 8042b7c:	6857      	ldr	r7, [r2, #4]
 8042b7e:	b97f      	cbnz	r7, 8042ba0 <kann_apply1+0x80>
 8042b80:	f892 c001 	ldrb.w	ip, [r2, #1]
 8042b84:	f01c 0f03 	tst.w	ip, #3
 8042b88:	d10a      	bne.n	8042ba0 <kann_apply1+0x80>
			a->v[i]->x = x[k++];
 8042b8a:	af02      	add	r7, sp, #8
 8042b8c:	eb07 0c8e 	add.w	ip, r7, lr, lsl #2
		if (kad_is_feed(a->v[i]) && chk_flg(a->v[i]->ext_flag, ext_flag) && chk_lbl(a->v[i]->ext_label, ext_label))
 8042b90:	6a57      	ldr	r7, [r2, #36]	@ 0x24
 8042b92:	07ff      	lsls	r7, r7, #31
 8042b94:	d504      	bpl.n	8042ba0 <kann_apply1+0x80>
			a->v[i]->x = x[k++];
 8042b96:	f85c 7c04 	ldr.w	r7, [ip, #-4]
 8042b9a:	f10e 0e01 	add.w	lr, lr, #1
 8042b9e:	6297      	str	r7, [r2, #40]	@ 0x28
	for (i = k = 0; i < a->n; ++i)
 8042ba0:	429e      	cmp	r6, r3
 8042ba2:	d1e9      	bne.n	8042b78 <kann_apply1+0x58>
	kad_eval_at(a->n, a->v, i_out);
 8042ba4:	4622      	mov	r2, r4
 8042ba6:	f007 fcdd 	bl	804a564 <kad_eval_at>
	return a->v[i_out]->x;
 8042baa:	686b      	ldr	r3, [r5, #4]
 8042bac:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
 8042bb0:	6a98      	ldr	r0, [r3, #40]	@ 0x28
}
 8042bb2:	b003      	add	sp, #12
 8042bb4:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8042bb6:	bf00      	nop

08042bb8 <kad_propagate_marks>:
 **********************************/

static void kad_propagate_marks(int n, kad_node_t **a)
{
	int i, j;
	for (i = n - 1; i >= 0; --i) {
 8042bb8:	2800      	cmp	r0, #0
 8042bba:	dd2a      	ble.n	8042c12 <kad_propagate_marks+0x5a>
{
 8042bbc:	b510      	push	{r4, lr}
		kad_node_t *p = a[i];
		if (p->tmp > 0) {
			if (kad_is_switch(p)) {
				int32_t *aux = (int32_t*)p->ptr;
				if (p->child[*aux]->tmp == 0)
					p->child[*aux]->tmp = 1;
 8042bbe:	2401      	movs	r4, #1
 8042bc0:	eb01 0e80 	add.w	lr, r1, r0, lsl #2
 8042bc4:	e00c      	b.n	8042be0 <kad_propagate_marks+0x28>
			if (kad_is_switch(p)) {
 8042bc6:	785a      	ldrb	r2, [r3, #1]
 8042bc8:	0752      	lsls	r2, r2, #29
 8042bca:	d411      	bmi.n	8042bf0 <kad_propagate_marks+0x38>
				if (p->child[*aux]->tmp == 0)
 8042bcc:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 8042bce:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8042bd0:	6812      	ldr	r2, [r2, #0]
 8042bd2:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8042bd6:	689a      	ldr	r2, [r3, #8]
 8042bd8:	b902      	cbnz	r2, 8042bdc <kad_propagate_marks+0x24>
					p->child[*aux]->tmp = 1;
 8042bda:	609c      	str	r4, [r3, #8]
	for (i = n - 1; i >= 0; --i) {
 8042bdc:	4571      	cmp	r1, lr
 8042bde:	d017      	beq.n	8042c10 <kad_propagate_marks+0x58>
		kad_node_t *p = a[i];
 8042be0:	f85e 3d04 	ldr.w	r3, [lr, #-4]!
		if (p->tmp > 0) {
 8042be4:	689a      	ldr	r2, [r3, #8]
 8042be6:	2a00      	cmp	r2, #0
 8042be8:	ddf8      	ble.n	8042bdc <kad_propagate_marks+0x24>
			if (kad_is_switch(p)) {
 8042bea:	885a      	ldrh	r2, [r3, #2]
 8042bec:	2a0c      	cmp	r2, #12
 8042bee:	d0ea      	beq.n	8042bc6 <kad_propagate_marks+0xe>
			} else {
				for (j = 0; j < p->n_child; ++j)
 8042bf0:	685a      	ldr	r2, [r3, #4]
 8042bf2:	2a00      	cmp	r2, #0
 8042bf4:	ddf2      	ble.n	8042bdc <kad_propagate_marks+0x24>
					if (p->child[j]->tmp == 0)
 8042bf6:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8042bf8:	3b04      	subs	r3, #4
 8042bfa:	eb03 0c82 	add.w	ip, r3, r2, lsl #2
 8042bfe:	f853 2f04 	ldr.w	r2, [r3, #4]!
 8042c02:	6890      	ldr	r0, [r2, #8]
 8042c04:	b900      	cbnz	r0, 8042c08 <kad_propagate_marks+0x50>
						p->child[j]->tmp = 1;
 8042c06:	6094      	str	r4, [r2, #8]
				for (j = 0; j < p->n_child; ++j)
 8042c08:	4563      	cmp	r3, ip
 8042c0a:	d1f8      	bne.n	8042bfe <kad_propagate_marks+0x46>
	for (i = n - 1; i >= 0; --i) {
 8042c0c:	4571      	cmp	r1, lr
 8042c0e:	d1e7      	bne.n	8042be0 <kad_propagate_marks+0x28>
			}
		}
	}
}
 8042c10:	bd10      	pop	{r4, pc}
 8042c12:	4770      	bx	lr
 8042c14:	0000      	movs	r0, r0
	...

08042c18 <kad_op_mse>:
}

/********** Cost functions **********/

int kad_op_mse(kad_node_t *p, int action)
{
 8042c18:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	kad_node_t *y1 = p->child[0]; /* test */
 8042c1c:	6b83      	ldr	r3, [r0, #56]	@ 0x38
{
 8042c1e:	4680      	mov	r8, r0
	kad_node_t *y1 = p->child[0]; /* test */
 8042c20:	e9d3 5400 	ldrd	r5, r4, [r3]
	for (i = 0; i < p->n_d; ++i) n *= p->d[i];
 8042c24:	7823      	ldrb	r3, [r4, #0]
{
 8042c26:	b082      	sub	sp, #8
 8042c28:	b393      	cbz	r3, 8042c90 <kad_op_mse+0x78>
 8042c2a:	2b01      	cmp	r3, #1
 8042c2c:	6926      	ldr	r6, [r4, #16]
 8042c2e:	d00c      	beq.n	8042c4a <kad_op_mse+0x32>
 8042c30:	6962      	ldr	r2, [r4, #20]
 8042c32:	2b02      	cmp	r3, #2
 8042c34:	fb02 f606 	mul.w	r6, r2, r6
 8042c38:	d007      	beq.n	8042c4a <kad_op_mse+0x32>
 8042c3a:	69a2      	ldr	r2, [r4, #24]
 8042c3c:	2b03      	cmp	r3, #3
 8042c3e:	fb02 f606 	mul.w	r6, r2, r6
 8042c42:	d002      	beq.n	8042c4a <kad_op_mse+0x32>
 8042c44:	69e3      	ldr	r3, [r4, #28]
 8042c46:	fb03 f606 	mul.w	r6, r3, r6
	kad_node_t *y0 = p->child[1]; /* truth */
	int i, n;

	n = kad_len(y0);
	if (action == KAD_SYNC_DIM) {
 8042c4a:	2904      	cmp	r1, #4
 8042c4c:	d007      	beq.n	8042c5e <kad_op_mse+0x46>
		if (n != kad_len(y1)) return -1;
		p->n_d = 0;
	} else if (action == KAD_FORWARD) {
 8042c4e:	2902      	cmp	r1, #2
 8042c50:	d024      	beq.n	8042c9c <kad_op_mse+0x84>
		double cost = 0.0;
		for (i = 0; i < n; ++i)
			cost += (y1->x[i] - y0->x[i]) * (y1->x[i] - y0->x[i]);
		p->x[0] = (float)(cost / n);
	} else if (action == KAD_BACKWARD && kad_is_back(y1)) {
 8042c52:	2903      	cmp	r1, #3
 8042c54:	d058      	beq.n	8042d08 <kad_op_mse+0xf0>
		float t = 2.0f * p->g[0] / n;
		for (i = 0; i < n; ++i)
			y1->g[i] += t * (y1->x[i] - y0->x[i]);
	}
	return 0;
 8042c56:	2000      	movs	r0, #0
}
 8042c58:	b002      	add	sp, #8
 8042c5a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8042c5e:	782a      	ldrb	r2, [r5, #0]
 8042c60:	2a00      	cmp	r2, #0
 8042c62:	d076      	beq.n	8042d52 <kad_op_mse+0x13a>
 8042c64:	2a01      	cmp	r2, #1
 8042c66:	692b      	ldr	r3, [r5, #16]
 8042c68:	d00c      	beq.n	8042c84 <kad_op_mse+0x6c>
 8042c6a:	6969      	ldr	r1, [r5, #20]
 8042c6c:	2a02      	cmp	r2, #2
 8042c6e:	fb01 f303 	mul.w	r3, r1, r3
 8042c72:	d007      	beq.n	8042c84 <kad_op_mse+0x6c>
 8042c74:	69a9      	ldr	r1, [r5, #24]
 8042c76:	2a03      	cmp	r2, #3
 8042c78:	fb01 f303 	mul.w	r3, r1, r3
 8042c7c:	d002      	beq.n	8042c84 <kad_op_mse+0x6c>
 8042c7e:	69ea      	ldr	r2, [r5, #28]
 8042c80:	fb02 f303 	mul.w	r3, r2, r3
		if (n != kad_len(y1)) return -1;
 8042c84:	429e      	cmp	r6, r3
 8042c86:	d16f      	bne.n	8042d68 <kad_op_mse+0x150>
		p->n_d = 0;
 8042c88:	2300      	movs	r3, #0
 8042c8a:	f888 3000 	strb.w	r3, [r8]
 8042c8e:	e7e2      	b.n	8042c56 <kad_op_mse+0x3e>
	if (action == KAD_SYNC_DIM) {
 8042c90:	2904      	cmp	r1, #4
 8042c92:	d034      	beq.n	8042cfe <kad_op_mse+0xe6>
	} else if (action == KAD_FORWARD) {
 8042c94:	2902      	cmp	r1, #2
 8042c96:	d05e      	beq.n	8042d56 <kad_op_mse+0x13e>
	int n = 1, i;
 8042c98:	2601      	movs	r6, #1
 8042c9a:	e7da      	b.n	8042c52 <kad_op_mse+0x3a>
		p->x[0] = (float)(cost / n);
 8042c9c:	4630      	mov	r0, r6
 8042c9e:	f7fd fc1d 	bl	80404dc <__aeabi_i2d>
		for (i = 0; i < n; ++i)
 8042ca2:	2e00      	cmp	r6, #0
		p->x[0] = (float)(cost / n);
 8042ca4:	e9cd 0100 	strd	r0, r1, [sp]
		for (i = 0; i < n; ++i)
 8042ca8:	dd5b      	ble.n	8042d62 <kad_op_mse+0x14a>
 8042caa:	f8d5 a028 	ldr.w	sl, [r5, #40]	@ 0x28
 8042cae:	f8d4 9028 	ldr.w	r9, [r4, #40]	@ 0x28
 8042cb2:	2700      	movs	r7, #0
		double cost = 0.0;
 8042cb4:	2400      	movs	r4, #0
 8042cb6:	2500      	movs	r5, #0
			cost += (y1->x[i] - y0->x[i]) * (y1->x[i] - y0->x[i]);
 8042cb8:	ecb9 7a01 	vldmia	r9!, {s14}
 8042cbc:	ecfa 7a01 	vldmia	sl!, {s15}
 8042cc0:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8042cc4:	ee67 7aa7 	vmul.f32	s15, s15, s15
 8042cc8:	ee17 0a90 	vmov	r0, s15
 8042ccc:	f7fd fc18 	bl	8040500 <__aeabi_f2d>
 8042cd0:	4602      	mov	r2, r0
 8042cd2:	460b      	mov	r3, r1
 8042cd4:	4620      	mov	r0, r4
 8042cd6:	4629      	mov	r1, r5
 8042cd8:	f7fd fab4 	bl	8040244 <__adddf3>
		for (i = 0; i < n; ++i)
 8042cdc:	3701      	adds	r7, #1
 8042cde:	42b7      	cmp	r7, r6
			cost += (y1->x[i] - y0->x[i]) * (y1->x[i] - y0->x[i]);
 8042ce0:	4604      	mov	r4, r0
 8042ce2:	460d      	mov	r5, r1
		for (i = 0; i < n; ++i)
 8042ce4:	dbe8      	blt.n	8042cb8 <kad_op_mse+0xa0>
		p->x[0] = (float)(cost / n);
 8042ce6:	e9dd 2300 	ldrd	r2, r3, [sp]
 8042cea:	4620      	mov	r0, r4
 8042cec:	4629      	mov	r1, r5
 8042cee:	f7fd fd89 	bl	8040804 <__aeabi_ddiv>
 8042cf2:	f7fd ff35 	bl	8040b60 <__aeabi_d2f>
 8042cf6:	f8d8 3028 	ldr.w	r3, [r8, #40]	@ 0x28
 8042cfa:	6018      	str	r0, [r3, #0]
 8042cfc:	e7ab      	b.n	8042c56 <kad_op_mse+0x3e>
	for (i = 0; i < p->n_d; ++i) n *= p->d[i];
 8042cfe:	782a      	ldrb	r2, [r5, #0]
 8042d00:	2a00      	cmp	r2, #0
 8042d02:	d0c1      	beq.n	8042c88 <kad_op_mse+0x70>
	int n = 1, i;
 8042d04:	2601      	movs	r6, #1
 8042d06:	e7ad      	b.n	8042c64 <kad_op_mse+0x4c>
	} else if (action == KAD_BACKWARD && kad_is_back(y1)) {
 8042d08:	786b      	ldrb	r3, [r5, #1]
 8042d0a:	07db      	lsls	r3, r3, #31
 8042d0c:	d5a3      	bpl.n	8042c56 <kad_op_mse+0x3e>
		float t = 2.0f * p->g[0] / n;
 8042d0e:	f8d8 302c 	ldr.w	r3, [r8, #44]	@ 0x2c
 8042d12:	ee07 6a10 	vmov	s14, r6
 8042d16:	edd3 7a00 	vldr	s15, [r3]
 8042d1a:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 8042d1e:	ee77 7aa7 	vadd.f32	s15, s15, s15
		for (i = 0; i < n; ++i)
 8042d22:	2e00      	cmp	r6, #0
		float t = 2.0f * p->g[0] / n;
 8042d24:	ee87 6a87 	vdiv.f32	s12, s15, s14
		for (i = 0; i < n; ++i)
 8042d28:	dd95      	ble.n	8042c56 <kad_op_mse+0x3e>
 8042d2a:	e9d5 130a 	ldrd	r1, r3, [r5, #40]	@ 0x28
 8042d2e:	6aa2      	ldr	r2, [r4, #40]	@ 0x28
 8042d30:	eb03 0686 	add.w	r6, r3, r6, lsl #2
			y1->g[i] += t * (y1->x[i] - y0->x[i]);
 8042d34:	ecb1 7a01 	vldmia	r1!, {s14}
 8042d38:	ecf2 6a01 	vldmia	r2!, {s13}
 8042d3c:	edd3 7a00 	vldr	s15, [r3]
 8042d40:	ee37 7a66 	vsub.f32	s14, s14, s13
 8042d44:	eee7 7a06 	vfma.f32	s15, s14, s12
 8042d48:	ece3 7a01 	vstmia	r3!, {s15}
		for (i = 0; i < n; ++i)
 8042d4c:	42b3      	cmp	r3, r6
 8042d4e:	d1f1      	bne.n	8042d34 <kad_op_mse+0x11c>
 8042d50:	e781      	b.n	8042c56 <kad_op_mse+0x3e>
 8042d52:	2301      	movs	r3, #1
 8042d54:	e796      	b.n	8042c84 <kad_op_mse+0x6c>
	} else if (action == KAD_FORWARD) {
 8042d56:	ed9f 7b06 	vldr	d7, [pc, #24]	@ 8042d70 <kad_op_mse+0x158>
 8042d5a:	2601      	movs	r6, #1
 8042d5c:	ed8d 7b00 	vstr	d7, [sp]
 8042d60:	e7a3      	b.n	8042caa <kad_op_mse+0x92>
		double cost = 0.0;
 8042d62:	2400      	movs	r4, #0
 8042d64:	2500      	movs	r5, #0
 8042d66:	e7be      	b.n	8042ce6 <kad_op_mse+0xce>
		if (n != kad_len(y1)) return -1;
 8042d68:	f04f 30ff 	mov.w	r0, #4294967295
 8042d6c:	e774      	b.n	8042c58 <kad_op_mse+0x40>
 8042d6e:	bf00      	nop
 8042d70:	00000000 	.word	0x00000000
 8042d74:	3ff00000 	.word	0x3ff00000

08042d78 <conv2d_add_3to1>:
					y[(ik + l) * d[1] + j] = x[ijk + l];
			}
}

static void conv2d_add_3to1(int d[4], const float *y, float *x) /* convert the NHWC shape back to NCHW and add to another NCHW-shaped array */
{
 8042d78:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	int i, j, k, l;
	for (i = 0; i < d[0]; ++i)
 8042d7c:	f8d0 c000 	ldr.w	ip, [r0]
{
 8042d80:	b089      	sub	sp, #36	@ 0x24
	for (i = 0; i < d[0]; ++i)
 8042d82:	f1bc 0f00 	cmp.w	ip, #0
{
 8042d86:	9103      	str	r1, [sp, #12]
	for (i = 0; i < d[0]; ++i)
 8042d88:	dd5d      	ble.n	8042e46 <conv2d_add_3to1+0xce>
		for (j = 0; j < d[1]; ++j)
 8042d8a:	6843      	ldr	r3, [r0, #4]
 8042d8c:	4604      	mov	r4, r0
 8042d8e:	2b00      	cmp	r3, #0
 8042d90:	9302      	str	r3, [sp, #8]
 8042d92:	dd58      	ble.n	8042e46 <conv2d_add_3to1+0xce>
 8042d94:	4693      	mov	fp, r2
			for (k = 0; k < d[2]; ++k) {
 8042d96:	2200      	movs	r2, #0
 8042d98:	4625      	mov	r5, r4
	for (i = 0; i < d[0]; ++i)
 8042d9a:	4611      	mov	r1, r2
 8042d9c:	4667      	mov	r7, ip
 8042d9e:	4614      	mov	r4, r2
			for (k = 0; k < d[2]; ++k) {
 8042da0:	6886      	ldr	r6, [r0, #8]
 8042da2:	0098      	lsls	r0, r3, #2
		for (j = 0; j < d[1]; ++j)
 8042da4:	2e00      	cmp	r6, #0
				int ik = (i * d[2] + k) * d[3], ijk = ((i * d[1] + j) * d[2] + k) * d[3];
 8042da6:	fb06 f301 	mul.w	r3, r6, r1
 8042daa:	dd47      	ble.n	8042e3c <conv2d_add_3to1+0xc4>
		for (j = 0; j < d[1]; ++j)
 8042dac:	f04f 0900 	mov.w	r9, #0
				int ik = (i * d[2] + k) * d[3], ijk = ((i * d[1] + j) * d[2] + k) * d[3];
 8042db0:	f8d5 c00c 	ldr.w	ip, [r5, #12]
 8042db4:	9a02      	ldr	r2, [sp, #8]
 8042db6:	fb0c f303 	mul.w	r3, ip, r3
 8042dba:	fb02 fe0c 	mul.w	lr, r2, ip
 8042dbe:	fb06 fa04 	mul.w	sl, r6, r4
 8042dc2:	fb02 f303 	mul.w	r3, r2, r3
 8042dc6:	ea4f 0e8e 	mov.w	lr, lr, lsl #2
 8042dca:	ea4f 088c 	mov.w	r8, ip, lsl #2
			for (k = 0; k < d[2]; ++k) {
 8042dce:	f1bc 0f00 	cmp.w	ip, #0
 8042dd2:	dd3b      	ble.n	8042e4c <conv2d_add_3to1+0xd4>
 8042dd4:	e9cd 1704 	strd	r1, r7, [sp, #16]
 8042dd8:	e9cd 4506 	strd	r4, r5, [sp, #24]
 8042ddc:	2500      	movs	r5, #0
 8042dde:	fb0a f20c 	mul.w	r2, sl, ip
 8042de2:	9903      	ldr	r1, [sp, #12]
 8042de4:	eb03 0409 	add.w	r4, r3, r9
 8042de8:	eb02 070c 	add.w	r7, r2, ip
 8042dec:	eb01 0484 	add.w	r4, r1, r4, lsl #2
 8042df0:	f8cd 9004 	str.w	r9, [sp, #4]
 8042df4:	eb0b 0187 	add.w	r1, fp, r7, lsl #2
 8042df8:	46a1      	mov	r9, r4
 8042dfa:	eb0b 0282 	add.w	r2, fp, r2, lsl #2
				for (l = 0; l < d[3]; ++l)
					x[ijk + l] += y[(ik + l) * d[1] + j];
 8042dfe:	edd9 7a00 	vldr	s15, [r9]
 8042e02:	ed92 7a00 	vldr	s14, [r2]
 8042e06:	ee77 7a87 	vadd.f32	s15, s15, s14
 8042e0a:	ece2 7a01 	vstmia	r2!, {s15}
				for (l = 0; l < d[3]; ++l)
 8042e0e:	4291      	cmp	r1, r2
 8042e10:	4481      	add	r9, r0
 8042e12:	d1f4      	bne.n	8042dfe <conv2d_add_3to1+0x86>
			for (k = 0; k < d[2]; ++k) {
 8042e14:	3501      	adds	r5, #1
 8042e16:	42b5      	cmp	r5, r6
 8042e18:	463a      	mov	r2, r7
 8042e1a:	4474      	add	r4, lr
 8042e1c:	4441      	add	r1, r8
 8042e1e:	d001      	beq.n	8042e24 <conv2d_add_3to1+0xac>
 8042e20:	4467      	add	r7, ip
 8042e22:	e7e9      	b.n	8042df8 <conv2d_add_3to1+0x80>
		for (j = 0; j < d[1]; ++j)
 8042e24:	f8dd 9004 	ldr.w	r9, [sp, #4]
 8042e28:	9a02      	ldr	r2, [sp, #8]
 8042e2a:	f109 0901 	add.w	r9, r9, #1
 8042e2e:	454a      	cmp	r2, r9
 8042e30:	44b2      	add	sl, r6
 8042e32:	d1d3      	bne.n	8042ddc <conv2d_add_3to1+0x64>
 8042e34:	e9dd 1704 	ldrd	r1, r7, [sp, #16]
 8042e38:	e9dd 4506 	ldrd	r4, r5, [sp, #24]
	for (i = 0; i < d[0]; ++i)
 8042e3c:	9b02      	ldr	r3, [sp, #8]
 8042e3e:	3101      	adds	r1, #1
 8042e40:	42b9      	cmp	r1, r7
 8042e42:	441c      	add	r4, r3
 8042e44:	d1ae      	bne.n	8042da4 <conv2d_add_3to1+0x2c>
			}
}
 8042e46:	b009      	add	sp, #36	@ 0x24
 8042e48:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		for (j = 0; j < d[1]; ++j)
 8042e4c:	9a02      	ldr	r2, [sp, #8]
 8042e4e:	f109 0901 	add.w	r9, r9, #1
 8042e52:	4591      	cmp	r9, r2
 8042e54:	44b2      	add	sl, r6
 8042e56:	d1ba      	bne.n	8042dce <conv2d_add_3to1+0x56>
 8042e58:	e7f0      	b.n	8042e3c <conv2d_add_3to1+0xc4>
 8042e5a:	bf00      	nop

08042e5c <kad_op_max2d>:
	free(t); free(q1); free(w1); free(x_padded);
	return 0;
}

int kad_op_max2d(kad_node_t *p, int action)
{
 8042e5c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	conv_conf_t *aux = (conv_conf_t*)p->ptr;
	kad_node_t *q = p->child[0];
 8042e60:	6b82      	ldr	r2, [r0, #56]	@ 0x38
	if (action == KAD_SYNC_DIM) {
 8042e62:	2904      	cmp	r1, #4
{
 8042e64:	4683      	mov	fp, r0
	conv_conf_t *aux = (conv_conf_t*)p->ptr;
 8042e66:	f8d0 c030 	ldr.w	ip, [r0, #48]	@ 0x30
	kad_node_t *q = p->child[0];
 8042e6a:	f8d2 8000 	ldr.w	r8, [r2]
{
 8042e6e:	b08f      	sub	sp, #60	@ 0x3c
	if (action == KAD_SYNC_DIM) {
 8042e70:	d028      	beq.n	8042ec4 <kad_op_max2d+0x68>
		if (q->n_d != 4) return -1;
		p->n_d = 4;
		p->d[0] = q->d[0], p->d[1] = q->d[1], p->d[2] = conv_out_size(q->d[2], &aux[0]), p->d[3] = conv_out_size(q->d[3], &aux[1]);
	} else if (action == KAD_ALLOC) {
 8042e72:	2901      	cmp	r1, #1
 8042e74:	d008      	beq.n	8042e88 <kad_op_max2d+0x2c>
		p->gtmp = realloc(p->gtmp, kad_len(p) * sizeof(int));
	} else if (action == KAD_FORWARD) {
 8042e76:	2902      	cmp	r1, #2
 8042e78:	f000 8081 	beq.w	8042f7e <kad_op_max2d+0x122>
							if (p->x[u + j] < q->x[v])
								p->x[u + j] = q->x[v], f[u + j] = v;
				} /* ~k */
			} /* ~i */
		}
	} else if (action == KAD_BACKWARD) {
 8042e7c:	2903      	cmp	r1, #3
 8042e7e:	d050      	beq.n	8042f22 <kad_op_max2d+0xc6>
		int i, len, *f = (int*)p->gtmp;
		len = kad_len(p);
		for (i = 0; i < len; ++i) q->g[f[i]] += p->g[i];
	}
	return 0;
 8042e80:	2000      	movs	r0, #0
}
 8042e82:	b00f      	add	sp, #60	@ 0x3c
 8042e84:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	for (i = 0; i < p->n_d; ++i) n *= p->d[i];
 8042e88:	7802      	ldrb	r2, [r0, #0]
		p->gtmp = realloc(p->gtmp, kad_len(p) * sizeof(int));
 8042e8a:	6b40      	ldr	r0, [r0, #52]	@ 0x34
 8042e8c:	2a00      	cmp	r2, #0
 8042e8e:	f000 814a 	beq.w	8043126 <kad_op_max2d+0x2ca>
 8042e92:	2a01      	cmp	r2, #1
 8042e94:	f8db 1010 	ldr.w	r1, [fp, #16]
 8042e98:	d00e      	beq.n	8042eb8 <kad_op_max2d+0x5c>
 8042e9a:	f8db 3014 	ldr.w	r3, [fp, #20]
 8042e9e:	2a02      	cmp	r2, #2
 8042ea0:	fb03 f101 	mul.w	r1, r3, r1
 8042ea4:	d008      	beq.n	8042eb8 <kad_op_max2d+0x5c>
 8042ea6:	f8db 3018 	ldr.w	r3, [fp, #24]
 8042eaa:	2a03      	cmp	r2, #3
 8042eac:	fb03 f101 	mul.w	r1, r3, r1
 8042eb0:	bf1c      	itt	ne
 8042eb2:	f8db 201c 	ldrne.w	r2, [fp, #28]
 8042eb6:	4351      	mulne	r1, r2
 8042eb8:	0089      	lsls	r1, r1, #2
 8042eba:	f008 fd7d 	bl	804b9b8 <realloc>
 8042ebe:	f8cb 0034 	str.w	r0, [fp, #52]	@ 0x34
 8042ec2:	e7dd      	b.n	8042e80 <kad_op_max2d+0x24>
		if (q->n_d != 4) return -1;
 8042ec4:	f898 3000 	ldrb.w	r3, [r8]
 8042ec8:	2b04      	cmp	r3, #4
 8042eca:	f040 812e 	bne.w	804312a <kad_op_max2d+0x2ce>
		p->n_d = 4;
 8042ece:	7003      	strb	r3, [r0, #0]
		p->d[0] = q->d[0], p->d[1] = q->d[1], p->d[2] = conv_out_size(q->d[2], &aux[0]), p->d[3] = conv_out_size(q->d[3], &aux[1]);
 8042ed0:	e9d8 2304 	ldrd	r2, r3, [r8, #16]
 8042ed4:	e9c0 2304 	strd	r2, r3, [r0, #16]
 8042ed8:	f8dc 1000 	ldr.w	r1, [ip]
 8042edc:	f8d8 2018 	ldr.w	r2, [r8, #24]
 8042ee0:	f8d8 301c 	ldr.w	r3, [r8, #28]
 8042ee4:	1a52      	subs	r2, r2, r1
 8042ee6:	f8dc 1008 	ldr.w	r1, [ip, #8]
 8042eea:	f8dc 001c 	ldr.w	r0, [ip, #28]
 8042eee:	440a      	add	r2, r1
 8042ef0:	f8dc 100c 	ldr.w	r1, [ip, #12]
 8042ef4:	440a      	add	r2, r1
 8042ef6:	f8dc 1004 	ldr.w	r1, [ip, #4]
 8042efa:	fb92 f2f1 	sdiv	r2, r2, r1
 8042efe:	f8dc 1010 	ldr.w	r1, [ip, #16]
 8042f02:	3201      	adds	r2, #1
 8042f04:	1a5b      	subs	r3, r3, r1
 8042f06:	f8dc 1018 	ldr.w	r1, [ip, #24]
 8042f0a:	440b      	add	r3, r1
 8042f0c:	f8dc 1014 	ldr.w	r1, [ip, #20]
 8042f10:	4403      	add	r3, r0
 8042f12:	fb93 f3f1 	sdiv	r3, r3, r1
 8042f16:	3301      	adds	r3, #1
 8042f18:	f8cb 2018 	str.w	r2, [fp, #24]
 8042f1c:	f8cb 301c 	str.w	r3, [fp, #28]
 8042f20:	e7ae      	b.n	8042e80 <kad_op_max2d+0x24>
 8042f22:	7801      	ldrb	r1, [r0, #0]
		int i, len, *f = (int*)p->gtmp;
 8042f24:	6b42      	ldr	r2, [r0, #52]	@ 0x34
 8042f26:	2900      	cmp	r1, #0
 8042f28:	f000 80fb 	beq.w	8043122 <kad_op_max2d+0x2c6>
 8042f2c:	2901      	cmp	r1, #1
 8042f2e:	6903      	ldr	r3, [r0, #16]
 8042f30:	d00d      	beq.n	8042f4e <kad_op_max2d+0xf2>
 8042f32:	6940      	ldr	r0, [r0, #20]
 8042f34:	2902      	cmp	r1, #2
 8042f36:	fb00 f303 	mul.w	r3, r0, r3
 8042f3a:	d008      	beq.n	8042f4e <kad_op_max2d+0xf2>
 8042f3c:	f8db 0018 	ldr.w	r0, [fp, #24]
 8042f40:	2903      	cmp	r1, #3
 8042f42:	fb00 f303 	mul.w	r3, r0, r3
 8042f46:	bf1c      	itt	ne
 8042f48:	f8db 101c 	ldrne.w	r1, [fp, #28]
 8042f4c:	434b      	mulne	r3, r1
		for (i = 0; i < len; ++i) q->g[f[i]] += p->g[i];
 8042f4e:	2b00      	cmp	r3, #0
 8042f50:	dd96      	ble.n	8042e80 <kad_op_max2d+0x24>
 8042f52:	2000      	movs	r0, #0
 8042f54:	f8d8 502c 	ldr.w	r5, [r8, #44]	@ 0x2c
 8042f58:	f8db 402c 	ldr.w	r4, [fp, #44]	@ 0x2c
 8042f5c:	3a04      	subs	r2, #4
 8042f5e:	f852 1f04 	ldr.w	r1, [r2, #4]!
 8042f62:	ecb4 7a01 	vldmia	r4!, {s14}
 8042f66:	eb05 0181 	add.w	r1, r5, r1, lsl #2
 8042f6a:	edd1 7a00 	vldr	s15, [r1]
 8042f6e:	ee77 7a87 	vadd.f32	s15, s15, s14
 8042f72:	3001      	adds	r0, #1
 8042f74:	4283      	cmp	r3, r0
 8042f76:	edc1 7a00 	vstr	s15, [r1]
 8042f7a:	dcf0      	bgt.n	8042f5e <kad_op_max2d+0x102>
 8042f7c:	e780      	b.n	8042e80 <kad_op_max2d+0x24>
 8042f7e:	7801      	ldrb	r1, [r0, #0]
		int *f = (int*)p->gtmp;
 8042f80:	6b47      	ldr	r7, [r0, #52]	@ 0x34
 8042f82:	2900      	cmp	r1, #0
 8042f84:	f000 80e1 	beq.w	804314a <kad_op_max2d+0x2ee>
 8042f88:	2901      	cmp	r1, #1
 8042f8a:	6903      	ldr	r3, [r0, #16]
 8042f8c:	f000 80d9 	beq.w	8043142 <kad_op_max2d+0x2e6>
 8042f90:	6944      	ldr	r4, [r0, #20]
 8042f92:	2902      	cmp	r1, #2
 8042f94:	fb04 f203 	mul.w	r2, r4, r3
 8042f98:	f000 80ca 	beq.w	8043130 <kad_op_max2d+0x2d4>
 8042f9c:	6980      	ldr	r0, [r0, #24]
 8042f9e:	2903      	cmp	r1, #3
 8042fa0:	fb00 f202 	mul.w	r2, r0, r2
 8042fa4:	f000 80c9 	beq.w	804313a <kad_op_max2d+0x2de>
 8042fa8:	f8db 001c 	ldr.w	r0, [fp, #28]
 8042fac:	fb00 f202 	mul.w	r2, r0, r2
		for (i = 0; i < len; ++i) p->x[i] = -FLT_MAX;
 8042fb0:	2a00      	cmp	r2, #0
 8042fb2:	dd13      	ble.n	8042fdc <kad_op_max2d+0x180>
 8042fb4:	2300      	movs	r3, #0
 8042fb6:	f46f 0400 	mvn.w	r4, #8388608	@ 0x800000
 8042fba:	f8db 0028 	ldr.w	r0, [fp, #40]	@ 0x28
 8042fbe:	3301      	adds	r3, #1
 8042fc0:	429a      	cmp	r2, r3
 8042fc2:	f840 4b04 	str.w	r4, [r0], #4
 8042fc6:	dcfa      	bgt.n	8042fbe <kad_op_max2d+0x162>
		for (i = 0; i < p->n_d - 2; ++i) rest *= p->d[i];
 8042fc8:	1e8a      	subs	r2, r1, #2
 8042fca:	2a00      	cmp	r2, #0
 8042fcc:	f340 80b3 	ble.w	8043136 <kad_op_max2d+0x2da>
 8042fd0:	2a02      	cmp	r2, #2
 8042fd2:	f8db 3010 	ldr.w	r3, [fp, #16]
 8042fd6:	d103      	bne.n	8042fe0 <kad_op_max2d+0x184>
 8042fd8:	f8db 4014 	ldr.w	r4, [fp, #20]
 8042fdc:	fb04 f303 	mul.w	r3, r4, r3
		for (t = 0; t < rest; ++t) {
 8042fe0:	2b00      	cmp	r3, #0
 8042fe2:	f77f af4d 	ble.w	8042e80 <kad_op_max2d+0x24>
 8042fe6:	eb0b 0281 	add.w	r2, fp, r1, lsl #2
			int i, j, k, l, p_row = p->d[p->n_d - 2], p_col = p->d[p->n_d - 1];
 8042fea:	e9d2 0a02 	ldrd	r0, sl, [r2, #8]
 8042fee:	2800      	cmp	r0, #0
 8042ff0:	ea4f 0181 	mov.w	r1, r1, lsl #2
 8042ff4:	f77f af44 	ble.w	8042e80 <kad_op_max2d+0x24>
 8042ff8:	2400      	movs	r4, #0
 8042ffa:	f8dc 9000 	ldr.w	r9, [ip]
 8042ffe:	eb08 0201 	add.w	r2, r8, r1
 8043002:	fb0a fe00 	mul.w	lr, sl, r0
		for (t = 0; t < rest; ++t) {
 8043006:	4619      	mov	r1, r3
 8043008:	9008      	str	r0, [sp, #32]
 804300a:	4623      	mov	r3, r4
 804300c:	4648      	mov	r0, r9
 804300e:	ea4f 068a 	mov.w	r6, sl, lsl #2
 8043012:	9202      	str	r2, [sp, #8]
 8043014:	9405      	str	r4, [sp, #20]
 8043016:	f8cd 8004 	str.w	r8, [sp, #4]
 804301a:	9609      	str	r6, [sp, #36]	@ 0x24
			for (i = 0; i < p_row; ++i) {
 804301c:	f04f 0900 	mov.w	r9, #0
				for (k = 0; k < aux[0].kernel_size; ++k) {
 8043020:	2800      	cmp	r0, #0
 8043022:	461c      	mov	r4, r3
 8043024:	46c8      	mov	r8, r9
 8043026:	e9cd e70a 	strd	lr, r7, [sp, #40]	@ 0x28
 804302a:	e9cd 130c 	strd	r1, r3, [sp, #48]	@ 0x30
 804302e:	eb07 0683 	add.w	r6, r7, r3, lsl #2
 8043032:	dd6a      	ble.n	804310a <kad_op_max2d+0x2ae>
 8043034:	ea4f 0984 	mov.w	r9, r4, lsl #2
 8043038:	e9cd 9406 	strd	r9, r4, [sp, #24]
 804303c:	2300      	movs	r3, #0
 804303e:	46c1      	mov	r9, r8
 8043040:	e002      	b.n	8043048 <kad_op_max2d+0x1ec>
 8043042:	3301      	adds	r3, #1
 8043044:	4283      	cmp	r3, r0
 8043046:	da55      	bge.n	80430f4 <kad_op_max2d+0x298>
					int v, v0, v_end, ii = i * aux[0].stride + k - aux[0].pad[0];
 8043048:	f8dc 2004 	ldr.w	r2, [ip, #4]
 804304c:	f8dc 1008 	ldr.w	r1, [ip, #8]
 8043050:	fb02 3209 	mla	r2, r2, r9, r3
					if (ii < 0 || ii >= q->d[p->n_d - 2]) continue;
 8043054:	1a52      	subs	r2, r2, r1
 8043056:	d4f4      	bmi.n	8043042 <kad_op_max2d+0x1e6>
 8043058:	9c02      	ldr	r4, [sp, #8]
 804305a:	68a1      	ldr	r1, [r4, #8]
 804305c:	4291      	cmp	r1, r2
 804305e:	ddf0      	ble.n	8043042 <kad_op_max2d+0x1e6>
					v0 = (t * q->d[p->n_d - 2] + ii) * q->d[p->n_d - 1];
 8043060:	9d05      	ldr	r5, [sp, #20]
 8043062:	f8d4 800c 	ldr.w	r8, [r4, #12]
 8043066:	fb05 2201 	mla	r2, r5, r1, r2
 804306a:	fb08 fe02 	mul.w	lr, r8, r2
					for (l = 0; l < aux[1].kernel_size; ++l)
 804306e:	f8dc 4010 	ldr.w	r4, [ip, #16]
					v_end = v0 + q->d[p->n_d - 1];
 8043072:	eb08 050e 	add.w	r5, r8, lr
					for (l = 0; l < aux[1].kernel_size; ++l)
 8043076:	2c00      	cmp	r4, #0
 8043078:	dde3      	ble.n	8043042 <kad_op_max2d+0x1e6>
 804307a:	2700      	movs	r7, #0
 804307c:	e9cd 9303 	strd	r9, r3, [sp, #12]
 8043080:	f8dd 9018 	ldr.w	r9, [sp, #24]
						for (j = 0, v = v0 + (l > aux[1].pad[0]? l - aux[1].pad[0] : 0); j < p_col && v < v_end; ++j, v += aux[1].stride)
 8043084:	f8dc 2018 	ldr.w	r2, [ip, #24]
 8043088:	42ba      	cmp	r2, r7
 804308a:	bfb3      	iteet	lt
 804308c:	1aba      	sublt	r2, r7, r2
					v0 = (t * q->d[p->n_d - 2] + ii) * q->d[p->n_d - 1];
 804308e:	4673      	movge	r3, lr
						for (j = 0, v = v0 + (l > aux[1].pad[0]? l - aux[1].pad[0] : 0); j < p_col && v < v_end; ++j, v += aux[1].stride)
 8043090:	2200      	movge	r2, #0
 8043092:	eb0e 0302 	addlt.w	r3, lr, r2
 8043096:	f1ba 0f00 	cmp.w	sl, #0
 804309a:	dd21      	ble.n	80430e0 <kad_op_max2d+0x284>
 804309c:	4590      	cmp	r8, r2
 804309e:	dd1f      	ble.n	80430e0 <kad_op_max2d+0x284>
 80430a0:	f8db 1028 	ldr.w	r1, [fp, #40]	@ 0x28
							if (p->x[u + j] < q->x[v])
 80430a4:	9801      	ldr	r0, [sp, #4]
						for (j = 0, v = v0 + (l > aux[1].pad[0]? l - aux[1].pad[0] : 0); j < p_col && v < v_end; ++j, v += aux[1].stride)
 80430a6:	2200      	movs	r2, #0
							if (p->x[u + j] < q->x[v])
 80430a8:	6a84      	ldr	r4, [r0, #40]	@ 0x28
 80430aa:	4449      	add	r1, r9
 80430ac:	e001      	b.n	80430b2 <kad_op_max2d+0x256>
						for (j = 0, v = v0 + (l > aux[1].pad[0]? l - aux[1].pad[0] : 0); j < p_col && v < v_end; ++j, v += aux[1].stride)
 80430ae:	429d      	cmp	r5, r3
 80430b0:	dd14      	ble.n	80430dc <kad_op_max2d+0x280>
							if (p->x[u + j] < q->x[v])
 80430b2:	eb04 0083 	add.w	r0, r4, r3, lsl #2
 80430b6:	edd0 7a00 	vldr	s15, [r0]
 80430ba:	ecb1 7a01 	vldmia	r1!, {s14}
 80430be:	eeb4 7ae7 	vcmpe.f32	s14, s15
 80430c2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
								p->x[u + j] = q->x[v], f[u + j] = v;
 80430c6:	bf44      	itt	mi
 80430c8:	ed41 7a01 	vstrmi	s15, [r1, #-4]
 80430cc:	f846 3022 	strmi.w	r3, [r6, r2, lsl #2]
						for (j = 0, v = v0 + (l > aux[1].pad[0]? l - aux[1].pad[0] : 0); j < p_col && v < v_end; ++j, v += aux[1].stride)
 80430d0:	f8dc 0014 	ldr.w	r0, [ip, #20]
 80430d4:	3201      	adds	r2, #1
 80430d6:	4592      	cmp	sl, r2
 80430d8:	4403      	add	r3, r0
 80430da:	d1e8      	bne.n	80430ae <kad_op_max2d+0x252>
 80430dc:	f8dc 4010 	ldr.w	r4, [ip, #16]
					for (l = 0; l < aux[1].kernel_size; ++l)
 80430e0:	3701      	adds	r7, #1
 80430e2:	42bc      	cmp	r4, r7
 80430e4:	dcce      	bgt.n	8043084 <kad_op_max2d+0x228>
 80430e6:	e9dd 9303 	ldrd	r9, r3, [sp, #12]
				for (k = 0; k < aux[0].kernel_size; ++k) {
 80430ea:	f8dc 0000 	ldr.w	r0, [ip]
 80430ee:	3301      	adds	r3, #1
 80430f0:	4283      	cmp	r3, r0
 80430f2:	dba9      	blt.n	8043048 <kad_op_max2d+0x1ec>
			for (i = 0; i < p_row; ++i) {
 80430f4:	9b08      	ldr	r3, [sp, #32]
 80430f6:	f109 0801 	add.w	r8, r9, #1
 80430fa:	4543      	cmp	r3, r8
 80430fc:	9c07      	ldr	r4, [sp, #28]
 80430fe:	d004      	beq.n	804310a <kad_op_max2d+0x2ae>
 8043100:	9b09      	ldr	r3, [sp, #36]	@ 0x24
				for (k = 0; k < aux[0].kernel_size; ++k) {
 8043102:	2800      	cmp	r0, #0
 8043104:	4454      	add	r4, sl
 8043106:	441e      	add	r6, r3
 8043108:	dc94      	bgt.n	8043034 <kad_op_max2d+0x1d8>
		for (t = 0; t < rest; ++t) {
 804310a:	e9dd 130c 	ldrd	r1, r3, [sp, #48]	@ 0x30
 804310e:	e9dd e70a 	ldrd	lr, r7, [sp, #40]	@ 0x28
 8043112:	9a05      	ldr	r2, [sp, #20]
 8043114:	4473      	add	r3, lr
 8043116:	3201      	adds	r2, #1
 8043118:	428a      	cmp	r2, r1
 804311a:	9205      	str	r2, [sp, #20]
 804311c:	f6ff af7e 	blt.w	804301c <kad_op_max2d+0x1c0>
 8043120:	e6ae      	b.n	8042e80 <kad_op_max2d+0x24>
	int n = 1, i;
 8043122:	2301      	movs	r3, #1
 8043124:	e715      	b.n	8042f52 <kad_op_max2d+0xf6>
	for (i = 0; i < p->n_d; ++i) n *= p->d[i];
 8043126:	2104      	movs	r1, #4
 8043128:	e6c7      	b.n	8042eba <kad_op_max2d+0x5e>
		if (q->n_d != 4) return -1;
 804312a:	f04f 30ff 	mov.w	r0, #4294967295
 804312e:	e6a8      	b.n	8042e82 <kad_op_max2d+0x26>
		for (i = 0; i < len; ++i) p->x[i] = -FLT_MAX;
 8043130:	2a00      	cmp	r2, #0
 8043132:	f73f af3f 	bgt.w	8042fb4 <kad_op_max2d+0x158>
		int rest = 1, len, t, i;
 8043136:	2301      	movs	r3, #1
 8043138:	e755      	b.n	8042fe6 <kad_op_max2d+0x18a>
		for (i = 0; i < len; ++i) p->x[i] = -FLT_MAX;
 804313a:	2a00      	cmp	r2, #0
 804313c:	f73f af3a 	bgt.w	8042fb4 <kad_op_max2d+0x158>
 8043140:	e74e      	b.n	8042fe0 <kad_op_max2d+0x184>
 8043142:	2b00      	cmp	r3, #0
 8043144:	ddf7      	ble.n	8043136 <kad_op_max2d+0x2da>
 8043146:	461a      	mov	r2, r3
 8043148:	e734      	b.n	8042fb4 <kad_op_max2d+0x158>
	int n = 1, i;
 804314a:	2201      	movs	r2, #1
 804314c:	e732      	b.n	8042fb4 <kad_op_max2d+0x158>
 804314e:	bf00      	nop

08043150 <kad_op_max1d>:
	free(t); free(q1); free(w1); free(x_padded);
	return 0;
}

int kad_op_max1d(kad_node_t *p, int action)
{
 8043150:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	conv_conf_t *aux = (conv_conf_t*)p->ptr;
	kad_node_t *q = p->child[0];
 8043154:	6b83      	ldr	r3, [r0, #56]	@ 0x38
	if (action == KAD_SYNC_DIM) {
 8043156:	2904      	cmp	r1, #4
{
 8043158:	4605      	mov	r5, r0
	kad_node_t *q = p->child[0];
 804315a:	f8d3 8000 	ldr.w	r8, [r3]
	conv_conf_t *aux = (conv_conf_t*)p->ptr;
 804315e:	6b00      	ldr	r0, [r0, #48]	@ 0x30
{
 8043160:	b087      	sub	sp, #28
	if (action == KAD_SYNC_DIM) {
 8043162:	d022      	beq.n	80431aa <kad_op_max1d+0x5a>
		if (q->n_d != 3) return -1;
		p->n_d = 3;
		p->d[0] = q->d[0], p->d[1] = q->d[1], p->d[2] = conv_out_size(q->d[2], aux);
	} else if (action == KAD_ALLOC) {
 8043164:	2901      	cmp	r1, #1
 8043166:	d007      	beq.n	8043178 <kad_op_max1d+0x28>
		p->gtmp = realloc(p->gtmp, kad_len(p) * sizeof(int));
	} else if (action == KAD_FORWARD) {
 8043168:	2902      	cmp	r1, #2
 804316a:	d061      	beq.n	8043230 <kad_op_max1d+0xe0>
			for (l = 0; l < aux->kernel_size; ++l)
				for (j = 0, v = v0 + (l > aux->pad[0]? l - aux->pad[0] : 0); j < p_width && v < v_end; ++j, v += aux->stride)
					if (p->x[u + j] < q->x[v])
						p->x[u + j] = q->x[v], f[u + j] = v;
		}
	} else if (action == KAD_BACKWARD) {
 804316c:	2903      	cmp	r1, #3
 804316e:	d034      	beq.n	80431da <kad_op_max1d+0x8a>
		int i, len, *f = (int*)p->gtmp;
		len = kad_len(p);
		for (i = 0; i < len; ++i) q->g[f[i]] += p->g[i];
	}
	return 0;
 8043170:	2000      	movs	r0, #0
}
 8043172:	b007      	add	sp, #28
 8043174:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	for (i = 0; i < p->n_d; ++i) n *= p->d[i];
 8043178:	782a      	ldrb	r2, [r5, #0]
		p->gtmp = realloc(p->gtmp, kad_len(p) * sizeof(int));
 804317a:	6b68      	ldr	r0, [r5, #52]	@ 0x34
 804317c:	2a00      	cmp	r2, #0
 804317e:	f000 80ea 	beq.w	8043356 <kad_op_max1d+0x206>
 8043182:	2a01      	cmp	r2, #1
 8043184:	6929      	ldr	r1, [r5, #16]
 8043186:	d00b      	beq.n	80431a0 <kad_op_max1d+0x50>
 8043188:	696b      	ldr	r3, [r5, #20]
 804318a:	2a02      	cmp	r2, #2
 804318c:	fb03 f101 	mul.w	r1, r3, r1
 8043190:	d006      	beq.n	80431a0 <kad_op_max1d+0x50>
 8043192:	69ab      	ldr	r3, [r5, #24]
 8043194:	2a03      	cmp	r2, #3
 8043196:	fb03 f101 	mul.w	r1, r3, r1
 804319a:	bf1c      	itt	ne
 804319c:	69ea      	ldrne	r2, [r5, #28]
 804319e:	4351      	mulne	r1, r2
 80431a0:	0089      	lsls	r1, r1, #2
 80431a2:	f008 fc09 	bl	804b9b8 <realloc>
 80431a6:	6368      	str	r0, [r5, #52]	@ 0x34
 80431a8:	e7e2      	b.n	8043170 <kad_op_max1d+0x20>
		if (q->n_d != 3) return -1;
 80431aa:	f898 3000 	ldrb.w	r3, [r8]
 80431ae:	2b03      	cmp	r3, #3
 80431b0:	f040 80e8 	bne.w	8043384 <kad_op_max1d+0x234>
		p->n_d = 3;
 80431b4:	702b      	strb	r3, [r5, #0]
		p->d[0] = q->d[0], p->d[1] = q->d[1], p->d[2] = conv_out_size(q->d[2], aux);
 80431b6:	e9d8 2304 	ldrd	r2, r3, [r8, #16]
 80431ba:	e9c5 2304 	strd	r2, r3, [r5, #16]
 80431be:	6801      	ldr	r1, [r0, #0]
 80431c0:	f8d8 3018 	ldr.w	r3, [r8, #24]
 80431c4:	6882      	ldr	r2, [r0, #8]
 80431c6:	1a5b      	subs	r3, r3, r1
 80431c8:	68c1      	ldr	r1, [r0, #12]
 80431ca:	4413      	add	r3, r2
 80431cc:	6842      	ldr	r2, [r0, #4]
 80431ce:	440b      	add	r3, r1
 80431d0:	fb93 f3f2 	sdiv	r3, r3, r2
 80431d4:	3301      	adds	r3, #1
 80431d6:	61ab      	str	r3, [r5, #24]
 80431d8:	e7ca      	b.n	8043170 <kad_op_max1d+0x20>
 80431da:	782b      	ldrb	r3, [r5, #0]
		int i, len, *f = (int*)p->gtmp;
 80431dc:	6b69      	ldr	r1, [r5, #52]	@ 0x34
 80431de:	2b00      	cmp	r3, #0
 80431e0:	f000 80cc 	beq.w	804337c <kad_op_max1d+0x22c>
 80431e4:	2b01      	cmp	r3, #1
 80431e6:	692c      	ldr	r4, [r5, #16]
 80431e8:	d00b      	beq.n	8043202 <kad_op_max1d+0xb2>
 80431ea:	696a      	ldr	r2, [r5, #20]
 80431ec:	2b02      	cmp	r3, #2
 80431ee:	fb02 f404 	mul.w	r4, r2, r4
 80431f2:	d006      	beq.n	8043202 <kad_op_max1d+0xb2>
 80431f4:	69aa      	ldr	r2, [r5, #24]
 80431f6:	2b03      	cmp	r3, #3
 80431f8:	fb02 f404 	mul.w	r4, r2, r4
 80431fc:	bf1c      	itt	ne
 80431fe:	69eb      	ldrne	r3, [r5, #28]
 8043200:	435c      	mulne	r4, r3
		for (i = 0; i < len; ++i) q->g[f[i]] += p->g[i];
 8043202:	2c00      	cmp	r4, #0
 8043204:	ddb4      	ble.n	8043170 <kad_op_max1d+0x20>
 8043206:	2200      	movs	r2, #0
 8043208:	f8d8 602c 	ldr.w	r6, [r8, #44]	@ 0x2c
 804320c:	6ae8      	ldr	r0, [r5, #44]	@ 0x2c
 804320e:	3904      	subs	r1, #4
 8043210:	f851 3f04 	ldr.w	r3, [r1, #4]!
 8043214:	ecb0 7a01 	vldmia	r0!, {s14}
 8043218:	eb06 0383 	add.w	r3, r6, r3, lsl #2
 804321c:	edd3 7a00 	vldr	s15, [r3]
 8043220:	ee77 7a87 	vadd.f32	s15, s15, s14
 8043224:	3201      	adds	r2, #1
 8043226:	4294      	cmp	r4, r2
 8043228:	edc3 7a00 	vstr	s15, [r3]
 804322c:	dcf0      	bgt.n	8043210 <kad_op_max1d+0xc0>
 804322e:	e79f      	b.n	8043170 <kad_op_max1d+0x20>
 8043230:	782f      	ldrb	r7, [r5, #0]
		int *f = (int*)p->gtmp;
 8043232:	6b6e      	ldr	r6, [r5, #52]	@ 0x34
 8043234:	2f00      	cmp	r7, #0
 8043236:	f000 8096 	beq.w	8043366 <kad_op_max1d+0x216>
 804323a:	2f01      	cmp	r7, #1
 804323c:	692a      	ldr	r2, [r5, #16]
 804323e:	f000 808e 	beq.w	804335e <kad_op_max1d+0x20e>
 8043242:	f8d5 c014 	ldr.w	ip, [r5, #20]
 8043246:	2f02      	cmp	r7, #2
 8043248:	fb0c f302 	mul.w	r3, ip, r2
 804324c:	461c      	mov	r4, r3
 804324e:	f000 8090 	beq.w	8043372 <kad_op_max1d+0x222>
 8043252:	f8d5 e018 	ldr.w	lr, [r5, #24]
 8043256:	2f03      	cmp	r7, #3
 8043258:	fb0e f403 	mul.w	r4, lr, r3
 804325c:	f000 8085 	beq.w	804336a <kad_op_max1d+0x21a>
 8043260:	69ea      	ldr	r2, [r5, #28]
 8043262:	fb02 f404 	mul.w	r4, r2, r4
		for (i = 0; i < len; ++i) p->x[i] = -FLT_MAX;
 8043266:	2c00      	cmp	r4, #0
 8043268:	f340 808f 	ble.w	804338a <kad_op_max1d+0x23a>
 804326c:	2300      	movs	r3, #0
 804326e:	f46f 0100 	mvn.w	r1, #8388608	@ 0x800000
 8043272:	6aaa      	ldr	r2, [r5, #40]	@ 0x28
 8043274:	3301      	adds	r3, #1
 8043276:	429c      	cmp	r4, r3
 8043278:	f842 1b04 	str.w	r1, [r2], #4
 804327c:	dcfa      	bgt.n	8043274 <kad_op_max1d+0x124>
		for (i = 0; i < p->n_d - 1; ++i) rest *= p->d[i];
 804327e:	1e79      	subs	r1, r7, #1
 8043280:	2900      	cmp	r1, #0
 8043282:	dd6a      	ble.n	804335a <kad_op_max1d+0x20a>
 8043284:	2901      	cmp	r1, #1
 8043286:	692a      	ldr	r2, [r5, #16]
 8043288:	d00a      	beq.n	80432a0 <kad_op_max1d+0x150>
 804328a:	f8d5 c014 	ldr.w	ip, [r5, #20]
 804328e:	2903      	cmp	r1, #3
 8043290:	fb0c f202 	mul.w	r2, ip, r2
 8043294:	d174      	bne.n	8043380 <kad_op_max1d+0x230>
 8043296:	f8d5 e018 	ldr.w	lr, [r5, #24]
 804329a:	2103      	movs	r1, #3
 804329c:	fb0e f202 	mul.w	r2, lr, r2
		for (t = 0; t < rest; ++t) {
 80432a0:	2a00      	cmp	r2, #0
 80432a2:	f77f af65 	ble.w	8043170 <kad_op_max1d+0x20>
			for (l = 0; l < aux->kernel_size; ++l)
 80432a6:	2300      	movs	r3, #0
			int j, l, p_width = p->d[p->n_d - 1];
 80432a8:	3104      	adds	r1, #4
 80432aa:	f855 c021 	ldr.w	ip, [r5, r1, lsl #2]
			int u = t * p_width, v, v0 = t * q->d[p->n_d - 1], v_end = v0 + q->d[p->n_d - 1];
 80432ae:	f858 9021 	ldr.w	r9, [r8, r1, lsl #2]
 80432b2:	ea4f 048c 	mov.w	r4, ip, lsl #2
 80432b6:	9404      	str	r4, [sp, #16]
 80432b8:	ea4f 0449 	mov.w	r4, r9, lsl #1
 80432bc:	9405      	str	r4, [sp, #20]
			for (l = 0; l < aux->kernel_size; ++l)
 80432be:	46ce      	mov	lr, r9
		for (t = 0; t < rest; ++t) {
 80432c0:	461c      	mov	r4, r3
			for (l = 0; l < aux->kernel_size; ++l)
 80432c2:	6801      	ldr	r1, [r0, #0]
		for (t = 0; t < rest; ++t) {
 80432c4:	f8cd 8000 	str.w	r8, [sp]
 80432c8:	9203      	str	r2, [sp, #12]
			for (l = 0; l < aux->kernel_size; ++l)
 80432ca:	2900      	cmp	r1, #0
 80432cc:	ebae 0809 	sub.w	r8, lr, r9
 80432d0:	f77f af4e 	ble.w	8043170 <kad_op_max1d+0x20>
 80432d4:	2700      	movs	r7, #0
 80432d6:	e9cd 3401 	strd	r3, r4, [sp, #4]
 80432da:	ea4f 0a84 	mov.w	sl, r4, lsl #2
				for (j = 0, v = v0 + (l > aux->pad[0]? l - aux->pad[0] : 0); j < p_width && v < v_end; ++j, v += aux->stride)
 80432de:	6882      	ldr	r2, [r0, #8]
 80432e0:	42ba      	cmp	r2, r7
 80432e2:	bfb3      	iteet	lt
 80432e4:	1aba      	sublt	r2, r7, r2
			int u = t * p_width, v, v0 = t * q->d[p->n_d - 1], v_end = v0 + q->d[p->n_d - 1];
 80432e6:	4643      	movge	r3, r8
				for (j = 0, v = v0 + (l > aux->pad[0]? l - aux->pad[0] : 0); j < p_width && v < v_end; ++j, v += aux->stride)
 80432e8:	2200      	movge	r2, #0
 80432ea:	eb08 0302 	addlt.w	r3, r8, r2
 80432ee:	f1bc 0f00 	cmp.w	ip, #0
 80432f2:	dd1f      	ble.n	8043334 <kad_op_max1d+0x1e4>
 80432f4:	4591      	cmp	r9, r2
 80432f6:	dd1d      	ble.n	8043334 <kad_op_max1d+0x1e4>
 80432f8:	6aa9      	ldr	r1, [r5, #40]	@ 0x28
					if (p->x[u + j] < q->x[v])
 80432fa:	9c00      	ldr	r4, [sp, #0]
				for (j = 0, v = v0 + (l > aux->pad[0]? l - aux->pad[0] : 0); j < p_width && v < v_end; ++j, v += aux->stride)
 80432fc:	2200      	movs	r2, #0
					if (p->x[u + j] < q->x[v])
 80432fe:	f8d4 b028 	ldr.w	fp, [r4, #40]	@ 0x28
 8043302:	4451      	add	r1, sl
 8043304:	e001      	b.n	804330a <kad_op_max1d+0x1ba>
				for (j = 0, v = v0 + (l > aux->pad[0]? l - aux->pad[0] : 0); j < p_width && v < v_end; ++j, v += aux->stride)
 8043306:	4573      	cmp	r3, lr
 8043308:	da13      	bge.n	8043332 <kad_op_max1d+0x1e2>
					if (p->x[u + j] < q->x[v])
 804330a:	eb0b 0483 	add.w	r4, fp, r3, lsl #2
 804330e:	edd4 7a00 	vldr	s15, [r4]
 8043312:	ecb1 7a01 	vldmia	r1!, {s14}
 8043316:	eeb4 7ae7 	vcmpe.f32	s14, s15
 804331a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
						p->x[u + j] = q->x[v], f[u + j] = v;
 804331e:	bf44      	itt	mi
 8043320:	ed41 7a01 	vstrmi	s15, [r1, #-4]
 8043324:	f846 3022 	strmi.w	r3, [r6, r2, lsl #2]
				for (j = 0, v = v0 + (l > aux->pad[0]? l - aux->pad[0] : 0); j < p_width && v < v_end; ++j, v += aux->stride)
 8043328:	6844      	ldr	r4, [r0, #4]
 804332a:	3201      	adds	r2, #1
 804332c:	4594      	cmp	ip, r2
 804332e:	4423      	add	r3, r4
 8043330:	d1e9      	bne.n	8043306 <kad_op_max1d+0x1b6>
 8043332:	6801      	ldr	r1, [r0, #0]
			for (l = 0; l < aux->kernel_size; ++l)
 8043334:	3701      	adds	r7, #1
 8043336:	42b9      	cmp	r1, r7
 8043338:	dcd1      	bgt.n	80432de <kad_op_max1d+0x18e>
 804333a:	e9dd 3401 	ldrd	r3, r4, [sp, #4]
		for (t = 0; t < rest; ++t) {
 804333e:	9a03      	ldr	r2, [sp, #12]
 8043340:	3301      	adds	r3, #1
 8043342:	4293      	cmp	r3, r2
 8043344:	f6bf af14 	bge.w	8043170 <kad_op_max1d+0x20>
 8043348:	9a05      	ldr	r2, [sp, #20]
 804334a:	4464      	add	r4, ip
 804334c:	eb02 0e08 	add.w	lr, r2, r8
 8043350:	9a04      	ldr	r2, [sp, #16]
 8043352:	4416      	add	r6, r2
 8043354:	e7b9      	b.n	80432ca <kad_op_max1d+0x17a>
 8043356:	2104      	movs	r1, #4
 8043358:	e723      	b.n	80431a2 <kad_op_max1d+0x52>
		int rest = 1, len, t, i;
 804335a:	2201      	movs	r2, #1
 804335c:	e7a3      	b.n	80432a6 <kad_op_max1d+0x156>
		for (i = 0; i < len; ++i) p->x[i] = -FLT_MAX;
 804335e:	2a00      	cmp	r2, #0
 8043360:	dd15      	ble.n	804338e <kad_op_max1d+0x23e>
 8043362:	4614      	mov	r4, r2
 8043364:	e782      	b.n	804326c <kad_op_max1d+0x11c>
	int n = 1, i;
 8043366:	2401      	movs	r4, #1
 8043368:	e780      	b.n	804326c <kad_op_max1d+0x11c>
 804336a:	2c00      	cmp	r4, #0
 804336c:	f73f af7e 	bgt.w	804326c <kad_op_max1d+0x11c>
 8043370:	e78d      	b.n	804328e <kad_op_max1d+0x13e>
 8043372:	2b00      	cmp	r3, #0
 8043374:	f73f af7a 	bgt.w	804326c <kad_op_max1d+0x11c>
		for (i = 0; i < p->n_d - 1; ++i) rest *= p->d[i];
 8043378:	2101      	movs	r1, #1
 804337a:	e791      	b.n	80432a0 <kad_op_max1d+0x150>
 804337c:	2401      	movs	r4, #1
 804337e:	e742      	b.n	8043206 <kad_op_max1d+0xb6>
 8043380:	2102      	movs	r1, #2
 8043382:	e78d      	b.n	80432a0 <kad_op_max1d+0x150>
		if (q->n_d != 3) return -1;
 8043384:	f04f 30ff 	mov.w	r0, #4294967295
 8043388:	e6f3      	b.n	8043172 <kad_op_max1d+0x22>
		for (i = 0; i < p->n_d - 1; ++i) rest *= p->d[i];
 804338a:	461a      	mov	r2, r3
 804338c:	e785      	b.n	804329a <kad_op_max1d+0x14a>
		int rest = 1, len, t, i;
 804338e:	463a      	mov	r2, r7
		for (i = 0; i < p->n_d - 1; ++i) rest *= p->d[i];
 8043390:	2100      	movs	r1, #0
 8043392:	e788      	b.n	80432a6 <kad_op_max1d+0x156>

08043394 <kad_op_avg1d>:

int kad_op_avg1d(kad_node_t *p, int action)
{
 8043394:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	conv_conf_t *aux = (conv_conf_t*)p->ptr;
	kad_node_t *q = p->child[0];
 8043398:	6b83      	ldr	r3, [r0, #56]	@ 0x38
	conv_conf_t *aux = (conv_conf_t*)p->ptr;
 804339a:	6b02      	ldr	r2, [r0, #48]	@ 0x30
	kad_node_t *q = p->child[0];
 804339c:	681b      	ldr	r3, [r3, #0]
{
 804339e:	b093      	sub	sp, #76	@ 0x4c
	if (action == KAD_SYNC_DIM) {
 80433a0:	2904      	cmp	r1, #4
{
 80433a2:	4681      	mov	r9, r0
	conv_conf_t *aux = (conv_conf_t*)p->ptr;
 80433a4:	9202      	str	r2, [sp, #8]
	kad_node_t *q = p->child[0];
 80433a6:	9301      	str	r3, [sp, #4]
	if (action == KAD_SYNC_DIM) {
 80433a8:	d028      	beq.n	80433fc <kad_op_avg1d+0x68>
		if (q->n_d != 3) return -1;
		p->n_d = 3;
		p->d[0] = q->d[0], p->d[1] = q->d[1], p->d[2] = conv_out_size(q->d[2], aux);
	} else if (action == KAD_ALLOC) {
 80433aa:	2901      	cmp	r1, #1
 80433ac:	d008      	beq.n	80433c0 <kad_op_avg1d+0x2c>
		p->gtmp = realloc(p->gtmp, kad_len(p) * sizeof(int));
	} else if (action == KAD_FORWARD) {
 80433ae:	2902      	cmp	r1, #2
 80433b0:	f000 8188 	beq.w	80436c4 <kad_op_avg1d+0x330>
			for (l = 0; l < aux->kernel_size; ++l)
				for (j = 0, v = v0 + (l > aux->pad[0]? l - aux->pad[0] : 0); j < p_width && v < v_end; ++j, v += aux->stride)
					p->x[u + j] += q->x[v], ++f[u + j];
		}
		for (i = 0; i < len; ++i) p->x[i] /= f[i];
	} else if (action == KAD_BACKWARD) {
 80433b4:	2903      	cmp	r1, #3
 80433b6:	d03a      	beq.n	804342e <kad_op_avg1d+0x9a>
			for (l = 0; l < aux->kernel_size; ++l)
				for (j = 0, v = v0 + (l > aux->pad[0]? l - aux->pad[0] : 0); j < p_width && v < v_end; ++j, v += aux->stride)
					q->g[v] += p->g[u + j] / f[u + j];
		}
	}
	return 0;
 80433b8:	2000      	movs	r0, #0
}
 80433ba:	b013      	add	sp, #76	@ 0x4c
 80433bc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	for (i = 0; i < p->n_d; ++i) n *= p->d[i];
 80433c0:	7802      	ldrb	r2, [r0, #0]
		p->gtmp = realloc(p->gtmp, kad_len(p) * sizeof(int));
 80433c2:	6b40      	ldr	r0, [r0, #52]	@ 0x34
 80433c4:	2a00      	cmp	r2, #0
 80433c6:	f000 8249 	beq.w	804385c <kad_op_avg1d+0x4c8>
 80433ca:	2a01      	cmp	r2, #1
 80433cc:	f8d9 1010 	ldr.w	r1, [r9, #16]
 80433d0:	d00e      	beq.n	80433f0 <kad_op_avg1d+0x5c>
 80433d2:	f8d9 3014 	ldr.w	r3, [r9, #20]
 80433d6:	2a02      	cmp	r2, #2
 80433d8:	fb03 f101 	mul.w	r1, r3, r1
 80433dc:	d008      	beq.n	80433f0 <kad_op_avg1d+0x5c>
 80433de:	f8d9 3018 	ldr.w	r3, [r9, #24]
 80433e2:	2a03      	cmp	r2, #3
 80433e4:	fb03 f101 	mul.w	r1, r3, r1
 80433e8:	bf1c      	itt	ne
 80433ea:	f8d9 201c 	ldrne.w	r2, [r9, #28]
 80433ee:	4351      	mulne	r1, r2
 80433f0:	0089      	lsls	r1, r1, #2
 80433f2:	f008 fae1 	bl	804b9b8 <realloc>
 80433f6:	f8c9 0034 	str.w	r0, [r9, #52]	@ 0x34
 80433fa:	e7dd      	b.n	80433b8 <kad_op_avg1d+0x24>
		if (q->n_d != 3) return -1;
 80433fc:	4619      	mov	r1, r3
 80433fe:	781b      	ldrb	r3, [r3, #0]
 8043400:	2b03      	cmp	r3, #3
 8043402:	f040 8246 	bne.w	8043892 <kad_op_avg1d+0x4fe>
		p->n_d = 3;
 8043406:	7003      	strb	r3, [r0, #0]
		p->d[0] = q->d[0], p->d[1] = q->d[1], p->d[2] = conv_out_size(q->d[2], aux);
 8043408:	e9d1 2304 	ldrd	r2, r3, [r1, #16]
 804340c:	e9c0 2304 	strd	r2, r3, [r0, #16]
 8043410:	9802      	ldr	r0, [sp, #8]
 8043412:	698b      	ldr	r3, [r1, #24]
 8043414:	6801      	ldr	r1, [r0, #0]
 8043416:	6882      	ldr	r2, [r0, #8]
 8043418:	1a5b      	subs	r3, r3, r1
 804341a:	68c1      	ldr	r1, [r0, #12]
 804341c:	4413      	add	r3, r2
 804341e:	6842      	ldr	r2, [r0, #4]
 8043420:	440b      	add	r3, r1
 8043422:	fb93 f3f2 	sdiv	r3, r3, r2
 8043426:	3301      	adds	r3, #1
 8043428:	f8c9 3018 	str.w	r3, [r9, #24]
 804342c:	e7c4      	b.n	80433b8 <kad_op_avg1d+0x24>
		for (i = 0; i < p->n_d - 1; ++i) rest *= p->d[i];
 804342e:	7803      	ldrb	r3, [r0, #0]
 8043430:	3b01      	subs	r3, #1
 8043432:	2b00      	cmp	r3, #0
 8043434:	f340 822a 	ble.w	804388c <kad_op_avg1d+0x4f8>
 8043438:	2b01      	cmp	r3, #1
 804343a:	f8d0 c010 	ldr.w	ip, [r0, #16]
 804343e:	d00c      	beq.n	804345a <kad_op_avg1d+0xc6>
 8043440:	6942      	ldr	r2, [r0, #20]
 8043442:	2b02      	cmp	r3, #2
 8043444:	fb02 fc0c 	mul.w	ip, r2, ip
 8043448:	d007      	beq.n	804345a <kad_op_avg1d+0xc6>
 804344a:	6982      	ldr	r2, [r0, #24]
 804344c:	2b03      	cmp	r3, #3
 804344e:	fb02 fc0c 	mul.w	ip, r2, ip
 8043452:	bf1c      	itt	ne
 8043454:	69c2      	ldrne	r2, [r0, #28]
 8043456:	fb02 fc0c 	mulne.w	ip, r2, ip
		for (t = 0; t < rest; ++t) {
 804345a:	f1bc 0f00 	cmp.w	ip, #0
 804345e:	ddab      	ble.n	80433b8 <kad_op_avg1d+0x24>
			for (l = 0; l < aux->kernel_size; ++l)
 8043460:	9902      	ldr	r1, [sp, #8]
			int u = t * p_width, v, v0 = t * q->d[p->n_d - 1], v_end = v0 + q->d[p->n_d - 1];
 8043462:	9801      	ldr	r0, [sp, #4]
			for (l = 0; l < aux->kernel_size; ++l)
 8043464:	680a      	ldr	r2, [r1, #0]
			int j, l, p_width = p->d[p->n_d - 1];
 8043466:	3304      	adds	r3, #4
 8043468:	2a00      	cmp	r2, #0
 804346a:	f859 b023 	ldr.w	fp, [r9, r3, lsl #2]
			int u = t * p_width, v, v0 = t * q->d[p->n_d - 1], v_end = v0 + q->d[p->n_d - 1];
 804346e:	f850 8023 	ldr.w	r8, [r0, r3, lsl #2]
			for (l = 0; l < aux->kernel_size; ++l)
 8043472:	9210      	str	r2, [sp, #64]	@ 0x40
 8043474:	4613      	mov	r3, r2
 8043476:	dd9f      	ble.n	80433b8 <kad_op_avg1d+0x24>
				for (j = 0, v = v0 + (l > aux->pad[0]? l - aux->pad[0] : 0); j < p_width && v < v_end; ++j, v += aux->stride)
 8043478:	f8d1 e008 	ldr.w	lr, [r1, #8]
 804347c:	3b01      	subs	r3, #1
 804347e:	4573      	cmp	r3, lr
 8043480:	bfa8      	it	ge
 8043482:	4673      	movge	r3, lr
		for (t = 0; t < rest; ++t) {
 8043484:	4676      	mov	r6, lr
				for (j = 0, v = v0 + (l > aux->pad[0]? l - aux->pad[0] : 0); j < p_width && v < v_end; ++j, v += aux->stride)
 8043486:	2200      	movs	r2, #0
 8043488:	930a      	str	r3, [sp, #40]	@ 0x28
		int *f = (int*)p->gtmp;
 804348a:	f8d9 3034 	ldr.w	r3, [r9, #52]	@ 0x34
 804348e:	2e00      	cmp	r6, #0
 8043490:	f1a3 0304 	sub.w	r3, r3, #4
 8043494:	9311      	str	r3, [sp, #68]	@ 0x44
 8043496:	f1cb 0300 	rsb	r3, fp, #0
 804349a:	9305      	str	r3, [sp, #20]
				for (j = 0, v = v0 + (l > aux->pad[0]? l - aux->pad[0] : 0); j < p_width && v < v_end; ++j, v += aux->stride)
 804349c:	465f      	mov	r7, fp
 804349e:	46c2      	mov	sl, r8
		for (t = 0; t < rest; ++t) {
 80434a0:	4613      	mov	r3, r2
			int u = t * p_width, v, v0 = t * q->d[p->n_d - 1], v_end = v0 + q->d[p->n_d - 1];
 80434a2:	f04f 0e00 	mov.w	lr, #0
				for (j = 0, v = v0 + (l > aux->pad[0]? l - aux->pad[0] : 0); j < p_width && v < v_end; ++j, v += aux->stride)
 80434a6:	9209      	str	r2, [sp, #36]	@ 0x24
		for (t = 0; t < rest; ++t) {
 80434a8:	f8cd 9010 	str.w	r9, [sp, #16]
			for (l = 0; l < aux->kernel_size; ++l)
 80434ac:	da60      	bge.n	8043570 <kad_op_avg1d+0x1dc>
 80434ae:	0091      	lsls	r1, r2, #2
 80434b0:	9103      	str	r1, [sp, #12]
 80434b2:	9909      	ldr	r1, [sp, #36]	@ 0x24
 80434b4:	ebae 0406 	sub.w	r4, lr, r6
 80434b8:	440c      	add	r4, r1
 80434ba:	eb04 000b 	add.w	r0, r4, fp
 80434be:	900c      	str	r0, [sp, #48]	@ 0x30
 80434c0:	9d11      	ldr	r5, [sp, #68]	@ 0x44
 80434c2:	9803      	ldr	r0, [sp, #12]
 80434c4:	e9cd 6c07 	strd	r6, ip, [sp, #28]
 80434c8:	4405      	add	r5, r0
 80434ca:	980c      	ldr	r0, [sp, #48]	@ 0x30
 80434cc:	e9cd 270c 	strd	r2, r7, [sp, #48]	@ 0x30
 80434d0:	f8dd e040 	ldr.w	lr, [sp, #64]	@ 0x40
 80434d4:	9506      	str	r5, [sp, #24]
 80434d6:	eba6 0901 	sub.w	r9, r6, r1
 80434da:	930b      	str	r3, [sp, #44]	@ 0x2c
				for (j = 0, v = v0 + (l > aux->pad[0]? l - aux->pad[0] : 0); j < p_width && v < v_end; ++j, v += aux->stride)
 80434dc:	f1bb 0f00 	cmp.w	fp, #0
 80434e0:	4623      	mov	r3, r4
 80434e2:	dd27      	ble.n	8043534 <kad_op_avg1d+0x1a0>
 80434e4:	9a05      	ldr	r2, [sp, #20]
 80434e6:	1882      	adds	r2, r0, r2
 80434e8:	4590      	cmp	r8, r2
 80434ea:	dd23      	ble.n	8043534 <kad_op_avg1d+0x1a0>
 80434ec:	9a02      	ldr	r2, [sp, #8]
					q->g[v] += p->g[u + j] / f[u + j];
 80434ee:	9904      	ldr	r1, [sp, #16]
				for (j = 0, v = v0 + (l > aux->pad[0]? l - aux->pad[0] : 0); j < p_width && v < v_end; ++j, v += aux->stride)
 80434f0:	6856      	ldr	r6, [r2, #4]
					q->g[v] += p->g[u + j] / f[u + j];
 80434f2:	9a01      	ldr	r2, [sp, #4]
 80434f4:	6ac9      	ldr	r1, [r1, #44]	@ 0x2c
 80434f6:	6ad2      	ldr	r2, [r2, #44]	@ 0x2c
 80434f8:	9d03      	ldr	r5, [sp, #12]
 80434fa:	2e01      	cmp	r6, #1
 80434fc:	eb02 0284 	add.w	r2, r2, r4, lsl #2
 8043500:	4429      	add	r1, r5
 8043502:	f040 8081 	bne.w	8043608 <kad_op_avg1d+0x274>
				for (j = 0, v = v0 + (l > aux->pad[0]? l - aux->pad[0] : 0); j < p_width && v < v_end; ++j, v += aux->stride)
 8043506:	9d06      	ldr	r5, [sp, #24]
 8043508:	e001      	b.n	804350e <kad_op_avg1d+0x17a>
 804350a:	4553      	cmp	r3, sl
 804350c:	da12      	bge.n	8043534 <kad_op_avg1d+0x1a0>
					q->g[v] += p->g[u + j] / f[u + j];
 804350e:	ed95 7a01 	vldr	s14, [r5, #4]
 8043512:	ecb1 6a01 	vldmia	r1!, {s12}
 8043516:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 804351a:	edd2 6a00 	vldr	s13, [r2]
 804351e:	eec6 7a07 	vdiv.f32	s15, s12, s14
 8043522:	ee77 7aa6 	vadd.f32	s15, s15, s13
				for (j = 0, v = v0 + (l > aux->pad[0]? l - aux->pad[0] : 0); j < p_width && v < v_end; ++j, v += aux->stride)
 8043526:	3301      	adds	r3, #1
 8043528:	4283      	cmp	r3, r0
					q->g[v] += p->g[u + j] / f[u + j];
 804352a:	f105 0504 	add.w	r5, r5, #4
 804352e:	ece2 7a01 	vstmia	r2!, {s15}
				for (j = 0, v = v0 + (l > aux->pad[0]? l - aux->pad[0] : 0); j < p_width && v < v_end; ++j, v += aux->stride)
 8043532:	d1ea      	bne.n	804350a <kad_op_avg1d+0x176>
			for (l = 0; l < aux->kernel_size; ++l)
 8043534:	3401      	adds	r4, #1
 8043536:	eb09 0304 	add.w	r3, r9, r4
 804353a:	459e      	cmp	lr, r3
 804353c:	f100 0001 	add.w	r0, r0, #1
 8043540:	dccc      	bgt.n	80434dc <kad_op_avg1d+0x148>
 8043542:	e9dd 6c07 	ldrd	r6, ip, [sp, #28]
 8043546:	e9dd 320b 	ldrd	r3, r2, [sp, #44]	@ 0x2c
 804354a:	9f0d      	ldr	r7, [sp, #52]	@ 0x34
		for (t = 0; t < rest; ++t) {
 804354c:	9909      	ldr	r1, [sp, #36]	@ 0x24
 804354e:	3301      	adds	r3, #1
 8043550:	4441      	add	r1, r8
 8043552:	9109      	str	r1, [sp, #36]	@ 0x24
 8043554:	9905      	ldr	r1, [sp, #20]
 8043556:	459c      	cmp	ip, r3
 8043558:	eba1 0108 	sub.w	r1, r1, r8
 804355c:	9105      	str	r1, [sp, #20]
 804355e:	445a      	add	r2, fp
 8043560:	44c2      	add	sl, r8
 8043562:	4447      	add	r7, r8
 8043564:	f77f af28 	ble.w	80433b8 <kad_op_avg1d+0x24>
			for (l = 0; l < aux->kernel_size; ++l)
 8043568:	2e00      	cmp	r6, #0
			int u = t * p_width, v, v0 = t * q->d[p->n_d - 1], v_end = v0 + q->d[p->n_d - 1];
 804356a:	f04f 0e00 	mov.w	lr, #0
 804356e:	db9e      	blt.n	80434ae <kad_op_avg1d+0x11a>
 8043570:	9909      	ldr	r1, [sp, #36]	@ 0x24
 8043572:	0089      	lsls	r1, r1, #2
 8043574:	910c      	str	r1, [sp, #48]	@ 0x30
 8043576:	0091      	lsls	r1, r2, #2
 8043578:	9103      	str	r1, [sp, #12]
 804357a:	9911      	ldr	r1, [sp, #68]	@ 0x44
 804357c:	eb01 0182 	add.w	r1, r1, r2, lsl #2
 8043580:	910b      	str	r1, [sp, #44]	@ 0x2c
				for (j = 0, v = v0 + (l > aux->pad[0]? l - aux->pad[0] : 0); j < p_width && v < v_end; ++j, v += aux->stride)
 8043582:	f1bb 0f00 	cmp.w	fp, #0
 8043586:	f340 8097 	ble.w	80436b8 <kad_op_avg1d+0x324>
 804358a:	4634      	mov	r4, r6
 804358c:	4618      	mov	r0, r3
 804358e:	4611      	mov	r1, r2
 8043590:	f1b8 0f00 	cmp.w	r8, #0
 8043594:	dd2b      	ble.n	80435ee <kad_op_avg1d+0x25a>
 8043596:	46f1      	mov	r9, lr
 8043598:	9b02      	ldr	r3, [sp, #8]
 804359a:	9a04      	ldr	r2, [sp, #16]
 804359c:	685d      	ldr	r5, [r3, #4]
 804359e:	9b01      	ldr	r3, [sp, #4]
 80435a0:	6ad2      	ldr	r2, [r2, #44]	@ 0x2c
 80435a2:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80435a4:	9108      	str	r1, [sp, #32]
 80435a6:	e9cd 2306 	strd	r2, r3, [sp, #24]
 80435aa:	2d01      	cmp	r5, #1
 80435ac:	d149      	bne.n	8043642 <kad_op_avg1d+0x2ae>
 80435ae:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
 80435b2:	9d0c      	ldr	r5, [sp, #48]	@ 0x30
 80435b4:	46ce      	mov	lr, r9
 80435b6:	442b      	add	r3, r5
 80435b8:	9d03      	ldr	r5, [sp, #12]
 80435ba:	9908      	ldr	r1, [sp, #32]
 80435bc:	442a      	add	r2, r5
 80435be:	9e0b      	ldr	r6, [sp, #44]	@ 0x2c
 80435c0:	9d09      	ldr	r5, [sp, #36]	@ 0x24
 80435c2:	e001      	b.n	80435c8 <kad_op_avg1d+0x234>
 80435c4:	4555      	cmp	r5, sl
 80435c6:	da12      	bge.n	80435ee <kad_op_avg1d+0x25a>
					q->g[v] += p->g[u + j] / f[u + j];
 80435c8:	ed96 7a01 	vldr	s14, [r6, #4]
 80435cc:	ecb2 6a01 	vldmia	r2!, {s12}
 80435d0:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 80435d4:	edd3 6a00 	vldr	s13, [r3]
 80435d8:	eec6 7a07 	vdiv.f32	s15, s12, s14
 80435dc:	ee77 7aa6 	vadd.f32	s15, s15, s13
				for (j = 0, v = v0 + (l > aux->pad[0]? l - aux->pad[0] : 0); j < p_width && v < v_end; ++j, v += aux->stride)
 80435e0:	3501      	adds	r5, #1
 80435e2:	42bd      	cmp	r5, r7
					q->g[v] += p->g[u + j] / f[u + j];
 80435e4:	f106 0604 	add.w	r6, r6, #4
 80435e8:	ece3 7a01 	vstmia	r3!, {s15}
				for (j = 0, v = v0 + (l > aux->pad[0]? l - aux->pad[0] : 0); j < p_width && v < v_end; ++j, v += aux->stride)
 80435ec:	d1ea      	bne.n	80435c4 <kad_op_avg1d+0x230>
			for (l = 0; l < aux->kernel_size; ++l)
 80435ee:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 80435f0:	f10e 0e01 	add.w	lr, lr, #1
 80435f4:	4573      	cmp	r3, lr
 80435f6:	dacb      	bge.n	8043590 <kad_op_avg1d+0x1fc>
 80435f8:	4626      	mov	r6, r4
 80435fa:	4603      	mov	r3, r0
 80435fc:	460a      	mov	r2, r1
 80435fe:	9910      	ldr	r1, [sp, #64]	@ 0x40
 8043600:	4571      	cmp	r1, lr
 8043602:	f73f af56 	bgt.w	80434b2 <kad_op_avg1d+0x11e>
 8043606:	e7a1      	b.n	804354c <kad_op_avg1d+0x1b8>
				for (j = 0, v = v0 + (l > aux->pad[0]? l - aux->pad[0] : 0); j < p_width && v < v_end; ++j, v += aux->stride)
 8043608:	2500      	movs	r5, #0
 804360a:	9f06      	ldr	r7, [sp, #24]
 804360c:	ea4f 0c86 	mov.w	ip, r6, lsl #2
 8043610:	e001      	b.n	8043616 <kad_op_avg1d+0x282>
 8043612:	4553      	cmp	r3, sl
 8043614:	da8e      	bge.n	8043534 <kad_op_avg1d+0x1a0>
					q->g[v] += p->g[u + j] / f[u + j];
 8043616:	ed97 7a01 	vldr	s14, [r7, #4]
 804361a:	ecb1 6a01 	vldmia	r1!, {s12}
 804361e:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 8043622:	edd2 7a00 	vldr	s15, [r2]
 8043626:	eec6 6a07 	vdiv.f32	s13, s12, s14
 804362a:	ee77 7aa6 	vadd.f32	s15, s15, s13
				for (j = 0, v = v0 + (l > aux->pad[0]? l - aux->pad[0] : 0); j < p_width && v < v_end; ++j, v += aux->stride)
 804362e:	3501      	adds	r5, #1
 8043630:	45ab      	cmp	fp, r5
					q->g[v] += p->g[u + j] / f[u + j];
 8043632:	edc2 7a00 	vstr	s15, [r2]
 8043636:	f107 0704 	add.w	r7, r7, #4
				for (j = 0, v = v0 + (l > aux->pad[0]? l - aux->pad[0] : 0); j < p_width && v < v_end; ++j, v += aux->stride)
 804363a:	4433      	add	r3, r6
 804363c:	4462      	add	r2, ip
 804363e:	d1e8      	bne.n	8043612 <kad_op_avg1d+0x27e>
 8043640:	e778      	b.n	8043534 <kad_op_avg1d+0x1a0>
 8043642:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 8043644:	9a0c      	ldr	r2, [sp, #48]	@ 0x30
 8043646:	930e      	str	r3, [sp, #56]	@ 0x38
 8043648:	2300      	movs	r3, #0
 804364a:	930d      	str	r3, [sp, #52]	@ 0x34
 804364c:	9b07      	ldr	r3, [sp, #28]
 804364e:	9903      	ldr	r1, [sp, #12]
 8043650:	4413      	add	r3, r2
 8043652:	9a06      	ldr	r2, [sp, #24]
 8043654:	f8cd 803c 	str.w	r8, [sp, #60]	@ 0x3c
 8043658:	eb02 0e01 	add.w	lr, r2, r1
 804365c:	9e09      	ldr	r6, [sp, #36]	@ 0x24
 804365e:	2200      	movs	r2, #0
 8043660:	990e      	ldr	r1, [sp, #56]	@ 0x38
 8043662:	ea4f 0885 	mov.w	r8, r5, lsl #2
 8043666:	e001      	b.n	804366c <kad_op_avg1d+0x2d8>
 8043668:	4556      	cmp	r6, sl
 804366a:	da20      	bge.n	80436ae <kad_op_avg1d+0x31a>
					q->g[v] += p->g[u + j] / f[u + j];
 804366c:	ed91 7a01 	vldr	s14, [r1, #4]
 8043670:	ecbe 6a01 	vldmia	lr!, {s12}
 8043674:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 8043678:	edd3 7a00 	vldr	s15, [r3]
 804367c:	eec6 6a07 	vdiv.f32	s13, s12, s14
 8043680:	ee77 7aa6 	vadd.f32	s15, s15, s13
				for (j = 0, v = v0 + (l > aux->pad[0]? l - aux->pad[0] : 0); j < p_width && v < v_end; ++j, v += aux->stride)
 8043684:	3201      	adds	r2, #1
 8043686:	4593      	cmp	fp, r2
					q->g[v] += p->g[u + j] / f[u + j];
 8043688:	edc3 7a00 	vstr	s15, [r3]
 804368c:	f101 0104 	add.w	r1, r1, #4
				for (j = 0, v = v0 + (l > aux->pad[0]? l - aux->pad[0] : 0); j < p_width && v < v_end; ++j, v += aux->stride)
 8043690:	442e      	add	r6, r5
 8043692:	4443      	add	r3, r8
 8043694:	d1e8      	bne.n	8043668 <kad_op_avg1d+0x2d4>
			for (l = 0; l < aux->kernel_size; ++l)
 8043696:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 8043698:	f109 0901 	add.w	r9, r9, #1
 804369c:	454b      	cmp	r3, r9
 804369e:	f8dd 803c 	ldr.w	r8, [sp, #60]	@ 0x3c
 80436a2:	da82      	bge.n	80435aa <kad_op_avg1d+0x216>
 80436a4:	4626      	mov	r6, r4
 80436a6:	4603      	mov	r3, r0
 80436a8:	46ce      	mov	lr, r9
 80436aa:	9a08      	ldr	r2, [sp, #32]
 80436ac:	e7a7      	b.n	80435fe <kad_op_avg1d+0x26a>
 80436ae:	46ce      	mov	lr, r9
 80436b0:	f8dd 803c 	ldr.w	r8, [sp, #60]	@ 0x3c
 80436b4:	9908      	ldr	r1, [sp, #32]
 80436b6:	e79a      	b.n	80435ee <kad_op_avg1d+0x25a>
 80436b8:	990a      	ldr	r1, [sp, #40]	@ 0x28
 80436ba:	f10e 0e01 	add.w	lr, lr, #1
 80436be:	458e      	cmp	lr, r1
 80436c0:	dc9d      	bgt.n	80435fe <kad_op_avg1d+0x26a>
 80436c2:	e75e      	b.n	8043582 <kad_op_avg1d+0x1ee>
 80436c4:	7805      	ldrb	r5, [r0, #0]
		int *f = (int*)p->gtmp;
 80436c6:	f8d0 a034 	ldr.w	sl, [r0, #52]	@ 0x34
 80436ca:	2d00      	cmp	r5, #0
 80436cc:	f000 80cf 	beq.w	804386e <kad_op_avg1d+0x4da>
 80436d0:	6904      	ldr	r4, [r0, #16]
 80436d2:	2d01      	cmp	r5, #1
 80436d4:	4620      	mov	r0, r4
 80436d6:	f000 80c5 	beq.w	8043864 <kad_op_avg1d+0x4d0>
 80436da:	f8d9 3014 	ldr.w	r3, [r9, #20]
 80436de:	2d02      	cmp	r5, #2
 80436e0:	fb03 f404 	mul.w	r4, r3, r4
 80436e4:	f000 80cc 	beq.w	8043880 <kad_op_avg1d+0x4ec>
 80436e8:	f8d9 2018 	ldr.w	r2, [r9, #24]
 80436ec:	2d03      	cmp	r5, #3
 80436ee:	fb02 f404 	mul.w	r4, r2, r4
 80436f2:	f000 80c0 	beq.w	8043876 <kad_op_avg1d+0x4e2>
 80436f6:	f8d9 101c 	ldr.w	r1, [r9, #28]
 80436fa:	fb01 f404 	mul.w	r4, r1, r4
		for (i = 0; i < len; ++i) p->x[i] = 0.0f, f[i] = 0;
 80436fe:	2c00      	cmp	r4, #0
 8043700:	f340 80d6 	ble.w	80438b0 <kad_op_avg1d+0x51c>
 8043704:	2c00      	cmp	r4, #0
 8043706:	ea4f 0684 	mov.w	r6, r4, lsl #2
 804370a:	bfd8      	it	le
 804370c:	2604      	movle	r6, #4
 804370e:	f8d9 0028 	ldr.w	r0, [r9, #40]	@ 0x28
 8043712:	eb0a 0306 	add.w	r3, sl, r6
 8043716:	4298      	cmp	r0, r3
 8043718:	d207      	bcs.n	804372a <kad_op_avg1d+0x396>
 804371a:	1983      	adds	r3, r0, r6
 804371c:	459a      	cmp	sl, r3
 804371e:	bf34      	ite	cc
 8043720:	2300      	movcc	r3, #0
 8043722:	2301      	movcs	r3, #1
 8043724:	2b00      	cmp	r3, #0
 8043726:	f000 80b7 	beq.w	8043898 <kad_op_avg1d+0x504>
 804372a:	4632      	mov	r2, r6
 804372c:	2100      	movs	r1, #0
 804372e:	f008 fb45 	bl	804bdbc <memset>
 8043732:	4632      	mov	r2, r6
 8043734:	2100      	movs	r1, #0
 8043736:	4650      	mov	r0, sl
 8043738:	f008 fb40 	bl	804bdbc <memset>
		for (i = 0; i < p->n_d - 1; ++i) rest *= p->d[i];
 804373c:	1e69      	subs	r1, r5, #1
 804373e:	2900      	cmp	r1, #0
 8043740:	f340 808e 	ble.w	8043860 <kad_op_avg1d+0x4cc>
 8043744:	2901      	cmp	r1, #1
 8043746:	f8d9 5010 	ldr.w	r5, [r9, #16]
 804374a:	d00a      	beq.n	8043762 <kad_op_avg1d+0x3ce>
 804374c:	f8d9 3014 	ldr.w	r3, [r9, #20]
 8043750:	2903      	cmp	r1, #3
 8043752:	fb03 f505 	mul.w	r5, r3, r5
 8043756:	f040 808c 	bne.w	8043872 <kad_op_avg1d+0x4de>
 804375a:	f8d9 2018 	ldr.w	r2, [r9, #24]
 804375e:	fb02 f505 	mul.w	r5, r2, r5
		for (t = 0; t < rest; ++t) {
 8043762:	2d00      	cmp	r5, #0
 8043764:	dd62      	ble.n	804382c <kad_op_avg1d+0x498>
			int u = t * p_width, v, v0 = t * q->d[p->n_d - 1], v_end = v0 + q->d[p->n_d - 1];
 8043766:	9a01      	ldr	r2, [sp, #4]
			int j, l, p_width = p->d[p->n_d - 1];
 8043768:	3104      	adds	r1, #4
			int u = t * p_width, v, v0 = t * q->d[p->n_d - 1], v_end = v0 + q->d[p->n_d - 1];
 804376a:	f852 8021 	ldr.w	r8, [r2, r1, lsl #2]
			for (l = 0; l < aux->kernel_size; ++l)
 804376e:	2300      	movs	r3, #0
 8043770:	4647      	mov	r7, r8
 8043772:	9a02      	ldr	r2, [sp, #8]
			int j, l, p_width = p->d[p->n_d - 1];
 8043774:	f859 6021 	ldr.w	r6, [r9, r1, lsl #2]
			for (l = 0; l < aux->kernel_size; ++l)
 8043778:	6811      	ldr	r1, [r2, #0]
 804377a:	ea4f 0048 	mov.w	r0, r8, lsl #1
 804377e:	f1aa 0204 	sub.w	r2, sl, #4
 8043782:	2900      	cmp	r1, #0
 8043784:	9007      	str	r0, [sp, #28]
		for (t = 0; t < rest; ++t) {
 8043786:	9506      	str	r5, [sp, #24]
 8043788:	4618      	mov	r0, r3
 804378a:	e9cd 4a08 	strd	r4, sl, [sp, #32]
 804378e:	9d02      	ldr	r5, [sp, #8]
 8043790:	9205      	str	r2, [sp, #20]
			int u = t * p_width, v, v0 = t * q->d[p->n_d - 1], v_end = v0 + q->d[p->n_d - 1];
 8043792:	eba7 0e08 	sub.w	lr, r7, r8
			for (l = 0; l < aux->kernel_size; ++l)
 8043796:	dd47      	ble.n	8043828 <kad_op_avg1d+0x494>
 8043798:	f04f 0c00 	mov.w	ip, #0
 804379c:	9a05      	ldr	r2, [sp, #20]
 804379e:	ea4f 0a83 	mov.w	sl, r3, lsl #2
 80437a2:	eb02 0283 	add.w	r2, r2, r3, lsl #2
 80437a6:	e9cd 2302 	strd	r2, r3, [sp, #8]
 80437aa:	9004      	str	r0, [sp, #16]
				for (j = 0, v = v0 + (l > aux->pad[0]? l - aux->pad[0] : 0); j < p_width && v < v_end; ++j, v += aux->stride)
 80437ac:	68aa      	ldr	r2, [r5, #8]
 80437ae:	4562      	cmp	r2, ip
 80437b0:	bfb3      	iteet	lt
 80437b2:	ebac 0202 	sublt.w	r2, ip, r2
			int u = t * p_width, v, v0 = t * q->d[p->n_d - 1], v_end = v0 + q->d[p->n_d - 1];
 80437b6:	4673      	movge	r3, lr
				for (j = 0, v = v0 + (l > aux->pad[0]? l - aux->pad[0] : 0); j < p_width && v < v_end; ++j, v += aux->stride)
 80437b8:	2200      	movge	r2, #0
 80437ba:	eb0e 0302 	addlt.w	r3, lr, r2
 80437be:	2e00      	cmp	r6, #0
 80437c0:	dd20      	ble.n	8043804 <kad_op_avg1d+0x470>
 80437c2:	4590      	cmp	r8, r2
 80437c4:	dd1e      	ble.n	8043804 <kad_op_avg1d+0x470>
 80437c6:	f8d9 2028 	ldr.w	r2, [r9, #40]	@ 0x28
					p->x[u + j] += q->x[v], ++f[u + j];
 80437ca:	9c01      	ldr	r4, [sp, #4]
				for (j = 0, v = v0 + (l > aux->pad[0]? l - aux->pad[0] : 0); j < p_width && v < v_end; ++j, v += aux->stride)
 80437cc:	2100      	movs	r1, #0
					p->x[u + j] += q->x[v], ++f[u + j];
 80437ce:	9802      	ldr	r0, [sp, #8]
 80437d0:	f8d4 b028 	ldr.w	fp, [r4, #40]	@ 0x28
 80437d4:	4452      	add	r2, sl
 80437d6:	e001      	b.n	80437dc <kad_op_avg1d+0x448>
				for (j = 0, v = v0 + (l > aux->pad[0]? l - aux->pad[0] : 0); j < p_width && v < v_end; ++j, v += aux->stride)
 80437d8:	42bb      	cmp	r3, r7
 80437da:	da12      	bge.n	8043802 <kad_op_avg1d+0x46e>
					p->x[u + j] += q->x[v], ++f[u + j];
 80437dc:	eb0b 0483 	add.w	r4, fp, r3, lsl #2
 80437e0:	edd4 7a00 	vldr	s15, [r4]
 80437e4:	ed92 7a00 	vldr	s14, [r2]
 80437e8:	ee77 7a87 	vadd.f32	s15, s15, s14
 80437ec:	f850 4f04 	ldr.w	r4, [r0, #4]!
 80437f0:	ece2 7a01 	vstmia	r2!, {s15}
 80437f4:	3401      	adds	r4, #1
 80437f6:	6004      	str	r4, [r0, #0]
				for (j = 0, v = v0 + (l > aux->pad[0]? l - aux->pad[0] : 0); j < p_width && v < v_end; ++j, v += aux->stride)
 80437f8:	686c      	ldr	r4, [r5, #4]
 80437fa:	3101      	adds	r1, #1
 80437fc:	428e      	cmp	r6, r1
 80437fe:	4423      	add	r3, r4
 8043800:	d1ea      	bne.n	80437d8 <kad_op_avg1d+0x444>
 8043802:	6829      	ldr	r1, [r5, #0]
			for (l = 0; l < aux->kernel_size; ++l)
 8043804:	f10c 0c01 	add.w	ip, ip, #1
 8043808:	4561      	cmp	r1, ip
 804380a:	dccf      	bgt.n	80437ac <kad_op_avg1d+0x418>
 804380c:	e9dd 3003 	ldrd	r3, r0, [sp, #12]
		for (t = 0; t < rest; ++t) {
 8043810:	9a06      	ldr	r2, [sp, #24]
 8043812:	3001      	adds	r0, #1
 8043814:	4290      	cmp	r0, r2
 8043816:	da07      	bge.n	8043828 <kad_op_avg1d+0x494>
 8043818:	9a07      	ldr	r2, [sp, #28]
			for (l = 0; l < aux->kernel_size; ++l)
 804381a:	2900      	cmp	r1, #0
 804381c:	eb02 070e 	add.w	r7, r2, lr
			int u = t * p_width, v, v0 = t * q->d[p->n_d - 1], v_end = v0 + q->d[p->n_d - 1];
 8043820:	4433      	add	r3, r6
 8043822:	eba7 0e08 	sub.w	lr, r7, r8
			for (l = 0; l < aux->kernel_size; ++l)
 8043826:	dcb7      	bgt.n	8043798 <kad_op_avg1d+0x404>
 8043828:	e9dd 4a08 	ldrd	r4, sl, [sp, #32]
		for (i = 0; i < len; ++i) p->x[i] /= f[i];
 804382c:	2c00      	cmp	r4, #0
 804382e:	f77f adc3 	ble.w	80433b8 <kad_op_avg1d+0x24>
 8043832:	f8d9 3028 	ldr.w	r3, [r9, #40]	@ 0x28
 8043836:	f1aa 0a04 	sub.w	sl, sl, #4
 804383a:	eb03 0984 	add.w	r9, r3, r4, lsl #2
 804383e:	edda 7a01 	vldr	s15, [sl, #4]
 8043842:	edd3 6a00 	vldr	s13, [r3]
 8043846:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 804384a:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 804384e:	eca3 7a01 	vstmia	r3!, {s14}
 8043852:	454b      	cmp	r3, r9
 8043854:	f10a 0a04 	add.w	sl, sl, #4
 8043858:	d1f1      	bne.n	804383e <kad_op_avg1d+0x4aa>
 804385a:	e5ad      	b.n	80433b8 <kad_op_avg1d+0x24>
 804385c:	2104      	movs	r1, #4
 804385e:	e5c8      	b.n	80433f2 <kad_op_avg1d+0x5e>
		int rest = 1, len, t, i;
 8043860:	2501      	movs	r5, #1
 8043862:	e780      	b.n	8043766 <kad_op_avg1d+0x3d2>
		for (i = 0; i < len; ++i) p->x[i] = 0.0f, f[i] = 0;
 8043864:	2c00      	cmp	r4, #0
 8043866:	f73f af4d 	bgt.w	8043704 <kad_op_avg1d+0x370>
		for (i = 0; i < p->n_d - 1; ++i) rest *= p->d[i];
 804386a:	2100      	movs	r1, #0
 804386c:	e77b      	b.n	8043766 <kad_op_avg1d+0x3d2>
	int n = 1, i;
 804386e:	2401      	movs	r4, #1
 8043870:	e748      	b.n	8043704 <kad_op_avg1d+0x370>
 8043872:	2102      	movs	r1, #2
 8043874:	e775      	b.n	8043762 <kad_op_avg1d+0x3ce>
		for (i = 0; i < len; ++i) p->x[i] = 0.0f, f[i] = 0;
 8043876:	2c00      	cmp	r4, #0
 8043878:	f73f af44 	bgt.w	8043704 <kad_op_avg1d+0x370>
		for (i = 0; i < p->n_d - 1; ++i) rest *= p->d[i];
 804387c:	4605      	mov	r5, r0
 804387e:	e767      	b.n	8043750 <kad_op_avg1d+0x3bc>
		for (i = 0; i < len; ++i) p->x[i] = 0.0f, f[i] = 0;
 8043880:	2c00      	cmp	r4, #0
 8043882:	f73f af3f 	bgt.w	8043704 <kad_op_avg1d+0x370>
		for (i = 0; i < p->n_d - 1; ++i) rest *= p->d[i];
 8043886:	4605      	mov	r5, r0
 8043888:	2101      	movs	r1, #1
 804388a:	e76a      	b.n	8043762 <kad_op_avg1d+0x3ce>
		int rest = 1, t, i;
 804388c:	f04f 0c01 	mov.w	ip, #1
 8043890:	e5e6      	b.n	8043460 <kad_op_avg1d+0xcc>
		if (q->n_d != 3) return -1;
 8043892:	f04f 30ff 	mov.w	r0, #4294967295
 8043896:	e590      	b.n	80433ba <kad_op_avg1d+0x26>
		for (i = 0; i < len; ++i) p->x[i] = 0.0f, f[i] = 0;
 8043898:	2600      	movs	r6, #0
 804389a:	4619      	mov	r1, r3
 804389c:	f1aa 0204 	sub.w	r2, sl, #4
 80438a0:	3301      	adds	r3, #1
 80438a2:	429c      	cmp	r4, r3
 80438a4:	f840 6b04 	str.w	r6, [r0], #4
 80438a8:	f842 1f04 	str.w	r1, [r2, #4]!
 80438ac:	dcf8      	bgt.n	80438a0 <kad_op_avg1d+0x50c>
 80438ae:	e745      	b.n	804373c <kad_op_avg1d+0x3a8>
		for (i = 0; i < p->n_d - 1; ++i) rest *= p->d[i];
 80438b0:	1e69      	subs	r1, r5, #1
 80438b2:	fb03 f500 	mul.w	r5, r3, r0
 80438b6:	e752      	b.n	804375e <kad_op_avg1d+0x3ca>

080438b8 <kad_op_reduce_sum>:
{
 80438b8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	kad_node_t *q = p->child[0];
 80438bc:	6b82      	ldr	r2, [r0, #56]	@ 0x38
	assert(p->ptr);
 80438be:	6b03      	ldr	r3, [r0, #48]	@ 0x30
	kad_node_t *q = p->child[0];
 80438c0:	f8d2 9000 	ldr.w	r9, [r2]
{
 80438c4:	b083      	sub	sp, #12
	assert(p->ptr);
 80438c6:	2b00      	cmp	r3, #0
 80438c8:	f000 8158 	beq.w	8043b7c <kad_op_reduce_sum+0x2c4>
	axis = *(int32_t*)p->ptr;
 80438cc:	681d      	ldr	r5, [r3, #0]
	if (axis < 0 || axis >= q->n_d) return -1;
 80438ce:	2d00      	cmp	r5, #0
 80438d0:	f2c0 8145 	blt.w	8043b5e <kad_op_reduce_sum+0x2a6>
 80438d4:	f899 3000 	ldrb.w	r3, [r9]
 80438d8:	42ab      	cmp	r3, r5
 80438da:	f340 8140 	ble.w	8043b5e <kad_op_reduce_sum+0x2a6>
	for (i = 0, d0 = 1; i < axis; ++i) d0 *= q->d[i];
 80438de:	4680      	mov	r8, r0
 80438e0:	2d00      	cmp	r5, #0
 80438e2:	f000 80ca 	beq.w	8043a7a <kad_op_reduce_sum+0x1c2>
 80438e6:	2d01      	cmp	r5, #1
 80438e8:	f8d9 6010 	ldr.w	r6, [r9, #16]
 80438ec:	d00f      	beq.n	804390e <kad_op_reduce_sum+0x56>
 80438ee:	f8d9 2014 	ldr.w	r2, [r9, #20]
 80438f2:	2d02      	cmp	r5, #2
 80438f4:	fb02 f606 	mul.w	r6, r2, r6
 80438f8:	d009      	beq.n	804390e <kad_op_reduce_sum+0x56>
 80438fa:	f8d9 2018 	ldr.w	r2, [r9, #24]
 80438fe:	2d03      	cmp	r5, #3
 8043900:	fb02 f606 	mul.w	r6, r2, r6
 8043904:	d003      	beq.n	804390e <kad_op_reduce_sum+0x56>
 8043906:	f8d9 201c 	ldr.w	r2, [r9, #28]
 804390a:	fb02 f606 	mul.w	r6, r2, r6
	for (i = axis + 1, d1 = 1; i < q->n_d; ++i) d1 *= q->d[i];
 804390e:	1c6a      	adds	r2, r5, #1
 8043910:	4293      	cmp	r3, r2
 8043912:	f340 8091 	ble.w	8043a38 <kad_op_reduce_sum+0x180>
 8043916:	1caa      	adds	r2, r5, #2
 8043918:	eb09 0085 	add.w	r0, r9, r5, lsl #2
 804391c:	4293      	cmp	r3, r2
 804391e:	6944      	ldr	r4, [r0, #20]
 8043920:	dd08      	ble.n	8043934 <kad_op_reduce_sum+0x7c>
 8043922:	6982      	ldr	r2, [r0, #24]
 8043924:	fb02 f404 	mul.w	r4, r2, r4
 8043928:	1cea      	adds	r2, r5, #3
 804392a:	4293      	cmp	r3, r2
 804392c:	dd02      	ble.n	8043934 <kad_op_reduce_sum+0x7c>
 804392e:	69c2      	ldr	r2, [r0, #28]
 8043930:	fb02 f404 	mul.w	r4, r2, r4
	if (action == KAD_SYNC_DIM) {
 8043934:	2904      	cmp	r1, #4
 8043936:	d060      	beq.n	80439fa <kad_op_reduce_sum+0x142>
	} else if (action == KAD_FORWARD) {
 8043938:	2902      	cmp	r1, #2
 804393a:	d006      	beq.n	804394a <kad_op_reduce_sum+0x92>
	} else if (action == KAD_BACKWARD && kad_is_back(q)) {
 804393c:	2903      	cmp	r1, #3
 804393e:	f000 809e 	beq.w	8043a7e <kad_op_reduce_sum+0x1c6>
	return 0;
 8043942:	2000      	movs	r0, #0
}
 8043944:	b003      	add	sp, #12
 8043946:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	for (i = 0; i < p->n_d; ++i) n *= p->d[i];
 804394a:	f898 2000 	ldrb.w	r2, [r8]
		memset(p->x, 0, kad_len(p) * sizeof(float));
 804394e:	f8d8 0028 	ldr.w	r0, [r8, #40]	@ 0x28
 8043952:	2a00      	cmp	r2, #0
 8043954:	f000 80fd 	beq.w	8043b52 <kad_op_reduce_sum+0x29a>
 8043958:	2a01      	cmp	r2, #1
 804395a:	f8d8 3010 	ldr.w	r3, [r8, #16]
 804395e:	d00e      	beq.n	804397e <kad_op_reduce_sum+0xc6>
 8043960:	f8d8 1014 	ldr.w	r1, [r8, #20]
 8043964:	2a02      	cmp	r2, #2
 8043966:	fb01 f303 	mul.w	r3, r1, r3
 804396a:	d008      	beq.n	804397e <kad_op_reduce_sum+0xc6>
 804396c:	f8d8 1018 	ldr.w	r1, [r8, #24]
 8043970:	2a03      	cmp	r2, #3
 8043972:	fb01 f303 	mul.w	r3, r1, r3
 8043976:	bf1c      	itt	ne
 8043978:	f8d8 201c 	ldrne.w	r2, [r8, #28]
 804397c:	4353      	mulne	r3, r2
 804397e:	009a      	lsls	r2, r3, #2
 8043980:	2100      	movs	r1, #0
 8043982:	f008 fa1b 	bl	804bdbc <memset>
		for (i = 0; i < d0; ++i)
 8043986:	2e00      	cmp	r6, #0
 8043988:	dddb      	ble.n	8043942 <kad_op_reduce_sum+0x8a>
			for (j = 0; j < q->d[axis]; ++j)
 804398a:	3504      	adds	r5, #4
 804398c:	f859 e025 	ldr.w	lr, [r9, r5, lsl #2]
 8043990:	f1be 0f00 	cmp.w	lr, #0
 8043994:	ddd5      	ble.n	8043942 <kad_op_reduce_sum+0x8a>
 8043996:	2c00      	cmp	r4, #0
 8043998:	ddd3      	ble.n	8043942 <kad_op_reduce_sum+0x8a>
					p->x[i * d1 + k] += q->x[(i * q->d[axis] + j) * d1 + k];
 804399a:	2300      	movs	r3, #0
 804399c:	00a2      	lsls	r2, r4, #2
 804399e:	4692      	mov	sl, r2
 80439a0:	f8d8 b028 	ldr.w	fp, [r8, #40]	@ 0x28
 80439a4:	f8d9 7028 	ldr.w	r7, [r9, #40]	@ 0x28
 80439a8:	9201      	str	r2, [sp, #4]
 80439aa:	4699      	mov	r9, r3
		for (i = 0; i < d0; ++i)
 80439ac:	4698      	mov	r8, r3
 80439ae:	4632      	mov	r2, r6
			for (j = 0; j < q->d[axis]; ++j)
 80439b0:	2600      	movs	r6, #0
 80439b2:	fb04 f509 	mul.w	r5, r4, r9
 80439b6:	eb0b 0c83 	add.w	ip, fp, r3, lsl #2
 80439ba:	eb0b 000a 	add.w	r0, fp, sl
 80439be:	f8cd b000 	str.w	fp, [sp]
 80439c2:	4661      	mov	r1, ip
 80439c4:	eb07 0b85 	add.w	fp, r7, r5, lsl #2
					p->x[i * d1 + k] += q->x[(i * q->d[axis] + j) * d1 + k];
 80439c8:	edd1 7a00 	vldr	s15, [r1]
 80439cc:	ecbb 7a01 	vldmia	fp!, {s14}
 80439d0:	ee77 7a87 	vadd.f32	s15, s15, s14
 80439d4:	ece1 7a01 	vstmia	r1!, {s15}
				for (k = 0; k < d1; ++k)
 80439d8:	4281      	cmp	r1, r0
 80439da:	d1f5      	bne.n	80439c8 <kad_op_reduce_sum+0x110>
			for (j = 0; j < q->d[axis]; ++j)
 80439dc:	3601      	adds	r6, #1
 80439de:	4576      	cmp	r6, lr
 80439e0:	4425      	add	r5, r4
 80439e2:	d1ee      	bne.n	80439c2 <kad_op_reduce_sum+0x10a>
		for (i = 0; i < d0; ++i)
 80439e4:	9901      	ldr	r1, [sp, #4]
 80439e6:	f108 0801 	add.w	r8, r8, #1
 80439ea:	4590      	cmp	r8, r2
 80439ec:	f8dd b000 	ldr.w	fp, [sp]
 80439f0:	44f1      	add	r9, lr
 80439f2:	4423      	add	r3, r4
 80439f4:	448a      	add	sl, r1
 80439f6:	d1db      	bne.n	80439b0 <kad_op_reduce_sum+0xf8>
 80439f8:	e7a3      	b.n	8043942 <kad_op_reduce_sum+0x8a>
		p->n_d = q->n_d - 1;
 80439fa:	3b01      	subs	r3, #1
 80439fc:	f888 3000 	strb.w	r3, [r8]
		for (i = j = 0; i < q->n_d; ++i)
 8043a00:	f899 3000 	ldrb.w	r3, [r9]
 8043a04:	2b00      	cmp	r3, #0
 8043a06:	d09c      	beq.n	8043942 <kad_op_reduce_sum+0x8a>
			if (i != axis) p->d[j++] = q->d[i];
 8043a08:	b1c5      	cbz	r5, 8043a3c <kad_op_reduce_sum+0x184>
 8043a0a:	f8d9 2010 	ldr.w	r2, [r9, #16]
		for (i = j = 0; i < q->n_d; ++i)
 8043a0e:	2b01      	cmp	r3, #1
			if (i != axis) p->d[j++] = q->d[i];
 8043a10:	f8c8 2010 	str.w	r2, [r8, #16]
		for (i = j = 0; i < q->n_d; ++i)
 8043a14:	d095      	beq.n	8043942 <kad_op_reduce_sum+0x8a>
			if (i != axis) p->d[j++] = q->d[i];
 8043a16:	2d01      	cmp	r5, #1
 8043a18:	d16e      	bne.n	8043af8 <kad_op_reduce_sum+0x240>
		for (i = j = 0; i < q->n_d; ++i)
 8043a1a:	2b02      	cmp	r3, #2
 8043a1c:	d091      	beq.n	8043942 <kad_op_reduce_sum+0x8a>
			if (i != axis) p->d[j++] = q->d[i];
 8043a1e:	f8d9 2018 	ldr.w	r2, [r9, #24]
		for (i = j = 0; i < q->n_d; ++i)
 8043a22:	2b03      	cmp	r3, #3
			if (i != axis) p->d[j++] = q->d[i];
 8043a24:	f8c8 2014 	str.w	r2, [r8, #20]
		for (i = j = 0; i < q->n_d; ++i)
 8043a28:	d08b      	beq.n	8043942 <kad_op_reduce_sum+0x8a>
			if (i != axis) p->d[j++] = q->d[i];
 8043a2a:	f8d9 201c 	ldr.w	r2, [r9, #28]
		for (i = j = 0; i < q->n_d; ++i)
 8043a2e:	2b04      	cmp	r3, #4
			if (i != axis) p->d[j++] = q->d[i];
 8043a30:	f8c8 2018 	str.w	r2, [r8, #24]
		for (i = j = 0; i < q->n_d; ++i)
 8043a34:	d173      	bne.n	8043b1e <kad_op_reduce_sum+0x266>
 8043a36:	e784      	b.n	8043942 <kad_op_reduce_sum+0x8a>
	for (i = axis + 1, d1 = 1; i < q->n_d; ++i) d1 *= q->d[i];
 8043a38:	2401      	movs	r4, #1
 8043a3a:	e77b      	b.n	8043934 <kad_op_reduce_sum+0x7c>
		for (i = j = 0; i < q->n_d; ++i)
 8043a3c:	2b01      	cmp	r3, #1
 8043a3e:	d080      	beq.n	8043942 <kad_op_reduce_sum+0x8a>
			if (i != axis) p->d[j++] = q->d[i];
 8043a40:	f8d9 2014 	ldr.w	r2, [r9, #20]
		for (i = j = 0; i < q->n_d; ++i)
 8043a44:	2b02      	cmp	r3, #2
			if (i != axis) p->d[j++] = q->d[i];
 8043a46:	f8c8 2010 	str.w	r2, [r8, #16]
		for (i = j = 0; i < q->n_d; ++i)
 8043a4a:	f43f af7a 	beq.w	8043942 <kad_op_reduce_sum+0x8a>
			if (i != axis) p->d[j++] = q->d[i];
 8043a4e:	f8d9 2018 	ldr.w	r2, [r9, #24]
		for (i = j = 0; i < q->n_d; ++i)
 8043a52:	2b03      	cmp	r3, #3
			if (i != axis) p->d[j++] = q->d[i];
 8043a54:	f8c8 2014 	str.w	r2, [r8, #20]
 8043a58:	bf18      	it	ne
 8043a5a:	2202      	movne	r2, #2
		for (i = j = 0; i < q->n_d; ++i)
 8043a5c:	f43f af71 	beq.w	8043942 <kad_op_reduce_sum+0x8a>
			if (i != axis) p->d[j++] = q->d[i];
 8043a60:	f8d9 001c 	ldr.w	r0, [r9, #28]
 8043a64:	1d11      	adds	r1, r2, #4
		for (i = j = 0; i < q->n_d; ++i)
 8043a66:	2b04      	cmp	r3, #4
			if (i != axis) p->d[j++] = q->d[i];
 8043a68:	f848 0021 	str.w	r0, [r8, r1, lsl #2]
 8043a6c:	f102 0201 	add.w	r2, r2, #1
		for (i = j = 0; i < q->n_d; ++i)
 8043a70:	f77f af67 	ble.w	8043942 <kad_op_reduce_sum+0x8a>
			if (i != axis) p->d[j++] = q->d[i];
 8043a74:	2d04      	cmp	r5, #4
 8043a76:	d059      	beq.n	8043b2c <kad_op_reduce_sum+0x274>
 8043a78:	e052      	b.n	8043b20 <kad_op_reduce_sum+0x268>
	for (i = 0, d0 = 1; i < axis; ++i) d0 *= q->d[i];
 8043a7a:	2601      	movs	r6, #1
 8043a7c:	e747      	b.n	804390e <kad_op_reduce_sum+0x56>
	} else if (action == KAD_BACKWARD && kad_is_back(q)) {
 8043a7e:	f899 3001 	ldrb.w	r3, [r9, #1]
 8043a82:	07db      	lsls	r3, r3, #31
 8043a84:	f57f af5d 	bpl.w	8043942 <kad_op_reduce_sum+0x8a>
		for (i = 0; i < d0; ++i)
 8043a88:	2e00      	cmp	r6, #0
 8043a8a:	f77f af5a 	ble.w	8043942 <kad_op_reduce_sum+0x8a>
			for (j = 0; j < q->d[axis]; ++j)
 8043a8e:	3504      	adds	r5, #4
 8043a90:	f859 7025 	ldr.w	r7, [r9, r5, lsl #2]
 8043a94:	2f00      	cmp	r7, #0
 8043a96:	f77f af54 	ble.w	8043942 <kad_op_reduce_sum+0x8a>
 8043a9a:	2c00      	cmp	r4, #0
 8043a9c:	f77f af51 	ble.w	8043942 <kad_op_reduce_sum+0x8a>
					q->g[(i * q->d[axis] + j) * d1 + k] += p->g[i * d1 + k];
 8043aa0:	2300      	movs	r3, #0
 8043aa2:	f8d9 e02c 	ldr.w	lr, [r9, #44]	@ 0x2c
		for (i = 0; i < d0; ++i)
 8043aa6:	461a      	mov	r2, r3
					q->g[(i * q->d[axis] + j) * d1 + k] += p->g[i * d1 + k];
 8043aa8:	4699      	mov	r9, r3
 8043aaa:	f8d8 a02c 	ldr.w	sl, [r8, #44]	@ 0x2c
 8043aae:	eb0e 0884 	add.w	r8, lr, r4, lsl #2
 8043ab2:	f8cd a000 	str.w	sl, [sp]
			for (j = 0; j < q->d[axis]; ++j)
 8043ab6:	f04f 0a00 	mov.w	sl, #0
 8043aba:	fb04 fc09 	mul.w	ip, r4, r9
 8043abe:	9900      	ldr	r1, [sp, #0]
 8043ac0:	eb01 0b83 	add.w	fp, r1, r3, lsl #2
		for (i = 0; i < d0; ++i)
 8043ac4:	4658      	mov	r0, fp
 8043ac6:	eb0e 018c 	add.w	r1, lr, ip, lsl #2
 8043aca:	eb08 058c 	add.w	r5, r8, ip, lsl #2
					q->g[(i * q->d[axis] + j) * d1 + k] += p->g[i * d1 + k];
 8043ace:	edd1 7a00 	vldr	s15, [r1]
 8043ad2:	ecb0 7a01 	vldmia	r0!, {s14}
 8043ad6:	ee77 7a87 	vadd.f32	s15, s15, s14
 8043ada:	ece1 7a01 	vstmia	r1!, {s15}
				for (k = 0; k < d1; ++k)
 8043ade:	428d      	cmp	r5, r1
 8043ae0:	d1f5      	bne.n	8043ace <kad_op_reduce_sum+0x216>
			for (j = 0; j < q->d[axis]; ++j)
 8043ae2:	f10a 0a01 	add.w	sl, sl, #1
 8043ae6:	45ba      	cmp	sl, r7
 8043ae8:	44a4      	add	ip, r4
 8043aea:	d1eb      	bne.n	8043ac4 <kad_op_reduce_sum+0x20c>
		for (i = 0; i < d0; ++i)
 8043aec:	3201      	adds	r2, #1
 8043aee:	42b2      	cmp	r2, r6
 8043af0:	44b9      	add	r9, r7
 8043af2:	4423      	add	r3, r4
 8043af4:	d1df      	bne.n	8043ab6 <kad_op_reduce_sum+0x1fe>
 8043af6:	e724      	b.n	8043942 <kad_op_reduce_sum+0x8a>
			if (i != axis) p->d[j++] = q->d[i];
 8043af8:	f8d9 2014 	ldr.w	r2, [r9, #20]
		for (i = j = 0; i < q->n_d; ++i)
 8043afc:	2b02      	cmp	r3, #2
			if (i != axis) p->d[j++] = q->d[i];
 8043afe:	f8c8 2014 	str.w	r2, [r8, #20]
		for (i = j = 0; i < q->n_d; ++i)
 8043b02:	f43f af1e 	beq.w	8043942 <kad_op_reduce_sum+0x8a>
			if (i != axis) p->d[j++] = q->d[i];
 8043b06:	2d02      	cmp	r5, #2
 8043b08:	d12c      	bne.n	8043b64 <kad_op_reduce_sum+0x2ac>
		for (i = j = 0; i < q->n_d; ++i)
 8043b0a:	2b03      	cmp	r3, #3
 8043b0c:	f43f af19 	beq.w	8043942 <kad_op_reduce_sum+0x8a>
			if (i != axis) p->d[j++] = q->d[i];
 8043b10:	f8d9 201c 	ldr.w	r2, [r9, #28]
		for (i = j = 0; i < q->n_d; ++i)
 8043b14:	2b04      	cmp	r3, #4
			if (i != axis) p->d[j++] = q->d[i];
 8043b16:	f8c8 2018 	str.w	r2, [r8, #24]
		for (i = j = 0; i < q->n_d; ++i)
 8043b1a:	f43f af12 	beq.w	8043942 <kad_op_reduce_sum+0x8a>
			if (i != axis) p->d[j++] = q->d[i];
 8043b1e:	2203      	movs	r2, #3
 8043b20:	f8d9 0020 	ldr.w	r0, [r9, #32]
 8043b24:	1d11      	adds	r1, r2, #4
 8043b26:	f848 0021 	str.w	r0, [r8, r1, lsl #2]
 8043b2a:	3201      	adds	r2, #1
		for (i = j = 0; i < q->n_d; ++i)
 8043b2c:	2b05      	cmp	r3, #5
 8043b2e:	f77f af08 	ble.w	8043942 <kad_op_reduce_sum+0x8a>
 8043b32:	2105      	movs	r1, #5
			if (i != axis) p->d[j++] = q->d[i];
 8043b34:	42a9      	cmp	r1, r5
 8043b36:	d00e      	beq.n	8043b56 <kad_op_reduce_sum+0x29e>
 8043b38:	f109 0010 	add.w	r0, r9, #16
 8043b3c:	f850 4021 	ldr.w	r4, [r0, r1, lsl #2]
		for (i = j = 0; i < q->n_d; ++i)
 8043b40:	3101      	adds	r1, #1
			if (i != axis) p->d[j++] = q->d[i];
 8043b42:	1d10      	adds	r0, r2, #4
		for (i = j = 0; i < q->n_d; ++i)
 8043b44:	4299      	cmp	r1, r3
			if (i != axis) p->d[j++] = q->d[i];
 8043b46:	f848 4020 	str.w	r4, [r8, r0, lsl #2]
 8043b4a:	f102 0201 	add.w	r2, r2, #1
		for (i = j = 0; i < q->n_d; ++i)
 8043b4e:	dbf1      	blt.n	8043b34 <kad_op_reduce_sum+0x27c>
 8043b50:	e6f7      	b.n	8043942 <kad_op_reduce_sum+0x8a>
 8043b52:	2204      	movs	r2, #4
 8043b54:	e714      	b.n	8043980 <kad_op_reduce_sum+0xc8>
 8043b56:	3101      	adds	r1, #1
 8043b58:	4299      	cmp	r1, r3
 8043b5a:	dbeb      	blt.n	8043b34 <kad_op_reduce_sum+0x27c>
 8043b5c:	e6f1      	b.n	8043942 <kad_op_reduce_sum+0x8a>
	if (axis < 0 || axis >= q->n_d) return -1;
 8043b5e:	f04f 30ff 	mov.w	r0, #4294967295
 8043b62:	e6ef      	b.n	8043944 <kad_op_reduce_sum+0x8c>
			if (i != axis) p->d[j++] = q->d[i];
 8043b64:	f8d9 2018 	ldr.w	r2, [r9, #24]
		for (i = j = 0; i < q->n_d; ++i)
 8043b68:	2b03      	cmp	r3, #3
			if (i != axis) p->d[j++] = q->d[i];
 8043b6a:	f8c8 2018 	str.w	r2, [r8, #24]
		for (i = j = 0; i < q->n_d; ++i)
 8043b6e:	f43f aee8 	beq.w	8043942 <kad_op_reduce_sum+0x8a>
			if (i != axis) p->d[j++] = q->d[i];
 8043b72:	2d03      	cmp	r5, #3
 8043b74:	d109      	bne.n	8043b8a <kad_op_reduce_sum+0x2d2>
		for (i = j = 0; i < q->n_d; ++i)
 8043b76:	2b04      	cmp	r3, #4
 8043b78:	d1d1      	bne.n	8043b1e <kad_op_reduce_sum+0x266>
 8043b7a:	e6e2      	b.n	8043942 <kad_op_reduce_sum+0x8a>
	assert(p->ptr);
 8043b7c:	f240 41e3 	movw	r1, #1251	@ 0x4e3
 8043b80:	4b03      	ldr	r3, [pc, #12]	@ (8043b90 <kad_op_reduce_sum+0x2d8>)
 8043b82:	4a04      	ldr	r2, [pc, #16]	@ (8043b94 <kad_op_reduce_sum+0x2dc>)
 8043b84:	4804      	ldr	r0, [pc, #16]	@ (8043b98 <kad_op_reduce_sum+0x2e0>)
 8043b86:	f007 fdf1 	bl	804b76c <__assert_func>
			if (i != axis) p->d[j++] = q->d[i];
 8043b8a:	2203      	movs	r2, #3
 8043b8c:	e768      	b.n	8043a60 <kad_op_reduce_sum+0x1a8>
 8043b8e:	bf00      	nop
 8043b90:	0804e320 	.word	0x0804e320
 8043b94:	0804e4dc 	.word	0x0804e4dc
 8043b98:	0804e328 	.word	0x0804e328

08043b9c <kad_op_reduce_mean>:
{
 8043b9c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8043ba0:	ed2d 8b02 	vpush	{d8}
	kad_node_t *q = p->child[0];
 8043ba4:	6b82      	ldr	r2, [r0, #56]	@ 0x38
	assert(p->ptr);
 8043ba6:	6b03      	ldr	r3, [r0, #48]	@ 0x30
	kad_node_t *q = p->child[0];
 8043ba8:	f8d2 8000 	ldr.w	r8, [r2]
{
 8043bac:	b083      	sub	sp, #12
	assert(p->ptr);
 8043bae:	2b00      	cmp	r3, #0
 8043bb0:	f000 8160 	beq.w	8043e74 <kad_op_reduce_mean+0x2d8>
	axis = *(int32_t*)p->ptr;
 8043bb4:	681b      	ldr	r3, [r3, #0]
	if (axis < 0 || axis >= q->n_d) return -1;
 8043bb6:	2b00      	cmp	r3, #0
 8043bb8:	f2c0 814e 	blt.w	8043e58 <kad_op_reduce_mean+0x2bc>
 8043bbc:	f898 2000 	ldrb.w	r2, [r8]
 8043bc0:	429a      	cmp	r2, r3
 8043bc2:	f340 8149 	ble.w	8043e58 <kad_op_reduce_mean+0x2bc>
	for (i = 0, d0 = 1; i < axis; ++i) d0 *= q->d[i];
 8043bc6:	4605      	mov	r5, r0
 8043bc8:	2b00      	cmp	r3, #0
 8043bca:	f000 80cb 	beq.w	8043d64 <kad_op_reduce_mean+0x1c8>
 8043bce:	2b01      	cmp	r3, #1
 8043bd0:	f8d8 6010 	ldr.w	r6, [r8, #16]
 8043bd4:	d00f      	beq.n	8043bf6 <kad_op_reduce_mean+0x5a>
 8043bd6:	f8d8 0014 	ldr.w	r0, [r8, #20]
 8043bda:	2b02      	cmp	r3, #2
 8043bdc:	fb00 f606 	mul.w	r6, r0, r6
 8043be0:	d009      	beq.n	8043bf6 <kad_op_reduce_mean+0x5a>
 8043be2:	f8d8 0018 	ldr.w	r0, [r8, #24]
 8043be6:	2b03      	cmp	r3, #3
 8043be8:	fb00 f606 	mul.w	r6, r0, r6
 8043bec:	d003      	beq.n	8043bf6 <kad_op_reduce_mean+0x5a>
 8043bee:	f8d8 001c 	ldr.w	r0, [r8, #28]
 8043bf2:	fb00 f606 	mul.w	r6, r0, r6
	for (i = axis + 1, d1 = 1; i < q->n_d; ++i) d1 *= q->d[i];
 8043bf6:	f103 0c01 	add.w	ip, r3, #1
 8043bfa:	4562      	cmp	r2, ip
 8043bfc:	f340 8092 	ble.w	8043d24 <kad_op_reduce_mean+0x188>
 8043c00:	1c98      	adds	r0, r3, #2
 8043c02:	eb08 0783 	add.w	r7, r8, r3, lsl #2
 8043c06:	4282      	cmp	r2, r0
 8043c08:	697c      	ldr	r4, [r7, #20]
 8043c0a:	dd08      	ble.n	8043c1e <kad_op_reduce_mean+0x82>
 8043c0c:	69b8      	ldr	r0, [r7, #24]
 8043c0e:	fb00 f404 	mul.w	r4, r0, r4
 8043c12:	1cd8      	adds	r0, r3, #3
 8043c14:	4282      	cmp	r2, r0
 8043c16:	dd02      	ble.n	8043c1e <kad_op_reduce_mean+0x82>
 8043c18:	69f8      	ldr	r0, [r7, #28]
 8043c1a:	fb00 f404 	mul.w	r4, r0, r4
	if (action == KAD_SYNC_DIM) {
 8043c1e:	2904      	cmp	r1, #4
 8043c20:	d065      	beq.n	8043cee <kad_op_reduce_mean+0x152>
	} else if (action == KAD_FORWARD) {
 8043c22:	2902      	cmp	r1, #2
 8043c24:	d008      	beq.n	8043c38 <kad_op_reduce_mean+0x9c>
	} else if (action == KAD_BACKWARD && kad_is_back(q)) {
 8043c26:	2903      	cmp	r1, #3
 8043c28:	f000 809e 	beq.w	8043d68 <kad_op_reduce_mean+0x1cc>
	return 0;
 8043c2c:	2000      	movs	r0, #0
}
 8043c2e:	b003      	add	sp, #12
 8043c30:	ecbd 8b02 	vpop	{d8}
 8043c34:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8043c38:	7829      	ldrb	r1, [r5, #0]
 8043c3a:	eb08 0783 	add.w	r7, r8, r3, lsl #2
		float t = 1.0f / q->d[axis];
 8043c3e:	ed97 8a04 	vldr	s16, [r7, #16]
		memset(p->x, 0, kad_len(p) * sizeof(float));
 8043c42:	6aa8      	ldr	r0, [r5, #40]	@ 0x28
 8043c44:	2900      	cmp	r1, #0
 8043c46:	f000 8101 	beq.w	8043e4c <kad_op_reduce_mean+0x2b0>
 8043c4a:	2901      	cmp	r1, #1
 8043c4c:	692a      	ldr	r2, [r5, #16]
 8043c4e:	d00b      	beq.n	8043c68 <kad_op_reduce_mean+0xcc>
 8043c50:	696b      	ldr	r3, [r5, #20]
 8043c52:	2902      	cmp	r1, #2
 8043c54:	fb03 f202 	mul.w	r2, r3, r2
 8043c58:	d006      	beq.n	8043c68 <kad_op_reduce_mean+0xcc>
 8043c5a:	69ab      	ldr	r3, [r5, #24]
 8043c5c:	2903      	cmp	r1, #3
 8043c5e:	fb03 f202 	mul.w	r2, r3, r2
 8043c62:	bf1c      	itt	ne
 8043c64:	69eb      	ldrne	r3, [r5, #28]
 8043c66:	435a      	mulne	r2, r3
 8043c68:	0092      	lsls	r2, r2, #2
 8043c6a:	2100      	movs	r1, #0
 8043c6c:	f008 f8a6 	bl	804bdbc <memset>
		for (i = 0; i < d0; ++i)
 8043c70:	2e00      	cmp	r6, #0
 8043c72:	dddb      	ble.n	8043c2c <kad_op_reduce_mean+0x90>
			for (j = 0; j < q->d[axis]; ++j)
 8043c74:	f8d7 e010 	ldr.w	lr, [r7, #16]
 8043c78:	f1be 0f00 	cmp.w	lr, #0
 8043c7c:	ddd6      	ble.n	8043c2c <kad_op_reduce_mean+0x90>
 8043c7e:	2c00      	cmp	r4, #0
 8043c80:	ddd4      	ble.n	8043c2c <kad_op_reduce_mean+0x90>
					p->x[i * d1 + k] += t * q->x[(i * q->d[axis] + j) * d1 + k];
 8043c82:	2300      	movs	r3, #0
		float t = 1.0f / q->d[axis];
 8043c84:	eef8 7ac8 	vcvt.f32.s32	s15, s16
 8043c88:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 8043c8c:	00a2      	lsls	r2, r4, #2
					p->x[i * d1 + k] += t * q->x[(i * q->d[axis] + j) * d1 + k];
 8043c8e:	4692      	mov	sl, r2
 8043c90:	f8d8 7028 	ldr.w	r7, [r8, #40]	@ 0x28
 8043c94:	9201      	str	r2, [sp, #4]
		float t = 1.0f / q->d[axis];
 8043c96:	eec7 6a27 	vdiv.f32	s13, s14, s15
					p->x[i * d1 + k] += t * q->x[(i * q->d[axis] + j) * d1 + k];
 8043c9a:	4699      	mov	r9, r3
		for (i = 0; i < d0; ++i)
 8043c9c:	4698      	mov	r8, r3
 8043c9e:	4632      	mov	r2, r6
					p->x[i * d1 + k] += t * q->x[(i * q->d[axis] + j) * d1 + k];
 8043ca0:	f8d5 b028 	ldr.w	fp, [r5, #40]	@ 0x28
			for (j = 0; j < q->d[axis]; ++j)
 8043ca4:	2600      	movs	r6, #0
 8043ca6:	fb04 f509 	mul.w	r5, r4, r9
 8043caa:	eb0b 0c83 	add.w	ip, fp, r3, lsl #2
 8043cae:	eb0b 000a 	add.w	r0, fp, sl
 8043cb2:	f8cd b000 	str.w	fp, [sp]
 8043cb6:	4661      	mov	r1, ip
 8043cb8:	eb07 0b85 	add.w	fp, r7, r5, lsl #2
					p->x[i * d1 + k] += t * q->x[(i * q->d[axis] + j) * d1 + k];
 8043cbc:	edd1 7a00 	vldr	s15, [r1]
 8043cc0:	ecbb 7a01 	vldmia	fp!, {s14}
 8043cc4:	eee7 7a26 	vfma.f32	s15, s14, s13
 8043cc8:	ece1 7a01 	vstmia	r1!, {s15}
				for (k = 0; k < d1; ++k)
 8043ccc:	4281      	cmp	r1, r0
 8043cce:	d1f5      	bne.n	8043cbc <kad_op_reduce_mean+0x120>
			for (j = 0; j < q->d[axis]; ++j)
 8043cd0:	3601      	adds	r6, #1
 8043cd2:	4576      	cmp	r6, lr
 8043cd4:	4425      	add	r5, r4
 8043cd6:	d1ee      	bne.n	8043cb6 <kad_op_reduce_mean+0x11a>
		for (i = 0; i < d0; ++i)
 8043cd8:	9901      	ldr	r1, [sp, #4]
 8043cda:	f108 0801 	add.w	r8, r8, #1
 8043cde:	4590      	cmp	r8, r2
 8043ce0:	f8dd b000 	ldr.w	fp, [sp]
 8043ce4:	44f1      	add	r9, lr
 8043ce6:	4423      	add	r3, r4
 8043ce8:	448a      	add	sl, r1
 8043cea:	d1db      	bne.n	8043ca4 <kad_op_reduce_mean+0x108>
 8043cec:	e79e      	b.n	8043c2c <kad_op_reduce_mean+0x90>
		p->n_d = q->n_d - 1;
 8043cee:	3a01      	subs	r2, #1
 8043cf0:	702a      	strb	r2, [r5, #0]
		for (i = j = 0; i < q->n_d; ++i)
 8043cf2:	f898 2000 	ldrb.w	r2, [r8]
 8043cf6:	2a00      	cmp	r2, #0
 8043cf8:	d098      	beq.n	8043c2c <kad_op_reduce_mean+0x90>
			if (i != axis) p->d[j++] = q->d[i];
 8043cfa:	b1ab      	cbz	r3, 8043d28 <kad_op_reduce_mean+0x18c>
 8043cfc:	f8d8 1010 	ldr.w	r1, [r8, #16]
		for (i = j = 0; i < q->n_d; ++i)
 8043d00:	2a01      	cmp	r2, #1
			if (i != axis) p->d[j++] = q->d[i];
 8043d02:	6129      	str	r1, [r5, #16]
		for (i = j = 0; i < q->n_d; ++i)
 8043d04:	d092      	beq.n	8043c2c <kad_op_reduce_mean+0x90>
			if (i != axis) p->d[j++] = q->d[i];
 8043d06:	2b01      	cmp	r3, #1
 8043d08:	d175      	bne.n	8043df6 <kad_op_reduce_mean+0x25a>
		for (i = j = 0; i < q->n_d; ++i)
 8043d0a:	2a02      	cmp	r2, #2
 8043d0c:	d08e      	beq.n	8043c2c <kad_op_reduce_mean+0x90>
			if (i != axis) p->d[j++] = q->d[i];
 8043d0e:	f8d8 1018 	ldr.w	r1, [r8, #24]
		for (i = j = 0; i < q->n_d; ++i)
 8043d12:	2a03      	cmp	r2, #3
			if (i != axis) p->d[j++] = q->d[i];
 8043d14:	6169      	str	r1, [r5, #20]
		for (i = j = 0; i < q->n_d; ++i)
 8043d16:	d089      	beq.n	8043c2c <kad_op_reduce_mean+0x90>
			if (i != axis) p->d[j++] = q->d[i];
 8043d18:	f8d8 101c 	ldr.w	r1, [r8, #28]
		for (i = j = 0; i < q->n_d; ++i)
 8043d1c:	2a04      	cmp	r2, #4
			if (i != axis) p->d[j++] = q->d[i];
 8043d1e:	61a9      	str	r1, [r5, #24]
		for (i = j = 0; i < q->n_d; ++i)
 8043d20:	d17a      	bne.n	8043e18 <kad_op_reduce_mean+0x27c>
 8043d22:	e783      	b.n	8043c2c <kad_op_reduce_mean+0x90>
	for (i = axis + 1, d1 = 1; i < q->n_d; ++i) d1 *= q->d[i];
 8043d24:	2401      	movs	r4, #1
 8043d26:	e77a      	b.n	8043c1e <kad_op_reduce_mean+0x82>
		for (i = j = 0; i < q->n_d; ++i)
 8043d28:	2a01      	cmp	r2, #1
 8043d2a:	f43f af7f 	beq.w	8043c2c <kad_op_reduce_mean+0x90>
			if (i != axis) p->d[j++] = q->d[i];
 8043d2e:	f8d8 1014 	ldr.w	r1, [r8, #20]
		for (i = j = 0; i < q->n_d; ++i)
 8043d32:	2a02      	cmp	r2, #2
			if (i != axis) p->d[j++] = q->d[i];
 8043d34:	6129      	str	r1, [r5, #16]
		for (i = j = 0; i < q->n_d; ++i)
 8043d36:	f43f af79 	beq.w	8043c2c <kad_op_reduce_mean+0x90>
			if (i != axis) p->d[j++] = q->d[i];
 8043d3a:	f8d8 1018 	ldr.w	r1, [r8, #24]
		for (i = j = 0; i < q->n_d; ++i)
 8043d3e:	2a03      	cmp	r2, #3
			if (i != axis) p->d[j++] = q->d[i];
 8043d40:	6169      	str	r1, [r5, #20]
 8043d42:	bf18      	it	ne
 8043d44:	2102      	movne	r1, #2
		for (i = j = 0; i < q->n_d; ++i)
 8043d46:	f43f af71 	beq.w	8043c2c <kad_op_reduce_mean+0x90>
			if (i != axis) p->d[j++] = q->d[i];
 8043d4a:	f8d8 401c 	ldr.w	r4, [r8, #28]
 8043d4e:	1d08      	adds	r0, r1, #4
		for (i = j = 0; i < q->n_d; ++i)
 8043d50:	2a04      	cmp	r2, #4
			if (i != axis) p->d[j++] = q->d[i];
 8043d52:	f845 4020 	str.w	r4, [r5, r0, lsl #2]
 8043d56:	f101 0101 	add.w	r1, r1, #1
		for (i = j = 0; i < q->n_d; ++i)
 8043d5a:	f77f af67 	ble.w	8043c2c <kad_op_reduce_mean+0x90>
			if (i != axis) p->d[j++] = q->d[i];
 8043d5e:	2b04      	cmp	r3, #4
 8043d60:	d061      	beq.n	8043e26 <kad_op_reduce_mean+0x28a>
 8043d62:	e05a      	b.n	8043e1a <kad_op_reduce_mean+0x27e>
	for (i = 0, d0 = 1; i < axis; ++i) d0 *= q->d[i];
 8043d64:	2601      	movs	r6, #1
 8043d66:	e746      	b.n	8043bf6 <kad_op_reduce_mean+0x5a>
	} else if (action == KAD_BACKWARD && kad_is_back(q)) {
 8043d68:	f898 2001 	ldrb.w	r2, [r8, #1]
 8043d6c:	07d2      	lsls	r2, r2, #31
 8043d6e:	f57f af5d 	bpl.w	8043c2c <kad_op_reduce_mean+0x90>
		float t = 1.0f / q->d[axis];
 8043d72:	3304      	adds	r3, #4
		for (i = 0; i < d0; ++i)
 8043d74:	2e00      	cmp	r6, #0
		float t = 1.0f / q->d[axis];
 8043d76:	f858 7023 	ldr.w	r7, [r8, r3, lsl #2]
		for (i = 0; i < d0; ++i)
 8043d7a:	f77f af57 	ble.w	8043c2c <kad_op_reduce_mean+0x90>
 8043d7e:	2f00      	cmp	r7, #0
 8043d80:	f77f af54 	ble.w	8043c2c <kad_op_reduce_mean+0x90>
 8043d84:	2c00      	cmp	r4, #0
 8043d86:	f77f af51 	ble.w	8043c2c <kad_op_reduce_mean+0x90>
		float t = 1.0f / q->d[axis];
 8043d8a:	ee07 7a90 	vmov	s15, r7
					q->g[(i * q->d[axis] + j) * d1 + k] += t * p->g[i * d1 + k];
 8043d8e:	2300      	movs	r3, #0
		float t = 1.0f / q->d[axis];
 8043d90:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8043d94:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
					q->g[(i * q->d[axis] + j) * d1 + k] += t * p->g[i * d1 + k];
 8043d98:	f8d5 a02c 	ldr.w	sl, [r5, #44]	@ 0x2c
		float t = 1.0f / q->d[axis];
 8043d9c:	eec7 6a27 	vdiv.f32	s13, s14, s15
					q->g[(i * q->d[axis] + j) * d1 + k] += t * p->g[i * d1 + k];
 8043da0:	4699      	mov	r9, r3
		for (i = 0; i < d0; ++i)
 8043da2:	461a      	mov	r2, r3
 8043da4:	4651      	mov	r1, sl
					q->g[(i * q->d[axis] + j) * d1 + k] += t * p->g[i * d1 + k];
 8043da6:	f8d8 e02c 	ldr.w	lr, [r8, #44]	@ 0x2c
 8043daa:	eb0e 0884 	add.w	r8, lr, r4, lsl #2
			for (j = 0; j < q->d[axis]; ++j)
 8043dae:	f04f 0a00 	mov.w	sl, #0
 8043db2:	fb04 fc09 	mul.w	ip, r4, r9
 8043db6:	eb01 0b83 	add.w	fp, r1, r3, lsl #2
 8043dba:	f8cd 9000 	str.w	r9, [sp]
		for (i = 0; i < d0; ++i)
 8043dbe:	465d      	mov	r5, fp
 8043dc0:	eb0e 008c 	add.w	r0, lr, ip, lsl #2
 8043dc4:	eb08 098c 	add.w	r9, r8, ip, lsl #2
					q->g[(i * q->d[axis] + j) * d1 + k] += t * p->g[i * d1 + k];
 8043dc8:	edd0 7a00 	vldr	s15, [r0]
 8043dcc:	ecb5 7a01 	vldmia	r5!, {s14}
 8043dd0:	eee7 7a26 	vfma.f32	s15, s14, s13
 8043dd4:	ece0 7a01 	vstmia	r0!, {s15}
				for (k = 0; k < d1; ++k)
 8043dd8:	4581      	cmp	r9, r0
 8043dda:	d1f5      	bne.n	8043dc8 <kad_op_reduce_mean+0x22c>
			for (j = 0; j < q->d[axis]; ++j)
 8043ddc:	f10a 0a01 	add.w	sl, sl, #1
 8043de0:	4557      	cmp	r7, sl
 8043de2:	44a4      	add	ip, r4
 8043de4:	d1eb      	bne.n	8043dbe <kad_op_reduce_mean+0x222>
		for (i = 0; i < d0; ++i)
 8043de6:	f8dd 9000 	ldr.w	r9, [sp]
 8043dea:	3201      	adds	r2, #1
 8043dec:	42b2      	cmp	r2, r6
 8043dee:	44b9      	add	r9, r7
 8043df0:	4423      	add	r3, r4
 8043df2:	d1dc      	bne.n	8043dae <kad_op_reduce_mean+0x212>
 8043df4:	e71a      	b.n	8043c2c <kad_op_reduce_mean+0x90>
			if (i != axis) p->d[j++] = q->d[i];
 8043df6:	f8d8 1014 	ldr.w	r1, [r8, #20]
		for (i = j = 0; i < q->n_d; ++i)
 8043dfa:	2a02      	cmp	r2, #2
			if (i != axis) p->d[j++] = q->d[i];
 8043dfc:	6169      	str	r1, [r5, #20]
		for (i = j = 0; i < q->n_d; ++i)
 8043dfe:	f43f af15 	beq.w	8043c2c <kad_op_reduce_mean+0x90>
			if (i != axis) p->d[j++] = q->d[i];
 8043e02:	2b02      	cmp	r3, #2
 8043e04:	d12b      	bne.n	8043e5e <kad_op_reduce_mean+0x2c2>
		for (i = j = 0; i < q->n_d; ++i)
 8043e06:	2a03      	cmp	r2, #3
 8043e08:	f43f af10 	beq.w	8043c2c <kad_op_reduce_mean+0x90>
			if (i != axis) p->d[j++] = q->d[i];
 8043e0c:	f8d8 101c 	ldr.w	r1, [r8, #28]
		for (i = j = 0; i < q->n_d; ++i)
 8043e10:	2a04      	cmp	r2, #4
			if (i != axis) p->d[j++] = q->d[i];
 8043e12:	61a9      	str	r1, [r5, #24]
		for (i = j = 0; i < q->n_d; ++i)
 8043e14:	f43f af0a 	beq.w	8043c2c <kad_op_reduce_mean+0x90>
			if (i != axis) p->d[j++] = q->d[i];
 8043e18:	2103      	movs	r1, #3
 8043e1a:	f8d8 4020 	ldr.w	r4, [r8, #32]
 8043e1e:	1d08      	adds	r0, r1, #4
 8043e20:	f845 4020 	str.w	r4, [r5, r0, lsl #2]
 8043e24:	3101      	adds	r1, #1
		for (i = j = 0; i < q->n_d; ++i)
 8043e26:	2a05      	cmp	r2, #5
 8043e28:	f77f af00 	ble.w	8043c2c <kad_op_reduce_mean+0x90>
 8043e2c:	2005      	movs	r0, #5
			if (i != axis) p->d[j++] = q->d[i];
 8043e2e:	4283      	cmp	r3, r0
 8043e30:	d00e      	beq.n	8043e50 <kad_op_reduce_mean+0x2b4>
 8043e32:	f108 0410 	add.w	r4, r8, #16
 8043e36:	f854 6020 	ldr.w	r6, [r4, r0, lsl #2]
		for (i = j = 0; i < q->n_d; ++i)
 8043e3a:	3001      	adds	r0, #1
			if (i != axis) p->d[j++] = q->d[i];
 8043e3c:	1d0c      	adds	r4, r1, #4
		for (i = j = 0; i < q->n_d; ++i)
 8043e3e:	4290      	cmp	r0, r2
			if (i != axis) p->d[j++] = q->d[i];
 8043e40:	f845 6024 	str.w	r6, [r5, r4, lsl #2]
 8043e44:	f101 0101 	add.w	r1, r1, #1
		for (i = j = 0; i < q->n_d; ++i)
 8043e48:	dbf1      	blt.n	8043e2e <kad_op_reduce_mean+0x292>
 8043e4a:	e6ef      	b.n	8043c2c <kad_op_reduce_mean+0x90>
 8043e4c:	2204      	movs	r2, #4
 8043e4e:	e70c      	b.n	8043c6a <kad_op_reduce_mean+0xce>
 8043e50:	4594      	cmp	ip, r2
 8043e52:	4660      	mov	r0, ip
 8043e54:	dbeb      	blt.n	8043e2e <kad_op_reduce_mean+0x292>
 8043e56:	e6e9      	b.n	8043c2c <kad_op_reduce_mean+0x90>
	if (axis < 0 || axis >= q->n_d) return -1;
 8043e58:	f04f 30ff 	mov.w	r0, #4294967295
 8043e5c:	e6e7      	b.n	8043c2e <kad_op_reduce_mean+0x92>
			if (i != axis) p->d[j++] = q->d[i];
 8043e5e:	f8d8 1018 	ldr.w	r1, [r8, #24]
		for (i = j = 0; i < q->n_d; ++i)
 8043e62:	2a03      	cmp	r2, #3
			if (i != axis) p->d[j++] = q->d[i];
 8043e64:	61a9      	str	r1, [r5, #24]
		for (i = j = 0; i < q->n_d; ++i)
 8043e66:	f43f aee1 	beq.w	8043c2c <kad_op_reduce_mean+0x90>
			if (i != axis) p->d[j++] = q->d[i];
 8043e6a:	2b03      	cmp	r3, #3
 8043e6c:	d109      	bne.n	8043e82 <kad_op_reduce_mean+0x2e6>
		for (i = j = 0; i < q->n_d; ++i)
 8043e6e:	2a04      	cmp	r2, #4
 8043e70:	d1d2      	bne.n	8043e18 <kad_op_reduce_mean+0x27c>
 8043e72:	e6db      	b.n	8043c2c <kad_op_reduce_mean+0x90>
	assert(p->ptr);
 8043e74:	f44f 61a0 	mov.w	r1, #1280	@ 0x500
 8043e78:	4b03      	ldr	r3, [pc, #12]	@ (8043e88 <kad_op_reduce_mean+0x2ec>)
 8043e7a:	4a04      	ldr	r2, [pc, #16]	@ (8043e8c <kad_op_reduce_mean+0x2f0>)
 8043e7c:	4804      	ldr	r0, [pc, #16]	@ (8043e90 <kad_op_reduce_mean+0x2f4>)
 8043e7e:	f007 fc75 	bl	804b76c <__assert_func>
			if (i != axis) p->d[j++] = q->d[i];
 8043e82:	2103      	movs	r1, #3
 8043e84:	e761      	b.n	8043d4a <kad_op_reduce_mean+0x1ae>
 8043e86:	bf00      	nop
 8043e88:	0804e320 	.word	0x0804e320
 8043e8c:	0804e4c8 	.word	0x0804e4c8
 8043e90:	0804e328 	.word	0x0804e328

08043e94 <kad_op_square>:
{
 8043e94:	b538      	push	{r3, r4, r5, lr}
	kad_node_t *q = p->child[0];
 8043e96:	6b83      	ldr	r3, [r0, #56]	@ 0x38
 8043e98:	681c      	ldr	r4, [r3, #0]
 8043e9a:	7825      	ldrb	r5, [r4, #0]
 8043e9c:	b305      	cbz	r5, 8043ee0 <kad_op_square+0x4c>
 8043e9e:	2d01      	cmp	r5, #1
 8043ea0:	6923      	ldr	r3, [r4, #16]
 8043ea2:	d00c      	beq.n	8043ebe <kad_op_square+0x2a>
 8043ea4:	6962      	ldr	r2, [r4, #20]
 8043ea6:	2d02      	cmp	r5, #2
 8043ea8:	fb02 f303 	mul.w	r3, r2, r3
 8043eac:	d007      	beq.n	8043ebe <kad_op_square+0x2a>
 8043eae:	69a2      	ldr	r2, [r4, #24]
 8043eb0:	2d03      	cmp	r5, #3
 8043eb2:	fb02 f303 	mul.w	r3, r2, r3
 8043eb6:	d002      	beq.n	8043ebe <kad_op_square+0x2a>
 8043eb8:	69e2      	ldr	r2, [r4, #28]
 8043eba:	fb02 f303 	mul.w	r3, r2, r3
	if (action == KAD_SYNC_DIM) {
 8043ebe:	2904      	cmp	r1, #4
 8043ec0:	d005      	beq.n	8043ece <kad_op_square+0x3a>
	} else if (action == KAD_FORWARD) {
 8043ec2:	2902      	cmp	r1, #2
 8043ec4:	d017      	beq.n	8043ef6 <kad_op_square+0x62>
	} else if (action == KAD_BACKWARD && kad_is_back(q)) {
 8043ec6:	2903      	cmp	r1, #3
 8043ec8:	d027      	beq.n	8043f1a <kad_op_square+0x86>
}
 8043eca:	2000      	movs	r0, #0
 8043ecc:	bd38      	pop	{r3, r4, r5, pc}
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 8043ece:	00aa      	lsls	r2, r5, #2
 8043ed0:	f104 0110 	add.w	r1, r4, #16
	dst->n_d = src->n_d;
 8043ed4:	f800 5b10 	strb.w	r5, [r0], #16
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 8043ed8:	f008 f86d 	bl	804bfb6 <memcpy>
}
 8043edc:	2000      	movs	r0, #0
 8043ede:	bd38      	pop	{r3, r4, r5, pc}
	if (action == KAD_SYNC_DIM) {
 8043ee0:	2904      	cmp	r1, #4
 8043ee2:	d018      	beq.n	8043f16 <kad_op_square+0x82>
	} else if (action == KAD_FORWARD) {
 8043ee4:	2902      	cmp	r1, #2
 8043ee6:	d031      	beq.n	8043f4c <kad_op_square+0xb8>
	} else if (action == KAD_BACKWARD && kad_is_back(q)) {
 8043ee8:	2903      	cmp	r1, #3
 8043eea:	d1ee      	bne.n	8043eca <kad_op_square+0x36>
 8043eec:	7863      	ldrb	r3, [r4, #1]
 8043eee:	07d9      	lsls	r1, r3, #31
 8043ef0:	d5eb      	bpl.n	8043eca <kad_op_square+0x36>
	int n = 1, i;
 8043ef2:	2301      	movs	r3, #1
 8043ef4:	e016      	b.n	8043f24 <kad_op_square+0x90>
		for (i = 0; i < n; ++i)
 8043ef6:	2b00      	cmp	r3, #0
 8043ef8:	dde7      	ble.n	8043eca <kad_op_square+0x36>
 8043efa:	2200      	movs	r2, #0
 8043efc:	6aa4      	ldr	r4, [r4, #40]	@ 0x28
 8043efe:	6a81      	ldr	r1, [r0, #40]	@ 0x28
			p->x[i] = q->x[i] * q->x[i];
 8043f00:	ecf4 7a01 	vldmia	r4!, {s15}
 8043f04:	ee67 7aa7 	vmul.f32	s15, s15, s15
		for (i = 0; i < n; ++i)
 8043f08:	3201      	adds	r2, #1
 8043f0a:	429a      	cmp	r2, r3
			p->x[i] = q->x[i] * q->x[i];
 8043f0c:	ece1 7a01 	vstmia	r1!, {s15}
		for (i = 0; i < n; ++i)
 8043f10:	dbf6      	blt.n	8043f00 <kad_op_square+0x6c>
}
 8043f12:	2000      	movs	r0, #0
 8043f14:	bd38      	pop	{r3, r4, r5, pc}
	dst->n_d = src->n_d;
 8043f16:	7005      	strb	r5, [r0, #0]
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 8043f18:	e7d7      	b.n	8043eca <kad_op_square+0x36>
	} else if (action == KAD_BACKWARD && kad_is_back(q)) {
 8043f1a:	7862      	ldrb	r2, [r4, #1]
 8043f1c:	07d2      	lsls	r2, r2, #31
 8043f1e:	d5d4      	bpl.n	8043eca <kad_op_square+0x36>
		for (i = 0; i < n; ++i)
 8043f20:	2b00      	cmp	r3, #0
 8043f22:	ddd2      	ble.n	8043eca <kad_op_square+0x36>
 8043f24:	6ae2      	ldr	r2, [r4, #44]	@ 0x2c
 8043f26:	6ac0      	ldr	r0, [r0, #44]	@ 0x2c
 8043f28:	6aa1      	ldr	r1, [r4, #40]	@ 0x28
 8043f2a:	eb02 0383 	add.w	r3, r2, r3, lsl #2
			q->g[i] += p->g[i] * (q->x[i] + q->x[i]);
 8043f2e:	ecf1 7a01 	vldmia	r1!, {s15}
 8043f32:	ed92 7a00 	vldr	s14, [r2]
 8043f36:	ecf0 6a01 	vldmia	r0!, {s13}
 8043f3a:	ee77 7aa7 	vadd.f32	s15, s15, s15
 8043f3e:	eea6 7aa7 	vfma.f32	s14, s13, s15
 8043f42:	eca2 7a01 	vstmia	r2!, {s14}
		for (i = 0; i < n; ++i)
 8043f46:	4293      	cmp	r3, r2
 8043f48:	d1f1      	bne.n	8043f2e <kad_op_square+0x9a>
 8043f4a:	e7be      	b.n	8043eca <kad_op_square+0x36>
 8043f4c:	2301      	movs	r3, #1
 8043f4e:	e7d4      	b.n	8043efa <kad_op_square+0x66>

08043f50 <kad_op_relu>:
{
 8043f50:	b570      	push	{r4, r5, r6, lr}
	kad_node_t *q = p->child[0];
 8043f52:	6b83      	ldr	r3, [r0, #56]	@ 0x38
 8043f54:	681c      	ldr	r4, [r3, #0]
	for (i = 0; i < p->n_d; ++i) n *= p->d[i];
 8043f56:	7825      	ldrb	r5, [r4, #0]
 8043f58:	b305      	cbz	r5, 8043f9c <kad_op_relu+0x4c>
 8043f5a:	2d01      	cmp	r5, #1
 8043f5c:	6923      	ldr	r3, [r4, #16]
 8043f5e:	d00c      	beq.n	8043f7a <kad_op_relu+0x2a>
 8043f60:	6962      	ldr	r2, [r4, #20]
 8043f62:	2d02      	cmp	r5, #2
 8043f64:	fb02 f303 	mul.w	r3, r2, r3
 8043f68:	d007      	beq.n	8043f7a <kad_op_relu+0x2a>
 8043f6a:	69a2      	ldr	r2, [r4, #24]
 8043f6c:	2d03      	cmp	r5, #3
 8043f6e:	fb02 f303 	mul.w	r3, r2, r3
 8043f72:	d002      	beq.n	8043f7a <kad_op_relu+0x2a>
 8043f74:	69e2      	ldr	r2, [r4, #28]
 8043f76:	fb02 f303 	mul.w	r3, r2, r3
	if (action == KAD_SYNC_DIM) {
 8043f7a:	2904      	cmp	r1, #4
 8043f7c:	d005      	beq.n	8043f8a <kad_op_relu+0x3a>
	} else if (action == KAD_FORWARD) {
 8043f7e:	2902      	cmp	r1, #2
 8043f80:	d017      	beq.n	8043fb2 <kad_op_relu+0x62>
	} else if (action == KAD_BACKWARD && kad_is_back(q)) {
 8043f82:	2903      	cmp	r1, #3
 8043f84:	d02e      	beq.n	8043fe4 <kad_op_relu+0x94>
}
 8043f86:	2000      	movs	r0, #0
 8043f88:	bd70      	pop	{r4, r5, r6, pc}
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 8043f8a:	00aa      	lsls	r2, r5, #2
 8043f8c:	f104 0110 	add.w	r1, r4, #16
	dst->n_d = src->n_d;
 8043f90:	f800 5b10 	strb.w	r5, [r0], #16
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 8043f94:	f008 f80f 	bl	804bfb6 <memcpy>
}
 8043f98:	2000      	movs	r0, #0
 8043f9a:	bd70      	pop	{r4, r5, r6, pc}
	if (action == KAD_SYNC_DIM) {
 8043f9c:	2904      	cmp	r1, #4
 8043f9e:	d01f      	beq.n	8043fe0 <kad_op_relu+0x90>
	} else if (action == KAD_FORWARD) {
 8043fa0:	2902      	cmp	r1, #2
 8043fa2:	d041      	beq.n	8044028 <kad_op_relu+0xd8>
	} else if (action == KAD_BACKWARD && kad_is_back(q)) {
 8043fa4:	2903      	cmp	r1, #3
 8043fa6:	d1ee      	bne.n	8043f86 <kad_op_relu+0x36>
 8043fa8:	7863      	ldrb	r3, [r4, #1]
 8043faa:	07d9      	lsls	r1, r3, #31
 8043fac:	d5eb      	bpl.n	8043f86 <kad_op_relu+0x36>
	int n = 1, i;
 8043fae:	2301      	movs	r3, #1
 8043fb0:	e01d      	b.n	8043fee <kad_op_relu+0x9e>
		for (i = 0; i < n; ++i)
 8043fb2:	2b00      	cmp	r3, #0
 8043fb4:	dde7      	ble.n	8043f86 <kad_op_relu+0x36>
 8043fb6:	2200      	movs	r2, #0
			p->x[i] = q->x[i] > 0.0f? q->x[i] : 0.0f;
 8043fb8:	ed9f 7a1c 	vldr	s14, [pc, #112]	@ 804402c <kad_op_relu+0xdc>
 8043fbc:	6aa4      	ldr	r4, [r4, #40]	@ 0x28
 8043fbe:	6a81      	ldr	r1, [r0, #40]	@ 0x28
 8043fc0:	ecf4 7a01 	vldmia	r4!, {s15}
 8043fc4:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8043fc8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8043fcc:	bfd8      	it	le
 8043fce:	eef0 7a47 	vmovle.f32	s15, s14
		for (i = 0; i < n; ++i)
 8043fd2:	3201      	adds	r2, #1
 8043fd4:	429a      	cmp	r2, r3
			p->x[i] = q->x[i] > 0.0f? q->x[i] : 0.0f;
 8043fd6:	ece1 7a01 	vstmia	r1!, {s15}
		for (i = 0; i < n; ++i)
 8043fda:	dbf1      	blt.n	8043fc0 <kad_op_relu+0x70>
}
 8043fdc:	2000      	movs	r0, #0
 8043fde:	bd70      	pop	{r4, r5, r6, pc}
	dst->n_d = src->n_d;
 8043fe0:	7005      	strb	r5, [r0, #0]
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 8043fe2:	e7d0      	b.n	8043f86 <kad_op_relu+0x36>
	} else if (action == KAD_BACKWARD && kad_is_back(q)) {
 8043fe4:	7862      	ldrb	r2, [r4, #1]
 8043fe6:	07d2      	lsls	r2, r2, #31
 8043fe8:	d5cd      	bpl.n	8043f86 <kad_op_relu+0x36>
		for (i = 0; i < n; ++i)
 8043fea:	2b00      	cmp	r3, #0
 8043fec:	ddcb      	ble.n	8043f86 <kad_op_relu+0x36>
			if (q->x[i] > 0.0f)
 8043fee:	2200      	movs	r2, #0
 8043ff0:	6aa1      	ldr	r1, [r4, #40]	@ 0x28
 8043ff2:	eb01 0383 	add.w	r3, r1, r3, lsl #2
 8043ff6:	ecf1 7a01 	vldmia	r1!, {s15}
 8043ffa:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8043ffe:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8044002:	dd0c      	ble.n	804401e <kad_op_relu+0xce>
				q->g[i] += p->g[i];
 8044004:	6ae5      	ldr	r5, [r4, #44]	@ 0x2c
 8044006:	6ac6      	ldr	r6, [r0, #44]	@ 0x2c
 8044008:	4415      	add	r5, r2
 804400a:	eb06 0c02 	add.w	ip, r6, r2
 804400e:	edd5 7a00 	vldr	s15, [r5]
 8044012:	ed9c 7a00 	vldr	s14, [ip]
 8044016:	ee77 7a87 	vadd.f32	s15, s15, s14
 804401a:	edc5 7a00 	vstr	s15, [r5]
		for (i = 0; i < n; ++i)
 804401e:	4299      	cmp	r1, r3
 8044020:	f102 0204 	add.w	r2, r2, #4
 8044024:	d1e7      	bne.n	8043ff6 <kad_op_relu+0xa6>
 8044026:	e7ae      	b.n	8043f86 <kad_op_relu+0x36>
 8044028:	2301      	movs	r3, #1
 804402a:	e7c4      	b.n	8043fb6 <kad_op_relu+0x66>
 804402c:	00000000 	.word	0x00000000

08044030 <kad_op_max>:
{
 8044030:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8044034:	4605      	mov	r5, r0
	kad_node_t *q = p->child[0];
 8044036:	6b80      	ldr	r0, [r0, #56]	@ 0x38
 8044038:	6806      	ldr	r6, [r0, #0]
	for (i = 0; i < p->n_d; ++i) n *= p->d[i];
 804403a:	f896 8000 	ldrb.w	r8, [r6]
 804403e:	f1b8 0f00 	cmp.w	r8, #0
 8044042:	d048      	beq.n	80440d6 <kad_op_max+0xa6>
 8044044:	f1b8 0f01 	cmp.w	r8, #1
 8044048:	6934      	ldr	r4, [r6, #16]
 804404a:	d00e      	beq.n	804406a <kad_op_max+0x3a>
 804404c:	6973      	ldr	r3, [r6, #20]
 804404e:	f1b8 0f02 	cmp.w	r8, #2
 8044052:	fb03 f404 	mul.w	r4, r3, r4
 8044056:	d008      	beq.n	804406a <kad_op_max+0x3a>
 8044058:	69b3      	ldr	r3, [r6, #24]
 804405a:	f1b8 0f03 	cmp.w	r8, #3
 804405e:	fb03 f404 	mul.w	r4, r3, r4
 8044062:	d002      	beq.n	804406a <kad_op_max+0x3a>
 8044064:	69f3      	ldr	r3, [r6, #28]
 8044066:	fb03 f404 	mul.w	r4, r3, r4
	if (action == KAD_SYNC_DIM) {
 804406a:	2904      	cmp	r1, #4
 804406c:	d007      	beq.n	804407e <kad_op_max+0x4e>
	} else if (action == KAD_FORWARD) {
 804406e:	2902      	cmp	r1, #2
 8044070:	d03a      	beq.n	80440e8 <kad_op_max+0xb8>
	} else if (action == KAD_BACKWARD) {
 8044072:	2903      	cmp	r1, #3
 8044074:	f000 8086 	beq.w	8044184 <kad_op_max+0x154>
	return 0;
 8044078:	2000      	movs	r0, #0
}
 804407a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		for (i = 1; i < p->n_child; ++i)
 804407e:	686f      	ldr	r7, [r5, #4]
 8044080:	2f01      	cmp	r7, #1
 8044082:	f340 809b 	ble.w	80441bc <kad_op_max+0x18c>
 8044086:	4686      	mov	lr, r0
 8044088:	f04f 0c01 	mov.w	ip, #1
 804408c:	e015      	b.n	80440ba <kad_op_max+0x8a>
 804408e:	2a01      	cmp	r2, #1
 8044090:	690b      	ldr	r3, [r1, #16]
 8044092:	d00c      	beq.n	80440ae <kad_op_max+0x7e>
 8044094:	6948      	ldr	r0, [r1, #20]
 8044096:	2a02      	cmp	r2, #2
 8044098:	fb00 f303 	mul.w	r3, r0, r3
 804409c:	d007      	beq.n	80440ae <kad_op_max+0x7e>
 804409e:	6988      	ldr	r0, [r1, #24]
 80440a0:	2a03      	cmp	r2, #3
 80440a2:	fb00 f303 	mul.w	r3, r0, r3
 80440a6:	d002      	beq.n	80440ae <kad_op_max+0x7e>
 80440a8:	69ca      	ldr	r2, [r1, #28]
 80440aa:	fb02 f303 	mul.w	r3, r2, r3
			if (kad_len(p->child[i]) != n) return -1;
 80440ae:	429c      	cmp	r4, r3
		for (i = 1; i < p->n_child; ++i)
 80440b0:	f10c 0c01 	add.w	ip, ip, #1
			if (kad_len(p->child[i]) != n) return -1;
 80440b4:	d10b      	bne.n	80440ce <kad_op_max+0x9e>
		for (i = 1; i < p->n_child; ++i)
 80440b6:	45bc      	cmp	ip, r7
 80440b8:	da54      	bge.n	8044164 <kad_op_max+0x134>
			if (kad_len(p->child[i]) != n) return -1;
 80440ba:	f85e 1f04 	ldr.w	r1, [lr, #4]!
 80440be:	780a      	ldrb	r2, [r1, #0]
 80440c0:	2a00      	cmp	r2, #0
 80440c2:	d1e4      	bne.n	804408e <kad_op_max+0x5e>
	int n = 1, i;
 80440c4:	2301      	movs	r3, #1
 80440c6:	429c      	cmp	r4, r3
		for (i = 1; i < p->n_child; ++i)
 80440c8:	f10c 0c01 	add.w	ip, ip, #1
			if (kad_len(p->child[i]) != n) return -1;
 80440cc:	d0f3      	beq.n	80440b6 <kad_op_max+0x86>
 80440ce:	f04f 30ff 	mov.w	r0, #4294967295
}
 80440d2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (action == KAD_SYNC_DIM) {
 80440d6:	2904      	cmp	r1, #4
 80440d8:	d03a      	beq.n	8044150 <kad_op_max+0x120>
	} else if (action == KAD_FORWARD) {
 80440da:	2902      	cmp	r1, #2
 80440dc:	d079      	beq.n	80441d2 <kad_op_max+0x1a2>
	} else if (action == KAD_BACKWARD) {
 80440de:	2903      	cmp	r1, #3
 80440e0:	d1ca      	bne.n	8044078 <kad_op_max+0x48>
 80440e2:	2401      	movs	r4, #1
		int *max_j = (int*)p->gtmp;
 80440e4:	6b6e      	ldr	r6, [r5, #52]	@ 0x34
		for (i = 0; i < n; ++i)
 80440e6:	e051      	b.n	804418c <kad_op_max+0x15c>
		int j, *max_j = (int*)p->gtmp;
 80440e8:	6b6f      	ldr	r7, [r5, #52]	@ 0x34
		memset(max_j, 0, n * sizeof(int));
 80440ea:	ea4f 0884 	mov.w	r8, r4, lsl #2
 80440ee:	2100      	movs	r1, #0
 80440f0:	4642      	mov	r2, r8
 80440f2:	4638      	mov	r0, r7
 80440f4:	f007 fe62 	bl	804bdbc <memset>
		memcpy(p->x, q->x, n * sizeof(float));
 80440f8:	4642      	mov	r2, r8
 80440fa:	6ab1      	ldr	r1, [r6, #40]	@ 0x28
 80440fc:	6aa8      	ldr	r0, [r5, #40]	@ 0x28
 80440fe:	f007 ff5a 	bl	804bfb6 <memcpy>
		for (j = 1; j < p->n_child; ++j)
 8044102:	686b      	ldr	r3, [r5, #4]
 8044104:	2b01      	cmp	r3, #1
 8044106:	ddb7      	ble.n	8044078 <kad_op_max+0x48>
 8044108:	2c00      	cmp	r4, #0
			for (i = 0, q = p->child[j]; i < n; ++i)
 804410a:	6baa      	ldr	r2, [r5, #56]	@ 0x38
 804410c:	ddb4      	ble.n	8044078 <kad_op_max+0x48>
		for (j = 1; j < p->n_child; ++j)
 804410e:	2401      	movs	r4, #1
 8044110:	6aae      	ldr	r6, [r5, #40]	@ 0x28
 8044112:	1f15      	subs	r5, r2, #4
 8044114:	eb05 0583 	add.w	r5, r5, r3, lsl #2
			for (i = 0, q = p->child[j]; i < n; ++i)
 8044118:	4638      	mov	r0, r7
				if (q->x[i] > p->x[i]) p->x[i] = q->x[i], max_j[i] = j;
 804411a:	4631      	mov	r1, r6
 804411c:	f852 3f04 	ldr.w	r3, [r2, #4]!
 8044120:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8044122:	eb08 0c03 	add.w	ip, r8, r3
 8044126:	ecf3 7a01 	vldmia	r3!, {s15}
 804412a:	ecb1 7a01 	vldmia	r1!, {s14}
 804412e:	eef4 7ac7 	vcmpe.f32	s15, s14
 8044132:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8044136:	bfc4      	itt	gt
 8044138:	ed41 7a01 	vstrgt	s15, [r1, #-4]
 804413c:	6004      	strgt	r4, [r0, #0]
			for (i = 0, q = p->child[j]; i < n; ++i)
 804413e:	4563      	cmp	r3, ip
 8044140:	f100 0004 	add.w	r0, r0, #4
 8044144:	d1ef      	bne.n	8044126 <kad_op_max+0xf6>
		for (j = 1; j < p->n_child; ++j)
 8044146:	4295      	cmp	r5, r2
 8044148:	f104 0401 	add.w	r4, r4, #1
 804414c:	d1e4      	bne.n	8044118 <kad_op_max+0xe8>
 804414e:	e793      	b.n	8044078 <kad_op_max+0x48>
		for (i = 1; i < p->n_child; ++i)
 8044150:	686f      	ldr	r7, [r5, #4]
 8044152:	2f01      	cmp	r7, #1
 8044154:	bfc8      	it	gt
 8044156:	2401      	movgt	r4, #1
 8044158:	dc95      	bgt.n	8044086 <kad_op_max+0x56>
	dst->n_d = src->n_d;
 804415a:	460e      	mov	r6, r1
 804415c:	2001      	movs	r0, #1
 804415e:	f885 8000 	strb.w	r8, [r5]
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 8044162:	e006      	b.n	8044172 <kad_op_max+0x142>
	dst->n_d = src->n_d;
 8044164:	f885 8000 	strb.w	r8, [r5]
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 8044168:	f1b8 0f00 	cmp.w	r8, #0
 804416c:	d128      	bne.n	80441c0 <kad_op_max+0x190>
		max_j = (int*)calloc(n, sizeof(int));
 804416e:	4620      	mov	r0, r4
		heapSize += n*sizeof(int);
 8044170:	00a6      	lsls	r6, r4, #2
		max_j = (int*)calloc(n, sizeof(int));
 8044172:	2104      	movs	r1, #4
 8044174:	f007 fb18 	bl	804b7a8 <calloc>
		heapSize += n*sizeof(int);
 8044178:	4a1d      	ldr	r2, [pc, #116]	@ (80441f0 <kad_op_max+0x1c0>)
		p->gtmp = max_j;
 804417a:	6368      	str	r0, [r5, #52]	@ 0x34
		heapSize += n*sizeof(int);
 804417c:	6813      	ldr	r3, [r2, #0]
 804417e:	4433      	add	r3, r6
 8044180:	6013      	str	r3, [r2, #0]
		p->gtmp = max_j;
 8044182:	e779      	b.n	8044078 <kad_op_max+0x48>
		for (i = 0; i < n; ++i)
 8044184:	2c00      	cmp	r4, #0
		int *max_j = (int*)p->gtmp;
 8044186:	6b6e      	ldr	r6, [r5, #52]	@ 0x34
		for (i = 0; i < n; ++i)
 8044188:	f77f af76 	ble.w	8044078 <kad_op_max+0x48>
 804418c:	1f32      	subs	r2, r6, #4
 804418e:	6ae9      	ldr	r1, [r5, #44]	@ 0x2c
 8044190:	eb02 0484 	add.w	r4, r2, r4, lsl #2
 8044194:	f1c6 0604 	rsb	r6, r6, #4
			p->child[max_j[i]]->g[i] += p->g[i];
 8044198:	18b5      	adds	r5, r6, r2
 804419a:	f852 3f04 	ldr.w	r3, [r2, #4]!
 804419e:	ecb1 7a01 	vldmia	r1!, {s14}
 80441a2:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
		for (i = 0; i < n; ++i)
 80441a6:	4294      	cmp	r4, r2
			p->child[max_j[i]]->g[i] += p->g[i];
 80441a8:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80441aa:	442b      	add	r3, r5
 80441ac:	edd3 7a00 	vldr	s15, [r3]
 80441b0:	ee77 7a87 	vadd.f32	s15, s15, s14
 80441b4:	edc3 7a00 	vstr	s15, [r3]
		for (i = 0; i < n; ++i)
 80441b8:	d1ee      	bne.n	8044198 <kad_op_max+0x168>
 80441ba:	e75d      	b.n	8044078 <kad_op_max+0x48>
	dst->n_d = src->n_d;
 80441bc:	f885 8000 	strb.w	r8, [r5]
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 80441c0:	ea4f 0288 	mov.w	r2, r8, lsl #2
 80441c4:	f106 0110 	add.w	r1, r6, #16
 80441c8:	f105 0010 	add.w	r0, r5, #16
 80441cc:	f007 fef3 	bl	804bfb6 <memcpy>
 80441d0:	e7cd      	b.n	804416e <kad_op_max+0x13e>
		int j, *max_j = (int*)p->gtmp;
 80441d2:	6b6f      	ldr	r7, [r5, #52]	@ 0x34
		memset(max_j, 0, n * sizeof(int));
 80441d4:	f8c7 8000 	str.w	r8, [r7]
		memcpy(p->x, q->x, n * sizeof(float));
 80441d8:	6ab2      	ldr	r2, [r6, #40]	@ 0x28
 80441da:	6aab      	ldr	r3, [r5, #40]	@ 0x28
 80441dc:	6812      	ldr	r2, [r2, #0]
 80441de:	601a      	str	r2, [r3, #0]
		for (j = 1; j < p->n_child; ++j)
 80441e0:	686b      	ldr	r3, [r5, #4]
 80441e2:	2b01      	cmp	r3, #1
 80441e4:	f77f af48 	ble.w	8044078 <kad_op_max+0x48>
		memset(max_j, 0, n * sizeof(int));
 80441e8:	f04f 0804 	mov.w	r8, #4
			for (i = 0, q = p->child[j]; i < n; ++i)
 80441ec:	6baa      	ldr	r2, [r5, #56]	@ 0x38
 80441ee:	e78e      	b.n	804410e <kad_op_max+0xde>
 80441f0:	20018344 	.word	0x20018344

080441f4 <kad_op_mul>:
{
 80441f4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	q[0] = p->child[0], n0 = kad_len(q[0]);
 80441f8:	6b83      	ldr	r3, [r0, #56]	@ 0x38
{
 80441fa:	4680      	mov	r8, r0
	q[0] = p->child[0], n0 = kad_len(q[0]);
 80441fc:	681e      	ldr	r6, [r3, #0]
{
 80441fe:	b083      	sub	sp, #12
	for (i = 0; i < p->n_d; ++i) n *= p->d[i];
 8044200:	7832      	ldrb	r2, [r6, #0]
 8044202:	2a00      	cmp	r2, #0
 8044204:	d079      	beq.n	80442fa <kad_op_mul+0x106>
 8044206:	2a01      	cmp	r2, #1
 8044208:	6935      	ldr	r5, [r6, #16]
 804420a:	d00c      	beq.n	8044226 <kad_op_mul+0x32>
 804420c:	6970      	ldr	r0, [r6, #20]
 804420e:	2a02      	cmp	r2, #2
 8044210:	fb00 f505 	mul.w	r5, r0, r5
 8044214:	d007      	beq.n	8044226 <kad_op_mul+0x32>
 8044216:	69b0      	ldr	r0, [r6, #24]
 8044218:	2a03      	cmp	r2, #3
 804421a:	fb00 f505 	mul.w	r5, r0, r5
 804421e:	d002      	beq.n	8044226 <kad_op_mul+0x32>
 8044220:	69f0      	ldr	r0, [r6, #28]
 8044222:	fb00 f505 	mul.w	r5, r0, r5
	q[1] = p->child[1], n1 = kad_len(q[1]);
 8044226:	685f      	ldr	r7, [r3, #4]
 8044228:	783b      	ldrb	r3, [r7, #0]
 804422a:	2b00      	cmp	r3, #0
 804422c:	d061      	beq.n	80442f2 <kad_op_mul+0xfe>
 804422e:	2b01      	cmp	r3, #1
 8044230:	693c      	ldr	r4, [r7, #16]
 8044232:	d00c      	beq.n	804424e <kad_op_mul+0x5a>
 8044234:	6978      	ldr	r0, [r7, #20]
 8044236:	2b02      	cmp	r3, #2
 8044238:	fb00 f404 	mul.w	r4, r0, r4
 804423c:	d007      	beq.n	804424e <kad_op_mul+0x5a>
 804423e:	69b8      	ldr	r0, [r7, #24]
 8044240:	2b03      	cmp	r3, #3
 8044242:	fb00 f404 	mul.w	r4, r0, r4
 8044246:	d002      	beq.n	804424e <kad_op_mul+0x5a>
 8044248:	69fb      	ldr	r3, [r7, #28]
 804424a:	fb03 f404 	mul.w	r4, r3, r4
	if (action == KAD_SYNC_DIM) {
 804424e:	2904      	cmp	r1, #4
 8044250:	d03d      	beq.n	80442ce <kad_op_mul+0xda>
	} else if (action == KAD_FORWARD) {
 8044252:	2902      	cmp	r1, #2
 8044254:	d005      	beq.n	8044262 <kad_op_mul+0x6e>
	} else if (action == KAD_BACKWARD) {
 8044256:	2903      	cmp	r1, #3
 8044258:	d051      	beq.n	80442fe <kad_op_mul+0x10a>
	return 0;
 804425a:	2000      	movs	r0, #0
}
 804425c:	b003      	add	sp, #12
 804425e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		assert(n0 >= n1);
 8044262:	42a5      	cmp	r5, r4
 8044264:	f2c0 80b8 	blt.w	80443d8 <kad_op_mul+0x1e4>
		memset(p->x, 0, n0 * sizeof(float));
 8044268:	2100      	movs	r1, #0
 804426a:	f8d8 0028 	ldr.w	r0, [r8, #40]	@ 0x28
 804426e:	00aa      	lsls	r2, r5, #2
 8044270:	f007 fda4 	bl	804bdbc <memset>
		if (q[0]->x != 0 && q[1]->x != 0)
 8044274:	f8d6 e028 	ldr.w	lr, [r6, #40]	@ 0x28
 8044278:	f1be 0f00 	cmp.w	lr, #0
 804427c:	d0ed      	beq.n	804425a <kad_op_mul+0x66>
 804427e:	f8d7 9028 	ldr.w	r9, [r7, #40]	@ 0x28
 8044282:	f1b9 0f00 	cmp.w	r9, #0
 8044286:	d0e8      	beq.n	804425a <kad_op_mul+0x66>
			for (i = 0; i < n0; i += n1) /* TODO: optimize when n1==1 */
 8044288:	2d00      	cmp	r5, #0
 804428a:	dde6      	ble.n	804425a <kad_op_mul+0x66>
 804428c:	2c00      	cmp	r4, #0
				kad_vec_mul_sum(n1, p->x + i, q[0]->x + i, q[1]->x);
 804428e:	f8d8 8028 	ldr.w	r8, [r8, #40]	@ 0x28
 8044292:	dde2      	ble.n	804425a <kad_op_mul+0x66>
 8044294:	2600      	movs	r6, #0
			for (i = 0; i < n0; i += n1) /* TODO: optimize when n1==1 */
 8044296:	4637      	mov	r7, r6
 8044298:	ea4f 0c84 	mov.w	ip, r4, lsl #2
 804429c:	eb08 0084 	add.w	r0, r8, r4, lsl #2
	for (i = 0; i < n; ++i) a[i] += b[i] * c[i];
 80442a0:	4649      	mov	r1, r9
 80442a2:	eb08 0306 	add.w	r3, r8, r6
 80442a6:	eb0e 0206 	add.w	r2, lr, r6
 80442aa:	edd3 7a00 	vldr	s15, [r3]
 80442ae:	ecf2 6a01 	vldmia	r2!, {s13}
 80442b2:	ecb1 7a01 	vldmia	r1!, {s14}
 80442b6:	eee6 7a87 	vfma.f32	s15, s13, s14
 80442ba:	ece3 7a01 	vstmia	r3!, {s15}
 80442be:	4298      	cmp	r0, r3
 80442c0:	d1f3      	bne.n	80442aa <kad_op_mul+0xb6>
			for (i = 0; i < n0; i += n1) /* TODO: optimize when n1==1 */
 80442c2:	4427      	add	r7, r4
 80442c4:	42bd      	cmp	r5, r7
 80442c6:	4466      	add	r6, ip
 80442c8:	4460      	add	r0, ip
 80442ca:	dce9      	bgt.n	80442a0 <kad_op_mul+0xac>
 80442cc:	e7c5      	b.n	804425a <kad_op_mul+0x66>
		if (n0 % n1 != 0) return -1;
 80442ce:	fb95 f3f4 	sdiv	r3, r5, r4
 80442d2:	fb04 5313 	mls	r3, r4, r3, r5
 80442d6:	2b00      	cmp	r3, #0
 80442d8:	d17b      	bne.n	80443d2 <kad_op_mul+0x1de>
	dst->n_d = src->n_d;
 80442da:	f888 2000 	strb.w	r2, [r8]
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 80442de:	2a00      	cmp	r2, #0
 80442e0:	d0bb      	beq.n	804425a <kad_op_mul+0x66>
 80442e2:	0092      	lsls	r2, r2, #2
 80442e4:	f106 0110 	add.w	r1, r6, #16
 80442e8:	f108 0010 	add.w	r0, r8, #16
 80442ec:	f007 fe63 	bl	804bfb6 <memcpy>
 80442f0:	e7b3      	b.n	804425a <kad_op_mul+0x66>
	if (action == KAD_SYNC_DIM) {
 80442f2:	2904      	cmp	r1, #4
 80442f4:	d0f1      	beq.n	80442da <kad_op_mul+0xe6>
	int n = 1, i;
 80442f6:	2401      	movs	r4, #1
 80442f8:	e7ab      	b.n	8044252 <kad_op_mul+0x5e>
 80442fa:	2501      	movs	r5, #1
 80442fc:	e793      	b.n	8044226 <kad_op_mul+0x32>
		if (kad_is_back(q[0]) && q[1]->x)
 80442fe:	7872      	ldrb	r2, [r6, #1]
 8044300:	787b      	ldrb	r3, [r7, #1]
 8044302:	07d2      	lsls	r2, r2, #31
 8044304:	f003 0301 	and.w	r3, r3, #1
 8044308:	d534      	bpl.n	8044374 <kad_op_mul+0x180>
 804430a:	f8d7 a028 	ldr.w	sl, [r7, #40]	@ 0x28
 804430e:	f1ba 0f00 	cmp.w	sl, #0
 8044312:	d02f      	beq.n	8044374 <kad_op_mul+0x180>
			for (i = 0; i < n0; i += n1)
 8044314:	2d00      	cmp	r5, #0
 8044316:	dda0      	ble.n	804425a <kad_op_mul+0x66>
 8044318:	2c00      	cmp	r4, #0
				kad_vec_mul_sum(n1, q[0]->g + i, p->g + i, q[1]->x);
 804431a:	f8d8 802c 	ldr.w	r8, [r8, #44]	@ 0x2c
 804431e:	f8d6 b02c 	ldr.w	fp, [r6, #44]	@ 0x2c
 8044322:	dd1e      	ble.n	8044362 <kad_op_mul+0x16e>
 8044324:	f04f 0c00 	mov.w	ip, #0
			for (i = 0; i < n0; i += n1)
 8044328:	46e6      	mov	lr, ip
 804432a:	ea4f 0984 	mov.w	r9, r4, lsl #2
 804432e:	eb0b 0084 	add.w	r0, fp, r4, lsl #2
 8044332:	9601      	str	r6, [sp, #4]
	for (i = 0; i < n; ++i) a[i] += b[i] * c[i];
 8044334:	4656      	mov	r6, sl
 8044336:	eb0b 020c 	add.w	r2, fp, ip
 804433a:	eb08 010c 	add.w	r1, r8, ip
 804433e:	edd2 7a00 	vldr	s15, [r2]
 8044342:	ecf1 6a01 	vldmia	r1!, {s13}
 8044346:	ecb6 7a01 	vldmia	r6!, {s14}
 804434a:	eee6 7a87 	vfma.f32	s15, s13, s14
 804434e:	ece2 7a01 	vstmia	r2!, {s15}
 8044352:	4290      	cmp	r0, r2
 8044354:	d1f3      	bne.n	804433e <kad_op_mul+0x14a>
			for (i = 0; i < n0; i += n1)
 8044356:	44a6      	add	lr, r4
 8044358:	4575      	cmp	r5, lr
 804435a:	44cc      	add	ip, r9
 804435c:	4448      	add	r0, r9
 804435e:	dce9      	bgt.n	8044334 <kad_op_mul+0x140>
 8044360:	9e01      	ldr	r6, [sp, #4]
		if (kad_is_back(q[1]) && q[0]->x)
 8044362:	2b00      	cmp	r3, #0
 8044364:	f43f af79 	beq.w	804425a <kad_op_mul+0x66>
 8044368:	f8d6 c028 	ldr.w	ip, [r6, #40]	@ 0x28
 804436c:	f1bc 0f00 	cmp.w	ip, #0
 8044370:	d10e      	bne.n	8044390 <kad_op_mul+0x19c>
 8044372:	e772      	b.n	804425a <kad_op_mul+0x66>
 8044374:	2b00      	cmp	r3, #0
 8044376:	f43f af70 	beq.w	804425a <kad_op_mul+0x66>
 804437a:	f8d6 c028 	ldr.w	ip, [r6, #40]	@ 0x28
 804437e:	f1bc 0f00 	cmp.w	ip, #0
 8044382:	f43f af6a 	beq.w	804425a <kad_op_mul+0x66>
			for (i = 0; i < n0; i += n1)
 8044386:	2d00      	cmp	r5, #0
 8044388:	f77f af67 	ble.w	804425a <kad_op_mul+0x66>
 804438c:	f8d8 802c 	ldr.w	r8, [r8, #44]	@ 0x2c
 8044390:	2c00      	cmp	r4, #0
				kad_vec_mul_sum(n1, q[1]->g, p->g + i, q[0]->x + i);
 8044392:	f8d7 e02c 	ldr.w	lr, [r7, #44]	@ 0x2c
 8044396:	f77f af60 	ble.w	804425a <kad_op_mul+0x66>
 804439a:	2600      	movs	r6, #0
			for (i = 0; i < n0; i += n1)
 804439c:	4637      	mov	r7, r6
 804439e:	ea4f 0984 	mov.w	r9, r4, lsl #2
 80443a2:	eb0e 0084 	add.w	r0, lr, r4, lsl #2
 80443a6:	4673      	mov	r3, lr
 80443a8:	eb08 0106 	add.w	r1, r8, r6
 80443ac:	eb0c 0206 	add.w	r2, ip, r6
	for (i = 0; i < n; ++i) a[i] += b[i] * c[i];
 80443b0:	edd3 7a00 	vldr	s15, [r3]
 80443b4:	ecf1 6a01 	vldmia	r1!, {s13}
 80443b8:	ecb2 7a01 	vldmia	r2!, {s14}
 80443bc:	eee6 7a87 	vfma.f32	s15, s13, s14
 80443c0:	ece3 7a01 	vstmia	r3!, {s15}
 80443c4:	4298      	cmp	r0, r3
 80443c6:	d1f3      	bne.n	80443b0 <kad_op_mul+0x1bc>
			for (i = 0; i < n0; i += n1)
 80443c8:	4427      	add	r7, r4
 80443ca:	42bd      	cmp	r5, r7
 80443cc:	444e      	add	r6, r9
 80443ce:	dcea      	bgt.n	80443a6 <kad_op_mul+0x1b2>
 80443d0:	e743      	b.n	804425a <kad_op_mul+0x66>
		if (n0 % n1 != 0) return -1;
 80443d2:	f04f 30ff 	mov.w	r0, #4294967295
 80443d6:	e741      	b.n	804425c <kad_op_mul+0x68>
		assert(n0 >= n1);
 80443d8:	f240 4159 	movw	r1, #1113	@ 0x459
 80443dc:	4b02      	ldr	r3, [pc, #8]	@ (80443e8 <kad_op_mul+0x1f4>)
 80443de:	4a03      	ldr	r2, [pc, #12]	@ (80443ec <kad_op_mul+0x1f8>)
 80443e0:	4803      	ldr	r0, [pc, #12]	@ (80443f0 <kad_op_mul+0x1fc>)
 80443e2:	f007 f9c3 	bl	804b76c <__assert_func>
 80443e6:	bf00      	nop
 80443e8:	0804e348 	.word	0x0804e348
 80443ec:	0804e4f0 	.word	0x0804e4f0
 80443f0:	0804e328 	.word	0x0804e328

080443f4 <kad_op_add>:
{
 80443f4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	q[0] = p->child[0], n0 = kad_len(q[0]);
 80443f8:	6b83      	ldr	r3, [r0, #56]	@ 0x38
{
 80443fa:	4680      	mov	r8, r0
	q[0] = p->child[0], n0 = kad_len(q[0]);
 80443fc:	6818      	ldr	r0, [r3, #0]
	for (i = 0; i < p->n_d; ++i) n *= p->d[i];
 80443fe:	7802      	ldrb	r2, [r0, #0]
 8044400:	2a00      	cmp	r2, #0
 8044402:	d06d      	beq.n	80444e0 <kad_op_add+0xec>
 8044404:	2a01      	cmp	r2, #1
 8044406:	6905      	ldr	r5, [r0, #16]
 8044408:	d00c      	beq.n	8044424 <kad_op_add+0x30>
 804440a:	6944      	ldr	r4, [r0, #20]
 804440c:	2a02      	cmp	r2, #2
 804440e:	fb04 f505 	mul.w	r5, r4, r5
 8044412:	d007      	beq.n	8044424 <kad_op_add+0x30>
 8044414:	6984      	ldr	r4, [r0, #24]
 8044416:	2a03      	cmp	r2, #3
 8044418:	fb04 f505 	mul.w	r5, r4, r5
 804441c:	d002      	beq.n	8044424 <kad_op_add+0x30>
 804441e:	69c4      	ldr	r4, [r0, #28]
 8044420:	fb04 f505 	mul.w	r5, r4, r5
	q[1] = p->child[1], n1 = kad_len(q[1]);
 8044424:	685f      	ldr	r7, [r3, #4]
 8044426:	783b      	ldrb	r3, [r7, #0]
 8044428:	2b00      	cmp	r3, #0
 804442a:	d055      	beq.n	80444d8 <kad_op_add+0xe4>
 804442c:	2b01      	cmp	r3, #1
 804442e:	693c      	ldr	r4, [r7, #16]
 8044430:	d00c      	beq.n	804444c <kad_op_add+0x58>
 8044432:	697e      	ldr	r6, [r7, #20]
 8044434:	2b02      	cmp	r3, #2
 8044436:	fb06 f404 	mul.w	r4, r6, r4
 804443a:	d007      	beq.n	804444c <kad_op_add+0x58>
 804443c:	69be      	ldr	r6, [r7, #24]
 804443e:	2b03      	cmp	r3, #3
 8044440:	fb06 f404 	mul.w	r4, r6, r4
 8044444:	d002      	beq.n	804444c <kad_op_add+0x58>
 8044446:	69fb      	ldr	r3, [r7, #28]
 8044448:	fb03 f404 	mul.w	r4, r3, r4
	if (action == KAD_SYNC_DIM) {
 804444c:	2904      	cmp	r1, #4
 804444e:	d031      	beq.n	80444b4 <kad_op_add+0xc0>
	} else if (action == KAD_FORWARD) {
 8044450:	2902      	cmp	r1, #2
 8044452:	d004      	beq.n	804445e <kad_op_add+0x6a>
	} else if (action == KAD_BACKWARD) {
 8044454:	2903      	cmp	r1, #3
 8044456:	d045      	beq.n	80444e4 <kad_op_add+0xf0>
	return 0;
 8044458:	2000      	movs	r0, #0
}
 804445a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		assert(n0 >= n1);
 804445e:	42ac      	cmp	r4, r5
 8044460:	dc7a      	bgt.n	8044558 <kad_op_add+0x164>
		memcpy(p->x, q[0]->x, n0 * sizeof(float));
 8044462:	6a81      	ldr	r1, [r0, #40]	@ 0x28
 8044464:	00aa      	lsls	r2, r5, #2
 8044466:	f8d8 0028 	ldr.w	r0, [r8, #40]	@ 0x28
 804446a:	f007 fda4 	bl	804bfb6 <memcpy>
		for (i = 0; i < n0; i += n1)
 804446e:	2d00      	cmp	r5, #0
 8044470:	ddf2      	ble.n	8044458 <kad_op_add+0x64>
 8044472:	2c00      	cmp	r4, #0
			kad_saxpy(n1, 1.0f, q[1]->x, p->x + i);
 8044474:	6abf      	ldr	r7, [r7, #40]	@ 0x28
 8044476:	f8d8 1028 	ldr.w	r1, [r8, #40]	@ 0x28
 804447a:	dded      	ble.n	8044458 <kad_op_add+0x64>
		for (i = 0; i < n0; i += n1)
 804447c:	2000      	movs	r0, #0
 804447e:	ebc4 7e44 	rsb	lr, r4, r4, lsl #29
 8044482:	00a6      	lsls	r6, r4, #2
 8044484:	eb01 0184 	add.w	r1, r1, r4, lsl #2
 8044488:	ea4f 0ece 	mov.w	lr, lr, lsl #3
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 804448c:	eba1 0c06 	sub.w	ip, r1, r6
 8044490:	463a      	mov	r2, r7
		for (i = 0; i < n0; i += n1)
 8044492:	4663      	mov	r3, ip
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 8044494:	edd3 7a00 	vldr	s15, [r3]
 8044498:	ecb2 7a01 	vldmia	r2!, {s14}
 804449c:	ee77 7a87 	vadd.f32	s15, s15, s14
 80444a0:	ece3 7a01 	vstmia	r3!, {s15}
 80444a4:	428b      	cmp	r3, r1
 80444a6:	d1f5      	bne.n	8044494 <kad_op_add+0xa0>
		for (i = 0; i < n0; i += n1)
 80444a8:	4420      	add	r0, r4
 80444aa:	42a8      	cmp	r0, r5
 80444ac:	ebac 010e 	sub.w	r1, ip, lr
 80444b0:	dbec      	blt.n	804448c <kad_op_add+0x98>
 80444b2:	e7d1      	b.n	8044458 <kad_op_add+0x64>
		if (n0 % n1 != 0) return -1;
 80444b4:	fb95 f3f4 	sdiv	r3, r5, r4
 80444b8:	fb04 5313 	mls	r3, r4, r3, r5
 80444bc:	2b00      	cmp	r3, #0
 80444be:	d148      	bne.n	8044552 <kad_op_add+0x15e>
	dst->n_d = src->n_d;
 80444c0:	f888 2000 	strb.w	r2, [r8]
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 80444c4:	2a00      	cmp	r2, #0
 80444c6:	d0c7      	beq.n	8044458 <kad_op_add+0x64>
 80444c8:	f100 0110 	add.w	r1, r0, #16
 80444cc:	0092      	lsls	r2, r2, #2
 80444ce:	f108 0010 	add.w	r0, r8, #16
 80444d2:	f007 fd70 	bl	804bfb6 <memcpy>
 80444d6:	e7bf      	b.n	8044458 <kad_op_add+0x64>
	if (action == KAD_SYNC_DIM) {
 80444d8:	2904      	cmp	r1, #4
 80444da:	d0f1      	beq.n	80444c0 <kad_op_add+0xcc>
	int n = 1, i;
 80444dc:	2401      	movs	r4, #1
 80444de:	e7b7      	b.n	8044450 <kad_op_add+0x5c>
 80444e0:	2501      	movs	r5, #1
 80444e2:	e79f      	b.n	8044424 <kad_op_add+0x30>
		if (kad_is_back(q[0])) kad_saxpy(n0, 1.0f, p->g, q[0]->g);
 80444e4:	7843      	ldrb	r3, [r0, #1]
 80444e6:	07d9      	lsls	r1, r3, #31
 80444e8:	d52b      	bpl.n	8044542 <kad_op_add+0x14e>
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 80444ea:	2d00      	cmp	r5, #0
		if (kad_is_back(q[0])) kad_saxpy(n0, 1.0f, p->g, q[0]->g);
 80444ec:	f8d8 602c 	ldr.w	r6, [r8, #44]	@ 0x2c
 80444f0:	6ac3      	ldr	r3, [r0, #44]	@ 0x2c
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 80444f2:	ddb1      	ble.n	8044458 <kad_op_add+0x64>
 80444f4:	4632      	mov	r2, r6
 80444f6:	eb03 0185 	add.w	r1, r3, r5, lsl #2
 80444fa:	edd3 7a00 	vldr	s15, [r3]
 80444fe:	ecb2 7a01 	vldmia	r2!, {s14}
 8044502:	ee77 7a87 	vadd.f32	s15, s15, s14
 8044506:	ece3 7a01 	vstmia	r3!, {s15}
 804450a:	4299      	cmp	r1, r3
 804450c:	d1f5      	bne.n	80444fa <kad_op_add+0x106>
		if (kad_is_back(q[1]))
 804450e:	787b      	ldrb	r3, [r7, #1]
 8044510:	07db      	lsls	r3, r3, #31
 8044512:	d5a1      	bpl.n	8044458 <kad_op_add+0x64>
 8044514:	2c00      	cmp	r4, #0
				kad_saxpy(n1, 1.0f, p->g + i, q[1]->g);
 8044516:	6aff      	ldr	r7, [r7, #44]	@ 0x2c
 8044518:	dd9e      	ble.n	8044458 <kad_op_add+0x64>
			for (i = 0; i < n0; i += n1)
 804451a:	2000      	movs	r0, #0
 804451c:	eb07 0184 	add.w	r1, r7, r4, lsl #2
 8044520:	463b      	mov	r3, r7
 8044522:	eb06 0280 	add.w	r2, r6, r0, lsl #2
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 8044526:	edd3 7a00 	vldr	s15, [r3]
 804452a:	ecb2 7a01 	vldmia	r2!, {s14}
 804452e:	ee77 7a87 	vadd.f32	s15, s15, s14
 8044532:	ece3 7a01 	vstmia	r3!, {s15}
 8044536:	4299      	cmp	r1, r3
 8044538:	d1f5      	bne.n	8044526 <kad_op_add+0x132>
			for (i = 0; i < n0; i += n1)
 804453a:	4420      	add	r0, r4
 804453c:	42a8      	cmp	r0, r5
 804453e:	dbef      	blt.n	8044520 <kad_op_add+0x12c>
 8044540:	e78a      	b.n	8044458 <kad_op_add+0x64>
		if (kad_is_back(q[1]))
 8044542:	787b      	ldrb	r3, [r7, #1]
 8044544:	07da      	lsls	r2, r3, #31
 8044546:	d587      	bpl.n	8044458 <kad_op_add+0x64>
			for (i = 0; i < n0; i += n1)
 8044548:	2d00      	cmp	r5, #0
 804454a:	dd85      	ble.n	8044458 <kad_op_add+0x64>
 804454c:	f8d8 602c 	ldr.w	r6, [r8, #44]	@ 0x2c
 8044550:	e7e0      	b.n	8044514 <kad_op_add+0x120>
		if (n0 % n1 != 0) return -1;
 8044552:	f04f 30ff 	mov.w	r0, #4294967295
 8044556:	e780      	b.n	804445a <kad_op_add+0x66>
		assert(n0 >= n1);
 8044558:	f240 4129 	movw	r1, #1065	@ 0x429
 804455c:	4b02      	ldr	r3, [pc, #8]	@ (8044568 <kad_op_add+0x174>)
 804455e:	4a03      	ldr	r2, [pc, #12]	@ (804456c <kad_op_add+0x178>)
 8044560:	4803      	ldr	r0, [pc, #12]	@ (8044570 <kad_op_add+0x17c>)
 8044562:	f007 f903 	bl	804b76c <__assert_func>
 8044566:	bf00      	nop
 8044568:	0804e348 	.word	0x0804e348
 804456c:	0804e508 	.word	0x0804e508
 8044570:	0804e328 	.word	0x0804e328

08044574 <kad_op_sub>:
{
 8044574:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	q[0] = p->child[0], n0 = kad_len(q[0]);
 8044578:	6b83      	ldr	r3, [r0, #56]	@ 0x38
{
 804457a:	4680      	mov	r8, r0
	q[0] = p->child[0], n0 = kad_len(q[0]);
 804457c:	6818      	ldr	r0, [r3, #0]
	for (i = 0; i < p->n_d; ++i) n *= p->d[i];
 804457e:	7802      	ldrb	r2, [r0, #0]
 8044580:	2a00      	cmp	r2, #0
 8044582:	d06d      	beq.n	8044660 <kad_op_sub+0xec>
 8044584:	2a01      	cmp	r2, #1
 8044586:	6905      	ldr	r5, [r0, #16]
 8044588:	d00c      	beq.n	80445a4 <kad_op_sub+0x30>
 804458a:	6944      	ldr	r4, [r0, #20]
 804458c:	2a02      	cmp	r2, #2
 804458e:	fb04 f505 	mul.w	r5, r4, r5
 8044592:	d007      	beq.n	80445a4 <kad_op_sub+0x30>
 8044594:	6984      	ldr	r4, [r0, #24]
 8044596:	2a03      	cmp	r2, #3
 8044598:	fb04 f505 	mul.w	r5, r4, r5
 804459c:	d002      	beq.n	80445a4 <kad_op_sub+0x30>
 804459e:	69c4      	ldr	r4, [r0, #28]
 80445a0:	fb04 f505 	mul.w	r5, r4, r5
	q[1] = p->child[1], n1 = kad_len(q[1]);
 80445a4:	685f      	ldr	r7, [r3, #4]
 80445a6:	783b      	ldrb	r3, [r7, #0]
 80445a8:	2b00      	cmp	r3, #0
 80445aa:	d055      	beq.n	8044658 <kad_op_sub+0xe4>
 80445ac:	2b01      	cmp	r3, #1
 80445ae:	693c      	ldr	r4, [r7, #16]
 80445b0:	d00c      	beq.n	80445cc <kad_op_sub+0x58>
 80445b2:	697e      	ldr	r6, [r7, #20]
 80445b4:	2b02      	cmp	r3, #2
 80445b6:	fb06 f404 	mul.w	r4, r6, r4
 80445ba:	d007      	beq.n	80445cc <kad_op_sub+0x58>
 80445bc:	69be      	ldr	r6, [r7, #24]
 80445be:	2b03      	cmp	r3, #3
 80445c0:	fb06 f404 	mul.w	r4, r6, r4
 80445c4:	d002      	beq.n	80445cc <kad_op_sub+0x58>
 80445c6:	69fb      	ldr	r3, [r7, #28]
 80445c8:	fb03 f404 	mul.w	r4, r3, r4
	if (action == KAD_SYNC_DIM) {
 80445cc:	2904      	cmp	r1, #4
 80445ce:	d031      	beq.n	8044634 <kad_op_sub+0xc0>
	} else if (action == KAD_FORWARD) {
 80445d0:	2902      	cmp	r1, #2
 80445d2:	d004      	beq.n	80445de <kad_op_sub+0x6a>
	} else if (action == KAD_BACKWARD) {
 80445d4:	2903      	cmp	r1, #3
 80445d6:	d045      	beq.n	8044664 <kad_op_sub+0xf0>
	return 0;
 80445d8:	2000      	movs	r0, #0
}
 80445da:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		assert(n0 >= n1);
 80445de:	42ac      	cmp	r4, r5
 80445e0:	dc7a      	bgt.n	80446d8 <kad_op_sub+0x164>
		memcpy(p->x, q[0]->x, n0 * sizeof(float));
 80445e2:	6a81      	ldr	r1, [r0, #40]	@ 0x28
 80445e4:	00aa      	lsls	r2, r5, #2
 80445e6:	f8d8 0028 	ldr.w	r0, [r8, #40]	@ 0x28
 80445ea:	f007 fce4 	bl	804bfb6 <memcpy>
		for (i = 0; i < n0; i += n1)
 80445ee:	2d00      	cmp	r5, #0
 80445f0:	ddf2      	ble.n	80445d8 <kad_op_sub+0x64>
 80445f2:	2c00      	cmp	r4, #0
			kad_saxpy(n1, -1.0f, q[1]->x, p->x + i);
 80445f4:	6abf      	ldr	r7, [r7, #40]	@ 0x28
 80445f6:	f8d8 1028 	ldr.w	r1, [r8, #40]	@ 0x28
 80445fa:	dded      	ble.n	80445d8 <kad_op_sub+0x64>
		for (i = 0; i < n0; i += n1)
 80445fc:	2000      	movs	r0, #0
 80445fe:	ebc4 7e44 	rsb	lr, r4, r4, lsl #29
 8044602:	00a6      	lsls	r6, r4, #2
 8044604:	eb01 0184 	add.w	r1, r1, r4, lsl #2
 8044608:	ea4f 0ece 	mov.w	lr, lr, lsl #3
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 804460c:	eba1 0c06 	sub.w	ip, r1, r6
 8044610:	463a      	mov	r2, r7
		for (i = 0; i < n0; i += n1)
 8044612:	4663      	mov	r3, ip
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 8044614:	edd3 7a00 	vldr	s15, [r3]
 8044618:	ecb2 7a01 	vldmia	r2!, {s14}
 804461c:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8044620:	ece3 7a01 	vstmia	r3!, {s15}
 8044624:	428b      	cmp	r3, r1
 8044626:	d1f5      	bne.n	8044614 <kad_op_sub+0xa0>
		for (i = 0; i < n0; i += n1)
 8044628:	4420      	add	r0, r4
 804462a:	42a8      	cmp	r0, r5
 804462c:	ebac 010e 	sub.w	r1, ip, lr
 8044630:	dbec      	blt.n	804460c <kad_op_sub+0x98>
 8044632:	e7d1      	b.n	80445d8 <kad_op_sub+0x64>
		if (n0 % n1 != 0) return -1;
 8044634:	fb95 f3f4 	sdiv	r3, r5, r4
 8044638:	fb04 5313 	mls	r3, r4, r3, r5
 804463c:	2b00      	cmp	r3, #0
 804463e:	d148      	bne.n	80446d2 <kad_op_sub+0x15e>
	dst->n_d = src->n_d;
 8044640:	f888 2000 	strb.w	r2, [r8]
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 8044644:	2a00      	cmp	r2, #0
 8044646:	d0c7      	beq.n	80445d8 <kad_op_sub+0x64>
 8044648:	f100 0110 	add.w	r1, r0, #16
 804464c:	0092      	lsls	r2, r2, #2
 804464e:	f108 0010 	add.w	r0, r8, #16
 8044652:	f007 fcb0 	bl	804bfb6 <memcpy>
 8044656:	e7bf      	b.n	80445d8 <kad_op_sub+0x64>
	if (action == KAD_SYNC_DIM) {
 8044658:	2904      	cmp	r1, #4
 804465a:	d0f1      	beq.n	8044640 <kad_op_sub+0xcc>
	int n = 1, i;
 804465c:	2401      	movs	r4, #1
 804465e:	e7b7      	b.n	80445d0 <kad_op_sub+0x5c>
 8044660:	2501      	movs	r5, #1
 8044662:	e79f      	b.n	80445a4 <kad_op_sub+0x30>
		if (kad_is_back(q[0])) kad_saxpy(n0, 1.0f, p->g, q[0]->g);
 8044664:	7843      	ldrb	r3, [r0, #1]
 8044666:	07d9      	lsls	r1, r3, #31
 8044668:	d52b      	bpl.n	80446c2 <kad_op_sub+0x14e>
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 804466a:	2d00      	cmp	r5, #0
		if (kad_is_back(q[0])) kad_saxpy(n0, 1.0f, p->g, q[0]->g);
 804466c:	f8d8 602c 	ldr.w	r6, [r8, #44]	@ 0x2c
 8044670:	6ac3      	ldr	r3, [r0, #44]	@ 0x2c
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 8044672:	ddb1      	ble.n	80445d8 <kad_op_sub+0x64>
 8044674:	4632      	mov	r2, r6
 8044676:	eb03 0185 	add.w	r1, r3, r5, lsl #2
 804467a:	edd3 7a00 	vldr	s15, [r3]
 804467e:	ecb2 7a01 	vldmia	r2!, {s14}
 8044682:	ee77 7a87 	vadd.f32	s15, s15, s14
 8044686:	ece3 7a01 	vstmia	r3!, {s15}
 804468a:	4299      	cmp	r1, r3
 804468c:	d1f5      	bne.n	804467a <kad_op_sub+0x106>
		if (kad_is_back(q[1]))
 804468e:	787b      	ldrb	r3, [r7, #1]
 8044690:	07db      	lsls	r3, r3, #31
 8044692:	d5a1      	bpl.n	80445d8 <kad_op_sub+0x64>
 8044694:	2c00      	cmp	r4, #0
				kad_saxpy(n1, -1.0f, p->g + i, q[1]->g);
 8044696:	6aff      	ldr	r7, [r7, #44]	@ 0x2c
 8044698:	dd9e      	ble.n	80445d8 <kad_op_sub+0x64>
			for (i = 0; i < n0; i += n1)
 804469a:	2000      	movs	r0, #0
 804469c:	eb07 0184 	add.w	r1, r7, r4, lsl #2
 80446a0:	463b      	mov	r3, r7
 80446a2:	eb06 0280 	add.w	r2, r6, r0, lsl #2
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 80446a6:	edd3 7a00 	vldr	s15, [r3]
 80446aa:	ecb2 7a01 	vldmia	r2!, {s14}
 80446ae:	ee77 7ac7 	vsub.f32	s15, s15, s14
 80446b2:	ece3 7a01 	vstmia	r3!, {s15}
 80446b6:	4299      	cmp	r1, r3
 80446b8:	d1f5      	bne.n	80446a6 <kad_op_sub+0x132>
			for (i = 0; i < n0; i += n1)
 80446ba:	4420      	add	r0, r4
 80446bc:	42a8      	cmp	r0, r5
 80446be:	dbef      	blt.n	80446a0 <kad_op_sub+0x12c>
 80446c0:	e78a      	b.n	80445d8 <kad_op_sub+0x64>
		if (kad_is_back(q[1]))
 80446c2:	787b      	ldrb	r3, [r7, #1]
 80446c4:	07da      	lsls	r2, r3, #31
 80446c6:	d587      	bpl.n	80445d8 <kad_op_sub+0x64>
			for (i = 0; i < n0; i += n1)
 80446c8:	2d00      	cmp	r5, #0
 80446ca:	dd85      	ble.n	80445d8 <kad_op_sub+0x64>
 80446cc:	f8d8 602c 	ldr.w	r6, [r8, #44]	@ 0x2c
 80446d0:	e7e0      	b.n	8044694 <kad_op_sub+0x120>
		if (n0 % n1 != 0) return -1;
 80446d2:	f04f 30ff 	mov.w	r0, #4294967295
 80446d6:	e780      	b.n	80445da <kad_op_sub+0x66>
		assert(n0 >= n1);
 80446d8:	f240 4141 	movw	r1, #1089	@ 0x441
 80446dc:	4b02      	ldr	r3, [pc, #8]	@ (80446e8 <kad_op_sub+0x174>)
 80446de:	4a03      	ldr	r2, [pc, #12]	@ (80446ec <kad_op_sub+0x178>)
 80446e0:	4803      	ldr	r0, [pc, #12]	@ (80446f0 <kad_op_sub+0x17c>)
 80446e2:	f007 f843 	bl	804b76c <__assert_func>
 80446e6:	bf00      	nop
 80446e8:	0804e348 	.word	0x0804e348
 80446ec:	0804e4fc 	.word	0x0804e4fc
 80446f0:	0804e328 	.word	0x0804e328

080446f4 <kad_op_1minus>:
{
 80446f4:	b538      	push	{r3, r4, r5, lr}
	kad_node_t *q = p->child[0];
 80446f6:	6b83      	ldr	r3, [r0, #56]	@ 0x38
 80446f8:	681c      	ldr	r4, [r3, #0]
	for (i = 0; i < p->n_d; ++i) n *= p->d[i];
 80446fa:	7825      	ldrb	r5, [r4, #0]
 80446fc:	b305      	cbz	r5, 8044740 <kad_op_1minus+0x4c>
 80446fe:	2d01      	cmp	r5, #1
 8044700:	6923      	ldr	r3, [r4, #16]
 8044702:	d00c      	beq.n	804471e <kad_op_1minus+0x2a>
 8044704:	6962      	ldr	r2, [r4, #20]
 8044706:	2d02      	cmp	r5, #2
 8044708:	fb02 f303 	mul.w	r3, r2, r3
 804470c:	d007      	beq.n	804471e <kad_op_1minus+0x2a>
 804470e:	69a2      	ldr	r2, [r4, #24]
 8044710:	2d03      	cmp	r5, #3
 8044712:	fb02 f303 	mul.w	r3, r2, r3
 8044716:	d002      	beq.n	804471e <kad_op_1minus+0x2a>
 8044718:	69e2      	ldr	r2, [r4, #28]
 804471a:	fb02 f303 	mul.w	r3, r2, r3
	if (action == KAD_SYNC_DIM) {
 804471e:	2904      	cmp	r1, #4
 8044720:	d005      	beq.n	804472e <kad_op_1minus+0x3a>
	} else if (action == KAD_FORWARD) {
 8044722:	2902      	cmp	r1, #2
 8044724:	d013      	beq.n	804474e <kad_op_1minus+0x5a>
	} else if (action == KAD_BACKWARD && kad_is_back(q)) {
 8044726:	2903      	cmp	r1, #3
 8044728:	d025      	beq.n	8044776 <kad_op_1minus+0x82>
}
 804472a:	2000      	movs	r0, #0
 804472c:	bd38      	pop	{r3, r4, r5, pc}
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 804472e:	00aa      	lsls	r2, r5, #2
 8044730:	f104 0110 	add.w	r1, r4, #16
	dst->n_d = src->n_d;
 8044734:	f800 5b10 	strb.w	r5, [r0], #16
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 8044738:	f007 fc3d 	bl	804bfb6 <memcpy>
}
 804473c:	2000      	movs	r0, #0
 804473e:	bd38      	pop	{r3, r4, r5, pc}
	if (action == KAD_SYNC_DIM) {
 8044740:	2904      	cmp	r1, #4
 8044742:	d016      	beq.n	8044772 <kad_op_1minus+0x7e>
	} else if (action == KAD_FORWARD) {
 8044744:	2902      	cmp	r1, #2
	int n = 1, i;
 8044746:	f04f 0301 	mov.w	r3, #1
 804474a:	d1ec      	bne.n	8044726 <kad_op_1minus+0x32>
 804474c:	e001      	b.n	8044752 <kad_op_1minus+0x5e>
		for (i = 0; i < n; ++i) p->x[i] = 1.0f - q->x[i];
 804474e:	2b00      	cmp	r3, #0
 8044750:	ddeb      	ble.n	804472a <kad_op_1minus+0x36>
 8044752:	2200      	movs	r2, #0
 8044754:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 8044758:	6aa4      	ldr	r4, [r4, #40]	@ 0x28
 804475a:	6a81      	ldr	r1, [r0, #40]	@ 0x28
 804475c:	ecf4 7a01 	vldmia	r4!, {s15}
 8044760:	ee77 7a67 	vsub.f32	s15, s14, s15
 8044764:	3201      	adds	r2, #1
 8044766:	429a      	cmp	r2, r3
 8044768:	ece1 7a01 	vstmia	r1!, {s15}
 804476c:	dbf6      	blt.n	804475c <kad_op_1minus+0x68>
}
 804476e:	2000      	movs	r0, #0
 8044770:	bd38      	pop	{r3, r4, r5, pc}
	dst->n_d = src->n_d;
 8044772:	7005      	strb	r5, [r0, #0]
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 8044774:	e7d9      	b.n	804472a <kad_op_1minus+0x36>
	} else if (action == KAD_BACKWARD && kad_is_back(q)) {
 8044776:	7862      	ldrb	r2, [r4, #1]
 8044778:	07d2      	lsls	r2, r2, #31
 804477a:	d5d6      	bpl.n	804472a <kad_op_1minus+0x36>
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 804477c:	2b00      	cmp	r3, #0
		kad_saxpy(n, -1.0f, p->g, q->g);
 804477e:	6ac1      	ldr	r1, [r0, #44]	@ 0x2c
 8044780:	6ae2      	ldr	r2, [r4, #44]	@ 0x2c
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 8044782:	ddd2      	ble.n	804472a <kad_op_1minus+0x36>
 8044784:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 8044788:	edd2 7a00 	vldr	s15, [r2]
 804478c:	ecb1 7a01 	vldmia	r1!, {s14}
 8044790:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8044794:	ece2 7a01 	vstmia	r2!, {s15}
 8044798:	4293      	cmp	r3, r2
 804479a:	d1f5      	bne.n	8044788 <kad_op_1minus+0x94>
 804479c:	e7c5      	b.n	804472a <kad_op_1minus+0x36>
 804479e:	bf00      	nop

080447a0 <kad_op_slice>:
{
 80447a0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	kad_node_t *q = p->child[0];
 80447a4:	6b83      	ldr	r3, [r0, #56]	@ 0x38
	assert(p->ptr);
 80447a6:	f8d0 a030 	ldr.w	sl, [r0, #48]	@ 0x30
	kad_node_t *q = p->child[0];
 80447aa:	681d      	ldr	r5, [r3, #0]
	assert(p->ptr);
 80447ac:	f1ba 0f00 	cmp.w	sl, #0
 80447b0:	f000 80b7 	beq.w	8044922 <kad_op_slice+0x182>
	aux = (int32_t*)p->ptr, axis = aux[0], range = aux + 1;
 80447b4:	f8da 4000 	ldr.w	r4, [sl]
	if (axis < 0 || axis >= q->n_d) return -1;
 80447b8:	2c00      	cmp	r4, #0
 80447ba:	f2c0 80af 	blt.w	804491c <kad_op_slice+0x17c>
 80447be:	782f      	ldrb	r7, [r5, #0]
 80447c0:	42a7      	cmp	r7, r4
 80447c2:	f340 80ab 	ble.w	804491c <kad_op_slice+0x17c>
	for (i = 0, d0 = 1; i < axis; ++i) d0 *= q->d[i];
 80447c6:	4606      	mov	r6, r0
 80447c8:	2c00      	cmp	r4, #0
 80447ca:	d06d      	beq.n	80448a8 <kad_op_slice+0x108>
 80447cc:	2c01      	cmp	r4, #1
 80447ce:	f8d5 9010 	ldr.w	r9, [r5, #16]
 80447d2:	d00c      	beq.n	80447ee <kad_op_slice+0x4e>
 80447d4:	696b      	ldr	r3, [r5, #20]
 80447d6:	2c02      	cmp	r4, #2
 80447d8:	fb03 f909 	mul.w	r9, r3, r9
 80447dc:	d007      	beq.n	80447ee <kad_op_slice+0x4e>
 80447de:	69ab      	ldr	r3, [r5, #24]
 80447e0:	2c03      	cmp	r4, #3
 80447e2:	fb03 f909 	mul.w	r9, r3, r9
 80447e6:	d002      	beq.n	80447ee <kad_op_slice+0x4e>
 80447e8:	69eb      	ldr	r3, [r5, #28]
 80447ea:	fb03 f909 	mul.w	r9, r3, r9
	for (i = axis + 1, d1 = 1; i < q->n_d; ++i) d1 *= q->d[i];
 80447ee:	1c63      	adds	r3, r4, #1
 80447f0:	429f      	cmp	r7, r3
 80447f2:	dd56      	ble.n	80448a2 <kad_op_slice+0x102>
 80447f4:	1ca3      	adds	r3, r4, #2
 80447f6:	eb05 0284 	add.w	r2, r5, r4, lsl #2
 80447fa:	429f      	cmp	r7, r3
 80447fc:	f8d2 8014 	ldr.w	r8, [r2, #20]
 8044800:	dd08      	ble.n	8044814 <kad_op_slice+0x74>
 8044802:	6993      	ldr	r3, [r2, #24]
 8044804:	fb03 f808 	mul.w	r8, r3, r8
 8044808:	1ce3      	adds	r3, r4, #3
 804480a:	429f      	cmp	r7, r3
 804480c:	dd02      	ble.n	8044814 <kad_op_slice+0x74>
 804480e:	69d3      	ldr	r3, [r2, #28]
 8044810:	fb03 f808 	mul.w	r8, r3, r8
	if (action == KAD_SYNC_DIM) {
 8044814:	2904      	cmp	r1, #4
 8044816:	d02b      	beq.n	8044870 <kad_op_slice+0xd0>
	} else if (action == KAD_FORWARD) {
 8044818:	2902      	cmp	r1, #2
 804481a:	d004      	beq.n	8044826 <kad_op_slice+0x86>
	} else if (action == KAD_BACKWARD && kad_is_back(q)) {
 804481c:	2903      	cmp	r1, #3
 804481e:	d046      	beq.n	80448ae <kad_op_slice+0x10e>
	return 0;
 8044820:	2000      	movs	r0, #0
}
 8044822:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		for (i = 0; i < d0; ++i)
 8044826:	f1b9 0f00 	cmp.w	r9, #0
 804482a:	ddf9      	ble.n	8044820 <kad_op_slice+0x80>
 804482c:	2700      	movs	r7, #0
 804482e:	3404      	adds	r4, #4
			memcpy(&p->x[i * p->d[axis] * d1], &q->x[(i * q->d[axis] + range[0]) * d1], (range[1] - range[0]) * d1 * sizeof(float));
 8044830:	f856 0024 	ldr.w	r0, [r6, r4, lsl #2]
 8044834:	f8da 1004 	ldr.w	r1, [sl, #4]
 8044838:	fb07 f000 	mul.w	r0, r7, r0
 804483c:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
 8044840:	f8da 2008 	ldr.w	r2, [sl, #8]
 8044844:	fb03 1307 	mla	r3, r3, r7, r1
 8044848:	fb08 f000 	mul.w	r0, r8, r0
 804484c:	1a52      	subs	r2, r2, r1
 804484e:	fb08 f303 	mul.w	r3, r8, r3
 8044852:	6ab1      	ldr	r1, [r6, #40]	@ 0x28
 8044854:	fb08 f202 	mul.w	r2, r8, r2
 8044858:	eb01 0080 	add.w	r0, r1, r0, lsl #2
 804485c:	6aa9      	ldr	r1, [r5, #40]	@ 0x28
		for (i = 0; i < d0; ++i)
 804485e:	3701      	adds	r7, #1
			memcpy(&p->x[i * p->d[axis] * d1], &q->x[(i * q->d[axis] + range[0]) * d1], (range[1] - range[0]) * d1 * sizeof(float));
 8044860:	0092      	lsls	r2, r2, #2
 8044862:	eb01 0183 	add.w	r1, r1, r3, lsl #2
 8044866:	f007 fba6 	bl	804bfb6 <memcpy>
		for (i = 0; i < d0; ++i)
 804486a:	454f      	cmp	r7, r9
 804486c:	d1e0      	bne.n	8044830 <kad_op_slice+0x90>
 804486e:	e7d7      	b.n	8044820 <kad_op_slice+0x80>
		if (range[0] >= range[1] || range[0] < 0 || range[1] > q->d[axis]) return -1;
 8044870:	e9da 2301 	ldrd	r2, r3, [sl, #4]
 8044874:	429a      	cmp	r2, r3
 8044876:	da51      	bge.n	804491c <kad_op_slice+0x17c>
 8044878:	2a00      	cmp	r2, #0
 804487a:	db4f      	blt.n	804491c <kad_op_slice+0x17c>
 804487c:	3404      	adds	r4, #4
 804487e:	f855 2024 	ldr.w	r2, [r5, r4, lsl #2]
 8044882:	4293      	cmp	r3, r2
 8044884:	dc4a      	bgt.n	804491c <kad_op_slice+0x17c>
	dst->n_d = src->n_d;
 8044886:	4630      	mov	r0, r6
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 8044888:	00ba      	lsls	r2, r7, #2
 804488a:	f105 0110 	add.w	r1, r5, #16
	dst->n_d = src->n_d;
 804488e:	f800 7b10 	strb.w	r7, [r0], #16
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 8044892:	f007 fb90 	bl	804bfb6 <memcpy>
		p->d[axis] = range[1] - range[0];
 8044896:	e9da 2301 	ldrd	r2, r3, [sl, #4]
 804489a:	1a9b      	subs	r3, r3, r2
 804489c:	f846 3024 	str.w	r3, [r6, r4, lsl #2]
 80448a0:	e7be      	b.n	8044820 <kad_op_slice+0x80>
	for (i = axis + 1, d1 = 1; i < q->n_d; ++i) d1 *= q->d[i];
 80448a2:	f04f 0801 	mov.w	r8, #1
 80448a6:	e7b5      	b.n	8044814 <kad_op_slice+0x74>
	for (i = 0, d0 = 1; i < axis; ++i) d0 *= q->d[i];
 80448a8:	f04f 0901 	mov.w	r9, #1
 80448ac:	e79f      	b.n	80447ee <kad_op_slice+0x4e>
	} else if (action == KAD_BACKWARD && kad_is_back(q)) {
 80448ae:	786b      	ldrb	r3, [r5, #1]
 80448b0:	07db      	lsls	r3, r3, #31
 80448b2:	d5b5      	bpl.n	8044820 <kad_op_slice+0x80>
		for (i = 0; i < d0; ++i)
 80448b4:	f1b9 0f00 	cmp.w	r9, #0
 80448b8:	ddb2      	ble.n	8044820 <kad_op_slice+0x80>
			kad_saxpy((range[1] - range[0]) * d1, 1.0f, &p->g[i * p->d[axis] * d1], &q->g[(i * q->d[axis] + range[0]) * d1]);
 80448ba:	e9da 2301 	ldrd	r2, r3, [sl, #4]
 80448be:	1a9b      	subs	r3, r3, r2
 80448c0:	fb08 f303 	mul.w	r3, r8, r3
 80448c4:	3404      	adds	r4, #4
 80448c6:	2b00      	cmp	r3, #0
 80448c8:	6af7      	ldr	r7, [r6, #44]	@ 0x2c
 80448ca:	f856 0024 	ldr.w	r0, [r6, r4, lsl #2]
 80448ce:	f855 1024 	ldr.w	r1, [r5, r4, lsl #2]
 80448d2:	6aee      	ldr	r6, [r5, #44]	@ 0x2c
 80448d4:	dda4      	ble.n	8044820 <kad_op_slice+0x80>
 80448d6:	2400      	movs	r4, #0
		for (i = 0; i < d0; ++i)
 80448d8:	4625      	mov	r5, r4
 80448da:	fb08 f202 	mul.w	r2, r8, r2
 80448de:	fb08 f101 	mul.w	r1, r8, r1
 80448e2:	fb08 fe00 	mul.w	lr, r8, r0
 80448e6:	4413      	add	r3, r2
 80448e8:	ea4f 0c81 	mov.w	ip, r1, lsl #2
 80448ec:	0090      	lsls	r0, r2, #2
 80448ee:	ea4f 0e8e 	mov.w	lr, lr, lsl #2
 80448f2:	eb06 0183 	add.w	r1, r6, r3, lsl #2
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 80448f6:	1833      	adds	r3, r6, r0
 80448f8:	193a      	adds	r2, r7, r4
 80448fa:	edd3 7a00 	vldr	s15, [r3]
 80448fe:	ecb2 7a01 	vldmia	r2!, {s14}
 8044902:	ee77 7a87 	vadd.f32	s15, s15, s14
 8044906:	ece3 7a01 	vstmia	r3!, {s15}
 804490a:	4299      	cmp	r1, r3
 804490c:	d1f5      	bne.n	80448fa <kad_op_slice+0x15a>
		for (i = 0; i < d0; ++i)
 804490e:	3501      	adds	r5, #1
 8044910:	454d      	cmp	r5, r9
 8044912:	4460      	add	r0, ip
 8044914:	4474      	add	r4, lr
 8044916:	4461      	add	r1, ip
 8044918:	d1ed      	bne.n	80448f6 <kad_op_slice+0x156>
 804491a:	e781      	b.n	8044820 <kad_op_slice+0x80>
	if (axis < 0 || axis >= q->n_d) return -1;
 804491c:	f04f 30ff 	mov.w	r0, #4294967295
 8044920:	e77f      	b.n	8044822 <kad_op_slice+0x82>
	assert(p->ptr);
 8044922:	f44f 61ab 	mov.w	r1, #1368	@ 0x558
 8044926:	4b02      	ldr	r3, [pc, #8]	@ (8044930 <kad_op_slice+0x190>)
 8044928:	4a02      	ldr	r2, [pc, #8]	@ (8044934 <kad_op_slice+0x194>)
 804492a:	4803      	ldr	r0, [pc, #12]	@ (8044938 <kad_op_slice+0x198>)
 804492c:	f006 ff1e 	bl	804b76c <__assert_func>
 8044930:	0804e320 	.word	0x0804e320
 8044934:	0804e4a8 	.word	0x0804e4a8
 8044938:	0804e328 	.word	0x0804e328

0804493c <kad_op_concat>:
{
 804493c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8044940:	4604      	mov	r4, r0
	kad_node_t *q = p->child[0];
 8044942:	6b80      	ldr	r0, [r0, #56]	@ 0x38
	assert(p->ptr);
 8044944:	6b22      	ldr	r2, [r4, #48]	@ 0x30
	kad_node_t *q = p->child[0];
 8044946:	6803      	ldr	r3, [r0, #0]
{
 8044948:	b083      	sub	sp, #12
	assert(p->ptr);
 804494a:	2a00      	cmp	r2, #0
 804494c:	f000 817c 	beq.w	8044c48 <kad_op_concat+0x30c>
	aux = (int32_t*)p->ptr, axis = aux[0];
 8044950:	6815      	ldr	r5, [r2, #0]
	for (i = 0, d0 = 1; i < axis; ++i) d0 *= q->d[i];
 8044952:	2d00      	cmp	r5, #0
 8044954:	f340 8114 	ble.w	8044b80 <kad_op_concat+0x244>
 8044958:	2d01      	cmp	r5, #1
 804495a:	f8d3 c010 	ldr.w	ip, [r3, #16]
 804495e:	d00c      	beq.n	804497a <kad_op_concat+0x3e>
 8044960:	695a      	ldr	r2, [r3, #20]
 8044962:	2d02      	cmp	r5, #2
 8044964:	fb02 fc0c 	mul.w	ip, r2, ip
 8044968:	d007      	beq.n	804497a <kad_op_concat+0x3e>
 804496a:	699a      	ldr	r2, [r3, #24]
 804496c:	2d03      	cmp	r5, #3
 804496e:	fb02 fc0c 	mul.w	ip, r2, ip
 8044972:	d002      	beq.n	804497a <kad_op_concat+0x3e>
 8044974:	69da      	ldr	r2, [r3, #28]
 8044976:	fb02 fc0c 	mul.w	ip, r2, ip
	for (i = axis + 1, d1 = 1; i < q->n_d; ++i) d1 *= q->d[i];
 804497a:	781a      	ldrb	r2, [r3, #0]
 804497c:	1c6e      	adds	r6, r5, #1
 804497e:	4296      	cmp	r6, r2
 8044980:	f280 80fc 	bge.w	8044b7c <kad_op_concat+0x240>
 8044984:	1caf      	adds	r7, r5, #2
 8044986:	eb03 0e85 	add.w	lr, r3, r5, lsl #2
 804498a:	42ba      	cmp	r2, r7
 804498c:	f8de 6014 	ldr.w	r6, [lr, #20]
 8044990:	dd11      	ble.n	80449b6 <kad_op_concat+0x7a>
 8044992:	f8de 7018 	ldr.w	r7, [lr, #24]
 8044996:	fb07 f606 	mul.w	r6, r7, r6
 804499a:	1cef      	adds	r7, r5, #3
 804499c:	42ba      	cmp	r2, r7
 804499e:	dd0a      	ble.n	80449b6 <kad_op_concat+0x7a>
 80449a0:	f8de 701c 	ldr.w	r7, [lr, #28]
 80449a4:	fb07 f606 	mul.w	r6, r7, r6
 80449a8:	1d2f      	adds	r7, r5, #4
 80449aa:	42ba      	cmp	r2, r7
 80449ac:	dd03      	ble.n	80449b6 <kad_op_concat+0x7a>
 80449ae:	f8de 7020 	ldr.w	r7, [lr, #32]
 80449b2:	fb07 f606 	mul.w	r6, r7, r6
	if (action == KAD_SYNC_DIM) {
 80449b6:	2904      	cmp	r1, #4
 80449b8:	d042      	beq.n	8044a40 <kad_op_concat+0x104>
	} else if (action == KAD_FORWARD) {
 80449ba:	2902      	cmp	r1, #2
 80449bc:	d006      	beq.n	80449cc <kad_op_concat+0x90>
	} else if (action == KAD_BACKWARD) {
 80449be:	2903      	cmp	r1, #3
 80449c0:	f000 80e1 	beq.w	8044b86 <kad_op_concat+0x24a>
	return 0;
 80449c4:	2000      	movs	r0, #0
}
 80449c6:	b003      	add	sp, #12
 80449c8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		for (i = 0; i < d0; ++i)
 80449cc:	f1bc 0f00 	cmp.w	ip, #0
 80449d0:	ddf8      	ble.n	80449c4 <kad_op_concat+0x88>
		for (i = 1; i < p->n_child; ++i) {
 80449d2:	6863      	ldr	r3, [r4, #4]
		for (i = 0; i < d0; ++i)
 80449d4:	f04f 0900 	mov.w	r9, #0
 80449d8:	461a      	mov	r2, r3
 80449da:	ea4f 0a85 	mov.w	sl, r5, lsl #2
 80449de:	f105 0b04 	add.w	fp, r5, #4
 80449e2:	f8cd c004 	str.w	ip, [sp, #4]
			for (j = k = 0; j < p->n_child; ++j) {
 80449e6:	2a00      	cmp	r2, #0
 80449e8:	ddec      	ble.n	80449c4 <kad_op_concat+0x88>
 80449ea:	2700      	movs	r7, #0
 80449ec:	463d      	mov	r5, r7
				q = p->child[j];
 80449ee:	6ba1      	ldr	r1, [r4, #56]	@ 0x38
				memcpy(&p->x[(i * p->d[axis] + k) * d1], &q->x[i * q->d[axis] * d1], q->d[axis] * d1 * sizeof(float));
 80449f0:	f854 202b 	ldr.w	r2, [r4, fp, lsl #2]
				q = p->child[j];
 80449f4:	f851 1025 	ldr.w	r1, [r1, r5, lsl #2]
				memcpy(&p->x[(i * p->d[axis] + k) * d1], &q->x[i * q->d[axis] * d1], q->d[axis] * d1 * sizeof(float));
 80449f8:	fb02 7c09 	mla	ip, r2, r9, r7
 80449fc:	eb01 080a 	add.w	r8, r1, sl
 8044a00:	f8d8 2010 	ldr.w	r2, [r8, #16]
 8044a04:	6a88      	ldr	r0, [r1, #40]	@ 0x28
 8044a06:	fb09 f102 	mul.w	r1, r9, r2
 8044a0a:	fb06 f101 	mul.w	r1, r6, r1
 8044a0e:	fb06 fc0c 	mul.w	ip, r6, ip
 8044a12:	fb06 f202 	mul.w	r2, r6, r2
 8044a16:	eb00 0181 	add.w	r1, r0, r1, lsl #2
 8044a1a:	6aa0      	ldr	r0, [r4, #40]	@ 0x28
 8044a1c:	0092      	lsls	r2, r2, #2
 8044a1e:	eb00 008c 	add.w	r0, r0, ip, lsl #2
 8044a22:	f007 fac8 	bl	804bfb6 <memcpy>
			for (j = k = 0; j < p->n_child; ++j) {
 8044a26:	6862      	ldr	r2, [r4, #4]
				k += q->d[axis];
 8044a28:	f8d8 1010 	ldr.w	r1, [r8, #16]
			for (j = k = 0; j < p->n_child; ++j) {
 8044a2c:	3501      	adds	r5, #1
 8044a2e:	42aa      	cmp	r2, r5
				k += q->d[axis];
 8044a30:	440f      	add	r7, r1
			for (j = k = 0; j < p->n_child; ++j) {
 8044a32:	dcdc      	bgt.n	80449ee <kad_op_concat+0xb2>
		for (i = 0; i < d0; ++i)
 8044a34:	9b01      	ldr	r3, [sp, #4]
 8044a36:	f109 0901 	add.w	r9, r9, #1
 8044a3a:	4599      	cmp	r9, r3
 8044a3c:	d1d3      	bne.n	80449e6 <kad_op_concat+0xaa>
 8044a3e:	e7c1      	b.n	80449c4 <kad_op_concat+0x88>
		for (i = 1; i < p->n_child; ++i) {
 8044a40:	6866      	ldr	r6, [r4, #4]
 8044a42:	2e01      	cmp	r6, #1
 8044a44:	f340 80ea 	ble.w	8044c1c <kad_op_concat+0x2e0>
 8044a48:	4684      	mov	ip, r0
 8044a4a:	f04f 0e01 	mov.w	lr, #1
 8044a4e:	46a0      	mov	r8, r4
 8044a50:	4607      	mov	r7, r0
			if (p->child[i]->n_d != q->n_d) return -1;
 8044a52:	f85c 1f04 	ldr.w	r1, [ip, #4]!
 8044a56:	7808      	ldrb	r0, [r1, #0]
 8044a58:	4290      	cmp	r0, r2
 8044a5a:	d128      	bne.n	8044aae <kad_op_concat+0x172>
			for (j = 0; j < q->n_d; ++j)
 8044a5c:	2a00      	cmp	r2, #0
 8044a5e:	d051      	beq.n	8044b04 <kad_op_concat+0x1c8>
				if (j != axis && q->d[j] != p->child[i]->d[j]) return -1;
 8044a60:	b355      	cbz	r5, 8044ab8 <kad_op_concat+0x17c>
 8044a62:	690c      	ldr	r4, [r1, #16]
 8044a64:	6918      	ldr	r0, [r3, #16]
 8044a66:	4284      	cmp	r4, r0
 8044a68:	d121      	bne.n	8044aae <kad_op_concat+0x172>
			for (j = 0; j < q->n_d; ++j)
 8044a6a:	2a01      	cmp	r2, #1
 8044a6c:	d04a      	beq.n	8044b04 <kad_op_concat+0x1c8>
				if (j != axis && q->d[j] != p->child[i]->d[j]) return -1;
 8044a6e:	2d01      	cmp	r5, #1
 8044a70:	d063      	beq.n	8044b3a <kad_op_concat+0x1fe>
 8044a72:	694c      	ldr	r4, [r1, #20]
 8044a74:	6958      	ldr	r0, [r3, #20]
 8044a76:	4284      	cmp	r4, r0
 8044a78:	d119      	bne.n	8044aae <kad_op_concat+0x172>
			for (j = 0; j < q->n_d; ++j)
 8044a7a:	2a02      	cmp	r2, #2
 8044a7c:	d042      	beq.n	8044b04 <kad_op_concat+0x1c8>
				if (j != axis && q->d[j] != p->child[i]->d[j]) return -1;
 8044a7e:	2d02      	cmp	r5, #2
 8044a80:	d122      	bne.n	8044ac8 <kad_op_concat+0x18c>
			for (j = 0; j < q->n_d; ++j)
 8044a82:	2a03      	cmp	r2, #3
 8044a84:	d03e      	beq.n	8044b04 <kad_op_concat+0x1c8>
				if (j != axis && q->d[j] != p->child[i]->d[j]) return -1;
 8044a86:	69cc      	ldr	r4, [r1, #28]
 8044a88:	69d8      	ldr	r0, [r3, #28]
 8044a8a:	4284      	cmp	r4, r0
 8044a8c:	d10f      	bne.n	8044aae <kad_op_concat+0x172>
			for (j = 0; j < q->n_d; ++j)
 8044a8e:	2a04      	cmp	r2, #4
 8044a90:	d038      	beq.n	8044b04 <kad_op_concat+0x1c8>
				if (j != axis && q->d[j] != p->child[i]->d[j]) return -1;
 8044a92:	6a0c      	ldr	r4, [r1, #32]
 8044a94:	6a18      	ldr	r0, [r3, #32]
 8044a96:	4284      	cmp	r4, r0
 8044a98:	d109      	bne.n	8044aae <kad_op_concat+0x172>
			for (j = 0; j < q->n_d; ++j)
 8044a9a:	2a05      	cmp	r2, #5
 8044a9c:	dd32      	ble.n	8044b04 <kad_op_concat+0x1c8>
				if (j != axis && q->d[j] != p->child[i]->d[j]) return -1;
 8044a9e:	2d05      	cmp	r5, #5
 8044aa0:	d122      	bne.n	8044ae8 <kad_op_concat+0x1ac>
			for (j = 0; j < q->n_d; ++j)
 8044aa2:	2a06      	cmp	r2, #6
 8044aa4:	d02e      	beq.n	8044b04 <kad_op_concat+0x1c8>
				if (j != axis && q->d[j] != p->child[i]->d[j]) return -1;
 8044aa6:	6a8c      	ldr	r4, [r1, #40]	@ 0x28
 8044aa8:	6a98      	ldr	r0, [r3, #40]	@ 0x28
 8044aaa:	4284      	cmp	r4, r0
 8044aac:	d024      	beq.n	8044af8 <kad_op_concat+0x1bc>
			if (p->child[i]->n_d != q->n_d) return -1;
 8044aae:	f04f 30ff 	mov.w	r0, #4294967295
}
 8044ab2:	b003      	add	sp, #12
 8044ab4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			for (j = 0; j < q->n_d; ++j)
 8044ab8:	2a01      	cmp	r2, #1
 8044aba:	d023      	beq.n	8044b04 <kad_op_concat+0x1c8>
				if (j != axis && q->d[j] != p->child[i]->d[j]) return -1;
 8044abc:	694c      	ldr	r4, [r1, #20]
 8044abe:	6958      	ldr	r0, [r3, #20]
 8044ac0:	4284      	cmp	r4, r0
 8044ac2:	d1f4      	bne.n	8044aae <kad_op_concat+0x172>
			for (j = 0; j < q->n_d; ++j)
 8044ac4:	2a02      	cmp	r2, #2
 8044ac6:	d01d      	beq.n	8044b04 <kad_op_concat+0x1c8>
				if (j != axis && q->d[j] != p->child[i]->d[j]) return -1;
 8044ac8:	699c      	ldr	r4, [r3, #24]
 8044aca:	6988      	ldr	r0, [r1, #24]
 8044acc:	4284      	cmp	r4, r0
 8044ace:	d1ee      	bne.n	8044aae <kad_op_concat+0x172>
			for (j = 0; j < q->n_d; ++j)
 8044ad0:	2a03      	cmp	r2, #3
 8044ad2:	dd17      	ble.n	8044b04 <kad_op_concat+0x1c8>
				if (j != axis && q->d[j] != p->child[i]->d[j]) return -1;
 8044ad4:	2d03      	cmp	r5, #3
 8044ad6:	d138      	bne.n	8044b4a <kad_op_concat+0x20e>
			for (j = 0; j < q->n_d; ++j)
 8044ad8:	2a04      	cmp	r2, #4
 8044ada:	d013      	beq.n	8044b04 <kad_op_concat+0x1c8>
				if (j != axis && q->d[j] != p->child[i]->d[j]) return -1;
 8044adc:	6a1c      	ldr	r4, [r3, #32]
 8044ade:	6a08      	ldr	r0, [r1, #32]
 8044ae0:	4284      	cmp	r4, r0
 8044ae2:	d1e4      	bne.n	8044aae <kad_op_concat+0x172>
			for (j = 0; j < q->n_d; ++j)
 8044ae4:	2a05      	cmp	r2, #5
 8044ae6:	d00d      	beq.n	8044b04 <kad_op_concat+0x1c8>
				if (j != axis && q->d[j] != p->child[i]->d[j]) return -1;
 8044ae8:	6a4c      	ldr	r4, [r1, #36]	@ 0x24
 8044aea:	6a58      	ldr	r0, [r3, #36]	@ 0x24
 8044aec:	4284      	cmp	r4, r0
 8044aee:	d1de      	bne.n	8044aae <kad_op_concat+0x172>
			for (j = 0; j < q->n_d; ++j)
 8044af0:	2a06      	cmp	r2, #6
 8044af2:	dd07      	ble.n	8044b04 <kad_op_concat+0x1c8>
				if (j != axis && q->d[j] != p->child[i]->d[j]) return -1;
 8044af4:	2d06      	cmp	r5, #6
 8044af6:	d138      	bne.n	8044b6a <kad_op_concat+0x22e>
			for (j = 0; j < q->n_d; ++j)
 8044af8:	2a07      	cmp	r2, #7
 8044afa:	d003      	beq.n	8044b04 <kad_op_concat+0x1c8>
				if (j != axis && q->d[j] != p->child[i]->d[j]) return -1;
 8044afc:	6ac8      	ldr	r0, [r1, #44]	@ 0x2c
 8044afe:	6ad9      	ldr	r1, [r3, #44]	@ 0x2c
 8044b00:	4288      	cmp	r0, r1
 8044b02:	d1d4      	bne.n	8044aae <kad_op_concat+0x172>
		for (i = 1; i < p->n_child; ++i) {
 8044b04:	f10e 0e01 	add.w	lr, lr, #1
 8044b08:	4576      	cmp	r6, lr
 8044b0a:	d1a2      	bne.n	8044a52 <kad_op_concat+0x116>
	dst->n_d = src->n_d;
 8044b0c:	4644      	mov	r4, r8
 8044b0e:	4638      	mov	r0, r7
 8044b10:	f888 2000 	strb.w	r2, [r8]
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 8044b14:	2a00      	cmp	r2, #0
 8044b16:	f040 808d 	bne.w	8044c34 <kad_op_concat+0x2f8>
 8044b1a:	eb04 0485 	add.w	r4, r4, r5, lsl #2
 8044b1e:	1f01      	subs	r1, r0, #4
			p->d[axis] += p->child[i]->d[axis];
 8044b20:	6923      	ldr	r3, [r4, #16]
 8044b22:	1d2f      	adds	r7, r5, #4
 8044b24:	eb01 0186 	add.w	r1, r1, r6, lsl #2
 8044b28:	f850 2f04 	ldr.w	r2, [r0, #4]!
 8044b2c:	f852 2027 	ldr.w	r2, [r2, r7, lsl #2]
		for (i = 1; i < p->n_child; ++i)
 8044b30:	4288      	cmp	r0, r1
			p->d[axis] += p->child[i]->d[axis];
 8044b32:	4413      	add	r3, r2
 8044b34:	6123      	str	r3, [r4, #16]
		for (i = 1; i < p->n_child; ++i)
 8044b36:	d1f7      	bne.n	8044b28 <kad_op_concat+0x1ec>
 8044b38:	e744      	b.n	80449c4 <kad_op_concat+0x88>
			for (j = 0; j < q->n_d; ++j)
 8044b3a:	2a02      	cmp	r2, #2
 8044b3c:	d0e2      	beq.n	8044b04 <kad_op_concat+0x1c8>
				if (j != axis && q->d[j] != p->child[i]->d[j]) return -1;
 8044b3e:	698c      	ldr	r4, [r1, #24]
 8044b40:	6998      	ldr	r0, [r3, #24]
 8044b42:	4284      	cmp	r4, r0
 8044b44:	d1b3      	bne.n	8044aae <kad_op_concat+0x172>
			for (j = 0; j < q->n_d; ++j)
 8044b46:	2a03      	cmp	r2, #3
 8044b48:	d0dc      	beq.n	8044b04 <kad_op_concat+0x1c8>
				if (j != axis && q->d[j] != p->child[i]->d[j]) return -1;
 8044b4a:	69cc      	ldr	r4, [r1, #28]
 8044b4c:	69d8      	ldr	r0, [r3, #28]
 8044b4e:	4284      	cmp	r4, r0
 8044b50:	d1ad      	bne.n	8044aae <kad_op_concat+0x172>
			for (j = 0; j < q->n_d; ++j)
 8044b52:	2a04      	cmp	r2, #4
 8044b54:	ddd6      	ble.n	8044b04 <kad_op_concat+0x1c8>
				if (j != axis && q->d[j] != p->child[i]->d[j]) return -1;
 8044b56:	2d04      	cmp	r5, #4
 8044b58:	d19b      	bne.n	8044a92 <kad_op_concat+0x156>
			for (j = 0; j < q->n_d; ++j)
 8044b5a:	2a05      	cmp	r2, #5
 8044b5c:	d0d2      	beq.n	8044b04 <kad_op_concat+0x1c8>
				if (j != axis && q->d[j] != p->child[i]->d[j]) return -1;
 8044b5e:	6a5c      	ldr	r4, [r3, #36]	@ 0x24
 8044b60:	6a48      	ldr	r0, [r1, #36]	@ 0x24
 8044b62:	4284      	cmp	r4, r0
 8044b64:	d1a3      	bne.n	8044aae <kad_op_concat+0x172>
			for (j = 0; j < q->n_d; ++j)
 8044b66:	2a06      	cmp	r2, #6
 8044b68:	d0cc      	beq.n	8044b04 <kad_op_concat+0x1c8>
				if (j != axis && q->d[j] != p->child[i]->d[j]) return -1;
 8044b6a:	6a8c      	ldr	r4, [r1, #40]	@ 0x28
 8044b6c:	6a98      	ldr	r0, [r3, #40]	@ 0x28
 8044b6e:	4284      	cmp	r4, r0
 8044b70:	d19d      	bne.n	8044aae <kad_op_concat+0x172>
			for (j = 0; j < q->n_d; ++j)
 8044b72:	2a07      	cmp	r2, #7
 8044b74:	ddc6      	ble.n	8044b04 <kad_op_concat+0x1c8>
				if (j != axis && q->d[j] != p->child[i]->d[j]) return -1;
 8044b76:	2d07      	cmp	r5, #7
 8044b78:	d0c4      	beq.n	8044b04 <kad_op_concat+0x1c8>
 8044b7a:	e7bf      	b.n	8044afc <kad_op_concat+0x1c0>
	for (i = axis + 1, d1 = 1; i < q->n_d; ++i) d1 *= q->d[i];
 8044b7c:	2601      	movs	r6, #1
 8044b7e:	e71a      	b.n	80449b6 <kad_op_concat+0x7a>
	for (i = 0, d0 = 1; i < axis; ++i) d0 *= q->d[i];
 8044b80:	f04f 0c01 	mov.w	ip, #1
 8044b84:	e6f9      	b.n	804497a <kad_op_concat+0x3e>
		for (i = 0; i < d0; ++i)
 8044b86:	f1bc 0f00 	cmp.w	ip, #0
 8044b8a:	f77f af1b 	ble.w	80449c4 <kad_op_concat+0x88>
			for (j = k = 0; j < p->n_child; ++j) {
 8044b8e:	6862      	ldr	r2, [r4, #4]
 8044b90:	2a00      	cmp	r2, #0
 8044b92:	f77f af17 	ble.w	80449c4 <kad_op_concat+0x88>
 8044b96:	1f03      	subs	r3, r0, #4
		for (i = 0; i < d0; ++i)
 8044b98:	f04f 0800 	mov.w	r8, #0
 8044b9c:	469e      	mov	lr, r3
 8044b9e:	eb03 0982 	add.w	r9, r3, r2, lsl #2
				kad_saxpy(q->d[axis] * d1, 1.0f, &p->g[(i * p->d[axis] + k) * d1], &q->g[i * q->d[axis] * d1]);
 8044ba2:	f105 0a04 	add.w	sl, r5, #4
 8044ba6:	f8cd c004 	str.w	ip, [sp, #4]
			for (j = k = 0; j < p->n_child; ++j) {
 8044baa:	4677      	mov	r7, lr
 8044bac:	f04f 0c00 	mov.w	ip, #0
 8044bb0:	e001      	b.n	8044bb6 <kad_op_concat+0x27a>
 8044bb2:	45b9      	cmp	r9, r7
 8044bb4:	d02c      	beq.n	8044c10 <kad_op_concat+0x2d4>
				q = p->child[j];
 8044bb6:	f857 3f04 	ldr.w	r3, [r7, #4]!
				if (!kad_is_back(q)) continue;
 8044bba:	785a      	ldrb	r2, [r3, #1]
 8044bbc:	07d2      	lsls	r2, r2, #31
 8044bbe:	d5f8      	bpl.n	8044bb2 <kad_op_concat+0x276>
				kad_saxpy(q->d[axis] * d1, 1.0f, &p->g[(i * p->d[axis] + k) * d1], &q->g[i * q->d[axis] * d1]);
 8044bc0:	f853 502a 	ldr.w	r5, [r3, sl, lsl #2]
 8044bc4:	f854 202a 	ldr.w	r2, [r4, sl, lsl #2]
 8044bc8:	fb08 fb05 	mul.w	fp, r8, r5
 8044bcc:	fb02 c008 	mla	r0, r2, r8, ip
 8044bd0:	fb06 f105 	mul.w	r1, r6, r5
 8044bd4:	fb06 f000 	mul.w	r0, r6, r0
 8044bd8:	fb06 fb0b 	mul.w	fp, r6, fp
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 8044bdc:	2900      	cmp	r1, #0
				kad_saxpy(q->d[axis] * d1, 1.0f, &p->g[(i * p->d[axis] + k) * d1], &q->g[i * q->d[axis] * d1]);
 8044bde:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8044be0:	6ae2      	ldr	r2, [r4, #44]	@ 0x2c
 8044be2:	ea4f 0080 	mov.w	r0, r0, lsl #2
 8044be6:	ea4f 0b8b 	mov.w	fp, fp, lsl #2
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 8044bea:	dd0e      	ble.n	8044c0a <kad_op_concat+0x2ce>
 8044bec:	eb03 0181 	add.w	r1, r3, r1, lsl #2
 8044bf0:	4402      	add	r2, r0
 8044bf2:	445b      	add	r3, fp
 8044bf4:	4459      	add	r1, fp
 8044bf6:	edd3 7a00 	vldr	s15, [r3]
 8044bfa:	ecb2 7a01 	vldmia	r2!, {s14}
 8044bfe:	ee77 7a87 	vadd.f32	s15, s15, s14
 8044c02:	ece3 7a01 	vstmia	r3!, {s15}
 8044c06:	4299      	cmp	r1, r3
 8044c08:	d1f5      	bne.n	8044bf6 <kad_op_concat+0x2ba>
			for (j = k = 0; j < p->n_child; ++j) {
 8044c0a:	45b9      	cmp	r9, r7
				k += q->d[axis];
 8044c0c:	44ac      	add	ip, r5
			for (j = k = 0; j < p->n_child; ++j) {
 8044c0e:	d1d2      	bne.n	8044bb6 <kad_op_concat+0x27a>
		for (i = 0; i < d0; ++i)
 8044c10:	9b01      	ldr	r3, [sp, #4]
 8044c12:	f108 0801 	add.w	r8, r8, #1
 8044c16:	4598      	cmp	r8, r3
 8044c18:	d1c7      	bne.n	8044baa <kad_op_concat+0x26e>
 8044c1a:	e6d3      	b.n	80449c4 <kad_op_concat+0x88>
	dst->n_d = src->n_d;
 8044c1c:	7022      	strb	r2, [r4, #0]
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 8044c1e:	2a00      	cmp	r2, #0
 8044c20:	f43f aed0 	beq.w	80449c4 <kad_op_concat+0x88>
 8044c24:	0092      	lsls	r2, r2, #2
 8044c26:	f103 0110 	add.w	r1, r3, #16
 8044c2a:	f104 0010 	add.w	r0, r4, #16
 8044c2e:	f007 f9c2 	bl	804bfb6 <memcpy>
		for (i = 1; i < p->n_child; ++i)
 8044c32:	e6c7      	b.n	80449c4 <kad_op_concat+0x88>
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 8044c34:	0092      	lsls	r2, r2, #2
 8044c36:	f103 0110 	add.w	r1, r3, #16
 8044c3a:	f108 0010 	add.w	r0, r8, #16
 8044c3e:	f007 f9ba 	bl	804bfb6 <memcpy>
		for (i = 1; i < p->n_child; ++i)
 8044c42:	f8d8 0038 	ldr.w	r0, [r8, #56]	@ 0x38
 8044c46:	e768      	b.n	8044b1a <kad_op_concat+0x1de>
	assert(p->ptr);
 8044c48:	f240 5171 	movw	r1, #1393	@ 0x571
 8044c4c:	4b02      	ldr	r3, [pc, #8]	@ (8044c58 <kad_op_concat+0x31c>)
 8044c4e:	4a03      	ldr	r2, [pc, #12]	@ (8044c5c <kad_op_concat+0x320>)
 8044c50:	4803      	ldr	r0, [pc, #12]	@ (8044c60 <kad_op_concat+0x324>)
 8044c52:	f006 fd8b 	bl	804b76c <__assert_func>
 8044c56:	bf00      	nop
 8044c58:	0804e320 	.word	0x0804e320
 8044c5c:	0804e498 	.word	0x0804e498
 8044c60:	0804e328 	.word	0x0804e328

08044c64 <kad_op_reshape>:
	kad_node_t *q = p->child[0];
 8044c64:	6b82      	ldr	r2, [r0, #56]	@ 0x38
	if (action == KAD_SYNC_DIM) {
 8044c66:	2904      	cmp	r1, #4
{
 8044c68:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8044c6c:	4603      	mov	r3, r0
	kad_node_t *q = p->child[0];
 8044c6e:	6815      	ldr	r5, [r2, #0]
	if (action == KAD_SYNC_DIM) {
 8044c70:	d01f      	beq.n	8044cb2 <kad_op_reshape+0x4e>
	} else if (action == KAD_FORWARD) {
 8044c72:	2902      	cmp	r1, #2
 8044c74:	d004      	beq.n	8044c80 <kad_op_reshape+0x1c>
	} else if (action == KAD_BACKWARD && kad_is_back(q)) {
 8044c76:	2903      	cmp	r1, #3
 8044c78:	d06f      	beq.n	8044d5a <kad_op_reshape+0xf6>
	return 0;
 8044c7a:	2000      	movs	r0, #0
}
 8044c7c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	for (i = 0; i < p->n_d; ++i) n *= p->d[i];
 8044c80:	7804      	ldrb	r4, [r0, #0]
		memcpy(p->x, q->x, kad_len(p) * sizeof(float));
 8044c82:	6aa9      	ldr	r1, [r5, #40]	@ 0x28
 8044c84:	6a80      	ldr	r0, [r0, #40]	@ 0x28
 8044c86:	2c00      	cmp	r4, #0
 8044c88:	f000 8112 	beq.w	8044eb0 <kad_op_reshape+0x24c>
 8044c8c:	2c01      	cmp	r4, #1
 8044c8e:	691a      	ldr	r2, [r3, #16]
 8044c90:	d00b      	beq.n	8044caa <kad_op_reshape+0x46>
 8044c92:	695d      	ldr	r5, [r3, #20]
 8044c94:	2c02      	cmp	r4, #2
 8044c96:	fb05 f202 	mul.w	r2, r5, r2
 8044c9a:	d006      	beq.n	8044caa <kad_op_reshape+0x46>
 8044c9c:	699d      	ldr	r5, [r3, #24]
 8044c9e:	2c03      	cmp	r4, #3
 8044ca0:	fb05 f202 	mul.w	r2, r5, r2
 8044ca4:	bf1c      	itt	ne
 8044ca6:	69db      	ldrne	r3, [r3, #28]
 8044ca8:	435a      	mulne	r2, r3
 8044caa:	0092      	lsls	r2, r2, #2
 8044cac:	f007 f983 	bl	804bfb6 <memcpy>
 8044cb0:	e7e3      	b.n	8044c7a <kad_op_reshape+0x16>
		if (p->ptr) {
 8044cb2:	6b01      	ldr	r1, [r0, #48]	@ 0x30
 8044cb4:	2900      	cmp	r1, #0
 8044cb6:	d079      	beq.n	8044dac <kad_op_reshape+0x148>
			p->n_d = p->ptr_size / 4;
 8044cb8:	68c2      	ldr	r2, [r0, #12]
 8044cba:	2a00      	cmp	r2, #0
 8044cbc:	bfb8      	it	lt
 8044cbe:	3203      	addlt	r2, #3
 8044cc0:	1092      	asrs	r2, r2, #2
			for (i = 0; i < p->n_d; ++i) p->d[i] = aux[i];
 8044cc2:	f012 0cff 	ands.w	ip, r2, #255	@ 0xff
			p->n_d = p->ptr_size / 4;
 8044cc6:	7002      	strb	r2, [r0, #0]
			for (i = 0; i < p->n_d; ++i) p->d[i] = aux[i];
 8044cc8:	f000 80d7 	beq.w	8044e7a <kad_op_reshape+0x216>
 8044ccc:	680c      	ldr	r4, [r1, #0]
 8044cce:	f012 06fe 	ands.w	r6, r2, #254	@ 0xfe
 8044cd2:	6104      	str	r4, [r0, #16]
 8044cd4:	f000 8170 	beq.w	8044fb8 <kad_op_reshape+0x354>
 8044cd8:	6848      	ldr	r0, [r1, #4]
 8044cda:	f1bc 0f02 	cmp.w	ip, #2
 8044cde:	6158      	str	r0, [r3, #20]
 8044ce0:	dd70      	ble.n	8044dc4 <kad_op_reshape+0x160>
 8044ce2:	688f      	ldr	r7, [r1, #8]
 8044ce4:	f012 0efc 	ands.w	lr, r2, #252	@ 0xfc
 8044ce8:	619f      	str	r7, [r3, #24]
 8044cea:	d06b      	beq.n	8044dc4 <kad_op_reshape+0x160>
 8044cec:	68c9      	ldr	r1, [r1, #12]
				if (p->d[i] <= 0) ++n_missing;
 8044cee:	2c00      	cmp	r4, #0
			for (i = 0; i < p->n_d; ++i) p->d[i] = aux[i];
 8044cf0:	61d9      	str	r1, [r3, #28]
				if (p->d[i] <= 0) ++n_missing;
 8044cf2:	dd69      	ble.n	8044dc8 <kad_op_reshape+0x164>
 8044cf4:	2800      	cmp	r0, #0
 8044cf6:	f340 80f1 	ble.w	8044edc <kad_op_reshape+0x278>
			int i, len = 1, n_missing = 0;
 8044cfa:	2700      	movs	r7, #0
				else len *= p->d[i];
 8044cfc:	fb04 f000 	mul.w	r0, r4, r0
				if (p->d[i] <= 0) ++n_missing;
 8044d00:	6999      	ldr	r1, [r3, #24]
 8044d02:	2900      	cmp	r1, #0
 8044d04:	f340 8131 	ble.w	8044f6a <kad_op_reshape+0x306>
				else len *= p->d[i];
 8044d08:	fb01 f000 	mul.w	r0, r1, r0
			for (i = 0; i < p->n_d; ++i)
 8044d0c:	f1be 0f00 	cmp.w	lr, #0
 8044d10:	d005      	beq.n	8044d1e <kad_op_reshape+0xba>
				if (p->d[i] <= 0) ++n_missing;
 8044d12:	69d9      	ldr	r1, [r3, #28]
 8044d14:	2900      	cmp	r1, #0
 8044d16:	f340 816c 	ble.w	8044ff2 <kad_op_reshape+0x38e>
				else len *= p->d[i];
 8044d1a:	fb01 f000 	mul.w	r0, r1, r0
			if (n_missing == 0 && len != kad_len(q)) return -1;
 8044d1e:	2f00      	cmp	r7, #0
 8044d20:	f000 80ac 	beq.w	8044e7c <kad_op_reshape+0x218>
 8044d24:	4639      	mov	r1, r7
			if (n_missing > 1) { /* attempt to infer missing dimensions except the last one */
 8044d26:	2901      	cmp	r1, #1
 8044d28:	d059      	beq.n	8044dde <kad_op_reshape+0x17a>
					if (p->d[i] <= 0 && i < q->n_d) {
 8044d2a:	2c00      	cmp	r4, #0
 8044d2c:	f340 812a 	ble.w	8044f84 <kad_op_reshape+0x320>
 8044d30:	695c      	ldr	r4, [r3, #20]
 8044d32:	2c00      	cmp	r4, #0
 8044d34:	f340 8133 	ble.w	8044f9e <kad_op_reshape+0x33a>
				for (i = 0; i < p->n_d; ++i)
 8044d38:	f1bc 0f02 	cmp.w	ip, #2
 8044d3c:	dd0a      	ble.n	8044d54 <kad_op_reshape+0xf0>
					if (p->d[i] <= 0 && i < q->n_d) {
 8044d3e:	699c      	ldr	r4, [r3, #24]
 8044d40:	2c00      	cmp	r4, #0
 8044d42:	f340 813d 	ble.w	8044fc0 <kad_op_reshape+0x35c>
				for (i = 0; i < p->n_d; ++i)
 8044d46:	f012 0ffc 	tst.w	r2, #252	@ 0xfc
 8044d4a:	d003      	beq.n	8044d54 <kad_op_reshape+0xf0>
					if (p->d[i] <= 0 && i < q->n_d) {
 8044d4c:	69dc      	ldr	r4, [r3, #28]
 8044d4e:	2c00      	cmp	r4, #0
 8044d50:	f340 8143 	ble.w	8044fda <kad_op_reshape+0x376>
			if (n_missing == 0 && len != kad_len(q)) return -1;
 8044d54:	f04f 30ff 	mov.w	r0, #4294967295
 8044d58:	e790      	b.n	8044c7c <kad_op_reshape+0x18>
	} else if (action == KAD_BACKWARD && kad_is_back(q)) {
 8044d5a:	786a      	ldrb	r2, [r5, #1]
 8044d5c:	07d2      	lsls	r2, r2, #31
 8044d5e:	d58c      	bpl.n	8044c7a <kad_op_reshape+0x16>
 8044d60:	7804      	ldrb	r4, [r0, #0]
		kad_saxpy(kad_len(p), 1.0f, p->g, q->g);
 8044d62:	6ac1      	ldr	r1, [r0, #44]	@ 0x2c
 8044d64:	6aea      	ldr	r2, [r5, #44]	@ 0x2c
 8044d66:	2c00      	cmp	r4, #0
 8044d68:	f000 8161 	beq.w	804502e <kad_op_reshape+0x3ca>
 8044d6c:	2c01      	cmp	r4, #1
 8044d6e:	6900      	ldr	r0, [r0, #16]
 8044d70:	d00b      	beq.n	8044d8a <kad_op_reshape+0x126>
 8044d72:	695d      	ldr	r5, [r3, #20]
 8044d74:	2c02      	cmp	r4, #2
 8044d76:	fb05 f000 	mul.w	r0, r5, r0
 8044d7a:	d006      	beq.n	8044d8a <kad_op_reshape+0x126>
 8044d7c:	699d      	ldr	r5, [r3, #24]
 8044d7e:	2c03      	cmp	r4, #3
 8044d80:	fb05 f000 	mul.w	r0, r5, r0
 8044d84:	bf1c      	itt	ne
 8044d86:	69db      	ldrne	r3, [r3, #28]
 8044d88:	4358      	mulne	r0, r3
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 8044d8a:	2800      	cmp	r0, #0
 8044d8c:	f77f af75 	ble.w	8044c7a <kad_op_reshape+0x16>
 8044d90:	4613      	mov	r3, r2
 8044d92:	2200      	movs	r2, #0
 8044d94:	edd3 7a00 	vldr	s15, [r3]
 8044d98:	ecb1 7a01 	vldmia	r1!, {s14}
 8044d9c:	ee77 7a87 	vadd.f32	s15, s15, s14
 8044da0:	3201      	adds	r2, #1
 8044da2:	4282      	cmp	r2, r0
 8044da4:	ece3 7a01 	vstmia	r3!, {s15}
 8044da8:	dbf4      	blt.n	8044d94 <kad_op_reshape+0x130>
 8044daa:	e766      	b.n	8044c7a <kad_op_reshape+0x16>
	dst->n_d = src->n_d;
 8044dac:	782a      	ldrb	r2, [r5, #0]
 8044dae:	7002      	strb	r2, [r0, #0]
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 8044db0:	2a00      	cmp	r2, #0
 8044db2:	f43f af62 	beq.w	8044c7a <kad_op_reshape+0x16>
 8044db6:	0092      	lsls	r2, r2, #2
 8044db8:	f105 0110 	add.w	r1, r5, #16
 8044dbc:	3010      	adds	r0, #16
 8044dbe:	f007 f8fa 	bl	804bfb6 <memcpy>
 8044dc2:	e75a      	b.n	8044c7a <kad_op_reshape+0x16>
				if (p->d[i] <= 0) ++n_missing;
 8044dc4:	2c00      	cmp	r4, #0
 8044dc6:	dc75      	bgt.n	8044eb4 <kad_op_reshape+0x250>
 8044dc8:	2800      	cmp	r0, #0
 8044dca:	dd78      	ble.n	8044ebe <kad_op_reshape+0x25a>
 8044dcc:	2701      	movs	r7, #1
			int i, len = 1, n_missing = 0;
 8044dce:	4639      	mov	r1, r7
			for (i = 0; i < p->n_d; ++i)
 8044dd0:	f1bc 0f02 	cmp.w	ip, #2
				else len *= p->d[i];
 8044dd4:	fb01 f000 	mul.w	r0, r1, r0
			for (i = 0; i < p->n_d; ++i)
 8044dd8:	dc77      	bgt.n	8044eca <kad_op_reshape+0x266>
			if (n_missing == 0 && len != kad_len(q)) return -1;
 8044dda:	2f00      	cmp	r7, #0
 8044ddc:	d04e      	beq.n	8044e7c <kad_op_reshape+0x218>
 8044dde:	7829      	ldrb	r1, [r5, #0]
 8044de0:	2900      	cmp	r1, #0
 8044de2:	f000 8132 	beq.w	804504a <kad_op_reshape+0x3e6>
 8044de6:	2901      	cmp	r1, #1
 8044de8:	692f      	ldr	r7, [r5, #16]
 8044dea:	f000 8122 	beq.w	8045032 <kad_op_reshape+0x3ce>
 8044dee:	f8d5 e014 	ldr.w	lr, [r5, #20]
 8044df2:	2902      	cmp	r1, #2
 8044df4:	fb0e f807 	mul.w	r8, lr, r7
 8044df8:	f000 80ff 	beq.w	8044ffa <kad_op_reshape+0x396>
 8044dfc:	69ac      	ldr	r4, [r5, #24]
 8044dfe:	2903      	cmp	r1, #3
 8044e00:	fb04 f808 	mul.w	r8, r4, r8
 8044e04:	f000 80f9 	beq.w	8044ffa <kad_op_reshape+0x396>
 8044e08:	69ec      	ldr	r4, [r5, #28]
 8044e0a:	fb04 f408 	mul.w	r4, r4, r8
				if (kad_len(q) % len != 0) return -1;
 8044e0e:	fb94 f8f0 	sdiv	r8, r4, r0
 8044e12:	fb00 4418 	mls	r4, r0, r8, r4
 8044e16:	2c00      	cmp	r4, #0
 8044e18:	d19c      	bne.n	8044d54 <kad_op_reshape+0xf0>
					if (p->d[i] <= 0) p->d[i] = kad_len(q) / len;
 8044e1a:	691c      	ldr	r4, [r3, #16]
 8044e1c:	2c00      	cmp	r4, #0
 8044e1e:	dd60      	ble.n	8044ee2 <kad_op_reshape+0x27e>
				for (i = 0; i < p->n_d; ++i)
 8044e20:	2e00      	cmp	r6, #0
 8044e22:	f43f af2a 	beq.w	8044c7a <kad_op_reshape+0x16>
					if (p->d[i] <= 0) p->d[i] = kad_len(q) / len;
 8044e26:	695c      	ldr	r4, [r3, #20]
 8044e28:	2c00      	cmp	r4, #0
 8044e2a:	dd71      	ble.n	8044f10 <kad_op_reshape+0x2ac>
				for (i = 0; i < p->n_d; ++i)
 8044e2c:	f1bc 0f02 	cmp.w	ip, #2
 8044e30:	f77f af23 	ble.w	8044c7a <kad_op_reshape+0x16>
					if (p->d[i] <= 0) p->d[i] = kad_len(q) / len;
 8044e34:	699c      	ldr	r4, [r3, #24]
 8044e36:	2c00      	cmp	r4, #0
 8044e38:	f340 810f 	ble.w	804505a <kad_op_reshape+0x3f6>
				for (i = 0; i < p->n_d; ++i)
 8044e3c:	f012 0ffc 	tst.w	r2, #252	@ 0xfc
 8044e40:	f43f af1b 	beq.w	8044c7a <kad_op_reshape+0x16>
					if (p->d[i] <= 0) p->d[i] = kad_len(q) / len;
 8044e44:	69da      	ldr	r2, [r3, #28]
 8044e46:	2a00      	cmp	r2, #0
 8044e48:	f73f af17 	bgt.w	8044c7a <kad_op_reshape+0x16>
 8044e4c:	2900      	cmp	r1, #0
 8044e4e:	f000 812b 	beq.w	80450a8 <kad_op_reshape+0x444>
 8044e52:	2901      	cmp	r1, #1
 8044e54:	692a      	ldr	r2, [r5, #16]
 8044e56:	d00c      	beq.n	8044e72 <kad_op_reshape+0x20e>
 8044e58:	696c      	ldr	r4, [r5, #20]
 8044e5a:	2902      	cmp	r1, #2
 8044e5c:	fb04 f202 	mul.w	r2, r4, r2
 8044e60:	d007      	beq.n	8044e72 <kad_op_reshape+0x20e>
 8044e62:	69ac      	ldr	r4, [r5, #24]
 8044e64:	2903      	cmp	r1, #3
 8044e66:	fb04 f202 	mul.w	r2, r4, r2
 8044e6a:	d002      	beq.n	8044e72 <kad_op_reshape+0x20e>
 8044e6c:	69e9      	ldr	r1, [r5, #28]
 8044e6e:	fb01 f202 	mul.w	r2, r1, r2
 8044e72:	fb92 f2f0 	sdiv	r2, r2, r0
 8044e76:	61da      	str	r2, [r3, #28]
				for (i = 0; i < p->n_d; ++i)
 8044e78:	e6ff      	b.n	8044c7a <kad_op_reshape+0x16>
			int i, len = 1, n_missing = 0;
 8044e7a:	2001      	movs	r0, #1
 8044e7c:	782a      	ldrb	r2, [r5, #0]
 8044e7e:	2a00      	cmp	r2, #0
 8044e80:	f000 80b9 	beq.w	8044ff6 <kad_op_reshape+0x392>
 8044e84:	2a01      	cmp	r2, #1
 8044e86:	692b      	ldr	r3, [r5, #16]
 8044e88:	d00c      	beq.n	8044ea4 <kad_op_reshape+0x240>
 8044e8a:	6969      	ldr	r1, [r5, #20]
 8044e8c:	2a02      	cmp	r2, #2
 8044e8e:	fb01 f303 	mul.w	r3, r1, r3
 8044e92:	d007      	beq.n	8044ea4 <kad_op_reshape+0x240>
 8044e94:	69a9      	ldr	r1, [r5, #24]
 8044e96:	2a03      	cmp	r2, #3
 8044e98:	fb01 f303 	mul.w	r3, r1, r3
 8044e9c:	d002      	beq.n	8044ea4 <kad_op_reshape+0x240>
 8044e9e:	69ea      	ldr	r2, [r5, #28]
 8044ea0:	fb02 f303 	mul.w	r3, r2, r3
			if (n_missing == 0 && len != kad_len(q)) return -1;
 8044ea4:	1ac0      	subs	r0, r0, r3
 8044ea6:	bf18      	it	ne
 8044ea8:	f04f 30ff 	movne.w	r0, #4294967295
}
 8044eac:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8044eb0:	2204      	movs	r2, #4
 8044eb2:	e6fb      	b.n	8044cac <kad_op_reshape+0x48>
				if (p->d[i] <= 0) ++n_missing;
 8044eb4:	2800      	cmp	r0, #0
 8044eb6:	dd0b      	ble.n	8044ed0 <kad_op_reshape+0x26c>
				else len *= p->d[i];
 8044eb8:	4621      	mov	r1, r4
			int i, len = 1, n_missing = 0;
 8044eba:	2700      	movs	r7, #0
 8044ebc:	e788      	b.n	8044dd0 <kad_op_reshape+0x16c>
			for (i = 0; i < p->n_d; ++i)
 8044ebe:	f1bc 0f02 	cmp.w	ip, #2
 8044ec2:	f340 80cd 	ble.w	8045060 <kad_op_reshape+0x3fc>
				if (p->d[i] <= 0) ++n_missing;
 8044ec6:	2702      	movs	r7, #2
			int i, len = 1, n_missing = 0;
 8044ec8:	2001      	movs	r0, #1
 8044eca:	f002 0efc 	and.w	lr, r2, #252	@ 0xfc
 8044ece:	e717      	b.n	8044d00 <kad_op_reshape+0x9c>
			for (i = 0; i < p->n_d; ++i)
 8044ed0:	f1bc 0f02 	cmp.w	ip, #2
 8044ed4:	f340 80df 	ble.w	8045096 <kad_op_reshape+0x432>
 8044ed8:	f002 0efc 	and.w	lr, r2, #252	@ 0xfc
				else len *= p->d[i];
 8044edc:	4620      	mov	r0, r4
				if (p->d[i] <= 0) ++n_missing;
 8044ede:	2701      	movs	r7, #1
 8044ee0:	e70e      	b.n	8044d00 <kad_op_reshape+0x9c>
 8044ee2:	2902      	cmp	r1, #2
 8044ee4:	fb0e fe07 	mul.w	lr, lr, r7
 8044ee8:	d007      	beq.n	8044efa <kad_op_reshape+0x296>
 8044eea:	69ac      	ldr	r4, [r5, #24]
 8044eec:	2903      	cmp	r1, #3
 8044eee:	fb04 fe0e 	mul.w	lr, r4, lr
 8044ef2:	bf1c      	itt	ne
 8044ef4:	69ec      	ldrne	r4, [r5, #28]
 8044ef6:	fb04 fe0e 	mulne.w	lr, r4, lr
 8044efa:	fb9e fef0 	sdiv	lr, lr, r0
					if (p->d[i] <= 0) p->d[i] = kad_len(q) / len;
 8044efe:	f8c3 e010 	str.w	lr, [r3, #16]
				for (i = 0; i < p->n_d; ++i)
 8044f02:	2e00      	cmp	r6, #0
 8044f04:	f43f aeb9 	beq.w	8044c7a <kad_op_reshape+0x16>
					if (p->d[i] <= 0) p->d[i] = kad_len(q) / len;
 8044f08:	695c      	ldr	r4, [r3, #20]
 8044f0a:	2c00      	cmp	r4, #0
 8044f0c:	dc8e      	bgt.n	8044e2c <kad_op_reshape+0x1c8>
 8044f0e:	692f      	ldr	r7, [r5, #16]
 8044f10:	2901      	cmp	r1, #1
 8044f12:	463e      	mov	r6, r7
 8044f14:	d00b      	beq.n	8044f2e <kad_op_reshape+0x2ca>
 8044f16:	696e      	ldr	r6, [r5, #20]
 8044f18:	2902      	cmp	r1, #2
 8044f1a:	fb07 f606 	mul.w	r6, r7, r6
 8044f1e:	d006      	beq.n	8044f2e <kad_op_reshape+0x2ca>
 8044f20:	69ac      	ldr	r4, [r5, #24]
 8044f22:	2903      	cmp	r1, #3
 8044f24:	fb04 f606 	mul.w	r6, r4, r6
 8044f28:	bf1c      	itt	ne
 8044f2a:	69ec      	ldrne	r4, [r5, #28]
 8044f2c:	4366      	mulne	r6, r4
 8044f2e:	fb96 f6f0 	sdiv	r6, r6, r0
				for (i = 0; i < p->n_d; ++i)
 8044f32:	f1bc 0f02 	cmp.w	ip, #2
					if (p->d[i] <= 0) p->d[i] = kad_len(q) / len;
 8044f36:	615e      	str	r6, [r3, #20]
				for (i = 0; i < p->n_d; ++i)
 8044f38:	f77f ae9f 	ble.w	8044c7a <kad_op_reshape+0x16>
					if (p->d[i] <= 0) p->d[i] = kad_len(q) / len;
 8044f3c:	699c      	ldr	r4, [r3, #24]
 8044f3e:	2c00      	cmp	r4, #0
 8044f40:	f73f af7c 	bgt.w	8044e3c <kad_op_reshape+0x1d8>
 8044f44:	2901      	cmp	r1, #1
 8044f46:	d00c      	beq.n	8044f62 <kad_op_reshape+0x2fe>
 8044f48:	696c      	ldr	r4, [r5, #20]
 8044f4a:	2902      	cmp	r1, #2
 8044f4c:	fb04 f707 	mul.w	r7, r4, r7
 8044f50:	d007      	beq.n	8044f62 <kad_op_reshape+0x2fe>
 8044f52:	69ac      	ldr	r4, [r5, #24]
 8044f54:	2903      	cmp	r1, #3
 8044f56:	fb04 f707 	mul.w	r7, r4, r7
 8044f5a:	d002      	beq.n	8044f62 <kad_op_reshape+0x2fe>
 8044f5c:	69ec      	ldr	r4, [r5, #28]
 8044f5e:	fb04 f707 	mul.w	r7, r4, r7
 8044f62:	fb97 f7f0 	sdiv	r7, r7, r0
 8044f66:	619f      	str	r7, [r3, #24]
 8044f68:	e768      	b.n	8044e3c <kad_op_reshape+0x1d8>
				if (p->d[i] <= 0) ++n_missing;
 8044f6a:	1c79      	adds	r1, r7, #1
			for (i = 0; i < p->n_d; ++i)
 8044f6c:	f1be 0f00 	cmp.w	lr, #0
 8044f70:	f43f aed9 	beq.w	8044d26 <kad_op_reshape+0xc2>
				if (p->d[i] <= 0) ++n_missing;
 8044f74:	f8d3 e01c 	ldr.w	lr, [r3, #28]
 8044f78:	f1be 0f00 	cmp.w	lr, #0
 8044f7c:	dd45      	ble.n	804500a <kad_op_reshape+0x3a6>
				else len *= p->d[i];
 8044f7e:	fb0e f000 	mul.w	r0, lr, r0
			if (n_missing == 0 && len != kad_len(q)) return -1;
 8044f82:	e6d0      	b.n	8044d26 <kad_op_reshape+0xc2>
					if (p->d[i] <= 0 && i < q->n_d) {
 8044f84:	782c      	ldrb	r4, [r5, #0]
 8044f86:	2c00      	cmp	r4, #0
 8044f88:	f43f aed2 	beq.w	8044d30 <kad_op_reshape+0xcc>
						p->d[i] = q->d[i], len *= p->d[i];
 8044f8c:	692c      	ldr	r4, [r5, #16]
						if (--n_missing == 1) break;
 8044f8e:	3901      	subs	r1, #1
 8044f90:	2901      	cmp	r1, #1
						p->d[i] = q->d[i], len *= p->d[i];
 8044f92:	fb04 f000 	mul.w	r0, r4, r0
 8044f96:	611c      	str	r4, [r3, #16]
						if (--n_missing == 1) break;
 8044f98:	f47f aeca 	bne.w	8044d30 <kad_op_reshape+0xcc>
 8044f9c:	e71f      	b.n	8044dde <kad_op_reshape+0x17a>
					if (p->d[i] <= 0 && i < q->n_d) {
 8044f9e:	782c      	ldrb	r4, [r5, #0]
 8044fa0:	2c01      	cmp	r4, #1
 8044fa2:	f67f aec9 	bls.w	8044d38 <kad_op_reshape+0xd4>
						p->d[i] = q->d[i], len *= p->d[i];
 8044fa6:	696c      	ldr	r4, [r5, #20]
						if (--n_missing == 1) break;
 8044fa8:	3901      	subs	r1, #1
 8044faa:	2901      	cmp	r1, #1
						p->d[i] = q->d[i], len *= p->d[i];
 8044fac:	fb04 f000 	mul.w	r0, r4, r0
 8044fb0:	615c      	str	r4, [r3, #20]
						if (--n_missing == 1) break;
 8044fb2:	f47f aec1 	bne.w	8044d38 <kad_op_reshape+0xd4>
 8044fb6:	e712      	b.n	8044dde <kad_op_reshape+0x17a>
				if (p->d[i] <= 0) ++n_missing;
 8044fb8:	2c00      	cmp	r4, #0
 8044fba:	dd28      	ble.n	804500e <kad_op_reshape+0x3aa>
				else len *= p->d[i];
 8044fbc:	4620      	mov	r0, r4
 8044fbe:	e75d      	b.n	8044e7c <kad_op_reshape+0x218>
					if (p->d[i] <= 0 && i < q->n_d) {
 8044fc0:	782c      	ldrb	r4, [r5, #0]
 8044fc2:	2c02      	cmp	r4, #2
 8044fc4:	f67f aebf 	bls.w	8044d46 <kad_op_reshape+0xe2>
						p->d[i] = q->d[i], len *= p->d[i];
 8044fc8:	69ac      	ldr	r4, [r5, #24]
						if (--n_missing == 1) break;
 8044fca:	3901      	subs	r1, #1
 8044fcc:	2901      	cmp	r1, #1
						p->d[i] = q->d[i], len *= p->d[i];
 8044fce:	fb04 f000 	mul.w	r0, r4, r0
 8044fd2:	619c      	str	r4, [r3, #24]
						if (--n_missing == 1) break;
 8044fd4:	f47f aeb7 	bne.w	8044d46 <kad_op_reshape+0xe2>
 8044fd8:	e701      	b.n	8044dde <kad_op_reshape+0x17a>
					if (p->d[i] <= 0 && i < q->n_d) {
 8044fda:	782c      	ldrb	r4, [r5, #0]
 8044fdc:	2c03      	cmp	r4, #3
 8044fde:	f67f aeb9 	bls.w	8044d54 <kad_op_reshape+0xf0>
						p->d[i] = q->d[i], len *= p->d[i];
 8044fe2:	69ec      	ldr	r4, [r5, #28]
						if (--n_missing == 1) break;
 8044fe4:	2902      	cmp	r1, #2
						p->d[i] = q->d[i], len *= p->d[i];
 8044fe6:	bf08      	it	eq
 8044fe8:	4360      	muleq	r0, r4
 8044fea:	61dc      	str	r4, [r3, #28]
						if (--n_missing == 1) break;
 8044fec:	f47f aeb2 	bne.w	8044d54 <kad_op_reshape+0xf0>
 8044ff0:	e6f5      	b.n	8044dde <kad_op_reshape+0x17a>
				if (p->d[i] <= 0) ++n_missing;
 8044ff2:	1c79      	adds	r1, r7, #1
			if (n_missing == 0 && len != kad_len(q)) return -1;
 8044ff4:	e697      	b.n	8044d26 <kad_op_reshape+0xc2>
	int n = 1, i;
 8044ff6:	2301      	movs	r3, #1
 8044ff8:	e754      	b.n	8044ea4 <kad_op_reshape+0x240>
				if (kad_len(q) % len != 0) return -1;
 8044ffa:	fb98 f4f0 	sdiv	r4, r8, r0
 8044ffe:	fb00 8414 	mls	r4, r0, r4, r8
 8045002:	2c00      	cmp	r4, #0
 8045004:	f43f af09 	beq.w	8044e1a <kad_op_reshape+0x1b6>
 8045008:	e6a4      	b.n	8044d54 <kad_op_reshape+0xf0>
				if (p->d[i] <= 0) ++n_missing;
 804500a:	1cb9      	adds	r1, r7, #2
			if (n_missing > 1) { /* attempt to infer missing dimensions except the last one */
 804500c:	e68d      	b.n	8044d2a <kad_op_reshape+0xc6>
	for (i = 0; i < p->n_d; ++i) n *= p->d[i];
 804500e:	7829      	ldrb	r1, [r5, #0]
 8045010:	2001      	movs	r0, #1
 8045012:	2900      	cmp	r1, #0
 8045014:	f47f aee7 	bne.w	8044de6 <kad_op_reshape+0x182>
					if (p->d[i] <= 0) p->d[i] = kad_len(q) / len;
 8045018:	6919      	ldr	r1, [r3, #16]
 804501a:	2900      	cmp	r1, #0
 804501c:	dd23      	ble.n	8045066 <kad_op_reshape+0x402>
				for (i = 0; i < p->n_d; ++i)
 804501e:	2e00      	cmp	r6, #0
 8045020:	f43f ae2b 	beq.w	8044c7a <kad_op_reshape+0x16>
					if (p->d[i] <= 0) p->d[i] = kad_len(q) / len;
 8045024:	6959      	ldr	r1, [r3, #20]
 8045026:	2900      	cmp	r1, #0
 8045028:	dd37      	ble.n	804509a <kad_op_reshape+0x436>
 804502a:	2100      	movs	r1, #0
 804502c:	e6fe      	b.n	8044e2c <kad_op_reshape+0x1c8>
	int n = 1, i;
 804502e:	2001      	movs	r0, #1
 8045030:	e6ae      	b.n	8044d90 <kad_op_reshape+0x12c>
				if (kad_len(q) % len != 0) return -1;
 8045032:	fb97 fef0 	sdiv	lr, r7, r0
 8045036:	fb00 741e 	mls	r4, r0, lr, r7
 804503a:	2c00      	cmp	r4, #0
 804503c:	f47f ae8a 	bne.w	8044d54 <kad_op_reshape+0xf0>
					if (p->d[i] <= 0) p->d[i] = kad_len(q) / len;
 8045040:	691c      	ldr	r4, [r3, #16]
 8045042:	2c00      	cmp	r4, #0
 8045044:	f73f aeec 	bgt.w	8044e20 <kad_op_reshape+0x1bc>
 8045048:	e759      	b.n	8044efe <kad_op_reshape+0x29a>
				if (kad_len(q) % len != 0) return -1;
 804504a:	2101      	movs	r1, #1
 804504c:	fb91 f1f0 	sdiv	r1, r1, r0
 8045050:	fb00 f101 	mul.w	r1, r0, r1
 8045054:	2901      	cmp	r1, #1
 8045056:	d0df      	beq.n	8045018 <kad_op_reshape+0x3b4>
 8045058:	e67c      	b.n	8044d54 <kad_op_reshape+0xf0>
	for (i = 0; i < p->n_d; ++i) n *= p->d[i];
 804505a:	b1d1      	cbz	r1, 8045092 <kad_op_reshape+0x42e>
 804505c:	692f      	ldr	r7, [r5, #16]
 804505e:	e771      	b.n	8044f44 <kad_op_reshape+0x2e0>
				if (p->d[i] <= 0) ++n_missing;
 8045060:	2102      	movs	r1, #2
			int i, len = 1, n_missing = 0;
 8045062:	2001      	movs	r0, #1
 8045064:	e661      	b.n	8044d2a <kad_op_reshape+0xc6>
					if (p->d[i] <= 0) p->d[i] = kad_len(q) / len;
 8045066:	1c41      	adds	r1, r0, #1
 8045068:	2902      	cmp	r1, #2
 804506a:	bf94      	ite	ls
 804506c:	4604      	movls	r4, r0
 804506e:	2400      	movhi	r4, #0
 8045070:	611c      	str	r4, [r3, #16]
				for (i = 0; i < p->n_d; ++i)
 8045072:	2e00      	cmp	r6, #0
 8045074:	f43f ae01 	beq.w	8044c7a <kad_op_reshape+0x16>
					if (p->d[i] <= 0) p->d[i] = kad_len(q) / len;
 8045078:	695c      	ldr	r4, [r3, #20]
 804507a:	2c00      	cmp	r4, #0
 804507c:	dd0e      	ble.n	804509c <kad_op_reshape+0x438>
				for (i = 0; i < p->n_d; ++i)
 804507e:	f1bc 0f02 	cmp.w	ip, #2
 8045082:	f77f adfa 	ble.w	8044c7a <kad_op_reshape+0x16>
					if (p->d[i] <= 0) p->d[i] = kad_len(q) / len;
 8045086:	6999      	ldr	r1, [r3, #24]
 8045088:	2900      	cmp	r1, #0
	int n = 1, i;
 804508a:	f04f 0100 	mov.w	r1, #0
 804508e:	f73f aed5 	bgt.w	8044e3c <kad_op_reshape+0x1d8>
 8045092:	2701      	movs	r7, #1
 8045094:	e765      	b.n	8044f62 <kad_op_reshape+0x2fe>
				else len *= p->d[i];
 8045096:	4620      	mov	r0, r4
 8045098:	e6a1      	b.n	8044dde <kad_op_reshape+0x17a>
 804509a:	1c41      	adds	r1, r0, #1
					if (p->d[i] <= 0) p->d[i] = kad_len(q) / len;
 804509c:	2902      	cmp	r1, #2
 804509e:	bf94      	ite	ls
 80450a0:	4601      	movls	r1, r0
 80450a2:	2100      	movhi	r1, #0
 80450a4:	6159      	str	r1, [r3, #20]
 80450a6:	e7ea      	b.n	804507e <kad_op_reshape+0x41a>
 80450a8:	2201      	movs	r2, #1
 80450aa:	e6e2      	b.n	8044e72 <kad_op_reshape+0x20e>

080450ac <kad_op_reverse>:
{
 80450ac:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	kad_node_t *q = p->child[0];
 80450b0:	6b83      	ldr	r3, [r0, #56]	@ 0x38
	axis = p->ptr? *(int32_t*)p->ptr : 0;
 80450b2:	6b02      	ldr	r2, [r0, #48]	@ 0x30
	kad_node_t *q = p->child[0];
 80450b4:	f8d3 8000 	ldr.w	r8, [r3]
{
 80450b8:	4683      	mov	fp, r0
	assert(axis >= 0 && axis < q->n_d);
 80450ba:	f898 5000 	ldrb.w	r5, [r8]
{
 80450be:	b085      	sub	sp, #20
	axis = p->ptr? *(int32_t*)p->ptr : 0;
 80450c0:	2a00      	cmp	r2, #0
 80450c2:	d041      	beq.n	8045148 <kad_op_reverse+0x9c>
 80450c4:	6812      	ldr	r2, [r2, #0]
	if (axis < 0) axis += q->n_d;
 80450c6:	2a00      	cmp	r2, #0
 80450c8:	db35      	blt.n	8045136 <kad_op_reverse+0x8a>
	assert(axis >= 0 && axis < q->n_d);
 80450ca:	42aa      	cmp	r2, r5
 80450cc:	da35      	bge.n	804513a <kad_op_reverse+0x8e>
	for (i = axis + 1, d1 = 1; i < q->n_d; ++i) d1 *= q->d[i];
 80450ce:	1c50      	adds	r0, r2, #1
	for (i = 0, d0 = 1; i < axis; ++i) d0 *= q->d[i];
 80450d0:	2a00      	cmp	r2, #0
 80450d2:	d03b      	beq.n	804514c <kad_op_reverse+0xa0>
 80450d4:	2a01      	cmp	r2, #1
 80450d6:	f8d8 3010 	ldr.w	r3, [r8, #16]
 80450da:	d00e      	beq.n	80450fa <kad_op_reverse+0x4e>
 80450dc:	f8d8 4014 	ldr.w	r4, [r8, #20]
 80450e0:	2a02      	cmp	r2, #2
 80450e2:	fb04 f303 	mul.w	r3, r4, r3
 80450e6:	d008      	beq.n	80450fa <kad_op_reverse+0x4e>
 80450e8:	f8d8 4018 	ldr.w	r4, [r8, #24]
 80450ec:	2a03      	cmp	r2, #3
 80450ee:	fb04 f303 	mul.w	r3, r4, r3
 80450f2:	bf1c      	itt	ne
 80450f4:	f8d8 401c 	ldrne.w	r4, [r8, #28]
 80450f8:	4363      	mulne	r3, r4
	n = q->d[axis];
 80450fa:	3204      	adds	r2, #4
	for (i = axis + 1, d1 = 1; i < q->n_d; ++i) d1 *= q->d[i];
 80450fc:	42a8      	cmp	r0, r5
	n = q->d[axis];
 80450fe:	f858 a022 	ldr.w	sl, [r8, r2, lsl #2]
	for (i = axis + 1, d1 = 1; i < q->n_d; ++i) d1 *= q->d[i];
 8045102:	da2a      	bge.n	804515a <kad_op_reverse+0xae>
 8045104:	1c42      	adds	r2, r0, #1
 8045106:	eb08 0680 	add.w	r6, r8, r0, lsl #2
 804510a:	4295      	cmp	r5, r2
 804510c:	6934      	ldr	r4, [r6, #16]
 804510e:	dd08      	ble.n	8045122 <kad_op_reverse+0x76>
 8045110:	6972      	ldr	r2, [r6, #20]
 8045112:	3002      	adds	r0, #2
 8045114:	42a8      	cmp	r0, r5
 8045116:	fb02 f404 	mul.w	r4, r2, r4
 804511a:	da02      	bge.n	8045122 <kad_op_reverse+0x76>
 804511c:	69b2      	ldr	r2, [r6, #24]
 804511e:	fb02 f404 	mul.w	r4, r2, r4
	if (action == KAD_SYNC_DIM) {
 8045122:	2904      	cmp	r1, #4
 8045124:	d01d      	beq.n	8045162 <kad_op_reverse+0xb6>
	} else if (action == KAD_FORWARD) {
 8045126:	2902      	cmp	r1, #2
 8045128:	d027      	beq.n	804517a <kad_op_reverse+0xce>
	} else if (action == KAD_BACKWARD && kad_is_back(q)) {
 804512a:	2903      	cmp	r1, #3
 804512c:	d05c      	beq.n	80451e8 <kad_op_reverse+0x13c>
}
 804512e:	2000      	movs	r0, #0
 8045130:	b005      	add	sp, #20
 8045132:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	assert(axis >= 0 && axis < q->n_d);
 8045136:	1952      	adds	r2, r2, r5
 8045138:	d5c9      	bpl.n	80450ce <kad_op_reverse+0x22>
 804513a:	f240 51bc 	movw	r1, #1468	@ 0x5bc
 804513e:	4b4b      	ldr	r3, [pc, #300]	@ (804526c <kad_op_reverse+0x1c0>)
 8045140:	4a4b      	ldr	r2, [pc, #300]	@ (8045270 <kad_op_reverse+0x1c4>)
 8045142:	484c      	ldr	r0, [pc, #304]	@ (8045274 <kad_op_reverse+0x1c8>)
 8045144:	f006 fb12 	bl	804b76c <__assert_func>
 8045148:	2d00      	cmp	r5, #0
 804514a:	d0f6      	beq.n	804513a <kad_op_reverse+0x8e>
	for (i = 0, d0 = 1; i < axis; ++i) d0 *= q->d[i];
 804514c:	2001      	movs	r0, #1
	n = q->d[axis];
 804514e:	3204      	adds	r2, #4
	for (i = axis + 1, d1 = 1; i < q->n_d; ++i) d1 *= q->d[i];
 8045150:	42a8      	cmp	r0, r5
	for (i = 0, d0 = 1; i < axis; ++i) d0 *= q->d[i];
 8045152:	4603      	mov	r3, r0
	n = q->d[axis];
 8045154:	f858 a022 	ldr.w	sl, [r8, r2, lsl #2]
	for (i = axis + 1, d1 = 1; i < q->n_d; ++i) d1 *= q->d[i];
 8045158:	dbd4      	blt.n	8045104 <kad_op_reverse+0x58>
	if (action == KAD_SYNC_DIM) {
 804515a:	2904      	cmp	r1, #4
	for (i = axis + 1, d1 = 1; i < q->n_d; ++i) d1 *= q->d[i];
 804515c:	f04f 0401 	mov.w	r4, #1
	if (action == KAD_SYNC_DIM) {
 8045160:	d1e1      	bne.n	8045126 <kad_op_reverse+0x7a>
	dst->n_d = src->n_d;
 8045162:	4658      	mov	r0, fp
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 8045164:	00aa      	lsls	r2, r5, #2
 8045166:	f108 0110 	add.w	r1, r8, #16
	dst->n_d = src->n_d;
 804516a:	f800 5b10 	strb.w	r5, [r0], #16
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 804516e:	f006 ff22 	bl	804bfb6 <memcpy>
}
 8045172:	2000      	movs	r0, #0
 8045174:	b005      	add	sp, #20
 8045176:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		for (i = 0; i < d0; ++i)
 804517a:	2b00      	cmp	r3, #0
 804517c:	ddd7      	ble.n	804512e <kad_op_reverse+0x82>
 804517e:	f1ba 0f00 	cmp.w	sl, #0
				memcpy(&p->x[(i * n + n - 1 - j) * d1], &q->x[(i * n + j) * d1], d1 * sizeof(float));
 8045182:	ea4f 0784 	mov.w	r7, r4, lsl #2
 8045186:	ddd2      	ble.n	804512e <kad_op_reverse+0x82>
 8045188:	2200      	movs	r2, #0
 804518a:	46b9      	mov	r9, r7
 804518c:	9303      	str	r3, [sp, #12]
 804518e:	4617      	mov	r7, r2
 8045190:	4613      	mov	r3, r2
 8045192:	fb04 f10a 	mul.w	r1, r4, sl
 8045196:	1b0c      	subs	r4, r1, r4
 8045198:	0089      	lsls	r1, r1, #2
 804519a:	9101      	str	r1, [sp, #4]
 804519c:	00a1      	lsls	r1, r4, #2
 804519e:	9102      	str	r1, [sp, #8]
			for (j = 0; j < n; ++j)
 80451a0:	9300      	str	r3, [sp, #0]
 80451a2:	465b      	mov	r3, fp
 80451a4:	9a02      	ldr	r2, [sp, #8]
	for (i = axis + 1, d1 = 1; i < q->n_d; ++i) d1 *= q->d[i];
 80451a6:	463e      	mov	r6, r7
 80451a8:	46bb      	mov	fp, r7
 80451aa:	19d4      	adds	r4, r2, r7
			for (j = 0; j < n; ++j)
 80451ac:	2500      	movs	r5, #0
 80451ae:	461f      	mov	r7, r3
				memcpy(&p->x[(i * n + n - 1 - j) * d1], &q->x[(i * n + j) * d1], d1 * sizeof(float));
 80451b0:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 80451b2:	f8d8 1028 	ldr.w	r1, [r8, #40]	@ 0x28
 80451b6:	4420      	add	r0, r4
 80451b8:	4431      	add	r1, r6
 80451ba:	464a      	mov	r2, r9
			for (j = 0; j < n; ++j)
 80451bc:	3501      	adds	r5, #1
				memcpy(&p->x[(i * n + n - 1 - j) * d1], &q->x[(i * n + j) * d1], d1 * sizeof(float));
 80451be:	f006 fefa 	bl	804bfb6 <memcpy>
			for (j = 0; j < n; ++j)
 80451c2:	45aa      	cmp	sl, r5
 80451c4:	eba4 0409 	sub.w	r4, r4, r9
 80451c8:	444e      	add	r6, r9
 80451ca:	d1f1      	bne.n	80451b0 <kad_op_reverse+0x104>
		for (i = 0; i < d0; ++i)
 80451cc:	463a      	mov	r2, r7
 80451ce:	465f      	mov	r7, fp
 80451d0:	4693      	mov	fp, r2
 80451d2:	9a01      	ldr	r2, [sp, #4]
 80451d4:	9b00      	ldr	r3, [sp, #0]
 80451d6:	4417      	add	r7, r2
 80451d8:	9a03      	ldr	r2, [sp, #12]
 80451da:	3301      	adds	r3, #1
 80451dc:	4293      	cmp	r3, r2
 80451de:	d1df      	bne.n	80451a0 <kad_op_reverse+0xf4>
}
 80451e0:	2000      	movs	r0, #0
 80451e2:	b005      	add	sp, #20
 80451e4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	} else if (action == KAD_BACKWARD && kad_is_back(q)) {
 80451e8:	f898 2001 	ldrb.w	r2, [r8, #1]
 80451ec:	07d2      	lsls	r2, r2, #31
 80451ee:	d59e      	bpl.n	804512e <kad_op_reverse+0x82>
		for (i = 0; i < d0; ++i)
 80451f0:	2b00      	cmp	r3, #0
 80451f2:	dd9c      	ble.n	804512e <kad_op_reverse+0x82>
 80451f4:	f1ba 0f00 	cmp.w	sl, #0
 80451f8:	dd99      	ble.n	804512e <kad_op_reverse+0x82>
 80451fa:	2c00      	cmp	r4, #0
 80451fc:	dd97      	ble.n	804512e <kad_op_reverse+0x82>
 80451fe:	f8d8 702c 	ldr.w	r7, [r8, #44]	@ 0x2c
				kad_saxpy(d1, 1.0f, &p->g[(i * n + n - 1 - j) * d1], &q->g[(i * n + j) * d1]);
 8045202:	f04f 0800 	mov.w	r8, #0
		for (i = 0; i < d0; ++i)
 8045206:	46c1      	mov	r9, r8
 8045208:	fb04 f20a 	mul.w	r2, r4, sl
 804520c:	00a6      	lsls	r6, r4, #2
 804520e:	eb07 0c84 	add.w	ip, r7, r4, lsl #2
 8045212:	1b14      	subs	r4, r2, r4
				kad_saxpy(d1, 1.0f, &p->g[(i * n + n - 1 - j) * d1], &q->g[(i * n + j) * d1]);
 8045214:	f8db e02c 	ldr.w	lr, [fp, #44]	@ 0x2c
 8045218:	ea4f 0b82 	mov.w	fp, r2, lsl #2
 804521c:	00a2      	lsls	r2, r4, #2
 804521e:	9200      	str	r2, [sp, #0]
 8045220:	f8cd b004 	str.w	fp, [sp, #4]
		for (i = 0; i < d0; ++i)
 8045224:	46c3      	mov	fp, r8
			for (j = 0; j < n; ++j)
 8045226:	2500      	movs	r5, #0
 8045228:	9a00      	ldr	r2, [sp, #0]
 804522a:	eb0c 0008 	add.w	r0, ip, r8
 804522e:	eb08 0402 	add.w	r4, r8, r2
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 8045232:	eb07 020b 	add.w	r2, r7, fp
 8045236:	eb0e 0104 	add.w	r1, lr, r4
 804523a:	edd2 7a00 	vldr	s15, [r2]
 804523e:	ecb1 7a01 	vldmia	r1!, {s14}
 8045242:	ee77 7a87 	vadd.f32	s15, s15, s14
 8045246:	ece2 7a01 	vstmia	r2!, {s15}
 804524a:	4290      	cmp	r0, r2
 804524c:	d1f5      	bne.n	804523a <kad_op_reverse+0x18e>
			for (j = 0; j < n; ++j)
 804524e:	3501      	adds	r5, #1
 8045250:	45aa      	cmp	sl, r5
 8045252:	44b3      	add	fp, r6
 8045254:	eba4 0406 	sub.w	r4, r4, r6
 8045258:	4430      	add	r0, r6
 804525a:	d1ea      	bne.n	8045232 <kad_op_reverse+0x186>
		for (i = 0; i < d0; ++i)
 804525c:	9a01      	ldr	r2, [sp, #4]
 804525e:	f109 0901 	add.w	r9, r9, #1
 8045262:	4599      	cmp	r9, r3
 8045264:	4490      	add	r8, r2
 8045266:	d1dd      	bne.n	8045224 <kad_op_reverse+0x178>
 8045268:	e761      	b.n	804512e <kad_op_reverse+0x82>
 804526a:	bf00      	nop
 804526c:	0804e354 	.word	0x0804e354
 8045270:	0804e488 	.word	0x0804e488
 8045274:	0804e328 	.word	0x0804e328

08045278 <kad_op_avg>:
{
 8045278:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	assert(p->n_child > 0);
 804527c:	6846      	ldr	r6, [r0, #4]
{
 804527e:	ed2d 8b02 	vpush	{d8}
	assert(p->n_child > 0);
 8045282:	2e00      	cmp	r6, #0
 8045284:	f340 80c4 	ble.w	8045410 <kad_op_avg+0x198>
	q = p->child[0];
 8045288:	6b82      	ldr	r2, [r0, #56]	@ 0x38
 804528a:	4605      	mov	r5, r0
 804528c:	6817      	ldr	r7, [r2, #0]
	for (i = 0; i < p->n_d; ++i) n *= p->d[i];
 804528e:	f897 8000 	ldrb.w	r8, [r7]
 8045292:	f1b8 0f00 	cmp.w	r8, #0
 8045296:	d06c      	beq.n	8045372 <kad_op_avg+0xfa>
 8045298:	f1b8 0f01 	cmp.w	r8, #1
 804529c:	693c      	ldr	r4, [r7, #16]
 804529e:	d00e      	beq.n	80452be <kad_op_avg+0x46>
 80452a0:	697b      	ldr	r3, [r7, #20]
 80452a2:	f1b8 0f02 	cmp.w	r8, #2
 80452a6:	fb03 f404 	mul.w	r4, r3, r4
 80452aa:	d008      	beq.n	80452be <kad_op_avg+0x46>
 80452ac:	69bb      	ldr	r3, [r7, #24]
 80452ae:	f1b8 0f03 	cmp.w	r8, #3
 80452b2:	fb03 f404 	mul.w	r4, r3, r4
 80452b6:	d002      	beq.n	80452be <kad_op_avg+0x46>
 80452b8:	69fb      	ldr	r3, [r7, #28]
 80452ba:	fb03 f404 	mul.w	r4, r3, r4
	if (action == KAD_SYNC_DIM) {
 80452be:	2904      	cmp	r1, #4
 80452c0:	d010      	beq.n	80452e4 <kad_op_avg+0x6c>
	tmp = 1.0f / p->n_child;
 80452c2:	ee07 6a90 	vmov	s15, r6
 80452c6:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 80452ca:	eef8 7ae7 	vcvt.f32.s32	s15, s15
	} else if (action == KAD_FORWARD) {
 80452ce:	2902      	cmp	r1, #2
	tmp = 1.0f / p->n_child;
 80452d0:	ee87 8a27 	vdiv.f32	s16, s14, s15
	} else if (action == KAD_FORWARD) {
 80452d4:	d05f      	beq.n	8045396 <kad_op_avg+0x11e>
	} else if (action == KAD_BACKWARD) {
 80452d6:	2903      	cmp	r1, #3
 80452d8:	d02f      	beq.n	804533a <kad_op_avg+0xc2>
}
 80452da:	ecbd 8b02 	vpop	{d8}
	return 0;
 80452de:	2000      	movs	r0, #0
}
 80452e0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		for (i = 1; i < p->n_child; ++i)
 80452e4:	2e01      	cmp	r6, #1
 80452e6:	f000 8090 	beq.w	804540a <kad_op_avg+0x192>
 80452ea:	4694      	mov	ip, r2
 80452ec:	f04f 0e01 	mov.w	lr, #1
 80452f0:	e015      	b.n	804531e <kad_op_avg+0xa6>
 80452f2:	2801      	cmp	r0, #1
 80452f4:	6913      	ldr	r3, [r2, #16]
 80452f6:	d00c      	beq.n	8045312 <kad_op_avg+0x9a>
 80452f8:	6951      	ldr	r1, [r2, #20]
 80452fa:	2802      	cmp	r0, #2
 80452fc:	fb01 f303 	mul.w	r3, r1, r3
 8045300:	d007      	beq.n	8045312 <kad_op_avg+0x9a>
 8045302:	6991      	ldr	r1, [r2, #24]
 8045304:	2803      	cmp	r0, #3
 8045306:	fb01 f303 	mul.w	r3, r1, r3
 804530a:	d002      	beq.n	8045312 <kad_op_avg+0x9a>
 804530c:	69d2      	ldr	r2, [r2, #28]
 804530e:	fb02 f303 	mul.w	r3, r2, r3
			if (kad_len(p->child[i]) != n) return -1;
 8045312:	429c      	cmp	r4, r3
 8045314:	d10b      	bne.n	804532e <kad_op_avg+0xb6>
		for (i = 1; i < p->n_child; ++i)
 8045316:	f10e 0e01 	add.w	lr, lr, #1
 804531a:	4576      	cmp	r6, lr
 804531c:	dd2d      	ble.n	804537a <kad_op_avg+0x102>
			if (kad_len(p->child[i]) != n) return -1;
 804531e:	f85c 2f04 	ldr.w	r2, [ip, #4]!
 8045322:	7810      	ldrb	r0, [r2, #0]
 8045324:	2800      	cmp	r0, #0
 8045326:	d1e4      	bne.n	80452f2 <kad_op_avg+0x7a>
	int n = 1, i;
 8045328:	2301      	movs	r3, #1
 804532a:	429c      	cmp	r4, r3
 804532c:	d0f3      	beq.n	8045316 <kad_op_avg+0x9e>
 804532e:	f04f 30ff 	mov.w	r0, #4294967295
}
 8045332:	ecbd 8b02 	vpop	{d8}
 8045336:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 804533a:	3a04      	subs	r2, #4
 804533c:	eb02 0686 	add.w	r6, r2, r6, lsl #2
 8045340:	00a7      	lsls	r7, r4, #2
 8045342:	e001      	b.n	8045348 <kad_op_avg+0xd0>
		for (i = 0; i < p->n_child; ++i)
 8045344:	4296      	cmp	r6, r2
 8045346:	d0c8      	beq.n	80452da <kad_op_avg+0x62>
			if (kad_is_back(p->child[i]))
 8045348:	f852 3f04 	ldr.w	r3, [r2, #4]!
 804534c:	7859      	ldrb	r1, [r3, #1]
 804534e:	07c9      	lsls	r1, r1, #31
 8045350:	d5f8      	bpl.n	8045344 <kad_op_avg+0xcc>
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 8045352:	2c00      	cmp	r4, #0
				kad_saxpy(n, tmp, p->g, p->child[i]->g);
 8045354:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8045356:	6ae9      	ldr	r1, [r5, #44]	@ 0x2c
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 8045358:	ddf4      	ble.n	8045344 <kad_op_avg+0xcc>
 804535a:	19d8      	adds	r0, r3, r7
 804535c:	edd3 7a00 	vldr	s15, [r3]
 8045360:	ecb1 7a01 	vldmia	r1!, {s14}
 8045364:	eee8 7a07 	vfma.f32	s15, s16, s14
 8045368:	ece3 7a01 	vstmia	r3!, {s15}
 804536c:	4298      	cmp	r0, r3
 804536e:	d1f5      	bne.n	804535c <kad_op_avg+0xe4>
 8045370:	e7e8      	b.n	8045344 <kad_op_avg+0xcc>
	if (action == KAD_SYNC_DIM) {
 8045372:	2904      	cmp	r1, #4
 8045374:	d03c      	beq.n	80453f0 <kad_op_avg+0x178>
 8045376:	2401      	movs	r4, #1
 8045378:	e7a3      	b.n	80452c2 <kad_op_avg+0x4a>
	dst->n_d = src->n_d;
 804537a:	f885 8000 	strb.w	r8, [r5]
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 804537e:	f1b8 0f00 	cmp.w	r8, #0
 8045382:	d0aa      	beq.n	80452da <kad_op_avg+0x62>
 8045384:	ea4f 0288 	mov.w	r2, r8, lsl #2
 8045388:	f107 0110 	add.w	r1, r7, #16
 804538c:	f105 0010 	add.w	r0, r5, #16
 8045390:	f006 fe11 	bl	804bfb6 <memcpy>
 8045394:	e7a1      	b.n	80452da <kad_op_avg+0x62>
		memcpy(p->x, q->x, n * sizeof(float));
 8045396:	00a6      	lsls	r6, r4, #2
 8045398:	4632      	mov	r2, r6
 804539a:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
 804539c:	6aa8      	ldr	r0, [r5, #40]	@ 0x28
 804539e:	f006 fe0a 	bl	804bfb6 <memcpy>
		for (i = 1; i < p->n_child; ++i)
 80453a2:	686a      	ldr	r2, [r5, #4]
 80453a4:	2a01      	cmp	r2, #1
 80453a6:	dd2b      	ble.n	8045400 <kad_op_avg+0x188>
 80453a8:	2c00      	cmp	r4, #0
			kad_saxpy(n, 1.0f, p->child[i]->x, p->x);
 80453aa:	6bab      	ldr	r3, [r5, #56]	@ 0x38
 80453ac:	6aad      	ldr	r5, [r5, #40]	@ 0x28
 80453ae:	dd94      	ble.n	80452da <kad_op_avg+0x62>
 80453b0:	461c      	mov	r4, r3
 80453b2:	1f1f      	subs	r7, r3, #4
 80453b4:	19a8      	adds	r0, r5, r6
 80453b6:	eb07 0782 	add.w	r7, r7, r2, lsl #2
 80453ba:	462b      	mov	r3, r5
 80453bc:	f854 2f04 	ldr.w	r2, [r4, #4]!
 80453c0:	6a91      	ldr	r1, [r2, #40]	@ 0x28
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 80453c2:	edd3 7a00 	vldr	s15, [r3]
 80453c6:	ecb1 7a01 	vldmia	r1!, {s14}
 80453ca:	ee77 7a87 	vadd.f32	s15, s15, s14
 80453ce:	ece3 7a01 	vstmia	r3!, {s15}
 80453d2:	4298      	cmp	r0, r3
 80453d4:	d1f5      	bne.n	80453c2 <kad_op_avg+0x14a>
		for (i = 1; i < p->n_child; ++i)
 80453d6:	42a7      	cmp	r7, r4
 80453d8:	d1ef      	bne.n	80453ba <kad_op_avg+0x142>
 80453da:	462b      	mov	r3, r5
 80453dc:	442e      	add	r6, r5
		for (i = 0; i < n; ++i) p->x[i] *= tmp;
 80453de:	edd3 7a00 	vldr	s15, [r3]
 80453e2:	ee67 7a88 	vmul.f32	s15, s15, s16
 80453e6:	ece3 7a01 	vstmia	r3!, {s15}
 80453ea:	429e      	cmp	r6, r3
 80453ec:	d1f7      	bne.n	80453de <kad_op_avg+0x166>
 80453ee:	e774      	b.n	80452da <kad_op_avg+0x62>
		for (i = 1; i < p->n_child; ++i)
 80453f0:	2e01      	cmp	r6, #1
	dst->n_d = src->n_d;
 80453f2:	bf08      	it	eq
 80453f4:	f880 8000 	strbeq.w	r8, [r0]
		for (i = 1; i < p->n_child; ++i)
 80453f8:	f43f af6f 	beq.w	80452da <kad_op_avg+0x62>
 80453fc:	2401      	movs	r4, #1
 80453fe:	e774      	b.n	80452ea <kad_op_avg+0x72>
		for (i = 0; i < n; ++i) p->x[i] *= tmp;
 8045400:	2c00      	cmp	r4, #0
 8045402:	f77f af6a 	ble.w	80452da <kad_op_avg+0x62>
 8045406:	6aad      	ldr	r5, [r5, #40]	@ 0x28
 8045408:	e7e7      	b.n	80453da <kad_op_avg+0x162>
	dst->n_d = src->n_d;
 804540a:	f885 8000 	strb.w	r8, [r5]
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 804540e:	e7b9      	b.n	8045384 <kad_op_avg+0x10c>
	assert(p->n_child > 0);
 8045410:	f240 61fb 	movw	r1, #1787	@ 0x6fb
 8045414:	4b02      	ldr	r3, [pc, #8]	@ (8045420 <kad_op_avg+0x1a8>)
 8045416:	4a03      	ldr	r2, [pc, #12]	@ (8045424 <kad_op_avg+0x1ac>)
 8045418:	4803      	ldr	r0, [pc, #12]	@ (8045428 <kad_op_avg+0x1b0>)
 804541a:	f006 f9a7 	bl	804b76c <__assert_func>
 804541e:	bf00      	nop
 8045420:	0804e370 	.word	0x0804e370
 8045424:	0804e45c 	.word	0x0804e45c
 8045428:	0804e328 	.word	0x0804e328

0804542c <kad_op_stack>:
{
 804542c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	assert(p->n_child > 0);
 8045430:	6847      	ldr	r7, [r0, #4]
 8045432:	2f00      	cmp	r7, #0
 8045434:	f340 8096 	ble.w	8045564 <kad_op_stack+0x138>
	q = p->child[0];
 8045438:	6b83      	ldr	r3, [r0, #56]	@ 0x38
 804543a:	4605      	mov	r5, r0
 804543c:	681e      	ldr	r6, [r3, #0]
	for (i = 0; i < p->n_d; ++i) n *= p->d[i];
 804543e:	f896 e000 	ldrb.w	lr, [r6]
 8045442:	f1be 0f00 	cmp.w	lr, #0
 8045446:	d057      	beq.n	80454f8 <kad_op_stack+0xcc>
 8045448:	f1be 0f01 	cmp.w	lr, #1
 804544c:	6930      	ldr	r0, [r6, #16]
 804544e:	d00e      	beq.n	804546e <kad_op_stack+0x42>
 8045450:	6972      	ldr	r2, [r6, #20]
 8045452:	f1be 0f02 	cmp.w	lr, #2
 8045456:	fb02 f000 	mul.w	r0, r2, r0
 804545a:	d008      	beq.n	804546e <kad_op_stack+0x42>
 804545c:	69b2      	ldr	r2, [r6, #24]
 804545e:	f1be 0f03 	cmp.w	lr, #3
 8045462:	fb02 f000 	mul.w	r0, r2, r0
 8045466:	d002      	beq.n	804546e <kad_op_stack+0x42>
 8045468:	69f2      	ldr	r2, [r6, #28]
 804546a:	fb02 f000 	mul.w	r0, r2, r0
	if (action == KAD_SYNC_DIM) {
 804546e:	2904      	cmp	r1, #4
 8045470:	d01a      	beq.n	80454a8 <kad_op_stack+0x7c>
	} else if (action == KAD_FORWARD) { /* TODO: doesn't work when axis != 0 */
 8045472:	2902      	cmp	r1, #2
 8045474:	d004      	beq.n	8045480 <kad_op_stack+0x54>
	} else if (action == KAD_BACKWARD) {
 8045476:	2903      	cmp	r1, #3
 8045478:	d053      	beq.n	8045522 <kad_op_stack+0xf6>
	return 0;
 804547a:	2000      	movs	r0, #0
}
 804547c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			memcpy(&p->x[i * n], p->child[i]->x, n * sizeof(float));
 8045480:	2700      	movs	r7, #0
 8045482:	ea4f 0880 	mov.w	r8, r0, lsl #2
		for (i = 0; i < p->n_child; ++i)
 8045486:	463c      	mov	r4, r7
 8045488:	e002      	b.n	8045490 <kad_op_stack+0x64>
			memcpy(&p->x[i * n], p->child[i]->x, n * sizeof(float));
 804548a:	6bab      	ldr	r3, [r5, #56]	@ 0x38
 804548c:	f853 6024 	ldr.w	r6, [r3, r4, lsl #2]
 8045490:	6aa8      	ldr	r0, [r5, #40]	@ 0x28
 8045492:	4642      	mov	r2, r8
 8045494:	4438      	add	r0, r7
 8045496:	6ab1      	ldr	r1, [r6, #40]	@ 0x28
 8045498:	f006 fd8d 	bl	804bfb6 <memcpy>
		for (i = 0; i < p->n_child; ++i)
 804549c:	686b      	ldr	r3, [r5, #4]
 804549e:	3401      	adds	r4, #1
 80454a0:	42a3      	cmp	r3, r4
 80454a2:	4447      	add	r7, r8
 80454a4:	dcf1      	bgt.n	804548a <kad_op_stack+0x5e>
 80454a6:	e7e8      	b.n	804547a <kad_op_stack+0x4e>
		for (i = 1; i < p->n_child; ++i)
 80454a8:	2f01      	cmp	r7, #1
 80454aa:	d027      	beq.n	80454fc <kad_op_stack+0xd0>
 80454ac:	4698      	mov	r8, r3
 80454ae:	f04f 0c01 	mov.w	ip, #1
 80454b2:	e015      	b.n	80454e0 <kad_op_stack+0xb4>
 80454b4:	2c01      	cmp	r4, #1
 80454b6:	6913      	ldr	r3, [r2, #16]
 80454b8:	d00c      	beq.n	80454d4 <kad_op_stack+0xa8>
 80454ba:	6951      	ldr	r1, [r2, #20]
 80454bc:	2c02      	cmp	r4, #2
 80454be:	fb01 f303 	mul.w	r3, r1, r3
 80454c2:	d007      	beq.n	80454d4 <kad_op_stack+0xa8>
 80454c4:	6991      	ldr	r1, [r2, #24]
 80454c6:	2c03      	cmp	r4, #3
 80454c8:	fb01 f303 	mul.w	r3, r1, r3
 80454cc:	d002      	beq.n	80454d4 <kad_op_stack+0xa8>
 80454ce:	69d2      	ldr	r2, [r2, #28]
 80454d0:	fb02 f303 	mul.w	r3, r2, r3
			if (kad_len(p->child[i]) != n) return -1;
 80454d4:	4298      	cmp	r0, r3
 80454d6:	d10b      	bne.n	80454f0 <kad_op_stack+0xc4>
		for (i = 1; i < p->n_child; ++i)
 80454d8:	f10c 0c01 	add.w	ip, ip, #1
 80454dc:	4567      	cmp	r7, ip
 80454de:	d00d      	beq.n	80454fc <kad_op_stack+0xd0>
			if (kad_len(p->child[i]) != n) return -1;
 80454e0:	f858 2f04 	ldr.w	r2, [r8, #4]!
 80454e4:	7814      	ldrb	r4, [r2, #0]
 80454e6:	2c00      	cmp	r4, #0
 80454e8:	d1e4      	bne.n	80454b4 <kad_op_stack+0x88>
	int n = 1, i;
 80454ea:	2301      	movs	r3, #1
 80454ec:	4298      	cmp	r0, r3
 80454ee:	d0f3      	beq.n	80454d8 <kad_op_stack+0xac>
 80454f0:	f04f 30ff 	mov.w	r0, #4294967295
}
 80454f4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80454f8:	2001      	movs	r0, #1
 80454fa:	e7b8      	b.n	804546e <kad_op_stack+0x42>
		p->n_d = q->n_d + 1;
 80454fc:	f10e 0e01 	add.w	lr, lr, #1
 8045500:	f885 e000 	strb.w	lr, [r5]
		p->d[axis] = p->n_child;
 8045504:	612f      	str	r7, [r5, #16]
		for (; i < q->n_d; ++i) p->d[i+1] = q->d[i];
 8045506:	7833      	ldrb	r3, [r6, #0]
 8045508:	2b00      	cmp	r3, #0
 804550a:	d0b6      	beq.n	804547a <kad_op_stack+0x4e>
 804550c:	6932      	ldr	r2, [r6, #16]
 804550e:	2b01      	cmp	r3, #1
 8045510:	616a      	str	r2, [r5, #20]
 8045512:	d0b2      	beq.n	804547a <kad_op_stack+0x4e>
 8045514:	6972      	ldr	r2, [r6, #20]
 8045516:	2b02      	cmp	r3, #2
 8045518:	61aa      	str	r2, [r5, #24]
 804551a:	d0ae      	beq.n	804547a <kad_op_stack+0x4e>
 804551c:	69b3      	ldr	r3, [r6, #24]
 804551e:	61eb      	str	r3, [r5, #28]
 8045520:	e7ab      	b.n	804547a <kad_op_stack+0x4e>
 8045522:	3b04      	subs	r3, #4
	} else if (action == KAD_BACKWARD) {
 8045524:	2600      	movs	r6, #0
 8045526:	ea4f 0c80 	mov.w	ip, r0, lsl #2
 804552a:	eb03 0787 	add.w	r7, r3, r7, lsl #2
 804552e:	e002      	b.n	8045536 <kad_op_stack+0x10a>
		for (i = 0; i < p->n_child; ++i)
 8045530:	429f      	cmp	r7, r3
 8045532:	4466      	add	r6, ip
 8045534:	d0a1      	beq.n	804547a <kad_op_stack+0x4e>
			if (kad_is_back(p->child[i]))
 8045536:	f853 2f04 	ldr.w	r2, [r3, #4]!
 804553a:	7851      	ldrb	r1, [r2, #1]
 804553c:	07c9      	lsls	r1, r1, #31
 804553e:	d5f7      	bpl.n	8045530 <kad_op_stack+0x104>
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 8045540:	2800      	cmp	r0, #0
				kad_saxpy(n, 1.0f, &p->g[i * n], p->child[i]->g);
 8045542:	6ad2      	ldr	r2, [r2, #44]	@ 0x2c
 8045544:	6ae9      	ldr	r1, [r5, #44]	@ 0x2c
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 8045546:	ddf3      	ble.n	8045530 <kad_op_stack+0x104>
 8045548:	4431      	add	r1, r6
 804554a:	eb02 040c 	add.w	r4, r2, ip
 804554e:	edd2 7a00 	vldr	s15, [r2]
 8045552:	ecb1 7a01 	vldmia	r1!, {s14}
 8045556:	ee77 7a87 	vadd.f32	s15, s15, s14
 804555a:	ece2 7a01 	vstmia	r2!, {s15}
 804555e:	42a2      	cmp	r2, r4
 8045560:	d1f5      	bne.n	804554e <kad_op_stack+0x122>
 8045562:	e7e5      	b.n	8045530 <kad_op_stack+0x104>
	assert(p->n_child > 0);
 8045564:	f240 7131 	movw	r1, #1841	@ 0x731
 8045568:	4b02      	ldr	r3, [pc, #8]	@ (8045574 <kad_op_stack+0x148>)
 804556a:	4a03      	ldr	r2, [pc, #12]	@ (8045578 <kad_op_stack+0x14c>)
 804556c:	4803      	ldr	r0, [pc, #12]	@ (804557c <kad_op_stack+0x150>)
 804556e:	f006 f8fd 	bl	804b76c <__assert_func>
 8045572:	bf00      	nop
 8045574:	0804e370 	.word	0x0804e370
 8045578:	0804e44c 	.word	0x0804e44c
 804557c:	0804e328 	.word	0x0804e328

08045580 <kad_op_select>:
{
 8045580:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	which = *(int32_t*)p->ptr;
 8045582:	6b03      	ldr	r3, [r0, #48]	@ 0x30
	if (which < 0) which += p->n_child;
 8045584:	6845      	ldr	r5, [r0, #4]
	which = *(int32_t*)p->ptr;
 8045586:	681b      	ldr	r3, [r3, #0]
	if (which < 0) which += p->n_child;
 8045588:	2b00      	cmp	r3, #0
 804558a:	db31      	blt.n	80455f0 <kad_op_select+0x70>
	assert(which >= 0 && which < p->n_child);
 804558c:	42ab      	cmp	r3, r5
 804558e:	da31      	bge.n	80455f4 <kad_op_select+0x74>
	q = p->child[which];
 8045590:	6b82      	ldr	r2, [r0, #56]	@ 0x38
 8045592:	f852 6023 	ldr.w	r6, [r2, r3, lsl #2]
	for (i = 0; i < p->n_d; ++i) n *= p->d[i];
 8045596:	7833      	ldrb	r3, [r6, #0]
 8045598:	2b00      	cmp	r3, #0
 804559a:	d05d      	beq.n	8045658 <kad_op_select+0xd8>
 804559c:	2b01      	cmp	r3, #1
 804559e:	6934      	ldr	r4, [r6, #16]
 80455a0:	d00c      	beq.n	80455bc <kad_op_select+0x3c>
 80455a2:	6977      	ldr	r7, [r6, #20]
 80455a4:	2b02      	cmp	r3, #2
 80455a6:	fb07 f404 	mul.w	r4, r7, r4
 80455aa:	d007      	beq.n	80455bc <kad_op_select+0x3c>
 80455ac:	69b7      	ldr	r7, [r6, #24]
 80455ae:	2b03      	cmp	r3, #3
 80455b0:	fb07 f404 	mul.w	r4, r7, r4
 80455b4:	d002      	beq.n	80455bc <kad_op_select+0x3c>
 80455b6:	69f7      	ldr	r7, [r6, #28]
 80455b8:	fb07 f404 	mul.w	r4, r7, r4
	if (action == KAD_SYNC_DIM) {
 80455bc:	2904      	cmp	r1, #4
 80455be:	d020      	beq.n	8045602 <kad_op_select+0x82>
	} else if (action == KAD_FORWARD) {
 80455c0:	2902      	cmp	r1, #2
 80455c2:	d04b      	beq.n	804565c <kad_op_select+0xdc>
	} else if (action == KAD_BACKWARD && kad_is_back(q)) {
 80455c4:	2903      	cmp	r1, #3
 80455c6:	d145      	bne.n	8045654 <kad_op_select+0xd4>
 80455c8:	7873      	ldrb	r3, [r6, #1]
 80455ca:	07db      	lsls	r3, r3, #31
 80455cc:	d542      	bpl.n	8045654 <kad_op_select+0xd4>
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 80455ce:	2c00      	cmp	r4, #0
		kad_saxpy(n, 1.0f, p->g, q->g);
 80455d0:	6ac2      	ldr	r2, [r0, #44]	@ 0x2c
 80455d2:	6af3      	ldr	r3, [r6, #44]	@ 0x2c
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 80455d4:	dd3e      	ble.n	8045654 <kad_op_select+0xd4>
 80455d6:	eb03 0484 	add.w	r4, r3, r4, lsl #2
 80455da:	edd3 7a00 	vldr	s15, [r3]
 80455de:	ecb2 7a01 	vldmia	r2!, {s14}
 80455e2:	ee77 7a87 	vadd.f32	s15, s15, s14
 80455e6:	ece3 7a01 	vstmia	r3!, {s15}
 80455ea:	42a3      	cmp	r3, r4
 80455ec:	d1f5      	bne.n	80455da <kad_op_select+0x5a>
 80455ee:	e031      	b.n	8045654 <kad_op_select+0xd4>
	assert(which >= 0 && which < p->n_child);
 80455f0:	195b      	adds	r3, r3, r5
 80455f2:	d5cd      	bpl.n	8045590 <kad_op_select+0x10>
 80455f4:	f240 714d 	movw	r1, #1869	@ 0x74d
 80455f8:	4b20      	ldr	r3, [pc, #128]	@ (804567c <kad_op_select+0xfc>)
 80455fa:	4a21      	ldr	r2, [pc, #132]	@ (8045680 <kad_op_select+0x100>)
 80455fc:	4821      	ldr	r0, [pc, #132]	@ (8045684 <kad_op_select+0x104>)
 80455fe:	f006 f8b5 	bl	804b76c <__assert_func>
		for (i = 0; i < p->n_child; ++i)
 8045602:	f04f 0c00 	mov.w	ip, #0
 8045606:	f1a2 0e04 	sub.w	lr, r2, #4
 804560a:	e015      	b.n	8045638 <kad_op_select+0xb8>
 804560c:	2b01      	cmp	r3, #1
 804560e:	690a      	ldr	r2, [r1, #16]
 8045610:	d00c      	beq.n	804562c <kad_op_select+0xac>
 8045612:	694f      	ldr	r7, [r1, #20]
 8045614:	2b02      	cmp	r3, #2
 8045616:	fb07 f202 	mul.w	r2, r7, r2
 804561a:	d007      	beq.n	804562c <kad_op_select+0xac>
 804561c:	698f      	ldr	r7, [r1, #24]
 804561e:	2b03      	cmp	r3, #3
 8045620:	fb07 f202 	mul.w	r2, r7, r2
 8045624:	d002      	beq.n	804562c <kad_op_select+0xac>
 8045626:	69c9      	ldr	r1, [r1, #28]
 8045628:	fb01 f202 	mul.w	r2, r1, r2
			if (p->child[i]->n_d != q->n_d || kad_len(p->child[i]) != n)
 804562c:	42a2      	cmp	r2, r4
 804562e:	d10d      	bne.n	804564c <kad_op_select+0xcc>
		for (i = 0; i < p->n_child; ++i)
 8045630:	f10c 0c01 	add.w	ip, ip, #1
 8045634:	45ac      	cmp	ip, r5
 8045636:	d00b      	beq.n	8045650 <kad_op_select+0xd0>
			if (p->child[i]->n_d != q->n_d || kad_len(p->child[i]) != n)
 8045638:	f85e 1f04 	ldr.w	r1, [lr, #4]!
 804563c:	780a      	ldrb	r2, [r1, #0]
 804563e:	429a      	cmp	r2, r3
 8045640:	d104      	bne.n	804564c <kad_op_select+0xcc>
 8045642:	2b00      	cmp	r3, #0
 8045644:	d1e2      	bne.n	804560c <kad_op_select+0x8c>
	int n = 1, i;
 8045646:	2201      	movs	r2, #1
 8045648:	42a2      	cmp	r2, r4
 804564a:	d0f1      	beq.n	8045630 <kad_op_select+0xb0>
		if (i < p->n_child) return -1;
 804564c:	45ac      	cmp	ip, r5
 804564e:	db12      	blt.n	8045676 <kad_op_select+0xf6>
	dst->n_d = src->n_d;
 8045650:	7003      	strb	r3, [r0, #0]
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 8045652:	b94b      	cbnz	r3, 8045668 <kad_op_select+0xe8>
	return 0;
 8045654:	2000      	movs	r0, #0
}
 8045656:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8045658:	2401      	movs	r4, #1
 804565a:	e7af      	b.n	80455bc <kad_op_select+0x3c>
		memcpy(p->x, q->x, n * sizeof(float));
 804565c:	6ab1      	ldr	r1, [r6, #40]	@ 0x28
 804565e:	00a2      	lsls	r2, r4, #2
 8045660:	6a80      	ldr	r0, [r0, #40]	@ 0x28
 8045662:	f006 fca8 	bl	804bfb6 <memcpy>
 8045666:	e7f5      	b.n	8045654 <kad_op_select+0xd4>
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 8045668:	009a      	lsls	r2, r3, #2
 804566a:	f106 0110 	add.w	r1, r6, #16
 804566e:	3010      	adds	r0, #16
 8045670:	f006 fca1 	bl	804bfb6 <memcpy>
 8045674:	e7ee      	b.n	8045654 <kad_op_select+0xd4>
		if (i < p->n_child) return -1;
 8045676:	f04f 30ff 	mov.w	r0, #4294967295
}
 804567a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 804567c:	0804e380 	.word	0x0804e380
 8045680:	0804e43c 	.word	0x0804e43c
 8045684:	0804e328 	.word	0x0804e328

08045688 <kad_op_ce_bin>:
{
 8045688:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 804568c:	ed2d 8b04 	vpush	{d8-d9}
	kad_node_t *y1 = p->child[0]; /* test */
 8045690:	6b82      	ldr	r2, [r0, #56]	@ 0x38
{
 8045692:	4681      	mov	r9, r0
	kad_node_t *y1 = p->child[0]; /* test */
 8045694:	e9d2 8300 	ldrd	r8, r3, [r2]
	for (i = 0; i < p->n_d; ++i) n *= p->d[i];
 8045698:	781a      	ldrb	r2, [r3, #0]
{
 804569a:	b083      	sub	sp, #12
 804569c:	2a00      	cmp	r2, #0
 804569e:	d03c      	beq.n	804571a <kad_op_ce_bin+0x92>
 80456a0:	2a01      	cmp	r2, #1
 80456a2:	691e      	ldr	r6, [r3, #16]
 80456a4:	d00c      	beq.n	80456c0 <kad_op_ce_bin+0x38>
 80456a6:	6958      	ldr	r0, [r3, #20]
 80456a8:	2a02      	cmp	r2, #2
 80456aa:	fb00 f606 	mul.w	r6, r0, r6
 80456ae:	d007      	beq.n	80456c0 <kad_op_ce_bin+0x38>
 80456b0:	6998      	ldr	r0, [r3, #24]
 80456b2:	2a03      	cmp	r2, #3
 80456b4:	fb00 f606 	mul.w	r6, r0, r6
 80456b8:	d002      	beq.n	80456c0 <kad_op_ce_bin+0x38>
 80456ba:	69da      	ldr	r2, [r3, #28]
 80456bc:	fb02 f606 	mul.w	r6, r2, r6
	if (action == KAD_SYNC_DIM) {
 80456c0:	2904      	cmp	r1, #4
 80456c2:	d00a      	beq.n	80456da <kad_op_ce_bin+0x52>
	} else if (action == KAD_FORWARD) {
 80456c4:	2902      	cmp	r1, #2
 80456c6:	d030      	beq.n	804572a <kad_op_ce_bin+0xa2>
	} else if (action == KAD_BACKWARD && kad_is_back(y1)) {
 80456c8:	2903      	cmp	r1, #3
 80456ca:	f000 80b8 	beq.w	804583e <kad_op_ce_bin+0x1b6>
	return 0;
 80456ce:	2000      	movs	r0, #0
}
 80456d0:	b003      	add	sp, #12
 80456d2:	ecbd 8b04 	vpop	{d8-d9}
 80456d6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80456da:	f898 2000 	ldrb.w	r2, [r8]
 80456de:	2a00      	cmp	r2, #0
 80456e0:	f000 810e 	beq.w	8045900 <kad_op_ce_bin+0x278>
 80456e4:	2a01      	cmp	r2, #1
 80456e6:	f8d8 3010 	ldr.w	r3, [r8, #16]
 80456ea:	d00f      	beq.n	804570c <kad_op_ce_bin+0x84>
 80456ec:	f8d8 1014 	ldr.w	r1, [r8, #20]
 80456f0:	2a02      	cmp	r2, #2
 80456f2:	fb01 f303 	mul.w	r3, r1, r3
 80456f6:	d009      	beq.n	804570c <kad_op_ce_bin+0x84>
 80456f8:	f8d8 1018 	ldr.w	r1, [r8, #24]
 80456fc:	2a03      	cmp	r2, #3
 80456fe:	fb01 f303 	mul.w	r3, r1, r3
 8045702:	d003      	beq.n	804570c <kad_op_ce_bin+0x84>
 8045704:	f8d8 201c 	ldr.w	r2, [r8, #28]
 8045708:	fb02 f303 	mul.w	r3, r2, r3
		if (n != kad_len(y1)) return -1;
 804570c:	429e      	cmp	r6, r3
 804570e:	f040 80fc 	bne.w	804590a <kad_op_ce_bin+0x282>
		p->n_d = 0;
 8045712:	2300      	movs	r3, #0
 8045714:	f889 3000 	strb.w	r3, [r9]
 8045718:	e7d9      	b.n	80456ce <kad_op_ce_bin+0x46>
	if (action == KAD_SYNC_DIM) {
 804571a:	2904      	cmp	r1, #4
 804571c:	f000 8088 	beq.w	8045830 <kad_op_ce_bin+0x1a8>
	} else if (action == KAD_FORWARD) {
 8045720:	2902      	cmp	r1, #2
	int n = 1, i;
 8045722:	f04f 0601 	mov.w	r6, #1
 8045726:	d1cf      	bne.n	80456c8 <kad_op_ce_bin+0x40>
 8045728:	e002      	b.n	8045730 <kad_op_ce_bin+0xa8>
		for (i = 0; i < n; ++i) {
 804572a:	2e00      	cmp	r6, #0
 804572c:	f340 80ea 	ble.w	8045904 <kad_op_ce_bin+0x27c>
				cost += y0->x[i] * log(y0->x[i] / (y1->x[i] > tiny? y1->x[i] : tiny));
 8045730:	eddf 8a77 	vldr	s17, [pc, #476]	@ 8045910 <kad_op_ce_bin+0x288>
			if (1.0f - y0->x[i] > 0.0f)
 8045734:	eeb7 9a00 	vmov.f32	s18, #112	@ 0x3f800000  1.0
		double cost = 0.0;
 8045738:	2400      	movs	r4, #0
 804573a:	2500      	movs	r5, #0
		for (i = 0; i < n; ++i) {
 804573c:	2700      	movs	r7, #0
 804573e:	f8d3 b028 	ldr.w	fp, [r3, #40]	@ 0x28
			if (y0->x[i] > 0.0f)
 8045742:	ecbb 8a01 	vldmia	fp!, {s16}
 8045746:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
 804574a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 804574e:	ea4f 0a87 	mov.w	sl, r7, lsl #2
		for (i = 0; i < n; ++i) {
 8045752:	f107 0701 	add.w	r7, r7, #1
			if (y0->x[i] > 0.0f)
 8045756:	dd28      	ble.n	80457aa <kad_op_ce_bin+0x122>
				cost += y0->x[i] * log(y0->x[i] / (y1->x[i] > tiny? y1->x[i] : tiny));
 8045758:	ee18 0a10 	vmov	r0, s16
 804575c:	f7fa fed0 	bl	8040500 <__aeabi_f2d>
 8045760:	f8d8 3028 	ldr.w	r3, [r8, #40]	@ 0x28
 8045764:	e9cd 0100 	strd	r0, r1, [sp]
 8045768:	4453      	add	r3, sl
 804576a:	edd3 7a00 	vldr	s15, [r3]
 804576e:	eef4 7ae8 	vcmpe.f32	s15, s17
 8045772:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8045776:	fe77 7aa8 	vselgt.f32	s15, s15, s17
 804577a:	eec8 7a27 	vdiv.f32	s15, s16, s15
 804577e:	ee17 0a90 	vmov	r0, s15
 8045782:	f7fa febd 	bl	8040500 <__aeabi_f2d>
 8045786:	ec41 0b10 	vmov	d0, r0, r1
 804578a:	f007 fa05 	bl	804cb98 <log>
 804578e:	e9dd 0100 	ldrd	r0, r1, [sp]
 8045792:	ec53 2b10 	vmov	r2, r3, d0
 8045796:	f7fa ff0b 	bl	80405b0 <__aeabi_dmul>
 804579a:	4602      	mov	r2, r0
 804579c:	460b      	mov	r3, r1
 804579e:	4620      	mov	r0, r4
 80457a0:	4629      	mov	r1, r5
 80457a2:	f7fa fd4f 	bl	8040244 <__adddf3>
 80457a6:	4604      	mov	r4, r0
 80457a8:	460d      	mov	r5, r1
			if (1.0f - y0->x[i] > 0.0f)
 80457aa:	ee39 8a48 	vsub.f32	s16, s18, s16
 80457ae:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
 80457b2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80457b6:	dd2a      	ble.n	804580e <kad_op_ce_bin+0x186>
				cost += (1.0f - y0->x[i]) * log((1.0f - y0->x[i]) / (1.0f - y1->x[i] > tiny? 1.0f - y1->x[i] : tiny));
 80457b8:	ee18 0a10 	vmov	r0, s16
 80457bc:	f7fa fea0 	bl	8040500 <__aeabi_f2d>
 80457c0:	f8d8 3028 	ldr.w	r3, [r8, #40]	@ 0x28
 80457c4:	e9cd 0100 	strd	r0, r1, [sp]
 80457c8:	4453      	add	r3, sl
 80457ca:	edd3 7a00 	vldr	s15, [r3]
 80457ce:	ee79 7a67 	vsub.f32	s15, s18, s15
 80457d2:	eef4 7ae8 	vcmpe.f32	s15, s17
 80457d6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80457da:	fe77 7aa8 	vselgt.f32	s15, s15, s17
 80457de:	eec8 7a27 	vdiv.f32	s15, s16, s15
 80457e2:	ee17 0a90 	vmov	r0, s15
 80457e6:	f7fa fe8b 	bl	8040500 <__aeabi_f2d>
 80457ea:	ec41 0b10 	vmov	d0, r0, r1
 80457ee:	f007 f9d3 	bl	804cb98 <log>
 80457f2:	e9dd 0100 	ldrd	r0, r1, [sp]
 80457f6:	ec53 2b10 	vmov	r2, r3, d0
 80457fa:	f7fa fed9 	bl	80405b0 <__aeabi_dmul>
 80457fe:	4602      	mov	r2, r0
 8045800:	460b      	mov	r3, r1
 8045802:	4620      	mov	r0, r4
 8045804:	4629      	mov	r1, r5
 8045806:	f7fa fd1d 	bl	8040244 <__adddf3>
 804580a:	4604      	mov	r4, r0
 804580c:	460d      	mov	r5, r1
		for (i = 0; i < n; ++i) {
 804580e:	42b7      	cmp	r7, r6
 8045810:	db97      	blt.n	8045742 <kad_op_ce_bin+0xba>
		p->x[0] = (float)(cost / n);
 8045812:	4630      	mov	r0, r6
 8045814:	f7fa fe62 	bl	80404dc <__aeabi_i2d>
 8045818:	460b      	mov	r3, r1
 804581a:	4602      	mov	r2, r0
 804581c:	4629      	mov	r1, r5
 804581e:	4620      	mov	r0, r4
 8045820:	f7fa fff0 	bl	8040804 <__aeabi_ddiv>
 8045824:	f7fb f99c 	bl	8040b60 <__aeabi_d2f>
 8045828:	f8d9 3028 	ldr.w	r3, [r9, #40]	@ 0x28
 804582c:	6018      	str	r0, [r3, #0]
 804582e:	e74e      	b.n	80456ce <kad_op_ce_bin+0x46>
	for (i = 0; i < p->n_d; ++i) n *= p->d[i];
 8045830:	f898 2000 	ldrb.w	r2, [r8]
 8045834:	2a00      	cmp	r2, #0
 8045836:	f43f af6c 	beq.w	8045712 <kad_op_ce_bin+0x8a>
	int n = 1, i;
 804583a:	2601      	movs	r6, #1
 804583c:	e752      	b.n	80456e4 <kad_op_ce_bin+0x5c>
	} else if (action == KAD_BACKWARD && kad_is_back(y1)) {
 804583e:	f898 2001 	ldrb.w	r2, [r8, #1]
 8045842:	07d2      	lsls	r2, r2, #31
 8045844:	f57f af43 	bpl.w	80456ce <kad_op_ce_bin+0x46>
		float t = p->g[0] / n;
 8045848:	ee07 6a90 	vmov	s15, r6
 804584c:	f8d9 202c 	ldr.w	r2, [r9, #44]	@ 0x2c
 8045850:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8045854:	ed92 7a00 	vldr	s14, [r2]
		for (i = 0; i < n; ++i) {
 8045858:	2e00      	cmp	r6, #0
		float t = p->g[0] / n;
 804585a:	ee87 5a27 	vdiv.f32	s10, s14, s15
		for (i = 0; i < n; ++i) {
 804585e:	f77f af36 	ble.w	80456ce <kad_op_ce_bin+0x46>
			if (y0->x[i] > 0.0f)
 8045862:	2200      	movs	r2, #0
				y1->g[i] -= t * y0->x[i] / (y1->x[i] > tiny? y1->x[i] : tiny);
 8045864:	eddf 6a2a 	vldr	s13, [pc, #168]	@ 8045910 <kad_op_ce_bin+0x288>
			if (1.0f - y0->x[i] > 0.0f)
 8045868:	eef7 5a00 	vmov.f32	s11, #112	@ 0x3f800000  1.0
 804586c:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 804586e:	eb03 0686 	add.w	r6, r3, r6, lsl #2
			if (y0->x[i] > 0.0f)
 8045872:	ecf3 7a01 	vldmia	r3!, {s15}
 8045876:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 804587a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 804587e:	dd19      	ble.n	80458b4 <kad_op_ce_bin+0x22c>
				y1->g[i] -= t * y0->x[i] / (y1->x[i] > tiny? y1->x[i] : tiny);
 8045880:	f8d8 1028 	ldr.w	r1, [r8, #40]	@ 0x28
 8045884:	ee67 7a85 	vmul.f32	s15, s15, s10
 8045888:	4411      	add	r1, r2
 804588a:	ed91 7a00 	vldr	s14, [r1]
 804588e:	eeb4 7ae6 	vcmpe.f32	s14, s13
 8045892:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8045896:	f8d8 102c 	ldr.w	r1, [r8, #44]	@ 0x2c
 804589a:	fe37 7a26 	vselgt.f32	s14, s14, s13
 804589e:	4411      	add	r1, r2
 80458a0:	ed91 6a00 	vldr	s12, [r1]
 80458a4:	eec7 4a87 	vdiv.f32	s9, s15, s14
 80458a8:	ee76 7a64 	vsub.f32	s15, s12, s9
 80458ac:	edc1 7a00 	vstr	s15, [r1]
			if (1.0f - y0->x[i] > 0.0f)
 80458b0:	ed53 7a01 	vldr	s15, [r3, #-4]
 80458b4:	ee75 7ae7 	vsub.f32	s15, s11, s15
 80458b8:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 80458bc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80458c0:	dd19      	ble.n	80458f6 <kad_op_ce_bin+0x26e>
				y1->g[i] += t * (1.0f - y0->x[i]) / (1.0f - y1->x[i] > tiny? 1.0f - y1->x[i] : tiny);
 80458c2:	f8d8 1028 	ldr.w	r1, [r8, #40]	@ 0x28
 80458c6:	ee67 7a85 	vmul.f32	s15, s15, s10
 80458ca:	4411      	add	r1, r2
 80458cc:	ed91 7a00 	vldr	s14, [r1]
 80458d0:	ee35 7ac7 	vsub.f32	s14, s11, s14
 80458d4:	eeb4 7ae6 	vcmpe.f32	s14, s13
 80458d8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80458dc:	f8d8 102c 	ldr.w	r1, [r8, #44]	@ 0x2c
 80458e0:	fe37 7a26 	vselgt.f32	s14, s14, s13
 80458e4:	4411      	add	r1, r2
 80458e6:	edd1 4a00 	vldr	s9, [r1]
 80458ea:	ee87 6a87 	vdiv.f32	s12, s15, s14
 80458ee:	ee76 7a24 	vadd.f32	s15, s12, s9
 80458f2:	edc1 7a00 	vstr	s15, [r1]
		for (i = 0; i < n; ++i) {
 80458f6:	42b3      	cmp	r3, r6
 80458f8:	f102 0204 	add.w	r2, r2, #4
 80458fc:	d1b9      	bne.n	8045872 <kad_op_ce_bin+0x1ea>
 80458fe:	e6e6      	b.n	80456ce <kad_op_ce_bin+0x46>
 8045900:	2301      	movs	r3, #1
 8045902:	e703      	b.n	804570c <kad_op_ce_bin+0x84>
		double cost = 0.0;
 8045904:	2400      	movs	r4, #0
 8045906:	2500      	movs	r5, #0
 8045908:	e783      	b.n	8045812 <kad_op_ce_bin+0x18a>
		if (n != kad_len(y1)) return -1;
 804590a:	f04f 30ff 	mov.w	r0, #4294967295
 804590e:	e6df      	b.n	80456d0 <kad_op_ce_bin+0x48>
 8045910:	3089705f 	.word	0x3089705f

08045914 <kad_op_ce_bin_neg>:
{
 8045914:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8045918:	ed2d 8b06 	vpush	{d8-d10}
	kad_node_t *y1 = p->child[0]; /* test */
 804591c:	6b82      	ldr	r2, [r0, #56]	@ 0x38
{
 804591e:	4681      	mov	r9, r0
	kad_node_t *y1 = p->child[0]; /* test */
 8045920:	e9d2 8300 	ldrd	r8, r3, [r2]
	for (i = 0; i < p->n_d; ++i) n *= p->d[i];
 8045924:	781a      	ldrb	r2, [r3, #0]
{
 8045926:	b083      	sub	sp, #12
 8045928:	2a00      	cmp	r2, #0
 804592a:	d03c      	beq.n	80459a6 <kad_op_ce_bin_neg+0x92>
 804592c:	2a01      	cmp	r2, #1
 804592e:	691e      	ldr	r6, [r3, #16]
 8045930:	d00c      	beq.n	804594c <kad_op_ce_bin_neg+0x38>
 8045932:	6958      	ldr	r0, [r3, #20]
 8045934:	2a02      	cmp	r2, #2
 8045936:	fb00 f606 	mul.w	r6, r0, r6
 804593a:	d007      	beq.n	804594c <kad_op_ce_bin_neg+0x38>
 804593c:	6998      	ldr	r0, [r3, #24]
 804593e:	2a03      	cmp	r2, #3
 8045940:	fb00 f606 	mul.w	r6, r0, r6
 8045944:	d002      	beq.n	804594c <kad_op_ce_bin_neg+0x38>
 8045946:	69da      	ldr	r2, [r3, #28]
 8045948:	fb02 f606 	mul.w	r6, r2, r6
	if (action == KAD_SYNC_DIM) {
 804594c:	2904      	cmp	r1, #4
 804594e:	d00a      	beq.n	8045966 <kad_op_ce_bin_neg+0x52>
	} else if (action == KAD_FORWARD) {
 8045950:	2902      	cmp	r1, #2
 8045952:	d030      	beq.n	80459b6 <kad_op_ce_bin_neg+0xa2>
	} else if (action == KAD_BACKWARD && kad_is_back(y1)) {
 8045954:	2903      	cmp	r1, #3
 8045956:	f000 80c2 	beq.w	8045ade <kad_op_ce_bin_neg+0x1ca>
	return 0;
 804595a:	2000      	movs	r0, #0
}
 804595c:	b003      	add	sp, #12
 804595e:	ecbd 8b06 	vpop	{d8-d10}
 8045962:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8045966:	f898 2000 	ldrb.w	r2, [r8]
 804596a:	2a00      	cmp	r2, #0
 804596c:	f000 8122 	beq.w	8045bb4 <kad_op_ce_bin_neg+0x2a0>
 8045970:	2a01      	cmp	r2, #1
 8045972:	f8d8 3010 	ldr.w	r3, [r8, #16]
 8045976:	d00f      	beq.n	8045998 <kad_op_ce_bin_neg+0x84>
 8045978:	f8d8 1014 	ldr.w	r1, [r8, #20]
 804597c:	2a02      	cmp	r2, #2
 804597e:	fb01 f303 	mul.w	r3, r1, r3
 8045982:	d009      	beq.n	8045998 <kad_op_ce_bin_neg+0x84>
 8045984:	f8d8 1018 	ldr.w	r1, [r8, #24]
 8045988:	2a03      	cmp	r2, #3
 804598a:	fb01 f303 	mul.w	r3, r1, r3
 804598e:	d003      	beq.n	8045998 <kad_op_ce_bin_neg+0x84>
 8045990:	f8d8 201c 	ldr.w	r2, [r8, #28]
 8045994:	fb02 f303 	mul.w	r3, r2, r3
		if (n != kad_len(y1)) return -1;
 8045998:	429e      	cmp	r6, r3
 804599a:	f040 8110 	bne.w	8045bbe <kad_op_ce_bin_neg+0x2aa>
		p->n_d = 0;
 804599e:	2300      	movs	r3, #0
 80459a0:	f889 3000 	strb.w	r3, [r9]
 80459a4:	e7d9      	b.n	804595a <kad_op_ce_bin_neg+0x46>
	if (action == KAD_SYNC_DIM) {
 80459a6:	2904      	cmp	r1, #4
 80459a8:	f000 8092 	beq.w	8045ad0 <kad_op_ce_bin_neg+0x1bc>
	} else if (action == KAD_FORWARD) {
 80459ac:	2902      	cmp	r1, #2
	int n = 1, i;
 80459ae:	f04f 0601 	mov.w	r6, #1
 80459b2:	d1cf      	bne.n	8045954 <kad_op_ce_bin_neg+0x40>
 80459b4:	e002      	b.n	80459bc <kad_op_ce_bin_neg+0xa8>
		for (i = 0; i < n; ++i) {
 80459b6:	2e00      	cmp	r6, #0
 80459b8:	f340 80fe 	ble.w	8045bb8 <kad_op_ce_bin_neg+0x2a4>
			if (1.0f + y0->x[i] > 0.0f)
 80459bc:	eef7 8a00 	vmov.f32	s17, #112	@ 0x3f800000  1.0
				cost += .5f * (1.0f + y0->x[i]) * log((1.0f + y0->x[i]) / (1.0f + y1->x[i] > tiny? 1.0f + y1->x[i] : tiny));
 80459c0:	eeb6 aa00 	vmov.f32	s20, #96	@ 0x3f000000  0.5
 80459c4:	eddf 9a7f 	vldr	s19, [pc, #508]	@ 8045bc4 <kad_op_ce_bin_neg+0x2b0>
		double cost = 0.0;
 80459c8:	2400      	movs	r4, #0
 80459ca:	2500      	movs	r5, #0
		for (i = 0; i < n; ++i) {
 80459cc:	2700      	movs	r7, #0
 80459ce:	f8d3 b028 	ldr.w	fp, [r3, #40]	@ 0x28
			if (1.0f + y0->x[i] > 0.0f)
 80459d2:	ecbb 8a01 	vldmia	fp!, {s16}
 80459d6:	ee38 9a28 	vadd.f32	s18, s16, s17
 80459da:	eeb5 9ac0 	vcmpe.f32	s18, #0.0
 80459de:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80459e2:	ea4f 0a87 	mov.w	sl, r7, lsl #2
		for (i = 0; i < n; ++i) {
 80459e6:	f107 0701 	add.w	r7, r7, #1
			if (1.0f + y0->x[i] > 0.0f)
 80459ea:	dd2c      	ble.n	8045a46 <kad_op_ce_bin_neg+0x132>
				cost += .5f * (1.0f + y0->x[i]) * log((1.0f + y0->x[i]) / (1.0f + y1->x[i] > tiny? 1.0f + y1->x[i] : tiny));
 80459ec:	ee69 7a0a 	vmul.f32	s15, s18, s20
 80459f0:	ee17 0a90 	vmov	r0, s15
 80459f4:	f7fa fd84 	bl	8040500 <__aeabi_f2d>
 80459f8:	f8d8 3028 	ldr.w	r3, [r8, #40]	@ 0x28
 80459fc:	e9cd 0100 	strd	r0, r1, [sp]
 8045a00:	4453      	add	r3, sl
 8045a02:	edd3 7a00 	vldr	s15, [r3]
 8045a06:	ee77 7aa8 	vadd.f32	s15, s15, s17
 8045a0a:	eef4 7ae9 	vcmpe.f32	s15, s19
 8045a0e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8045a12:	fe77 7aa9 	vselgt.f32	s15, s15, s19
 8045a16:	eec9 7a27 	vdiv.f32	s15, s18, s15
 8045a1a:	ee17 0a90 	vmov	r0, s15
 8045a1e:	f7fa fd6f 	bl	8040500 <__aeabi_f2d>
 8045a22:	ec41 0b10 	vmov	d0, r0, r1
 8045a26:	f007 f8b7 	bl	804cb98 <log>
 8045a2a:	e9dd 0100 	ldrd	r0, r1, [sp]
 8045a2e:	ec53 2b10 	vmov	r2, r3, d0
 8045a32:	f7fa fdbd 	bl	80405b0 <__aeabi_dmul>
 8045a36:	4602      	mov	r2, r0
 8045a38:	460b      	mov	r3, r1
 8045a3a:	4620      	mov	r0, r4
 8045a3c:	4629      	mov	r1, r5
 8045a3e:	f7fa fc01 	bl	8040244 <__adddf3>
 8045a42:	4604      	mov	r4, r0
 8045a44:	460d      	mov	r5, r1
			if (1.0f - y0->x[i] > 0.0f)
 8045a46:	ee38 8ac8 	vsub.f32	s16, s17, s16
 8045a4a:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
 8045a4e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8045a52:	dd2c      	ble.n	8045aae <kad_op_ce_bin_neg+0x19a>
				cost += .5f * (1.0f - y0->x[i]) * log((1.0f - y0->x[i]) / (1.0f - y1->x[i] > tiny? 1.0f - y1->x[i] : tiny));
 8045a54:	ee68 7a0a 	vmul.f32	s15, s16, s20
 8045a58:	ee17 0a90 	vmov	r0, s15
 8045a5c:	f7fa fd50 	bl	8040500 <__aeabi_f2d>
 8045a60:	f8d8 3028 	ldr.w	r3, [r8, #40]	@ 0x28
 8045a64:	e9cd 0100 	strd	r0, r1, [sp]
 8045a68:	4453      	add	r3, sl
 8045a6a:	edd3 7a00 	vldr	s15, [r3]
 8045a6e:	ee78 7ae7 	vsub.f32	s15, s17, s15
 8045a72:	eef4 7ae9 	vcmpe.f32	s15, s19
 8045a76:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8045a7a:	fe77 7aa9 	vselgt.f32	s15, s15, s19
 8045a7e:	eec8 7a27 	vdiv.f32	s15, s16, s15
 8045a82:	ee17 0a90 	vmov	r0, s15
 8045a86:	f7fa fd3b 	bl	8040500 <__aeabi_f2d>
 8045a8a:	ec41 0b10 	vmov	d0, r0, r1
 8045a8e:	f007 f883 	bl	804cb98 <log>
 8045a92:	e9dd 0100 	ldrd	r0, r1, [sp]
 8045a96:	ec53 2b10 	vmov	r2, r3, d0
 8045a9a:	f7fa fd89 	bl	80405b0 <__aeabi_dmul>
 8045a9e:	4602      	mov	r2, r0
 8045aa0:	460b      	mov	r3, r1
 8045aa2:	4620      	mov	r0, r4
 8045aa4:	4629      	mov	r1, r5
 8045aa6:	f7fa fbcd 	bl	8040244 <__adddf3>
 8045aaa:	4604      	mov	r4, r0
 8045aac:	460d      	mov	r5, r1
		for (i = 0; i < n; ++i) {
 8045aae:	42b7      	cmp	r7, r6
 8045ab0:	db8f      	blt.n	80459d2 <kad_op_ce_bin_neg+0xbe>
		p->x[0] = (float)(cost / n);
 8045ab2:	4630      	mov	r0, r6
 8045ab4:	f7fa fd12 	bl	80404dc <__aeabi_i2d>
 8045ab8:	460b      	mov	r3, r1
 8045aba:	4602      	mov	r2, r0
 8045abc:	4629      	mov	r1, r5
 8045abe:	4620      	mov	r0, r4
 8045ac0:	f7fa fea0 	bl	8040804 <__aeabi_ddiv>
 8045ac4:	f7fb f84c 	bl	8040b60 <__aeabi_d2f>
 8045ac8:	f8d9 3028 	ldr.w	r3, [r9, #40]	@ 0x28
 8045acc:	6018      	str	r0, [r3, #0]
 8045ace:	e744      	b.n	804595a <kad_op_ce_bin_neg+0x46>
	for (i = 0; i < p->n_d; ++i) n *= p->d[i];
 8045ad0:	f898 2000 	ldrb.w	r2, [r8]
 8045ad4:	2a00      	cmp	r2, #0
 8045ad6:	f43f af62 	beq.w	804599e <kad_op_ce_bin_neg+0x8a>
	int n = 1, i;
 8045ada:	2601      	movs	r6, #1
 8045adc:	e748      	b.n	8045970 <kad_op_ce_bin_neg+0x5c>
	} else if (action == KAD_BACKWARD && kad_is_back(y1)) {
 8045ade:	f898 2001 	ldrb.w	r2, [r8, #1]
 8045ae2:	07d2      	lsls	r2, r2, #31
 8045ae4:	f57f af39 	bpl.w	804595a <kad_op_ce_bin_neg+0x46>
		float t = p->g[0] / n;
 8045ae8:	ee07 6a90 	vmov	s15, r6
 8045aec:	f8d9 202c 	ldr.w	r2, [r9, #44]	@ 0x2c
 8045af0:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8045af4:	ed92 7a00 	vldr	s14, [r2]
		for (i = 0; i < n; ++i) {
 8045af8:	2e00      	cmp	r6, #0
		float t = p->g[0] / n;
 8045afa:	eec7 4a27 	vdiv.f32	s9, s14, s15
		for (i = 0; i < n; ++i) {
 8045afe:	f77f af2c 	ble.w	804595a <kad_op_ce_bin_neg+0x46>
			if (1.0f + y0->x[i] > 0.0f)
 8045b02:	2200      	movs	r2, #0
 8045b04:	eeb7 6a00 	vmov.f32	s12, #112	@ 0x3f800000  1.0
				y1->g[i] -= .5f * t * (1.0f + y0->x[i]) / (1.0f + y1->x[i] > tiny? 1.0f + y1->x[i] : tiny);
 8045b08:	eeb6 4a00 	vmov.f32	s8, #96	@ 0x3f000000  0.5
 8045b0c:	eddf 5a2d 	vldr	s11, [pc, #180]	@ 8045bc4 <kad_op_ce_bin_neg+0x2b0>
 8045b10:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8045b12:	eb03 0686 	add.w	r6, r3, r6, lsl #2
			if (1.0f + y0->x[i] > 0.0f)
 8045b16:	ecf3 7a01 	vldmia	r3!, {s15}
 8045b1a:	ee77 6a86 	vadd.f32	s13, s15, s12
 8045b1e:	eef5 6ac0 	vcmpe.f32	s13, #0.0
 8045b22:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8045b26:	dd1d      	ble.n	8045b64 <kad_op_ce_bin_neg+0x250>
				y1->g[i] -= .5f * t * (1.0f + y0->x[i]) / (1.0f + y1->x[i] > tiny? 1.0f + y1->x[i] : tiny);
 8045b28:	f8d8 1028 	ldr.w	r1, [r8, #40]	@ 0x28
 8045b2c:	ee24 7a84 	vmul.f32	s14, s9, s8
 8045b30:	4411      	add	r1, r2
 8045b32:	edd1 7a00 	vldr	s15, [r1]
 8045b36:	ee77 7a86 	vadd.f32	s15, s15, s12
 8045b3a:	eef4 7ae5 	vcmpe.f32	s15, s11
 8045b3e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8045b42:	ee27 7a26 	vmul.f32	s14, s14, s13
 8045b46:	f8d8 102c 	ldr.w	r1, [r8, #44]	@ 0x2c
 8045b4a:	fe77 7aa5 	vselgt.f32	s15, s15, s11
 8045b4e:	4411      	add	r1, r2
 8045b50:	ed91 5a00 	vldr	s10, [r1]
 8045b54:	eec7 6a27 	vdiv.f32	s13, s14, s15
 8045b58:	ee75 7a66 	vsub.f32	s15, s10, s13
 8045b5c:	edc1 7a00 	vstr	s15, [r1]
			if (1.0f - y0->x[i] > 0.0f)
 8045b60:	ed53 7a01 	vldr	s15, [r3, #-4]
 8045b64:	ee76 7a67 	vsub.f32	s15, s12, s15
 8045b68:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8045b6c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8045b70:	dd1b      	ble.n	8045baa <kad_op_ce_bin_neg+0x296>
				y1->g[i] += .5f * t * (1.0f - y0->x[i]) / (1.0f - y1->x[i] > tiny? 1.0f - y1->x[i] : tiny);
 8045b72:	f8d8 1028 	ldr.w	r1, [r8, #40]	@ 0x28
 8045b76:	ee64 6a84 	vmul.f32	s13, s9, s8
 8045b7a:	4411      	add	r1, r2
 8045b7c:	ed91 7a00 	vldr	s14, [r1]
 8045b80:	ee66 6aa7 	vmul.f32	s13, s13, s15
 8045b84:	ee76 7a47 	vsub.f32	s15, s12, s14
 8045b88:	eef4 7ae5 	vcmpe.f32	s15, s11
 8045b8c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8045b90:	f8d8 102c 	ldr.w	r1, [r8, #44]	@ 0x2c
 8045b94:	fe77 7aa5 	vselgt.f32	s15, s15, s11
 8045b98:	4411      	add	r1, r2
 8045b9a:	ed91 5a00 	vldr	s10, [r1]
 8045b9e:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 8045ba2:	ee77 7a05 	vadd.f32	s15, s14, s10
 8045ba6:	edc1 7a00 	vstr	s15, [r1]
		for (i = 0; i < n; ++i) {
 8045baa:	42b3      	cmp	r3, r6
 8045bac:	f102 0204 	add.w	r2, r2, #4
 8045bb0:	d1b1      	bne.n	8045b16 <kad_op_ce_bin_neg+0x202>
 8045bb2:	e6d2      	b.n	804595a <kad_op_ce_bin_neg+0x46>
 8045bb4:	2301      	movs	r3, #1
 8045bb6:	e6ef      	b.n	8045998 <kad_op_ce_bin_neg+0x84>
		double cost = 0.0;
 8045bb8:	2400      	movs	r4, #0
 8045bba:	2500      	movs	r5, #0
 8045bbc:	e779      	b.n	8045ab2 <kad_op_ce_bin_neg+0x19e>
		if (n != kad_len(y1)) return -1;
 8045bbe:	f04f 30ff 	mov.w	r0, #4294967295
 8045bc2:	e6cb      	b.n	804595c <kad_op_ce_bin_neg+0x48>
 8045bc4:	3089705f 	.word	0x3089705f

08045bc8 <kad_op_ce_multi>:
{
 8045bc8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8045bcc:	ed2d 8b02 	vpush	{d8}
	kad_node_t *y1 = p->child[0]; /* test */
 8045bd0:	6b87      	ldr	r7, [r0, #56]	@ 0x38
{
 8045bd2:	b08b      	sub	sp, #44	@ 0x2c
	kad_node_t *y1 = p->child[0]; /* test */
 8045bd4:	e9d7 5200 	ldrd	r5, r2, [r7]
{
 8045bd8:	9002      	str	r0, [sp, #8]
	n1 = y0->d[y0->n_d - 1];
 8045bda:	7810      	ldrb	r0, [r2, #0]
 8045bdc:	1cc3      	adds	r3, r0, #3
 8045bde:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
	for (i = 0; i < p->n_d; ++i) n *= p->d[i];
 8045be2:	2800      	cmp	r0, #0
 8045be4:	f000 80ea 	beq.w	8045dbc <kad_op_ce_multi+0x1f4>
 8045be8:	2801      	cmp	r0, #1
 8045bea:	6914      	ldr	r4, [r2, #16]
 8045bec:	d00c      	beq.n	8045c08 <kad_op_ce_multi+0x40>
 8045bee:	6956      	ldr	r6, [r2, #20]
 8045bf0:	2802      	cmp	r0, #2
 8045bf2:	fb06 f404 	mul.w	r4, r6, r4
 8045bf6:	d007      	beq.n	8045c08 <kad_op_ce_multi+0x40>
 8045bf8:	6996      	ldr	r6, [r2, #24]
 8045bfa:	2803      	cmp	r0, #3
 8045bfc:	fb06 f404 	mul.w	r4, r6, r4
 8045c00:	d002      	beq.n	8045c08 <kad_op_ce_multi+0x40>
 8045c02:	69d6      	ldr	r6, [r2, #28]
 8045c04:	fb06 f404 	mul.w	r4, r6, r4
	d0 = kad_len(y0) / n1;
 8045c08:	fb94 fcf3 	sdiv	ip, r4, r3
	if (p->n_child == 3) {
 8045c0c:	9c02      	ldr	r4, [sp, #8]
 8045c0e:	6864      	ldr	r4, [r4, #4]
 8045c10:	2c03      	cmp	r4, #3
 8045c12:	d043      	beq.n	8045c9c <kad_op_ce_multi+0xd4>
	if (action == KAD_SYNC_DIM) {
 8045c14:	2904      	cmp	r1, #4
 8045c16:	d00d      	beq.n	8045c34 <kad_op_ce_multi+0x6c>
	} else if (action == KAD_FORWARD) {
 8045c18:	2902      	cmp	r1, #2
 8045c1a:	f000 811f 	beq.w	8045e5c <kad_op_ce_multi+0x294>
	kad_node_t *c = 0;
 8045c1e:	f04f 0900 	mov.w	r9, #0
	} else if (action == KAD_BACKWARD && kad_is_back(y1)) {
 8045c22:	2903      	cmp	r1, #3
 8045c24:	f000 80cc 	beq.w	8045dc0 <kad_op_ce_multi+0x1f8>
	return 0;
 8045c28:	2000      	movs	r0, #0
}
 8045c2a:	b00b      	add	sp, #44	@ 0x2c
 8045c2c:	ecbd 8b02 	vpop	{d8}
 8045c30:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8045c34:	7829      	ldrb	r1, [r5, #0]
 8045c36:	2800      	cmp	r0, #0
 8045c38:	f000 8172 	beq.w	8045f20 <kad_op_ce_multi+0x358>
 8045c3c:	2801      	cmp	r0, #1
 8045c3e:	6914      	ldr	r4, [r2, #16]
 8045c40:	d00c      	beq.n	8045c5c <kad_op_ce_multi+0x94>
 8045c42:	6956      	ldr	r6, [r2, #20]
 8045c44:	2802      	cmp	r0, #2
 8045c46:	fb06 f404 	mul.w	r4, r6, r4
 8045c4a:	d007      	beq.n	8045c5c <kad_op_ce_multi+0x94>
 8045c4c:	6996      	ldr	r6, [r2, #24]
 8045c4e:	2803      	cmp	r0, #3
 8045c50:	fb06 f404 	mul.w	r4, r6, r4
 8045c54:	d002      	beq.n	8045c5c <kad_op_ce_multi+0x94>
 8045c56:	69d2      	ldr	r2, [r2, #28]
 8045c58:	fb02 f404 	mul.w	r4, r2, r4
 8045c5c:	2900      	cmp	r1, #0
 8045c5e:	f000 8164 	beq.w	8045f2a <kad_op_ce_multi+0x362>
 8045c62:	2901      	cmp	r1, #1
 8045c64:	692a      	ldr	r2, [r5, #16]
 8045c66:	dd0c      	ble.n	8045c82 <kad_op_ce_multi+0xba>
 8045c68:	6968      	ldr	r0, [r5, #20]
 8045c6a:	2902      	cmp	r1, #2
 8045c6c:	fb00 f202 	mul.w	r2, r0, r2
 8045c70:	d007      	beq.n	8045c82 <kad_op_ce_multi+0xba>
 8045c72:	69a8      	ldr	r0, [r5, #24]
 8045c74:	2903      	cmp	r1, #3
 8045c76:	fb00 f202 	mul.w	r2, r0, r2
 8045c7a:	d002      	beq.n	8045c82 <kad_op_ce_multi+0xba>
 8045c7c:	69e8      	ldr	r0, [r5, #28]
 8045c7e:	fb00 f202 	mul.w	r2, r0, r2
		if (kad_len(y0) != kad_len(y1) || y0->d[y0->n_d - 1] != y1->d[y1->n_d - 1]) return -1;
 8045c82:	4294      	cmp	r4, r2
 8045c84:	f040 818b 	bne.w	8045f9e <kad_op_ce_multi+0x3d6>
 8045c88:	3103      	adds	r1, #3
 8045c8a:	f855 2021 	ldr.w	r2, [r5, r1, lsl #2]
 8045c8e:	429a      	cmp	r2, r3
 8045c90:	f040 8185 	bne.w	8045f9e <kad_op_ce_multi+0x3d6>
		p->n_d = 0;
 8045c94:	2300      	movs	r3, #0
 8045c96:	9a02      	ldr	r2, [sp, #8]
 8045c98:	7013      	strb	r3, [r2, #0]
 8045c9a:	e7c5      	b.n	8045c28 <kad_op_ce_multi+0x60>
		c = p->child[2];
 8045c9c:	f8d7 9008 	ldr.w	r9, [r7, #8]
		assert(c->n_d == 1 && c->d[0] == n1);
 8045ca0:	f899 4000 	ldrb.w	r4, [r9]
 8045ca4:	2c01      	cmp	r4, #1
 8045ca6:	f040 817d 	bne.w	8045fa4 <kad_op_ce_multi+0x3dc>
 8045caa:	f8d9 4010 	ldr.w	r4, [r9, #16]
 8045cae:	429c      	cmp	r4, r3
 8045cb0:	f040 8178 	bne.w	8045fa4 <kad_op_ce_multi+0x3dc>
	if (action == KAD_SYNC_DIM) {
 8045cb4:	2904      	cmp	r1, #4
 8045cb6:	d0bd      	beq.n	8045c34 <kad_op_ce_multi+0x6c>
	} else if (action == KAD_FORWARD) {
 8045cb8:	2902      	cmp	r1, #2
 8045cba:	d1b2      	bne.n	8045c22 <kad_op_ce_multi+0x5a>
			for (j = 0; j < d0; ++j) {
 8045cbc:	f1bc 0f00 	cmp.w	ip, #0
 8045cc0:	f340 8135 	ble.w	8045f2e <kad_op_ce_multi+0x366>
				float *x1 = &y1->x[j * n1], *x0 = &y0->x[j * n1];
 8045cc4:	2600      	movs	r6, #0
			for (j = 0; j < d0; ++j) {
 8045cc6:	e9cd c306 	strd	ip, r3, [sp, #24]
						cost += c->x[i] * x0[i] * log(x0[i] / (x1[i] > tiny? x1[i] : tiny));
 8045cca:	eddf 8aba 	vldr	s17, [pc, #744]	@ 8045fb4 <kad_op_ce_multi+0x3ec>
		double cost = 0.0;
 8045cce:	f04f 0a00 	mov.w	sl, #0
 8045cd2:	f04f 0b00 	mov.w	fp, #0
			for (j = 0; j < d0; ++j) {
 8045cd6:	46b4      	mov	ip, r6
 8045cd8:	6a91      	ldr	r1, [r2, #40]	@ 0x28
				float *x1 = &y1->x[j * n1], *x0 = &y0->x[j * n1];
 8045cda:	6aaa      	ldr	r2, [r5, #40]	@ 0x28
 8045cdc:	009f      	lsls	r7, r3, #2
 8045cde:	9208      	str	r2, [sp, #32]
 8045ce0:	eb01 0883 	add.w	r8, r1, r3, lsl #2
 8045ce4:	f1c1 0e00 	rsb	lr, r1, #0
			for (j = 0; j < d0; ++j) {
 8045ce8:	9109      	str	r1, [sp, #36]	@ 0x24
				for (i = 0; i < n1; ++i)
 8045cea:	9b07      	ldr	r3, [sp, #28]
 8045cec:	2b00      	cmp	r3, #0
 8045cee:	dd4c      	ble.n	8045d8a <kad_op_ce_multi+0x1c2>
 8045cf0:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8045cf2:	e9cd 7604 	strd	r7, r6, [sp, #16]
 8045cf6:	199c      	adds	r4, r3, r6
 8045cf8:	9b08      	ldr	r3, [sp, #32]
 8045cfa:	f8cd c00c 	str.w	ip, [sp, #12]
 8045cfe:	199d      	adds	r5, r3, r6
 8045d00:	f8cd e004 	str.w	lr, [sp, #4]
					if (x0[i] > 0.0f)
 8045d04:	ed94 8a00 	vldr	s16, [r4]
 8045d08:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
 8045d0c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8045d10:	4622      	mov	r2, r4
 8045d12:	f104 0404 	add.w	r4, r4, #4
 8045d16:	dd2e      	ble.n	8045d76 <kad_op_ce_multi+0x1ae>
						cost += c->x[i] * x0[i] * log(x0[i] / (x1[i] > tiny? x1[i] : tiny));
 8045d18:	9901      	ldr	r1, [sp, #4]
 8045d1a:	f8d9 3028 	ldr.w	r3, [r9, #40]	@ 0x28
 8045d1e:	440b      	add	r3, r1
 8045d20:	4413      	add	r3, r2
 8045d22:	edd3 7a00 	vldr	s15, [r3]
 8045d26:	ee68 7a27 	vmul.f32	s15, s16, s15
 8045d2a:	ee17 0a90 	vmov	r0, s15
 8045d2e:	f7fa fbe7 	bl	8040500 <__aeabi_f2d>
 8045d32:	edd5 7a00 	vldr	s15, [r5]
 8045d36:	eef4 7ae8 	vcmpe.f32	s15, s17
 8045d3a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8045d3e:	fe77 7aa8 	vselgt.f32	s15, s15, s17
 8045d42:	eec8 7a27 	vdiv.f32	s15, s16, s15
 8045d46:	4606      	mov	r6, r0
 8045d48:	ee17 0a90 	vmov	r0, s15
 8045d4c:	460f      	mov	r7, r1
 8045d4e:	f7fa fbd7 	bl	8040500 <__aeabi_f2d>
 8045d52:	ec41 0b10 	vmov	d0, r0, r1
 8045d56:	f006 ff1f 	bl	804cb98 <log>
 8045d5a:	4630      	mov	r0, r6
 8045d5c:	ec53 2b10 	vmov	r2, r3, d0
 8045d60:	4639      	mov	r1, r7
 8045d62:	f7fa fc25 	bl	80405b0 <__aeabi_dmul>
 8045d66:	4602      	mov	r2, r0
 8045d68:	460b      	mov	r3, r1
 8045d6a:	4650      	mov	r0, sl
 8045d6c:	4659      	mov	r1, fp
 8045d6e:	f7fa fa69 	bl	8040244 <__adddf3>
 8045d72:	4682      	mov	sl, r0
 8045d74:	468b      	mov	fp, r1
				for (i = 0; i < n1; ++i)
 8045d76:	45a0      	cmp	r8, r4
 8045d78:	f105 0504 	add.w	r5, r5, #4
 8045d7c:	d1c2      	bne.n	8045d04 <kad_op_ce_multi+0x13c>
 8045d7e:	e9dd 7604 	ldrd	r7, r6, [sp, #16]
 8045d82:	f8dd c00c 	ldr.w	ip, [sp, #12]
 8045d86:	f8dd e004 	ldr.w	lr, [sp, #4]
			for (j = 0; j < d0; ++j) {
 8045d8a:	9b06      	ldr	r3, [sp, #24]
 8045d8c:	f10c 0c01 	add.w	ip, ip, #1
 8045d90:	4563      	cmp	r3, ip
 8045d92:	44b8      	add	r8, r7
 8045d94:	ebae 0e07 	sub.w	lr, lr, r7
 8045d98:	443e      	add	r6, r7
 8045d9a:	d1a6      	bne.n	8045cea <kad_op_ce_multi+0x122>
 8045d9c:	469c      	mov	ip, r3
		p->x[0] = (float)(cost / d0);
 8045d9e:	4660      	mov	r0, ip
 8045da0:	f7fa fb9c 	bl	80404dc <__aeabi_i2d>
 8045da4:	460b      	mov	r3, r1
 8045da6:	4602      	mov	r2, r0
 8045da8:	4659      	mov	r1, fp
 8045daa:	4650      	mov	r0, sl
 8045dac:	f7fa fd2a 	bl	8040804 <__aeabi_ddiv>
 8045db0:	f7fa fed6 	bl	8040b60 <__aeabi_d2f>
 8045db4:	9b02      	ldr	r3, [sp, #8]
 8045db6:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8045db8:	6018      	str	r0, [r3, #0]
 8045dba:	e735      	b.n	8045c28 <kad_op_ce_multi+0x60>
	int n = 1, i;
 8045dbc:	2401      	movs	r4, #1
 8045dbe:	e723      	b.n	8045c08 <kad_op_ce_multi+0x40>
	} else if (action == KAD_BACKWARD && kad_is_back(y1)) {
 8045dc0:	7869      	ldrb	r1, [r5, #1]
 8045dc2:	07c9      	lsls	r1, r1, #31
 8045dc4:	f57f af30 	bpl.w	8045c28 <kad_op_ce_multi+0x60>
		float t = p->g[0] / d0;
 8045dc8:	ee07 ca90 	vmov	s15, ip
 8045dcc:	9902      	ldr	r1, [sp, #8]
 8045dce:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8045dd2:	6ac9      	ldr	r1, [r1, #44]	@ 0x2c
 8045dd4:	ed91 7a00 	vldr	s14, [r1]
 8045dd8:	ee87 5a27 	vdiv.f32	s10, s14, s15
		if (c == 0) {
 8045ddc:	f1b9 0f00 	cmp.w	r9, #0
 8045de0:	f000 80aa 	beq.w	8045f38 <kad_op_ce_multi+0x370>
			for (j = 0; j < d0; ++j) {
 8045de4:	f1bc 0f00 	cmp.w	ip, #0
 8045de8:	f77f af1e 	ble.w	8045c28 <kad_op_ce_multi+0x60>
				float *g = &y1->g[j * n1], *x1 = &y1->x[j * n1], *x0 = &y0->x[j * n1];
 8045dec:	e9d5 8e0a 	ldrd	r8, lr, [r5, #40]	@ 0x28
 8045df0:	2b00      	cmp	r3, #0
 8045df2:	f8d2 a028 	ldr.w	sl, [r2, #40]	@ 0x28
 8045df6:	f77f af17 	ble.w	8045c28 <kad_op_ce_multi+0x60>
					g[i] -= t * c->x[i] * x0[i] / (x1[i] > tiny? x1[i] : tiny);
 8045dfa:	2600      	movs	r6, #0
 8045dfc:	ed9f 6a6d 	vldr	s12, [pc, #436]	@ 8045fb4 <kad_op_ce_multi+0x3ec>
			for (j = 0; j < d0; ++j) {
 8045e00:	4637      	mov	r7, r6
 8045e02:	f8d9 b028 	ldr.w	fp, [r9, #40]	@ 0x28
 8045e06:	eb0e 0583 	add.w	r5, lr, r3, lsl #2
 8045e0a:	ea4f 0983 	mov.w	r9, r3, lsl #2
 8045e0e:	465c      	mov	r4, fp
 8045e10:	eb0e 0286 	add.w	r2, lr, r6, lsl #2
 8045e14:	eb0a 0086 	add.w	r0, sl, r6, lsl #2
 8045e18:	eb08 0186 	add.w	r1, r8, r6, lsl #2
					g[i] -= t * c->x[i] * x0[i] / (x1[i] > tiny? x1[i] : tiny);
 8045e1c:	ecb1 7a01 	vldmia	r1!, {s14}
 8045e20:	ecf4 7a01 	vldmia	r4!, {s15}
 8045e24:	eeb4 7ac6 	vcmpe.f32	s14, s12
 8045e28:	ecf0 5a01 	vldmia	r0!, {s11}
 8045e2c:	ee65 7a27 	vmul.f32	s15, s10, s15
 8045e30:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8045e34:	ee67 7aa5 	vmul.f32	s15, s15, s11
 8045e38:	fe37 7a06 	vselgt.f32	s14, s14, s12
 8045e3c:	ecf2 6a01 	vldmia	r2!, {s13}
 8045e40:	eec7 5a87 	vdiv.f32	s11, s15, s14
 8045e44:	ee76 7ae5 	vsub.f32	s15, s13, s11
				for (i = 0; i < n1; ++i)
 8045e48:	4295      	cmp	r5, r2
					g[i] -= t * c->x[i] * x0[i] / (x1[i] > tiny? x1[i] : tiny);
 8045e4a:	ed42 7a01 	vstr	s15, [r2, #-4]
				for (i = 0; i < n1; ++i)
 8045e4e:	d1e5      	bne.n	8045e1c <kad_op_ce_multi+0x254>
			for (j = 0; j < d0; ++j) {
 8045e50:	3701      	adds	r7, #1
 8045e52:	45bc      	cmp	ip, r7
 8045e54:	444d      	add	r5, r9
 8045e56:	441e      	add	r6, r3
 8045e58:	d1d9      	bne.n	8045e0e <kad_op_ce_multi+0x246>
 8045e5a:	e6e5      	b.n	8045c28 <kad_op_ce_multi+0x60>
			for (j = 0; j < d0; ++j) {
 8045e5c:	f1bc 0f00 	cmp.w	ip, #0
 8045e60:	dd65      	ble.n	8045f2e <kad_op_ce_multi+0x366>
				float *x1 = &y1->x[j * n1], *x0 = &y0->x[j * n1];
 8045e62:	2400      	movs	r4, #0
 8045e64:	f8d2 9028 	ldr.w	r9, [r2, #40]	@ 0x28
						cost += x0[i] * log(x0[i] / (x1[i] > tiny? x1[i] : tiny));
 8045e68:	eddf 8a52 	vldr	s17, [pc, #328]	@ 8045fb4 <kad_op_ce_multi+0x3ec>
				float *x1 = &y1->x[j * n1], *x0 = &y0->x[j * n1];
 8045e6c:	6aaa      	ldr	r2, [r5, #40]	@ 0x28
 8045e6e:	eb09 0883 	add.w	r8, r9, r3, lsl #2
			for (j = 0; j < d0; ++j) {
 8045e72:	f8cd 901c 	str.w	r9, [sp, #28]
		double cost = 0.0;
 8045e76:	f04f 0a00 	mov.w	sl, #0
 8045e7a:	f04f 0b00 	mov.w	fp, #0
			for (j = 0; j < d0; ++j) {
 8045e7e:	4625      	mov	r5, r4
 8045e80:	4699      	mov	r9, r3
				float *x1 = &y1->x[j * n1], *x0 = &y0->x[j * n1];
 8045e82:	9206      	str	r2, [sp, #24]
 8045e84:	009a      	lsls	r2, r3, #2
 8045e86:	9205      	str	r2, [sp, #20]
			for (j = 0; j < d0; ++j) {
 8045e88:	f8cd c010 	str.w	ip, [sp, #16]
				for (i = 0; i < n1; ++i)
 8045e8c:	f1b9 0f00 	cmp.w	r9, #0
 8045e90:	dd3e      	ble.n	8045f10 <kad_op_ce_multi+0x348>
 8045e92:	f8cd 9004 	str.w	r9, [sp, #4]
 8045e96:	46a9      	mov	r9, r5
 8045e98:	9b07      	ldr	r3, [sp, #28]
 8045e9a:	9403      	str	r4, [sp, #12]
 8045e9c:	eb03 0684 	add.w	r6, r3, r4, lsl #2
 8045ea0:	9b06      	ldr	r3, [sp, #24]
 8045ea2:	eb03 0784 	add.w	r7, r3, r4, lsl #2
					if (x0[i] > 0.0f)
 8045ea6:	ecb6 8a01 	vldmia	r6!, {s16}
 8045eaa:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
 8045eae:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8045eb2:	dd25      	ble.n	8045f00 <kad_op_ce_multi+0x338>
						cost += x0[i] * log(x0[i] / (x1[i] > tiny? x1[i] : tiny));
 8045eb4:	ee18 0a10 	vmov	r0, s16
 8045eb8:	f7fa fb22 	bl	8040500 <__aeabi_f2d>
 8045ebc:	edd7 7a00 	vldr	s15, [r7]
 8045ec0:	eef4 7ae8 	vcmpe.f32	s15, s17
 8045ec4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8045ec8:	fe77 7aa8 	vselgt.f32	s15, s15, s17
 8045ecc:	eec8 7a27 	vdiv.f32	s15, s16, s15
 8045ed0:	4604      	mov	r4, r0
 8045ed2:	ee17 0a90 	vmov	r0, s15
 8045ed6:	460d      	mov	r5, r1
 8045ed8:	f7fa fb12 	bl	8040500 <__aeabi_f2d>
 8045edc:	ec41 0b10 	vmov	d0, r0, r1
 8045ee0:	f006 fe5a 	bl	804cb98 <log>
 8045ee4:	4620      	mov	r0, r4
 8045ee6:	ec53 2b10 	vmov	r2, r3, d0
 8045eea:	4629      	mov	r1, r5
 8045eec:	f7fa fb60 	bl	80405b0 <__aeabi_dmul>
 8045ef0:	4602      	mov	r2, r0
 8045ef2:	460b      	mov	r3, r1
 8045ef4:	4650      	mov	r0, sl
 8045ef6:	4659      	mov	r1, fp
 8045ef8:	f7fa f9a4 	bl	8040244 <__adddf3>
 8045efc:	4682      	mov	sl, r0
 8045efe:	468b      	mov	fp, r1
				for (i = 0; i < n1; ++i)
 8045f00:	4546      	cmp	r6, r8
 8045f02:	f107 0704 	add.w	r7, r7, #4
 8045f06:	d1ce      	bne.n	8045ea6 <kad_op_ce_multi+0x2de>
 8045f08:	464d      	mov	r5, r9
 8045f0a:	9c03      	ldr	r4, [sp, #12]
 8045f0c:	f8dd 9004 	ldr.w	r9, [sp, #4]
			for (j = 0; j < d0; ++j) {
 8045f10:	9b05      	ldr	r3, [sp, #20]
 8045f12:	3501      	adds	r5, #1
 8045f14:	4498      	add	r8, r3
 8045f16:	9b04      	ldr	r3, [sp, #16]
 8045f18:	444c      	add	r4, r9
 8045f1a:	42ab      	cmp	r3, r5
 8045f1c:	d1b6      	bne.n	8045e8c <kad_op_ce_multi+0x2c4>
 8045f1e:	e73d      	b.n	8045d9c <kad_op_ce_multi+0x1d4>
	for (i = 0; i < p->n_d; ++i) n *= p->d[i];
 8045f20:	2900      	cmp	r1, #0
 8045f22:	f43f aeb1 	beq.w	8045c88 <kad_op_ce_multi+0xc0>
 8045f26:	2401      	movs	r4, #1
 8045f28:	e69b      	b.n	8045c62 <kad_op_ce_multi+0x9a>
	int n = 1, i;
 8045f2a:	2201      	movs	r2, #1
 8045f2c:	e6a9      	b.n	8045c82 <kad_op_ce_multi+0xba>
		double cost = 0.0;
 8045f2e:	f04f 0a00 	mov.w	sl, #0
 8045f32:	f04f 0b00 	mov.w	fp, #0
 8045f36:	e732      	b.n	8045d9e <kad_op_ce_multi+0x1d6>
			for (j = 0; j < d0; ++j) {
 8045f38:	f1bc 0f00 	cmp.w	ip, #0
 8045f3c:	f77f ae74 	ble.w	8045c28 <kad_op_ce_multi+0x60>
				float *g = &y1->g[j * n1], *x1 = &y1->x[j * n1], *x0 = &y0->x[j * n1];
 8045f40:	e9d5 760a 	ldrd	r7, r6, [r5, #40]	@ 0x28
 8045f44:	2b00      	cmp	r3, #0
 8045f46:	f8d2 e028 	ldr.w	lr, [r2, #40]	@ 0x28
 8045f4a:	f77f ae6d 	ble.w	8045c28 <kad_op_ce_multi+0x60>
					g[i] -= t * x0[i] / (x1[i] > tiny? x1[i] : tiny);
 8045f4e:	ed9f 6a19 	vldr	s12, [pc, #100]	@ 8045fb4 <kad_op_ce_multi+0x3ec>
			for (j = 0; j < d0; ++j) {
 8045f52:	464c      	mov	r4, r9
 8045f54:	009d      	lsls	r5, r3, #2
 8045f56:	eb06 0083 	add.w	r0, r6, r3, lsl #2
				for (i = 0; i < n1; ++i)
 8045f5a:	eb06 0309 	add.w	r3, r6, r9
 8045f5e:	eb0e 0109 	add.w	r1, lr, r9
 8045f62:	eb07 0209 	add.w	r2, r7, r9
					g[i] -= t * x0[i] / (x1[i] > tiny? x1[i] : tiny);
 8045f66:	ecf2 7a01 	vldmia	r2!, {s15}
 8045f6a:	eef4 7ac6 	vcmpe.f32	s15, s12
 8045f6e:	ecf1 6a01 	vldmia	r1!, {s13}
 8045f72:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8045f76:	ee65 6a26 	vmul.f32	s13, s10, s13
 8045f7a:	fe77 7a86 	vselgt.f32	s15, s15, s12
 8045f7e:	ecb3 7a01 	vldmia	r3!, {s14}
 8045f82:	eec6 5aa7 	vdiv.f32	s11, s13, s15
 8045f86:	ee77 7a65 	vsub.f32	s15, s14, s11
				for (i = 0; i < n1; ++i)
 8045f8a:	4298      	cmp	r0, r3
					g[i] -= t * x0[i] / (x1[i] > tiny? x1[i] : tiny);
 8045f8c:	ed43 7a01 	vstr	s15, [r3, #-4]
				for (i = 0; i < n1; ++i)
 8045f90:	d1e9      	bne.n	8045f66 <kad_op_ce_multi+0x39e>
			for (j = 0; j < d0; ++j) {
 8045f92:	3401      	adds	r4, #1
 8045f94:	45a4      	cmp	ip, r4
 8045f96:	4428      	add	r0, r5
 8045f98:	44a9      	add	r9, r5
 8045f9a:	d1de      	bne.n	8045f5a <kad_op_ce_multi+0x392>
 8045f9c:	e644      	b.n	8045c28 <kad_op_ce_multi+0x60>
		if (kad_len(y0) != kad_len(y1) || y0->d[y0->n_d - 1] != y1->d[y1->n_d - 1]) return -1;
 8045f9e:	f04f 30ff 	mov.w	r0, #4294967295
 8045fa2:	e642      	b.n	8045c2a <kad_op_ce_multi+0x62>
		assert(c->n_d == 1 && c->d[0] == n1);
 8045fa4:	f240 6133 	movw	r1, #1587	@ 0x633
 8045fa8:	4b03      	ldr	r3, [pc, #12]	@ (8045fb8 <kad_op_ce_multi+0x3f0>)
 8045faa:	4a04      	ldr	r2, [pc, #16]	@ (8045fbc <kad_op_ce_multi+0x3f4>)
 8045fac:	4804      	ldr	r0, [pc, #16]	@ (8045fc0 <kad_op_ce_multi+0x3f8>)
 8045fae:	f005 fbdd 	bl	804b76c <__assert_func>
 8045fb2:	bf00      	nop
 8045fb4:	3089705f 	.word	0x3089705f
 8045fb8:	0804e3a4 	.word	0x0804e3a4
 8045fbc:	0804e478 	.word	0x0804e478
 8045fc0:	0804e328 	.word	0x0804e328

08045fc4 <kad_op_stdnorm>:
{
 8045fc4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8045fc8:	ed2d 8b02 	vpush	{d8}
	kad_node_t *q = p->child[0];
 8045fcc:	6b83      	ldr	r3, [r0, #56]	@ 0x38
{
 8045fce:	b091      	sub	sp, #68	@ 0x44
	kad_node_t *q = p->child[0];
 8045fd0:	681c      	ldr	r4, [r3, #0]
	assert(q->n_d > 0);
 8045fd2:	7825      	ldrb	r5, [r4, #0]
 8045fd4:	2d00      	cmp	r5, #0
 8045fd6:	f000 8198 	beq.w	804630a <kad_op_stdnorm+0x346>
	n = q->d[q->n_d - 1];
 8045fda:	1ceb      	adds	r3, r5, #3
	for (i = 0; i < p->n_d; ++i) n *= p->d[i];
 8045fdc:	2d01      	cmp	r5, #1
 8045fde:	f854 e023 	ldr.w	lr, [r4, r3, lsl #2]
 8045fe2:	4606      	mov	r6, r0
 8045fe4:	6923      	ldr	r3, [r4, #16]
 8045fe6:	d00b      	beq.n	8046000 <kad_op_stdnorm+0x3c>
 8045fe8:	6962      	ldr	r2, [r4, #20]
 8045fea:	2d02      	cmp	r5, #2
 8045fec:	fb02 f303 	mul.w	r3, r2, r3
 8045ff0:	d006      	beq.n	8046000 <kad_op_stdnorm+0x3c>
 8045ff2:	69a2      	ldr	r2, [r4, #24]
 8045ff4:	2d03      	cmp	r5, #3
 8045ff6:	fb02 f303 	mul.w	r3, r2, r3
 8045ffa:	bf1c      	itt	ne
 8045ffc:	69e2      	ldrne	r2, [r4, #28]
 8045ffe:	4353      	mulne	r3, r2
	if (action == KAD_SYNC_DIM) {
 8046000:	2904      	cmp	r1, #4
	m = kad_len(q) / n;
 8046002:	fb93 f3fe 	sdiv	r3, r3, lr
	if (action == KAD_SYNC_DIM) {
 8046006:	f000 808f 	beq.w	8046128 <kad_op_stdnorm+0x164>
	} else if (action == KAD_ALLOC) {
 804600a:	2901      	cmp	r1, #1
 804600c:	f000 80af 	beq.w	804616e <kad_op_stdnorm+0x1aa>
	} else if (action == KAD_FORWARD) {
 8046010:	2902      	cmp	r1, #2
 8046012:	d008      	beq.n	8046026 <kad_op_stdnorm+0x62>
	} else if (action == KAD_BACKWARD && kad_is_back(q)) {
 8046014:	2903      	cmp	r1, #3
 8046016:	f000 80b5 	beq.w	8046184 <kad_op_stdnorm+0x1c0>
}
 804601a:	2000      	movs	r0, #0
 804601c:	b011      	add	sp, #68	@ 0x44
 804601e:	ecbd 8b02 	vpop	{d8}
 8046022:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		for (j = 0; j < m; ++j) {
 8046026:	2b00      	cmp	r3, #0
		float *si = (float*)p->gtmp;
 8046028:	6b72      	ldr	r2, [r6, #52]	@ 0x34
		for (j = 0; j < m; ++j) {
 804602a:	ddf6      	ble.n	804601a <kad_op_stdnorm+0x56>
 804602c:	eb02 0383 	add.w	r3, r2, r3, lsl #2
			std_inv = s == 0.0? 1.0f : (float)(1.0 / sqrt(s / n));
 8046030:	e9cd e308 	strd	lr, r3, [sp, #32]
 8046034:	6ab1      	ldr	r1, [r6, #40]	@ 0x28
 8046036:	f8d4 b028 	ldr.w	fp, [r4, #40]	@ 0x28
			for (i = 0, s = 0.0; i < n; ++i) s += qx[i];
 804603a:	9b08      	ldr	r3, [sp, #32]
 804603c:	eb01 078e 	add.w	r7, r1, lr, lsl #2
 8046040:	eb0b 068e 	add.w	r6, fp, lr, lsl #2
 8046044:	2b00      	cmp	r3, #0
			std_inv = s == 0.0? 1.0f : (float)(1.0 / sqrt(s / n));
 8046046:	460c      	mov	r4, r1
 8046048:	9704      	str	r7, [sp, #16]
 804604a:	9602      	str	r6, [sp, #8]
 804604c:	ea4f 0a8e 	mov.w	sl, lr, lsl #2
 8046050:	9200      	str	r2, [sp, #0]
			for (i = 0, s = 0.0; i < n; ++i) s += qx[i];
 8046052:	dd66      	ble.n	8046122 <kad_op_stdnorm+0x15e>
 8046054:	465d      	mov	r5, fp
 8046056:	f04f 0800 	mov.w	r8, #0
 804605a:	f04f 0900 	mov.w	r9, #0
 804605e:	f855 0b04 	ldr.w	r0, [r5], #4
 8046062:	f7fa fa4d 	bl	8040500 <__aeabi_f2d>
 8046066:	4602      	mov	r2, r0
 8046068:	460b      	mov	r3, r1
 804606a:	4640      	mov	r0, r8
 804606c:	4649      	mov	r1, r9
 804606e:	f7fa f8e9 	bl	8040244 <__adddf3>
 8046072:	42ae      	cmp	r6, r5
 8046074:	4680      	mov	r8, r0
 8046076:	4689      	mov	r9, r1
 8046078:	d1f1      	bne.n	804605e <kad_op_stdnorm+0x9a>
			avg = (float)(s / n);
 804607a:	9808      	ldr	r0, [sp, #32]
 804607c:	f7fa fa2e 	bl	80404dc <__aeabi_i2d>
 8046080:	460b      	mov	r3, r1
 8046082:	4602      	mov	r2, r0
 8046084:	4649      	mov	r1, r9
 8046086:	4640      	mov	r0, r8
 8046088:	e9cd 2306 	strd	r2, r3, [sp, #24]
 804608c:	f7fa fbba 	bl	8040804 <__aeabi_ddiv>
 8046090:	f7fa fd66 	bl	8040b60 <__aeabi_d2f>
 8046094:	4623      	mov	r3, r4
 8046096:	ee07 0a10 	vmov	s14, r0
			for (i = 0; i < n; ++i) px[i] = qx[i] - avg;
 804609a:	ecfb 7a01 	vldmia	fp!, {s15}
 804609e:	ee77 7ac7 	vsub.f32	s15, s15, s14
 80460a2:	455e      	cmp	r6, fp
 80460a4:	ece3 7a01 	vstmia	r3!, {s15}
 80460a8:	d1f7      	bne.n	804609a <kad_op_stdnorm+0xd6>
 80460aa:	4625      	mov	r5, r4
			for (i = 0, s = 0.0; i < n; ++i) s += px[i] * px[i];
 80460ac:	f04f 0800 	mov.w	r8, #0
 80460b0:	f04f 0900 	mov.w	r9, #0
 80460b4:	ecf5 7a01 	vldmia	r5!, {s15}
 80460b8:	ee67 7aa7 	vmul.f32	s15, s15, s15
 80460bc:	ee17 0a90 	vmov	r0, s15
 80460c0:	f7fa fa1e 	bl	8040500 <__aeabi_f2d>
 80460c4:	4602      	mov	r2, r0
 80460c6:	460b      	mov	r3, r1
 80460c8:	4640      	mov	r0, r8
 80460ca:	4649      	mov	r1, r9
 80460cc:	f7fa f8ba 	bl	8040244 <__adddf3>
 80460d0:	42af      	cmp	r7, r5
 80460d2:	4680      	mov	r8, r0
 80460d4:	4689      	mov	r9, r1
 80460d6:	d1ed      	bne.n	80460b4 <kad_op_stdnorm+0xf0>
			std_inv = s == 0.0? 1.0f : (float)(1.0 / sqrt(s / n));
 80460d8:	2200      	movs	r2, #0
 80460da:	2300      	movs	r3, #0
 80460dc:	f7fa fcd0 	bl	8040a80 <__aeabi_dcmpeq>
 80460e0:	b380      	cbz	r0, 8046144 <kad_op_stdnorm+0x180>
 80460e2:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
			for (i = 0; i < n; ++i) px[i] *= std_inv;
 80460e6:	edd4 7a00 	vldr	s15, [r4]
 80460ea:	ee67 7a87 	vmul.f32	s15, s15, s14
 80460ee:	ece4 7a01 	vstmia	r4!, {s15}
 80460f2:	42bc      	cmp	r4, r7
 80460f4:	d1f7      	bne.n	80460e6 <kad_op_stdnorm+0x122>
			si[j] = std_inv;
 80460f6:	9b00      	ldr	r3, [sp, #0]
		for (j = 0; j < m; ++j) {
 80460f8:	9a09      	ldr	r2, [sp, #36]	@ 0x24
			si[j] = std_inv;
 80460fa:	eca3 7a01 	vstmia	r3!, {s14}
		for (j = 0; j < m; ++j) {
 80460fe:	9804      	ldr	r0, [sp, #16]
 8046100:	9902      	ldr	r1, [sp, #8]
 8046102:	429a      	cmp	r2, r3
 8046104:	4604      	mov	r4, r0
 8046106:	468b      	mov	fp, r1
			si[j] = std_inv;
 8046108:	9300      	str	r3, [sp, #0]
		for (j = 0; j < m; ++j) {
 804610a:	4457      	add	r7, sl
 804610c:	4456      	add	r6, sl
 804610e:	d084      	beq.n	804601a <kad_op_stdnorm+0x56>
 8046110:	4603      	mov	r3, r0
 8046112:	4453      	add	r3, sl
 8046114:	9304      	str	r3, [sp, #16]
 8046116:	460b      	mov	r3, r1
 8046118:	4453      	add	r3, sl
 804611a:	9302      	str	r3, [sp, #8]
			for (i = 0, s = 0.0; i < n; ++i) s += qx[i];
 804611c:	9b08      	ldr	r3, [sp, #32]
 804611e:	2b00      	cmp	r3, #0
 8046120:	dc98      	bgt.n	8046054 <kad_op_stdnorm+0x90>
			std_inv = s == 0.0? 1.0f : (float)(1.0 / sqrt(s / n));
 8046122:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 8046126:	e7e6      	b.n	80460f6 <kad_op_stdnorm+0x132>
	dst->n_d = src->n_d;
 8046128:	4630      	mov	r0, r6
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 804612a:	00aa      	lsls	r2, r5, #2
 804612c:	f104 0110 	add.w	r1, r4, #16
	dst->n_d = src->n_d;
 8046130:	f800 5b10 	strb.w	r5, [r0], #16
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 8046134:	f005 ff3f 	bl	804bfb6 <memcpy>
}
 8046138:	2000      	movs	r0, #0
 804613a:	b011      	add	sp, #68	@ 0x44
 804613c:	ecbd 8b02 	vpop	{d8}
 8046140:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			std_inv = s == 0.0? 1.0f : (float)(1.0 / sqrt(s / n));
 8046144:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
 8046148:	4640      	mov	r0, r8
 804614a:	4649      	mov	r1, r9
 804614c:	f7fa fb5a 	bl	8040804 <__aeabi_ddiv>
 8046150:	ec41 0b10 	vmov	d0, r0, r1
 8046154:	f006 fd5e 	bl	804cc14 <sqrt>
 8046158:	2000      	movs	r0, #0
 804615a:	ec53 2b10 	vmov	r2, r3, d0
 804615e:	496e      	ldr	r1, [pc, #440]	@ (8046318 <kad_op_stdnorm+0x354>)
 8046160:	f7fa fb50 	bl	8040804 <__aeabi_ddiv>
 8046164:	f7fa fcfc 	bl	8040b60 <__aeabi_d2f>
 8046168:	ee07 0a10 	vmov	s14, r0
 804616c:	e7bb      	b.n	80460e6 <kad_op_stdnorm+0x122>
		p->gtmp = realloc(p->gtmp, m * sizeof(float));
 804616e:	6b70      	ldr	r0, [r6, #52]	@ 0x34
 8046170:	0099      	lsls	r1, r3, #2
 8046172:	f005 fc21 	bl	804b9b8 <realloc>
 8046176:	6370      	str	r0, [r6, #52]	@ 0x34
}
 8046178:	2000      	movs	r0, #0
 804617a:	b011      	add	sp, #68	@ 0x44
 804617c:	ecbd 8b02 	vpop	{d8}
 8046180:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	} else if (action == KAD_BACKWARD && kad_is_back(q)) {
 8046184:	7862      	ldrb	r2, [r4, #1]
 8046186:	07d2      	lsls	r2, r2, #31
 8046188:	f57f af47 	bpl.w	804601a <kad_op_stdnorm+0x56>
		for (j = 0; j < m; ++j) {
 804618c:	2b00      	cmp	r3, #0
		float *si = (float*)p->gtmp;
 804618e:	6b72      	ldr	r2, [r6, #52]	@ 0x34
		for (j = 0; j < m; ++j) {
 8046190:	f77f af43 	ble.w	804601a <kad_op_stdnorm+0x56>
 8046194:	e9d6 150a 	ldrd	r1, r5, [r6, #40]	@ 0x28
 8046198:	9108      	str	r1, [sp, #32]
 804619a:	eb05 018e 	add.w	r1, r5, lr, lsl #2
 804619e:	910b      	str	r1, [sp, #44]	@ 0x2c
 80461a0:	9109      	str	r1, [sp, #36]	@ 0x24
			float *pg = &p->g[j * n], *qg = &q->g[j * n], *px = &p->x[j * n], std_inv = si[j];
 80461a2:	2100      	movs	r1, #0
 80461a4:	eb02 0383 	add.w	r3, r2, r3, lsl #2
			for (i = 0, s = t = 0.0; i < n; ++i)
 80461a8:	e9cd e30c 	strd	lr, r3, [sp, #48]	@ 0x30
 80461ac:	4613      	mov	r3, r2
 80461ae:	f8d4 c02c 	ldr.w	ip, [r4, #44]	@ 0x2c
			float *pg = &p->g[j * n], *qg = &q->g[j * n], *px = &p->x[j * n], std_inv = si[j];
 80461b2:	910a      	str	r1, [sp, #40]	@ 0x28
 80461b4:	ea4f 018e 	mov.w	r1, lr, lsl #2
 80461b8:	9206      	str	r2, [sp, #24]
 80461ba:	910e      	str	r1, [sp, #56]	@ 0x38
 80461bc:	eb0c 0b8e 	add.w	fp, ip, lr, lsl #2
			for (i = 0, s = t = 0.0; i < n; ++i)
 80461c0:	f8cd c03c 	str.w	ip, [sp, #60]	@ 0x3c
			float *pg = &p->g[j * n], *qg = &q->g[j * n], *px = &p->x[j * n], std_inv = si[j];
 80461c4:	ecf3 7a01 	vldmia	r3!, {s15}
 80461c8:	9306      	str	r3, [sp, #24]
			for (i = 0, s = t = 0.0; i < n; ++i)
 80461ca:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
			float *pg = &p->g[j * n], *qg = &q->g[j * n], *px = &p->x[j * n], std_inv = si[j];
 80461cc:	edcd 7a02 	vstr	s15, [sp, #8]
			for (i = 0, s = t = 0.0; i < n; ++i)
 80461d0:	2b00      	cmp	r3, #0
 80461d2:	f340 8084 	ble.w	80462de <kad_op_stdnorm+0x31a>
 80461d6:	f04f 0800 	mov.w	r8, #0
 80461da:	f04f 0900 	mov.w	r9, #0
 80461de:	f8cd b010 	str.w	fp, [sp, #16]
 80461e2:	46c2      	mov	sl, r8
 80461e4:	46cb      	mov	fp, r9
 80461e6:	462c      	mov	r4, r5
 80461e8:	462f      	mov	r7, r5
 80461ea:	9e08      	ldr	r6, [sp, #32]
 80461ec:	9d09      	ldr	r5, [sp, #36]	@ 0x24
				s += pg[i], t += px[i] * pg[i];
 80461ee:	ecb4 8a01 	vldmia	r4!, {s16}
 80461f2:	ee18 0a10 	vmov	r0, s16
 80461f6:	f7fa f983 	bl	8040500 <__aeabi_f2d>
 80461fa:	4602      	mov	r2, r0
 80461fc:	460b      	mov	r3, r1
 80461fe:	4640      	mov	r0, r8
 8046200:	4649      	mov	r1, r9
 8046202:	f7fa f81f 	bl	8040244 <__adddf3>
 8046206:	ecf6 7a01 	vldmia	r6!, {s15}
 804620a:	ee68 7a27 	vmul.f32	s15, s16, s15
 804620e:	4680      	mov	r8, r0
 8046210:	ee17 0a90 	vmov	r0, s15
 8046214:	4689      	mov	r9, r1
 8046216:	f7fa f973 	bl	8040500 <__aeabi_f2d>
 804621a:	4602      	mov	r2, r0
 804621c:	460b      	mov	r3, r1
 804621e:	4650      	mov	r0, sl
 8046220:	4659      	mov	r1, fp
 8046222:	f7fa f80f 	bl	8040244 <__adddf3>
			for (i = 0, s = t = 0.0; i < n; ++i)
 8046226:	42a5      	cmp	r5, r4
				s += pg[i], t += px[i] * pg[i];
 8046228:	4682      	mov	sl, r0
 804622a:	468b      	mov	fp, r1
			for (i = 0, s = t = 0.0; i < n; ++i)
 804622c:	d1df      	bne.n	80461ee <kad_op_stdnorm+0x22a>
			s /= n, t /= n;
 804622e:	980c      	ldr	r0, [sp, #48]	@ 0x30
				qg[i] += std_inv * (pg[i] - s - px[i] * t);
 8046230:	e9cd ab00 	strd	sl, fp, [sp]
			s /= n, t /= n;
 8046234:	f7fa f952 	bl	80404dc <__aeabi_i2d>
 8046238:	4602      	mov	r2, r0
 804623a:	460b      	mov	r3, r1
 804623c:	4640      	mov	r0, r8
 804623e:	4649      	mov	r1, r9
 8046240:	4690      	mov	r8, r2
 8046242:	4699      	mov	r9, r3
 8046244:	f7fa fade 	bl	8040804 <__aeabi_ddiv>
 8046248:	9e0a      	ldr	r6, [sp, #40]	@ 0x28
 804624a:	9c0f      	ldr	r4, [sp, #60]	@ 0x3c
				qg[i] += std_inv * (pg[i] - s - px[i] * t);
 804624c:	463d      	mov	r5, r7
			s /= n, t /= n;
 804624e:	4434      	add	r4, r6
 8046250:	460f      	mov	r7, r1
 8046252:	4606      	mov	r6, r0
 8046254:	e9dd 0100 	ldrd	r0, r1, [sp]
 8046258:	4642      	mov	r2, r8
 804625a:	464b      	mov	r3, r9
 804625c:	e9cd 6700 	strd	r6, r7, [sp]
 8046260:	f7fa fad0 	bl	8040804 <__aeabi_ddiv>
 8046264:	4602      	mov	r2, r0
 8046266:	460b      	mov	r3, r1
				qg[i] += std_inv * (pg[i] - s - px[i] * t);
 8046268:	9802      	ldr	r0, [sp, #8]
			s /= n, t /= n;
 804626a:	e9cd 2302 	strd	r2, r3, [sp, #8]
				qg[i] += std_inv * (pg[i] - s - px[i] * t);
 804626e:	f7fa f947 	bl	8040500 <__aeabi_f2d>
 8046272:	f8dd b010 	ldr.w	fp, [sp, #16]
 8046276:	e9cd 0104 	strd	r0, r1, [sp, #16]
 804627a:	f8dd a020 	ldr.w	sl, [sp, #32]
 804627e:	f855 0b04 	ldr.w	r0, [r5], #4
 8046282:	f7fa f93d 	bl	8040500 <__aeabi_f2d>
 8046286:	e9dd 2300 	ldrd	r2, r3, [sp]
 804628a:	f7f9 ffd9 	bl	8040240 <__aeabi_dsub>
 804628e:	f85a 3b04 	ldr.w	r3, [sl], #4
 8046292:	4606      	mov	r6, r0
 8046294:	4618      	mov	r0, r3
 8046296:	460f      	mov	r7, r1
 8046298:	f7fa f932 	bl	8040500 <__aeabi_f2d>
 804629c:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 80462a0:	f7fa f986 	bl	80405b0 <__aeabi_dmul>
 80462a4:	4602      	mov	r2, r0
 80462a6:	460b      	mov	r3, r1
 80462a8:	4630      	mov	r0, r6
 80462aa:	4639      	mov	r1, r7
 80462ac:	f7f9 ffc8 	bl	8040240 <__aeabi_dsub>
 80462b0:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 80462b4:	f7fa f97c 	bl	80405b0 <__aeabi_dmul>
 80462b8:	f8d4 8000 	ldr.w	r8, [r4]
 80462bc:	4606      	mov	r6, r0
 80462be:	4640      	mov	r0, r8
 80462c0:	460f      	mov	r7, r1
 80462c2:	f7fa f91d 	bl	8040500 <__aeabi_f2d>
 80462c6:	4602      	mov	r2, r0
 80462c8:	460b      	mov	r3, r1
 80462ca:	4630      	mov	r0, r6
 80462cc:	4639      	mov	r1, r7
 80462ce:	f7f9 ffb9 	bl	8040244 <__adddf3>
 80462d2:	f7fa fc45 	bl	8040b60 <__aeabi_d2f>
 80462d6:	f844 0b04 	str.w	r0, [r4], #4
			for (i = 0; i < n; ++i)
 80462da:	45a3      	cmp	fp, r4
 80462dc:	d1cf      	bne.n	804627e <kad_op_stdnorm+0x2ba>
		for (j = 0; j < m; ++j) {
 80462de:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
 80462e0:	9a08      	ldr	r2, [sp, #32]
 80462e2:	990d      	ldr	r1, [sp, #52]	@ 0x34
 80462e4:	441a      	add	r2, r3
 80462e6:	9208      	str	r2, [sp, #32]
 80462e8:	9a0a      	ldr	r2, [sp, #40]	@ 0x28
 80462ea:	9806      	ldr	r0, [sp, #24]
 80462ec:	441a      	add	r2, r3
 80462ee:	920a      	str	r2, [sp, #40]	@ 0x28
 80462f0:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 80462f2:	4281      	cmp	r1, r0
 80462f4:	441a      	add	r2, r3
 80462f6:	9209      	str	r2, [sp, #36]	@ 0x24
 80462f8:	9a0b      	ldr	r2, [sp, #44]	@ 0x2c
 80462fa:	449b      	add	fp, r3
 80462fc:	4615      	mov	r5, r2
 80462fe:	f43f ae8c 	beq.w	804601a <kad_op_stdnorm+0x56>
 8046302:	441a      	add	r2, r3
 8046304:	920b      	str	r2, [sp, #44]	@ 0x2c
 8046306:	4603      	mov	r3, r0
 8046308:	e75c      	b.n	80461c4 <kad_op_stdnorm+0x200>
	assert(q->n_d > 0);
 804630a:	f240 6163 	movw	r1, #1635	@ 0x663
 804630e:	4b03      	ldr	r3, [pc, #12]	@ (804631c <kad_op_stdnorm+0x358>)
 8046310:	4a03      	ldr	r2, [pc, #12]	@ (8046320 <kad_op_stdnorm+0x35c>)
 8046312:	4804      	ldr	r0, [pc, #16]	@ (8046324 <kad_op_stdnorm+0x360>)
 8046314:	f005 fa2a 	bl	804b76c <__assert_func>
 8046318:	3ff00000 	.word	0x3ff00000
 804631c:	0804e3c4 	.word	0x0804e3c4
 8046320:	0804e468 	.word	0x0804e468
 8046324:	0804e328 	.word	0x0804e328

08046328 <kad_op_exp>:
{
 8046328:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	kad_node_t *q = p->child[0];
 804632a:	6b83      	ldr	r3, [r0, #56]	@ 0x38
 804632c:	681b      	ldr	r3, [r3, #0]
 804632e:	781d      	ldrb	r5, [r3, #0]
 8046330:	b305      	cbz	r5, 8046374 <kad_op_exp+0x4c>
 8046332:	2d01      	cmp	r5, #1
 8046334:	691c      	ldr	r4, [r3, #16]
 8046336:	d00c      	beq.n	8046352 <kad_op_exp+0x2a>
 8046338:	695a      	ldr	r2, [r3, #20]
 804633a:	2d02      	cmp	r5, #2
 804633c:	fb02 f404 	mul.w	r4, r2, r4
 8046340:	d007      	beq.n	8046352 <kad_op_exp+0x2a>
 8046342:	699a      	ldr	r2, [r3, #24]
 8046344:	2d03      	cmp	r5, #3
 8046346:	fb02 f404 	mul.w	r4, r2, r4
 804634a:	d002      	beq.n	8046352 <kad_op_exp+0x2a>
 804634c:	69da      	ldr	r2, [r3, #28]
 804634e:	fb02 f404 	mul.w	r4, r2, r4
	if (action == KAD_SYNC_DIM) {
 8046352:	2904      	cmp	r1, #4
 8046354:	d005      	beq.n	8046362 <kad_op_exp+0x3a>
	} else if (action == KAD_FORWARD) {
 8046356:	2902      	cmp	r1, #2
 8046358:	d017      	beq.n	804638a <kad_op_exp+0x62>
	} else if (action == KAD_BACKWARD && kad_is_back(q)) {
 804635a:	2903      	cmp	r1, #3
 804635c:	d027      	beq.n	80463ae <kad_op_exp+0x86>
}
 804635e:	2000      	movs	r0, #0
 8046360:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 8046362:	00aa      	lsls	r2, r5, #2
 8046364:	f103 0110 	add.w	r1, r3, #16
	dst->n_d = src->n_d;
 8046368:	f800 5b10 	strb.w	r5, [r0], #16
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 804636c:	f005 fe23 	bl	804bfb6 <memcpy>
}
 8046370:	2000      	movs	r0, #0
 8046372:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (action == KAD_SYNC_DIM) {
 8046374:	2904      	cmp	r1, #4
 8046376:	d018      	beq.n	80463aa <kad_op_exp+0x82>
	} else if (action == KAD_FORWARD) {
 8046378:	2902      	cmp	r1, #2
 804637a:	d02f      	beq.n	80463dc <kad_op_exp+0xb4>
	} else if (action == KAD_BACKWARD && kad_is_back(q)) {
 804637c:	2903      	cmp	r1, #3
 804637e:	d1ee      	bne.n	804635e <kad_op_exp+0x36>
 8046380:	785a      	ldrb	r2, [r3, #1]
 8046382:	07d1      	lsls	r1, r2, #31
 8046384:	d5eb      	bpl.n	804635e <kad_op_exp+0x36>
	int n = 1, i;
 8046386:	2401      	movs	r4, #1
 8046388:	e016      	b.n	80463b8 <kad_op_exp+0x90>
		for (i = 0; i < n; ++i) p->x[i] = expf(q->x[i]);
 804638a:	2c00      	cmp	r4, #0
 804638c:	dde7      	ble.n	804635e <kad_op_exp+0x36>
 804638e:	2500      	movs	r5, #0
 8046390:	6a9f      	ldr	r7, [r3, #40]	@ 0x28
 8046392:	6a86      	ldr	r6, [r0, #40]	@ 0x28
 8046394:	ecb7 0a01 	vldmia	r7!, {s0}
 8046398:	f006 fc68 	bl	804cc6c <expf>
 804639c:	3501      	adds	r5, #1
 804639e:	42a5      	cmp	r5, r4
 80463a0:	eca6 0a01 	vstmia	r6!, {s0}
 80463a4:	dbf6      	blt.n	8046394 <kad_op_exp+0x6c>
}
 80463a6:	2000      	movs	r0, #0
 80463a8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	dst->n_d = src->n_d;
 80463aa:	7005      	strb	r5, [r0, #0]
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 80463ac:	e7d7      	b.n	804635e <kad_op_exp+0x36>
	} else if (action == KAD_BACKWARD && kad_is_back(q)) {
 80463ae:	785a      	ldrb	r2, [r3, #1]
 80463b0:	07d2      	lsls	r2, r2, #31
 80463b2:	d5d4      	bpl.n	804635e <kad_op_exp+0x36>
		for (i = 0; i < n; ++i)
 80463b4:	2c00      	cmp	r4, #0
 80463b6:	ddd2      	ble.n	804635e <kad_op_exp+0x36>
 80463b8:	e9d0 210a 	ldrd	r2, r1, [r0, #40]	@ 0x28
 80463bc:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80463be:	eb03 0484 	add.w	r4, r3, r4, lsl #2
			q->g[i] += p->g[i] * p->x[i];
 80463c2:	edd3 7a00 	vldr	s15, [r3]
 80463c6:	ecf1 6a01 	vldmia	r1!, {s13}
 80463ca:	ecb2 7a01 	vldmia	r2!, {s14}
 80463ce:	eee6 7a87 	vfma.f32	s15, s13, s14
 80463d2:	ece3 7a01 	vstmia	r3!, {s15}
		for (i = 0; i < n; ++i)
 80463d6:	429c      	cmp	r4, r3
 80463d8:	d1f3      	bne.n	80463c2 <kad_op_exp+0x9a>
 80463da:	e7c0      	b.n	804635e <kad_op_exp+0x36>
 80463dc:	2401      	movs	r4, #1
 80463de:	e7d6      	b.n	804638e <kad_op_exp+0x66>

080463e0 <kad_op_sigm>:
{
 80463e0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80463e2:	ed2d 8b02 	vpush	{d8}
	kad_node_t *q = p->child[0];
 80463e6:	6b83      	ldr	r3, [r0, #56]	@ 0x38
{
 80463e8:	4605      	mov	r5, r0
	kad_node_t *q = p->child[0];
 80463ea:	681b      	ldr	r3, [r3, #0]
	for (i = 0; i < p->n_d; ++i) n *= p->d[i];
 80463ec:	781c      	ldrb	r4, [r3, #0]
 80463ee:	b32c      	cbz	r4, 804643c <kad_op_sigm+0x5c>
 80463f0:	2c01      	cmp	r4, #1
 80463f2:	691e      	ldr	r6, [r3, #16]
 80463f4:	d00c      	beq.n	8046410 <kad_op_sigm+0x30>
 80463f6:	695a      	ldr	r2, [r3, #20]
 80463f8:	2c02      	cmp	r4, #2
 80463fa:	fb02 f606 	mul.w	r6, r2, r6
 80463fe:	d007      	beq.n	8046410 <kad_op_sigm+0x30>
 8046400:	699a      	ldr	r2, [r3, #24]
 8046402:	2c03      	cmp	r4, #3
 8046404:	fb02 f606 	mul.w	r6, r2, r6
 8046408:	d002      	beq.n	8046410 <kad_op_sigm+0x30>
 804640a:	69da      	ldr	r2, [r3, #28]
 804640c:	fb02 f606 	mul.w	r6, r2, r6
	if (action == KAD_SYNC_DIM) {
 8046410:	2904      	cmp	r1, #4
 8046412:	d007      	beq.n	8046424 <kad_op_sigm+0x44>
	} else if (action == KAD_FORWARD) {
 8046414:	2902      	cmp	r1, #2
 8046416:	d01c      	beq.n	8046452 <kad_op_sigm+0x72>
	} else if (action == KAD_BACKWARD && kad_is_back(q)) {
 8046418:	2903      	cmp	r1, #3
 804641a:	d038      	beq.n	804648e <kad_op_sigm+0xae>
}
 804641c:	ecbd 8b02 	vpop	{d8}
 8046420:	2000      	movs	r0, #0
 8046422:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	dst->n_d = src->n_d;
 8046424:	4628      	mov	r0, r5
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 8046426:	00a2      	lsls	r2, r4, #2
 8046428:	f103 0110 	add.w	r1, r3, #16
	dst->n_d = src->n_d;
 804642c:	f800 4b10 	strb.w	r4, [r0], #16
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 8046430:	f005 fdc1 	bl	804bfb6 <memcpy>
}
 8046434:	ecbd 8b02 	vpop	{d8}
 8046438:	2000      	movs	r0, #0
 804643a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (action == KAD_SYNC_DIM) {
 804643c:	2904      	cmp	r1, #4
 804643e:	d024      	beq.n	804648a <kad_op_sigm+0xaa>
	} else if (action == KAD_FORWARD) {
 8046440:	2902      	cmp	r1, #2
 8046442:	d041      	beq.n	80464c8 <kad_op_sigm+0xe8>
	} else if (action == KAD_BACKWARD && kad_is_back(q)) {
 8046444:	2903      	cmp	r1, #3
 8046446:	d1e9      	bne.n	804641c <kad_op_sigm+0x3c>
 8046448:	785a      	ldrb	r2, [r3, #1]
 804644a:	07d1      	lsls	r1, r2, #31
 804644c:	d5e6      	bpl.n	804641c <kad_op_sigm+0x3c>
	int n = 1, i;
 804644e:	2601      	movs	r6, #1
 8046450:	e022      	b.n	8046498 <kad_op_sigm+0xb8>
		for (i = 0; i < n; ++i)
 8046452:	2e00      	cmp	r6, #0
 8046454:	dde2      	ble.n	804641c <kad_op_sigm+0x3c>
 8046456:	2400      	movs	r4, #0
			p->x[i] = 1.0f / (1.0f + expf(-q->x[i]));
 8046458:	eeb7 8a00 	vmov.f32	s16, #112	@ 0x3f800000  1.0
 804645c:	6a9f      	ldr	r7, [r3, #40]	@ 0x28
 804645e:	ecb7 0a01 	vldmia	r7!, {s0}
 8046462:	eeb1 0a40 	vneg.f32	s0, s0
 8046466:	f006 fc01 	bl	804cc6c <expf>
 804646a:	ee30 0a08 	vadd.f32	s0, s0, s16
 804646e:	eec8 7a00 	vdiv.f32	s15, s16, s0
 8046472:	6aab      	ldr	r3, [r5, #40]	@ 0x28
 8046474:	eb03 0384 	add.w	r3, r3, r4, lsl #2
		for (i = 0; i < n; ++i)
 8046478:	3401      	adds	r4, #1
 804647a:	42b4      	cmp	r4, r6
			p->x[i] = 1.0f / (1.0f + expf(-q->x[i]));
 804647c:	edc3 7a00 	vstr	s15, [r3]
		for (i = 0; i < n; ++i)
 8046480:	dbed      	blt.n	804645e <kad_op_sigm+0x7e>
}
 8046482:	ecbd 8b02 	vpop	{d8}
 8046486:	2000      	movs	r0, #0
 8046488:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	dst->n_d = src->n_d;
 804648a:	7004      	strb	r4, [r0, #0]
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 804648c:	e7c6      	b.n	804641c <kad_op_sigm+0x3c>
	} else if (action == KAD_BACKWARD && kad_is_back(q)) {
 804648e:	785a      	ldrb	r2, [r3, #1]
 8046490:	07d2      	lsls	r2, r2, #31
 8046492:	d5c3      	bpl.n	804641c <kad_op_sigm+0x3c>
		for (i = 0; i < n; ++i)
 8046494:	2e00      	cmp	r6, #0
 8046496:	ddc1      	ble.n	804641c <kad_op_sigm+0x3c>
 8046498:	e9d5 210a 	ldrd	r2, r1, [r5, #40]	@ 0x28
			q->g[i] += p->g[i] * (p->x[i] * (1.0f - p->x[i]));
 804649c:	eef7 5a00 	vmov.f32	s11, #112	@ 0x3f800000  1.0
 80464a0:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80464a2:	eb03 0686 	add.w	r6, r3, r6, lsl #2
 80464a6:	ecf2 6a01 	vldmia	r2!, {s13}
 80464aa:	ee35 7ae6 	vsub.f32	s14, s11, s13
 80464ae:	edd3 7a00 	vldr	s15, [r3]
 80464b2:	ecb1 6a01 	vldmia	r1!, {s12}
 80464b6:	ee27 7a26 	vmul.f32	s14, s14, s13
 80464ba:	eee6 7a07 	vfma.f32	s15, s12, s14
 80464be:	ece3 7a01 	vstmia	r3!, {s15}
		for (i = 0; i < n; ++i)
 80464c2:	429e      	cmp	r6, r3
 80464c4:	d1ef      	bne.n	80464a6 <kad_op_sigm+0xc6>
 80464c6:	e7a9      	b.n	804641c <kad_op_sigm+0x3c>
 80464c8:	2601      	movs	r6, #1
 80464ca:	e7c4      	b.n	8046456 <kad_op_sigm+0x76>

080464cc <kad_op_tanh>:
{
 80464cc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80464d0:	ed2d 8b04 	vpush	{d8-d9}
	kad_node_t *q = p->child[0];
 80464d4:	6b83      	ldr	r3, [r0, #56]	@ 0x38
{
 80464d6:	4605      	mov	r5, r0
	kad_node_t *q = p->child[0];
 80464d8:	681b      	ldr	r3, [r3, #0]
	for (i = 0; i < p->n_d; ++i) n *= p->d[i];
 80464da:	781c      	ldrb	r4, [r3, #0]
 80464dc:	b33c      	cbz	r4, 804652e <kad_op_tanh+0x62>
 80464de:	2c01      	cmp	r4, #1
 80464e0:	691e      	ldr	r6, [r3, #16]
 80464e2:	d00c      	beq.n	80464fe <kad_op_tanh+0x32>
 80464e4:	695a      	ldr	r2, [r3, #20]
 80464e6:	2c02      	cmp	r4, #2
 80464e8:	fb02 f606 	mul.w	r6, r2, r6
 80464ec:	d007      	beq.n	80464fe <kad_op_tanh+0x32>
 80464ee:	699a      	ldr	r2, [r3, #24]
 80464f0:	2c03      	cmp	r4, #3
 80464f2:	fb02 f606 	mul.w	r6, r2, r6
 80464f6:	d002      	beq.n	80464fe <kad_op_tanh+0x32>
 80464f8:	69da      	ldr	r2, [r3, #28]
 80464fa:	fb02 f606 	mul.w	r6, r2, r6
	if (action == KAD_SYNC_DIM) {
 80464fe:	2904      	cmp	r1, #4
 8046500:	d008      	beq.n	8046514 <kad_op_tanh+0x48>
	} else if (action == KAD_FORWARD) {
 8046502:	2902      	cmp	r1, #2
 8046504:	d01e      	beq.n	8046544 <kad_op_tanh+0x78>
	} else if (action == KAD_BACKWARD && kad_is_back(q)) {
 8046506:	2903      	cmp	r1, #3
 8046508:	d048      	beq.n	804659c <kad_op_tanh+0xd0>
}
 804650a:	ecbd 8b04 	vpop	{d8-d9}
 804650e:	2000      	movs	r0, #0
 8046510:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	dst->n_d = src->n_d;
 8046514:	4628      	mov	r0, r5
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 8046516:	00a2      	lsls	r2, r4, #2
 8046518:	f103 0110 	add.w	r1, r3, #16
	dst->n_d = src->n_d;
 804651c:	f800 4b10 	strb.w	r4, [r0], #16
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 8046520:	f005 fd49 	bl	804bfb6 <memcpy>
}
 8046524:	ecbd 8b04 	vpop	{d8-d9}
 8046528:	2000      	movs	r0, #0
 804652a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (action == KAD_SYNC_DIM) {
 804652e:	2904      	cmp	r1, #4
 8046530:	d032      	beq.n	8046598 <kad_op_tanh+0xcc>
	} else if (action == KAD_FORWARD) {
 8046532:	2902      	cmp	r1, #2
 8046534:	d04f      	beq.n	80465d6 <kad_op_tanh+0x10a>
	} else if (action == KAD_BACKWARD && kad_is_back(q)) {
 8046536:	2903      	cmp	r1, #3
 8046538:	d1e7      	bne.n	804650a <kad_op_tanh+0x3e>
 804653a:	785a      	ldrb	r2, [r3, #1]
 804653c:	07d1      	lsls	r1, r2, #31
 804653e:	d5e4      	bpl.n	804650a <kad_op_tanh+0x3e>
	int n = 1, i;
 8046540:	2601      	movs	r6, #1
 8046542:	e030      	b.n	80465a6 <kad_op_tanh+0xda>
		for (i = 0; i < n; ++i) {
 8046544:	2e00      	cmp	r6, #0
 8046546:	dde0      	ble.n	804650a <kad_op_tanh+0x3e>
 8046548:	2400      	movs	r4, #0
			if (q->x[i] < -20.0f) p->x[i] = -1.0f;
 804654a:	eebb 8a04 	vmov.f32	s16, #180	@ 0xc1a00000 -20.0
				y = expf(-2.0f * q->x[i]);
 804654e:	eeb8 9a00 	vmov.f32	s18, #128	@ 0xc0000000 -2.0
				p->x[i] = (1.0f - y) / (1.0f + y);
 8046552:	eef7 8a00 	vmov.f32	s17, #112	@ 0x3f800000  1.0
 8046556:	6a9f      	ldr	r7, [r3, #40]	@ 0x28
 8046558:	e006      	b.n	8046568 <kad_op_tanh+0x9c>
			if (q->x[i] < -20.0f) p->x[i] = -1.0f;
 804655a:	6aab      	ldr	r3, [r5, #40]	@ 0x28
 804655c:	4a1f      	ldr	r2, [pc, #124]	@ (80465dc <kad_op_tanh+0x110>)
 804655e:	4443      	add	r3, r8
 8046560:	601a      	str	r2, [r3, #0]
		for (i = 0; i < n; ++i) {
 8046562:	3401      	adds	r4, #1
 8046564:	42b4      	cmp	r4, r6
 8046566:	dad0      	bge.n	804650a <kad_op_tanh+0x3e>
			if (q->x[i] < -20.0f) p->x[i] = -1.0f;
 8046568:	ecb7 0a01 	vldmia	r7!, {s0}
 804656c:	eeb4 0ac8 	vcmpe.f32	s0, s16
 8046570:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8046574:	ea4f 0884 	mov.w	r8, r4, lsl #2
 8046578:	d4ef      	bmi.n	804655a <kad_op_tanh+0x8e>
				y = expf(-2.0f * q->x[i]);
 804657a:	ee20 0a09 	vmul.f32	s0, s0, s18
 804657e:	f006 fb75 	bl	804cc6c <expf>
				p->x[i] = (1.0f - y) / (1.0f + y);
 8046582:	ee38 7ac0 	vsub.f32	s14, s17, s0
 8046586:	ee30 0a28 	vadd.f32	s0, s0, s17
 804658a:	eec7 7a00 	vdiv.f32	s15, s14, s0
 804658e:	6aab      	ldr	r3, [r5, #40]	@ 0x28
 8046590:	4443      	add	r3, r8
 8046592:	edc3 7a00 	vstr	s15, [r3]
 8046596:	e7e4      	b.n	8046562 <kad_op_tanh+0x96>
	dst->n_d = src->n_d;
 8046598:	7004      	strb	r4, [r0, #0]
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 804659a:	e7b6      	b.n	804650a <kad_op_tanh+0x3e>
	} else if (action == KAD_BACKWARD && kad_is_back(q)) {
 804659c:	785a      	ldrb	r2, [r3, #1]
 804659e:	07d2      	lsls	r2, r2, #31
 80465a0:	d5b3      	bpl.n	804650a <kad_op_tanh+0x3e>
		for (i = 0; i < n; ++i)
 80465a2:	2e00      	cmp	r6, #0
 80465a4:	ddb1      	ble.n	804650a <kad_op_tanh+0x3e>
 80465a6:	e9d5 210a 	ldrd	r2, r1, [r5, #40]	@ 0x28
			q->g[i] += p->g[i] * (1.0f - p->x[i] * p->x[i]);
 80465aa:	eef7 5a00 	vmov.f32	s11, #112	@ 0x3f800000  1.0
 80465ae:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80465b0:	eb03 0686 	add.w	r6, r3, r6, lsl #2
 80465b4:	ecb2 7a01 	vldmia	r2!, {s14}
 80465b8:	eef0 6a65 	vmov.f32	s13, s11
 80465bc:	edd3 7a00 	vldr	s15, [r3]
 80465c0:	ecb1 6a01 	vldmia	r1!, {s12}
 80465c4:	eee7 6a47 	vfms.f32	s13, s14, s14
 80465c8:	eee6 7a26 	vfma.f32	s15, s12, s13
 80465cc:	ece3 7a01 	vstmia	r3!, {s15}
		for (i = 0; i < n; ++i)
 80465d0:	429e      	cmp	r6, r3
 80465d2:	d1ef      	bne.n	80465b4 <kad_op_tanh+0xe8>
 80465d4:	e799      	b.n	804650a <kad_op_tanh+0x3e>
 80465d6:	2601      	movs	r6, #1
 80465d8:	e7b6      	b.n	8046548 <kad_op_tanh+0x7c>
 80465da:	bf00      	nop
 80465dc:	bf800000 	.word	0xbf800000

080465e0 <kad_op_softmax>:
{
 80465e0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80465e4:	ed2d 8b04 	vpush	{d8-d9}
	kad_node_t *q = p->child[0];
 80465e8:	6b83      	ldr	r3, [r0, #56]	@ 0x38
{
 80465ea:	b085      	sub	sp, #20
	kad_node_t *q = p->child[0];
 80465ec:	681b      	ldr	r3, [r3, #0]
	n1 = q->d[q->n_d - 1];
 80465ee:	781c      	ldrb	r4, [r3, #0]
 80465f0:	1ce2      	adds	r2, r4, #3
 80465f2:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80465f6:	9202      	str	r2, [sp, #8]
	for (i = 0; i < p->n_d; ++i) n *= p->d[i];
 80465f8:	2c00      	cmp	r4, #0
 80465fa:	d076      	beq.n	80466ea <kad_op_softmax+0x10a>
 80465fc:	2c01      	cmp	r4, #1
 80465fe:	691d      	ldr	r5, [r3, #16]
 8046600:	d00c      	beq.n	804661c <kad_op_softmax+0x3c>
 8046602:	695a      	ldr	r2, [r3, #20]
 8046604:	2c02      	cmp	r4, #2
 8046606:	fb02 f505 	mul.w	r5, r2, r5
 804660a:	d007      	beq.n	804661c <kad_op_softmax+0x3c>
 804660c:	699a      	ldr	r2, [r3, #24]
 804660e:	2c03      	cmp	r4, #3
 8046610:	fb02 f505 	mul.w	r5, r2, r5
 8046614:	d002      	beq.n	804661c <kad_op_softmax+0x3c>
 8046616:	69da      	ldr	r2, [r3, #28]
 8046618:	fb02 f505 	mul.w	r5, r2, r5
	if (action == KAD_SYNC_DIM) {
 804661c:	2904      	cmp	r1, #4
 804661e:	d057      	beq.n	80466d0 <kad_op_softmax+0xf0>
	d0 = kad_len(q) / n1;
 8046620:	9a02      	ldr	r2, [sp, #8]
 8046622:	fb95 f2f2 	sdiv	r2, r5, r2
 8046626:	9203      	str	r2, [sp, #12]
	} else if (action == KAD_FORWARD) {
 8046628:	2902      	cmp	r1, #2
 804662a:	d007      	beq.n	804663c <kad_op_softmax+0x5c>
	} else if (action == KAD_BACKWARD && kad_is_back(q)) {
 804662c:	2903      	cmp	r1, #3
 804662e:	d068      	beq.n	8046702 <kad_op_softmax+0x122>
}
 8046630:	2000      	movs	r0, #0
 8046632:	b005      	add	sp, #20
 8046634:	ecbd 8b04 	vpop	{d8-d9}
 8046638:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		for (j = 0; j < d0; ++j) {
 804663c:	9a03      	ldr	r2, [sp, #12]
 804663e:	2a00      	cmp	r2, #0
 8046640:	ddf6      	ble.n	8046630 <kad_op_softmax+0x50>
 8046642:	9a02      	ldr	r2, [sp, #8]
 8046644:	6a81      	ldr	r1, [r0, #40]	@ 0x28
 8046646:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8046648:	eb01 0982 	add.w	r9, r1, r2, lsl #2
 804664c:	eb03 0882 	add.w	r8, r3, r2, lsl #2
			for (i = 0, s = 1.0f / s; i < n1; ++i) y[i] *= s;
 8046650:	eeb7 9a00 	vmov.f32	s18, #112	@ 0x3f800000  1.0
 8046654:	464c      	mov	r4, r9
 8046656:	4645      	mov	r5, r8
		for (j = 0; j < d0; ++j) {
 8046658:	2700      	movs	r7, #0
 804665a:	9101      	str	r1, [sp, #4]
 804665c:	0096      	lsls	r6, r2, #2
			for (i = 0, max = -FLT_MAX; i < n1; ++i)
 804665e:	9a02      	ldr	r2, [sp, #8]
 8046660:	2a00      	cmp	r2, #0
 8046662:	dd29      	ble.n	80466b8 <kad_op_softmax+0xd8>
 8046664:	ed9f 8a47 	vldr	s16, [pc, #284]	@ 8046784 <kad_op_softmax+0x1a4>
 8046668:	4619      	mov	r1, r3
				max = max > x[i]? max : x[i];
 804666a:	ecf1 7a01 	vldmia	r1!, {s15}
 804666e:	eef4 7ac8 	vcmpe.f32	s15, s16
 8046672:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8046676:	bf58      	it	pl
 8046678:	eeb0 8a67 	vmovpl.f32	s16, s15
			for (i = 0, max = -FLT_MAX; i < n1; ++i)
 804667c:	428d      	cmp	r5, r1
 804667e:	d1f4      	bne.n	804666a <kad_op_softmax+0x8a>
 8046680:	469b      	mov	fp, r3
			for (i = 0, s = 0.0f; i < n1; ++i) {
 8046682:	eddf 8a41 	vldr	s17, [pc, #260]	@ 8046788 <kad_op_softmax+0x1a8>
			for (i = 0, max = -FLT_MAX; i < n1; ++i)
 8046686:	f8dd a004 	ldr.w	sl, [sp, #4]
				y[i] = expf(x[i] - max);
 804668a:	ecbb 0a01 	vldmia	fp!, {s0}
 804668e:	ee30 0a48 	vsub.f32	s0, s0, s16
 8046692:	f006 faeb 	bl	804cc6c <expf>
			for (i = 0, s = 0.0f; i < n1; ++i) {
 8046696:	45ab      	cmp	fp, r5
				y[i] = expf(x[i] - max);
 8046698:	ecaa 0a01 	vstmia	sl!, {s0}
				s += y[i];
 804669c:	ee78 8a80 	vadd.f32	s17, s17, s0
			for (i = 0, s = 0.0f; i < n1; ++i) {
 80466a0:	d1f3      	bne.n	804668a <kad_op_softmax+0xaa>
			for (i = 0, s = 1.0f / s; i < n1; ++i) y[i] *= s;
 80466a2:	ee89 7a28 	vdiv.f32	s14, s18, s17
 80466a6:	9b01      	ldr	r3, [sp, #4]
 80466a8:	edd3 7a00 	vldr	s15, [r3]
 80466ac:	ee67 7a87 	vmul.f32	s15, s15, s14
 80466b0:	ece3 7a01 	vstmia	r3!, {s15}
 80466b4:	429c      	cmp	r4, r3
 80466b6:	d1f7      	bne.n	80466a8 <kad_op_softmax+0xc8>
		for (j = 0; j < d0; ++j) {
 80466b8:	9a03      	ldr	r2, [sp, #12]
 80466ba:	3701      	adds	r7, #1
 80466bc:	42ba      	cmp	r2, r7
 80466be:	4643      	mov	r3, r8
 80466c0:	f8cd 9004 	str.w	r9, [sp, #4]
 80466c4:	4434      	add	r4, r6
 80466c6:	4435      	add	r5, r6
 80466c8:	d0b2      	beq.n	8046630 <kad_op_softmax+0x50>
 80466ca:	44b1      	add	r9, r6
 80466cc:	44b0      	add	r8, r6
 80466ce:	e7c6      	b.n	804665e <kad_op_softmax+0x7e>
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 80466d0:	00a2      	lsls	r2, r4, #2
 80466d2:	f103 0110 	add.w	r1, r3, #16
	dst->n_d = src->n_d;
 80466d6:	f800 4b10 	strb.w	r4, [r0], #16
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 80466da:	f005 fc6c 	bl	804bfb6 <memcpy>
}
 80466de:	2000      	movs	r0, #0
 80466e0:	b005      	add	sp, #20
 80466e2:	ecbd 8b04 	vpop	{d8-d9}
 80466e6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (action == KAD_SYNC_DIM) {
 80466ea:	2904      	cmp	r1, #4
 80466ec:	d007      	beq.n	80466fe <kad_op_softmax+0x11e>
 80466ee:	4614      	mov	r4, r2
	d0 = kad_len(q) / n1;
 80466f0:	3201      	adds	r2, #1
 80466f2:	2a02      	cmp	r2, #2
 80466f4:	bf94      	ite	ls
 80466f6:	4622      	movls	r2, r4
 80466f8:	2200      	movhi	r2, #0
 80466fa:	9203      	str	r2, [sp, #12]
 80466fc:	e794      	b.n	8046628 <kad_op_softmax+0x48>
	dst->n_d = src->n_d;
 80466fe:	7004      	strb	r4, [r0, #0]
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 8046700:	e796      	b.n	8046630 <kad_op_softmax+0x50>
	} else if (action == KAD_BACKWARD && kad_is_back(q)) {
 8046702:	785a      	ldrb	r2, [r3, #1]
 8046704:	07d2      	lsls	r2, r2, #31
 8046706:	d593      	bpl.n	8046630 <kad_op_softmax+0x50>
		for (j = 0; j < d0; ++j) {
 8046708:	9a03      	ldr	r2, [sp, #12]
 804670a:	2a00      	cmp	r2, #0
 804670c:	dd90      	ble.n	8046630 <kad_op_softmax+0x50>
 804670e:	e9d0 620a 	ldrd	r6, r2, [r0, #40]	@ 0x28
			float s, *g = &p->g[j * n1], *y = &p->x[j * n1], *h = &q->g[j * n1];
 8046712:	f04f 0c00 	mov.w	ip, #0
 8046716:	f8d3 802c 	ldr.w	r8, [r3, #44]	@ 0x2c
 804671a:	9b02      	ldr	r3, [sp, #8]
		for (j = 0; j < d0; ++j) {
 804671c:	4667      	mov	r7, ip
 804671e:	eb02 0e83 	add.w	lr, r2, r3, lsl #2
 8046722:	4670      	mov	r0, lr
 8046724:	009c      	lsls	r4, r3, #2
 8046726:	eb08 0183 	add.w	r1, r8, r3, lsl #2
			for (i = 0, s = 0.0f; i < n1; ++i)
 804672a:	9b02      	ldr	r3, [sp, #8]
 804672c:	2b00      	cmp	r3, #0
 804672e:	dd1c      	ble.n	804676a <kad_op_softmax+0x18a>
 8046730:	eddf 6a15 	vldr	s13, [pc, #84]	@ 8046788 <kad_op_softmax+0x1a8>
 8046734:	46b1      	mov	r9, r6
 8046736:	4613      	mov	r3, r2
				s += g[i] * y[i];
 8046738:	ecb3 7a01 	vldmia	r3!, {s14}
 804673c:	ecf9 7a01 	vldmia	r9!, {s15}
			for (i = 0, s = 0.0f; i < n1; ++i)
 8046740:	4283      	cmp	r3, r0
				s += g[i] * y[i];
 8046742:	eee7 6a27 	vfma.f32	s13, s14, s15
			for (i = 0, s = 0.0f; i < n1; ++i)
 8046746:	d1f7      	bne.n	8046738 <kad_op_softmax+0x158>
 8046748:	46b1      	mov	r9, r6
 804674a:	eb0c 0308 	add.w	r3, ip, r8
				h[i] += y[i] * (g[i] - s);
 804674e:	ecb2 7a01 	vldmia	r2!, {s14}
 8046752:	edd3 7a00 	vldr	s15, [r3]
 8046756:	ecb9 6a01 	vldmia	r9!, {s12}
 804675a:	ee37 7a66 	vsub.f32	s14, s14, s13
 804675e:	eee6 7a07 	vfma.f32	s15, s12, s14
 8046762:	ece3 7a01 	vstmia	r3!, {s15}
			for (i = 0; i < n1; ++i)
 8046766:	428b      	cmp	r3, r1
 8046768:	d1f1      	bne.n	804674e <kad_op_softmax+0x16e>
		for (j = 0; j < d0; ++j) {
 804676a:	9b03      	ldr	r3, [sp, #12]
 804676c:	3701      	adds	r7, #1
 804676e:	42bb      	cmp	r3, r7
 8046770:	4672      	mov	r2, lr
 8046772:	4426      	add	r6, r4
 8046774:	44a4      	add	ip, r4
 8046776:	4421      	add	r1, r4
 8046778:	4420      	add	r0, r4
 804677a:	f43f af59 	beq.w	8046630 <kad_op_softmax+0x50>
 804677e:	44a6      	add	lr, r4
 8046780:	e7d3      	b.n	804672a <kad_op_softmax+0x14a>
 8046782:	bf00      	nop
 8046784:	ff7fffff 	.word	0xff7fffff
 8046788:	00000000 	.word	0x00000000

0804678c <kad_op_log>:
{
 804678c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	kad_node_t *q = p->child[0];
 804678e:	6b83      	ldr	r3, [r0, #56]	@ 0x38
 8046790:	681b      	ldr	r3, [r3, #0]
 8046792:	781d      	ldrb	r5, [r3, #0]
 8046794:	b305      	cbz	r5, 80467d8 <kad_op_log+0x4c>
 8046796:	2d01      	cmp	r5, #1
 8046798:	691c      	ldr	r4, [r3, #16]
 804679a:	d00c      	beq.n	80467b6 <kad_op_log+0x2a>
 804679c:	695a      	ldr	r2, [r3, #20]
 804679e:	2d02      	cmp	r5, #2
 80467a0:	fb02 f404 	mul.w	r4, r2, r4
 80467a4:	d007      	beq.n	80467b6 <kad_op_log+0x2a>
 80467a6:	699a      	ldr	r2, [r3, #24]
 80467a8:	2d03      	cmp	r5, #3
 80467aa:	fb02 f404 	mul.w	r4, r2, r4
 80467ae:	d002      	beq.n	80467b6 <kad_op_log+0x2a>
 80467b0:	69da      	ldr	r2, [r3, #28]
 80467b2:	fb02 f404 	mul.w	r4, r2, r4
	if (action == KAD_SYNC_DIM) {
 80467b6:	2904      	cmp	r1, #4
 80467b8:	d005      	beq.n	80467c6 <kad_op_log+0x3a>
	} else if (action == KAD_FORWARD) {
 80467ba:	2902      	cmp	r1, #2
 80467bc:	d017      	beq.n	80467ee <kad_op_log+0x62>
	} else if (action == KAD_BACKWARD && kad_is_back(q)) {
 80467be:	2903      	cmp	r1, #3
 80467c0:	d027      	beq.n	8046812 <kad_op_log+0x86>
}
 80467c2:	2000      	movs	r0, #0
 80467c4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 80467c6:	00aa      	lsls	r2, r5, #2
 80467c8:	f103 0110 	add.w	r1, r3, #16
	dst->n_d = src->n_d;
 80467cc:	f800 5b10 	strb.w	r5, [r0], #16
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 80467d0:	f005 fbf1 	bl	804bfb6 <memcpy>
}
 80467d4:	2000      	movs	r0, #0
 80467d6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (action == KAD_SYNC_DIM) {
 80467d8:	2904      	cmp	r1, #4
 80467da:	d018      	beq.n	804680e <kad_op_log+0x82>
	} else if (action == KAD_FORWARD) {
 80467dc:	2902      	cmp	r1, #2
 80467de:	d031      	beq.n	8046844 <kad_op_log+0xb8>
	} else if (action == KAD_BACKWARD && kad_is_back(q)) {
 80467e0:	2903      	cmp	r1, #3
 80467e2:	d1ee      	bne.n	80467c2 <kad_op_log+0x36>
 80467e4:	785a      	ldrb	r2, [r3, #1]
 80467e6:	07d1      	lsls	r1, r2, #31
 80467e8:	d5eb      	bpl.n	80467c2 <kad_op_log+0x36>
	int n = 1, i;
 80467ea:	2401      	movs	r4, #1
 80467ec:	e016      	b.n	804681c <kad_op_log+0x90>
		for (i = 0; i < n; ++i) p->x[i] = logf(q->x[i]);
 80467ee:	2c00      	cmp	r4, #0
 80467f0:	dde7      	ble.n	80467c2 <kad_op_log+0x36>
 80467f2:	2500      	movs	r5, #0
 80467f4:	6a9f      	ldr	r7, [r3, #40]	@ 0x28
 80467f6:	6a86      	ldr	r6, [r0, #40]	@ 0x28
 80467f8:	ecb7 0a01 	vldmia	r7!, {s0}
 80467fc:	f006 fa6c 	bl	804ccd8 <logf>
 8046800:	3501      	adds	r5, #1
 8046802:	42a5      	cmp	r5, r4
 8046804:	eca6 0a01 	vstmia	r6!, {s0}
 8046808:	dbf6      	blt.n	80467f8 <kad_op_log+0x6c>
}
 804680a:	2000      	movs	r0, #0
 804680c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	dst->n_d = src->n_d;
 804680e:	7005      	strb	r5, [r0, #0]
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 8046810:	e7d7      	b.n	80467c2 <kad_op_log+0x36>
	} else if (action == KAD_BACKWARD && kad_is_back(q)) {
 8046812:	785a      	ldrb	r2, [r3, #1]
 8046814:	07d2      	lsls	r2, r2, #31
 8046816:	d5d4      	bpl.n	80467c2 <kad_op_log+0x36>
		for (i = 0; i < n; ++i)
 8046818:	2c00      	cmp	r4, #0
 804681a:	ddd2      	ble.n	80467c2 <kad_op_log+0x36>
 804681c:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 804681e:	6ac1      	ldr	r1, [r0, #44]	@ 0x2c
 8046820:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8046822:	eb02 0484 	add.w	r4, r2, r4, lsl #2
			q->g[i] += p->g[i] / q->x[i];
 8046826:	ecb1 6a01 	vldmia	r1!, {s12}
 804682a:	ecf3 6a01 	vldmia	r3!, {s13}
 804682e:	ed92 7a00 	vldr	s14, [r2]
 8046832:	eec6 7a26 	vdiv.f32	s15, s12, s13
 8046836:	ee77 7a87 	vadd.f32	s15, s15, s14
 804683a:	ece2 7a01 	vstmia	r2!, {s15}
		for (i = 0; i < n; ++i)
 804683e:	4294      	cmp	r4, r2
 8046840:	d1f1      	bne.n	8046826 <kad_op_log+0x9a>
 8046842:	e7be      	b.n	80467c2 <kad_op_log+0x36>
 8046844:	2401      	movs	r4, #1
 8046846:	e7d4      	b.n	80467f2 <kad_op_log+0x66>

08046848 <kad_op_sin>:
{
 8046848:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	kad_node_t *q = p->child[0];
 804684a:	6b83      	ldr	r3, [r0, #56]	@ 0x38
 804684c:	681b      	ldr	r3, [r3, #0]
	for (i = 0; i < p->n_d; ++i) n *= p->d[i];
 804684e:	781d      	ldrb	r5, [r3, #0]
 8046850:	b305      	cbz	r5, 8046894 <kad_op_sin+0x4c>
 8046852:	2d01      	cmp	r5, #1
 8046854:	691c      	ldr	r4, [r3, #16]
 8046856:	d00c      	beq.n	8046872 <kad_op_sin+0x2a>
 8046858:	695a      	ldr	r2, [r3, #20]
 804685a:	2d02      	cmp	r5, #2
 804685c:	fb02 f404 	mul.w	r4, r2, r4
 8046860:	d007      	beq.n	8046872 <kad_op_sin+0x2a>
 8046862:	699a      	ldr	r2, [r3, #24]
 8046864:	2d03      	cmp	r5, #3
 8046866:	fb02 f404 	mul.w	r4, r2, r4
 804686a:	d002      	beq.n	8046872 <kad_op_sin+0x2a>
 804686c:	69da      	ldr	r2, [r3, #28]
 804686e:	fb02 f404 	mul.w	r4, r2, r4
	if (action == KAD_SYNC_DIM) {
 8046872:	2904      	cmp	r1, #4
 8046874:	d005      	beq.n	8046882 <kad_op_sin+0x3a>
	} else if (action == KAD_FORWARD) {
 8046876:	2902      	cmp	r1, #2
 8046878:	d017      	beq.n	80468aa <kad_op_sin+0x62>
	} else if (action == KAD_BACKWARD && kad_is_back(q)) {
 804687a:	2903      	cmp	r1, #3
 804687c:	d027      	beq.n	80468ce <kad_op_sin+0x86>
}
 804687e:	2000      	movs	r0, #0
 8046880:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 8046882:	00aa      	lsls	r2, r5, #2
 8046884:	f103 0110 	add.w	r1, r3, #16
	dst->n_d = src->n_d;
 8046888:	f800 5b10 	strb.w	r5, [r0], #16
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 804688c:	f005 fb93 	bl	804bfb6 <memcpy>
}
 8046890:	2000      	movs	r0, #0
 8046892:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (action == KAD_SYNC_DIM) {
 8046894:	2904      	cmp	r1, #4
 8046896:	d018      	beq.n	80468ca <kad_op_sin+0x82>
	} else if (action == KAD_FORWARD) {
 8046898:	2902      	cmp	r1, #2
 804689a:	d031      	beq.n	8046900 <kad_op_sin+0xb8>
	} else if (action == KAD_BACKWARD && kad_is_back(q)) {
 804689c:	2903      	cmp	r1, #3
 804689e:	d1ee      	bne.n	804687e <kad_op_sin+0x36>
 80468a0:	785a      	ldrb	r2, [r3, #1]
 80468a2:	07d1      	lsls	r1, r2, #31
 80468a4:	d5eb      	bpl.n	804687e <kad_op_sin+0x36>
	int n = 1, i;
 80468a6:	2401      	movs	r4, #1
 80468a8:	e016      	b.n	80468d8 <kad_op_sin+0x90>
		for (i = 0; i < n; ++i) p->x[i] = sinf(q->x[i]);
 80468aa:	2c00      	cmp	r4, #0
 80468ac:	dde7      	ble.n	804687e <kad_op_sin+0x36>
 80468ae:	2500      	movs	r5, #0
 80468b0:	6a9f      	ldr	r7, [r3, #40]	@ 0x28
 80468b2:	6a86      	ldr	r6, [r0, #40]	@ 0x28
 80468b4:	ecb7 0a01 	vldmia	r7!, {s0}
 80468b8:	f006 fa9e 	bl	804cdf8 <sinf>
 80468bc:	3501      	adds	r5, #1
 80468be:	42a5      	cmp	r5, r4
 80468c0:	eca6 0a01 	vstmia	r6!, {s0}
 80468c4:	dbf6      	blt.n	80468b4 <kad_op_sin+0x6c>
}
 80468c6:	2000      	movs	r0, #0
 80468c8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	dst->n_d = src->n_d;
 80468ca:	7005      	strb	r5, [r0, #0]
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 80468cc:	e7d7      	b.n	804687e <kad_op_sin+0x36>
	} else if (action == KAD_BACKWARD && kad_is_back(q)) {
 80468ce:	785a      	ldrb	r2, [r3, #1]
 80468d0:	07d2      	lsls	r2, r2, #31
 80468d2:	d5d4      	bpl.n	804687e <kad_op_sin+0x36>
		for (i = 0; i < n; ++i)
 80468d4:	2c00      	cmp	r4, #0
 80468d6:	ddd2      	ble.n	804687e <kad_op_sin+0x36>
 80468d8:	6add      	ldr	r5, [r3, #44]	@ 0x2c
 80468da:	6ac7      	ldr	r7, [r0, #44]	@ 0x2c
 80468dc:	6a9e      	ldr	r6, [r3, #40]	@ 0x28
 80468de:	eb05 0484 	add.w	r4, r5, r4, lsl #2
			q->g[i] += p->g[i] * cosf(q->x[i]);
 80468e2:	ecb6 0a01 	vldmia	r6!, {s0}
 80468e6:	f006 fa43 	bl	804cd70 <cosf>
 80468ea:	edd5 7a00 	vldr	s15, [r5]
 80468ee:	ecb7 7a01 	vldmia	r7!, {s14}
 80468f2:	eee7 7a00 	vfma.f32	s15, s14, s0
 80468f6:	ece5 7a01 	vstmia	r5!, {s15}
		for (i = 0; i < n; ++i)
 80468fa:	42ac      	cmp	r4, r5
 80468fc:	d1f1      	bne.n	80468e2 <kad_op_sin+0x9a>
 80468fe:	e7be      	b.n	804687e <kad_op_sin+0x36>
 8046900:	2401      	movs	r4, #1
 8046902:	e7d4      	b.n	80468ae <kad_op_sin+0x66>

08046904 <kad_allocate_internal>:
{
 8046904:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	for (i = 0; i < n; ++i) {
 8046908:	1e06      	subs	r6, r0, #0
 804690a:	dd65      	ble.n	80469d8 <kad_allocate_internal+0xd4>
 804690c:	1f0d      	subs	r5, r1, #4
 804690e:	462f      	mov	r7, r5
 8046910:	eb05 0c86 	add.w	ip, r5, r6, lsl #2
 8046914:	e001      	b.n	804691a <kad_allocate_internal+0x16>
 8046916:	4567      	cmp	r7, ip
 8046918:	d019      	beq.n	804694e <kad_allocate_internal+0x4a>
		if (v[i]->n_child == 0) continue;
 804691a:	f857 4f04 	ldr.w	r4, [r7, #4]!
 804691e:	6860      	ldr	r0, [r4, #4]
 8046920:	2800      	cmp	r0, #0
 8046922:	d0f8      	beq.n	8046916 <kad_allocate_internal+0x12>
		for (j = 0; j < v[i]->n_child; ++j)
 8046924:	dd5a      	ble.n	80469dc <kad_allocate_internal+0xd8>
 8046926:	6ba2      	ldr	r2, [r4, #56]	@ 0x38
 8046928:	2300      	movs	r3, #0
 804692a:	3a04      	subs	r2, #4
 804692c:	e002      	b.n	8046934 <kad_allocate_internal+0x30>
 804692e:	3301      	adds	r3, #1
 8046930:	4298      	cmp	r0, r3
 8046932:	d053      	beq.n	80469dc <kad_allocate_internal+0xd8>
			if (kad_is_back(v[i]->child[j]))
 8046934:	f852 1f04 	ldr.w	r1, [r2, #4]!
 8046938:	7849      	ldrb	r1, [r1, #1]
 804693a:	07c9      	lsls	r1, r1, #31
 804693c:	d5f7      	bpl.n	804692e <kad_allocate_internal+0x2a>
		if (j < v[i]->n_child) v[i]->flag |= KAD_VAR;
 804693e:	4298      	cmp	r0, r3
 8046940:	dd4c      	ble.n	80469dc <kad_allocate_internal+0xd8>
 8046942:	7863      	ldrb	r3, [r4, #1]
	for (i = 0; i < n; ++i) {
 8046944:	4567      	cmp	r7, ip
		if (j < v[i]->n_child) v[i]->flag |= KAD_VAR;
 8046946:	f043 0301 	orr.w	r3, r3, #1
 804694a:	7063      	strb	r3, [r4, #1]
	for (i = 0; i < n; ++i) {
 804694c:	d1e5      	bne.n	804691a <kad_allocate_internal+0x16>
	for (i = 0; i < n; ++i) {
 804694e:	2700      	movs	r7, #0
			kad_op_list[p->op](p, KAD_ALLOC);
 8046950:	f8df 809c 	ldr.w	r8, [pc, #156]	@ 80469f0 <kad_allocate_internal+0xec>
 8046954:	e002      	b.n	804695c <kad_allocate_internal+0x58>
	for (i = 0; i < n; ++i) {
 8046956:	3701      	adds	r7, #1
 8046958:	42be      	cmp	r6, r7
 804695a:	d03d      	beq.n	80469d8 <kad_allocate_internal+0xd4>
		kad_node_t *p = v[i];
 804695c:	f855 4f04 	ldr.w	r4, [r5, #4]!
		if (p->n_child == 0) continue;
 8046960:	6863      	ldr	r3, [r4, #4]
 8046962:	2b00      	cmp	r3, #0
 8046964:	d0f7      	beq.n	8046956 <kad_allocate_internal+0x52>
	for (i = 0; i < p->n_d; ++i) n *= p->d[i];
 8046966:	7823      	ldrb	r3, [r4, #0]
		p->x = (float*)realloc(p->x, kad_len(p) * sizeof(float));
 8046968:	6aa0      	ldr	r0, [r4, #40]	@ 0x28
 804696a:	2b00      	cmp	r3, #0
 804696c:	d03b      	beq.n	80469e6 <kad_allocate_internal+0xe2>
 804696e:	2b01      	cmp	r3, #1
 8046970:	6921      	ldr	r1, [r4, #16]
 8046972:	d00b      	beq.n	804698c <kad_allocate_internal+0x88>
 8046974:	6962      	ldr	r2, [r4, #20]
 8046976:	2b02      	cmp	r3, #2
 8046978:	fb02 f101 	mul.w	r1, r2, r1
 804697c:	d006      	beq.n	804698c <kad_allocate_internal+0x88>
 804697e:	69a2      	ldr	r2, [r4, #24]
 8046980:	2b03      	cmp	r3, #3
 8046982:	fb02 f101 	mul.w	r1, r2, r1
 8046986:	bf1c      	itt	ne
 8046988:	69e3      	ldrne	r3, [r4, #28]
 804698a:	4359      	mulne	r1, r3
 804698c:	0089      	lsls	r1, r1, #2
 804698e:	f005 f813 	bl	804b9b8 <realloc>
		if (kad_is_back(p)) {
 8046992:	7863      	ldrb	r3, [r4, #1]
		p->x = (float*)realloc(p->x, kad_len(p) * sizeof(float));
 8046994:	62a0      	str	r0, [r4, #40]	@ 0x28
		if (kad_is_back(p)) {
 8046996:	07db      	lsls	r3, r3, #31
 8046998:	d5dd      	bpl.n	8046956 <kad_allocate_internal+0x52>
 804699a:	7823      	ldrb	r3, [r4, #0]
			p->g = (float*)realloc(p->g, kad_len(p) * sizeof(float));
 804699c:	6ae0      	ldr	r0, [r4, #44]	@ 0x2c
 804699e:	b323      	cbz	r3, 80469ea <kad_allocate_internal+0xe6>
 80469a0:	2b01      	cmp	r3, #1
 80469a2:	6921      	ldr	r1, [r4, #16]
 80469a4:	d00b      	beq.n	80469be <kad_allocate_internal+0xba>
 80469a6:	6962      	ldr	r2, [r4, #20]
 80469a8:	2b02      	cmp	r3, #2
 80469aa:	fb02 f101 	mul.w	r1, r2, r1
 80469ae:	d006      	beq.n	80469be <kad_allocate_internal+0xba>
 80469b0:	69a2      	ldr	r2, [r4, #24]
 80469b2:	2b03      	cmp	r3, #3
 80469b4:	fb02 f101 	mul.w	r1, r2, r1
 80469b8:	bf1c      	itt	ne
 80469ba:	69e3      	ldrne	r3, [r4, #28]
 80469bc:	4359      	mulne	r1, r3
 80469be:	0089      	lsls	r1, r1, #2
 80469c0:	f004 fffa 	bl	804b9b8 <realloc>
			kad_op_list[p->op](p, KAD_ALLOC);
 80469c4:	8863      	ldrh	r3, [r4, #2]
			p->g = (float*)realloc(p->g, kad_len(p) * sizeof(float));
 80469c6:	62e0      	str	r0, [r4, #44]	@ 0x2c
			kad_op_list[p->op](p, KAD_ALLOC);
 80469c8:	2101      	movs	r1, #1
 80469ca:	4620      	mov	r0, r4
 80469cc:	f858 3023 	ldr.w	r3, [r8, r3, lsl #2]
	for (i = 0; i < n; ++i) {
 80469d0:	3701      	adds	r7, #1
			kad_op_list[p->op](p, KAD_ALLOC);
 80469d2:	4798      	blx	r3
	for (i = 0; i < n; ++i) {
 80469d4:	42be      	cmp	r6, r7
 80469d6:	d1c1      	bne.n	804695c <kad_allocate_internal+0x58>
}
 80469d8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		else v[i]->flag &= ~KAD_VAR;
 80469dc:	7863      	ldrb	r3, [r4, #1]
 80469de:	f023 0301 	bic.w	r3, r3, #1
 80469e2:	7063      	strb	r3, [r4, #1]
 80469e4:	e797      	b.n	8046916 <kad_allocate_internal+0x12>
 80469e6:	2104      	movs	r1, #4
 80469e8:	e7d1      	b.n	804698e <kad_allocate_internal+0x8a>
 80469ea:	2104      	movs	r1, #4
 80469ec:	e7e8      	b.n	80469c0 <kad_allocate_internal+0xbc>
 80469ee:	bf00      	nop
 80469f0:	20018004 	.word	0x20018004

080469f4 <kad_op_dropout>:
{
 80469f4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80469f8:	ed2d 8b02 	vpush	{d8}
	kad_node_t *q = p->child[0];
 80469fc:	6b83      	ldr	r3, [r0, #56]	@ 0x38
{
 80469fe:	b087      	sub	sp, #28
	kad_node_t *q = p->child[0];
 8046a00:	e9d3 6200 	ldrd	r6, r2, [r3]
	assert(p->child[1]->n_d == 0);
 8046a04:	7813      	ldrb	r3, [r2, #0]
 8046a06:	2b00      	cmp	r3, #0
 8046a08:	f040 8171 	bne.w	8046cee <kad_op_dropout+0x2fa>
 8046a0c:	7834      	ldrb	r4, [r6, #0]
 8046a0e:	4682      	mov	sl, r0
 8046a10:	2c00      	cmp	r4, #0
 8046a12:	d060      	beq.n	8046ad6 <kad_op_dropout+0xe2>
 8046a14:	2c01      	cmp	r4, #1
 8046a16:	f8d6 b010 	ldr.w	fp, [r6, #16]
 8046a1a:	d00c      	beq.n	8046a36 <kad_op_dropout+0x42>
 8046a1c:	6973      	ldr	r3, [r6, #20]
 8046a1e:	2c02      	cmp	r4, #2
 8046a20:	fb03 fb0b 	mul.w	fp, r3, fp
 8046a24:	d007      	beq.n	8046a36 <kad_op_dropout+0x42>
 8046a26:	69b3      	ldr	r3, [r6, #24]
 8046a28:	2c03      	cmp	r4, #3
 8046a2a:	fb03 fb0b 	mul.w	fp, r3, fp
 8046a2e:	d002      	beq.n	8046a36 <kad_op_dropout+0x42>
 8046a30:	69f3      	ldr	r3, [r6, #28]
 8046a32:	fb03 fb0b 	mul.w	fp, r3, fp
	if (action == KAD_SYNC_DIM) {
 8046a36:	2904      	cmp	r1, #4
 8046a38:	d016      	beq.n	8046a68 <kad_op_dropout+0x74>
	} else if (action == KAD_ALLOC) {
 8046a3a:	2901      	cmp	r1, #1
 8046a3c:	d009      	beq.n	8046a52 <kad_op_dropout+0x5e>
	} else if (action == KAD_FORWARD) {
 8046a3e:	2902      	cmp	r1, #2
 8046a40:	d04f      	beq.n	8046ae2 <kad_op_dropout+0xee>
	} else if (action == KAD_BACKWARD && kad_is_back(p->child[0])) {
 8046a42:	2903      	cmp	r1, #3
 8046a44:	d01e      	beq.n	8046a84 <kad_op_dropout+0x90>
}
 8046a46:	2000      	movs	r0, #0
 8046a48:	b007      	add	sp, #28
 8046a4a:	ecbd 8b02 	vpop	{d8}
 8046a4e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (kad_is_back(p->child[0]))
 8046a52:	7873      	ldrb	r3, [r6, #1]
 8046a54:	07dc      	lsls	r4, r3, #31
 8046a56:	d5f6      	bpl.n	8046a46 <kad_op_dropout+0x52>
			p->gtmp = realloc(p->gtmp, n);
 8046a58:	4659      	mov	r1, fp
 8046a5a:	f8da 0034 	ldr.w	r0, [sl, #52]	@ 0x34
 8046a5e:	f004 ffab 	bl	804b9b8 <realloc>
 8046a62:	f8ca 0034 	str.w	r0, [sl, #52]	@ 0x34
 8046a66:	e7ee      	b.n	8046a46 <kad_op_dropout+0x52>
	dst->n_d = src->n_d;
 8046a68:	4650      	mov	r0, sl
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 8046a6a:	00a2      	lsls	r2, r4, #2
 8046a6c:	f106 0110 	add.w	r1, r6, #16
	dst->n_d = src->n_d;
 8046a70:	f800 4b10 	strb.w	r4, [r0], #16
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 8046a74:	f005 fa9f 	bl	804bfb6 <memcpy>
}
 8046a78:	2000      	movs	r0, #0
 8046a7a:	b007      	add	sp, #28
 8046a7c:	ecbd 8b02 	vpop	{d8}
 8046a80:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	} else if (action == KAD_BACKWARD && kad_is_back(p->child[0])) {
 8046a84:	7873      	ldrb	r3, [r6, #1]
 8046a86:	07d9      	lsls	r1, r3, #31
 8046a88:	d5dd      	bpl.n	8046a46 <kad_op_dropout+0x52>
		float r = kad_is_const(q) || kad_is_var(q)? 0.0f : *p->child[1]->x, z = 1.0f / (1.0f - r);
 8046a8a:	6871      	ldr	r1, [r6, #4]
 8046a8c:	2900      	cmp	r1, #0
 8046a8e:	f040 8122 	bne.w	8046cd6 <kad_op_dropout+0x2e2>
 8046a92:	079b      	lsls	r3, r3, #30
 8046a94:	f000 811f 	beq.w	8046cd6 <kad_op_dropout+0x2e2>
 8046a98:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
		for (i = 0; i < n; ++i)
 8046a9c:	f1bb 0f00 	cmp.w	fp, #0
		uint8_t *flag = (uint8_t*)p->gtmp;
 8046aa0:	f8da 3034 	ldr.w	r3, [sl, #52]	@ 0x34
		for (i = 0; i < n; ++i)
 8046aa4:	ddcf      	ble.n	8046a46 <kad_op_dropout+0x52>
 8046aa6:	2200      	movs	r2, #0
 8046aa8:	3b01      	subs	r3, #1
 8046aaa:	449b      	add	fp, r3
			if (flag[i]) q->g[i] += z * p->g[i];
 8046aac:	f813 1f01 	ldrb.w	r1, [r3, #1]!
 8046ab0:	b161      	cbz	r1, 8046acc <kad_op_dropout+0xd8>
 8046ab2:	6af1      	ldr	r1, [r6, #44]	@ 0x2c
 8046ab4:	f8da 002c 	ldr.w	r0, [sl, #44]	@ 0x2c
 8046ab8:	4411      	add	r1, r2
 8046aba:	4410      	add	r0, r2
 8046abc:	edd1 7a00 	vldr	s15, [r1]
 8046ac0:	ed90 7a00 	vldr	s14, [r0]
 8046ac4:	eee7 7a26 	vfma.f32	s15, s14, s13
 8046ac8:	edc1 7a00 	vstr	s15, [r1]
		for (i = 0; i < n; ++i)
 8046acc:	459b      	cmp	fp, r3
 8046ace:	f102 0204 	add.w	r2, r2, #4
 8046ad2:	d1eb      	bne.n	8046aac <kad_op_dropout+0xb8>
 8046ad4:	e7b7      	b.n	8046a46 <kad_op_dropout+0x52>
	if (action == KAD_SYNC_DIM) {
 8046ad6:	2904      	cmp	r1, #4
 8046ad8:	f000 808d 	beq.w	8046bf6 <kad_op_dropout+0x202>
	int n = 1, i;
 8046adc:	f04f 0b01 	mov.w	fp, #1
 8046ae0:	e7ab      	b.n	8046a3a <kad_op_dropout+0x46>
		float r = kad_is_const(q) || kad_is_var(q)? 0.0f : *p->child[1]->x, z = 1.0f / (1.0f - r);
 8046ae2:	6873      	ldr	r3, [r6, #4]
 8046ae4:	b91b      	cbnz	r3, 8046aee <kad_op_dropout+0xfa>
 8046ae6:	7873      	ldrb	r3, [r6, #1]
 8046ae8:	0798      	lsls	r0, r3, #30
 8046aea:	f040 8086 	bne.w	8046bfa <kad_op_dropout+0x206>
 8046aee:	6a93      	ldr	r3, [r2, #40]	@ 0x28
 8046af0:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 8046af4:	6818      	ldr	r0, [r3, #0]
 8046af6:	ee07 0a10 	vmov	s14, r0
 8046afa:	ee37 7ac7 	vsub.f32	s14, s15, s14
 8046afe:	ee87 8a87 	vdiv.f32	s16, s15, s14
		for (i = 0; i < n; ++i) {
 8046b02:	f1bb 0f00 	cmp.w	fp, #0
		uint8_t *flag = (uint8_t*)p->gtmp;
 8046b06:	f8da 7034 	ldr.w	r7, [sl, #52]	@ 0x34
		for (i = 0; i < n; ++i) {
 8046b0a:	dd9c      	ble.n	8046a46 <kad_op_dropout+0x52>
			int kept = (kad_drand(p->ptr) >= r);
 8046b0c:	f7f9 fcf8 	bl	8040500 <__aeabi_f2d>
 8046b10:	e9cd 0102 	strd	r0, r1, [sp, #8]
 8046b14:	2f00      	cmp	r7, #0
 8046b16:	d074      	beq.n	8046c02 <kad_op_dropout+0x20e>
 8046b18:	2400      	movs	r4, #0
			p->x[i] = kept? q->x[i] * z : 0.0f;
 8046b1a:	eddf 8a78 	vldr	s17, [pc, #480]	@ 8046cfc <kad_op_dropout+0x308>
 8046b1e:	eb07 030b 	add.w	r3, r7, fp
 8046b22:	9300      	str	r3, [sp, #0]
	return u.d - 1.0;
 8046b24:	9604      	str	r6, [sp, #16]
			int kept = (kad_drand(p->ptr) >= r);
 8046b26:	f8da 1030 	ldr.w	r1, [sl, #48]	@ 0x30
	u.i = 0x3FFULL << 52 | kad_xoroshiro128plus_next(d? (kad_rng_t*)d : &kad_rng_dat) >> 12;
 8046b2a:	4b75      	ldr	r3, [pc, #468]	@ (8046d00 <kad_op_dropout+0x30c>)
	return u.d - 1.0;
 8046b2c:	2200      	movs	r2, #0
	u.i = 0x3FFULL << 52 | kad_xoroshiro128plus_next(d? (kad_rng_t*)d : &kad_rng_dat) >> 12;
 8046b2e:	2900      	cmp	r1, #0
 8046b30:	bf08      	it	eq
 8046b32:	4619      	moveq	r1, r3
	const uint64_t s0 = r->s[0];
 8046b34:	f8d1 c000 	ldr.w	ip, [r1]
	const uint64_t result = s0 + s1;
 8046b38:	68ce      	ldr	r6, [r1, #12]
	const uint64_t s0 = r->s[0];
 8046b3a:	e9d1 0b01 	ldrd	r0, fp, [r1, #4]
	const uint64_t result = s0 + s1;
 8046b3e:	eb1c 050b 	adds.w	r5, ip, fp
 8046b42:	eb40 0e06 	adc.w	lr, r0, r6
	u.i = 0x3FFULL << 52 | kad_xoroshiro128plus_next(d? (kad_rng_t*)d : &kad_rng_dat) >> 12;
 8046b46:	0b2d      	lsrs	r5, r5, #12
 8046b48:	ea45 580e 	orr.w	r8, r5, lr, lsl #20
 8046b4c:	ea4f 3e1e 	mov.w	lr, lr, lsr #12
 8046b50:	f04e 597f 	orr.w	r9, lr, #1069547520	@ 0x3fc00000
	r->s[0] = (s0 << 55 | s0 >> 9) ^ s1 ^ (s1 << 14);
 8046b54:	ea4f 2e5c 	mov.w	lr, ip, lsr #9
	s1 ^= s0;
 8046b58:	ea8c 0b0b 	eor.w	fp, ip, fp
	r->s[0] = (s0 << 55 | s0 >> 9) ^ s1 ^ (s1 << 14);
 8046b5c:	ea4e 5ec0 	orr.w	lr, lr, r0, lsl #23
 8046b60:	ea8e 0e0b 	eor.w	lr, lr, fp
 8046b64:	ea8e 3e8b 	eor.w	lr, lr, fp, lsl #14
 8046b68:	f8c1 e000 	str.w	lr, [r1]
 8046b6c:	ea4f 2e50 	mov.w	lr, r0, lsr #9
	s1 ^= s0;
 8046b70:	ea80 0506 	eor.w	r5, r0, r6
	r->s[0] = (s0 << 55 | s0 >> 9) ^ s1 ^ (s1 << 14);
 8046b74:	ea4e 5ecc 	orr.w	lr, lr, ip, lsl #23
 8046b78:	ea8e 0e05 	eor.w	lr, lr, r5
 8046b7c:	03ad      	lsls	r5, r5, #14
 8046b7e:	ea45 459b 	orr.w	r5, r5, fp, lsr #18
 8046b82:	ea8e 0505 	eor.w	r5, lr, r5
 8046b86:	604d      	str	r5, [r1, #4]
	r->s[1] = s0 << 36 | s0 >> 28;
 8046b88:	ea4f 751c 	mov.w	r5, ip, lsr #28
 8046b8c:	ea45 1500 	orr.w	r5, r5, r0, lsl #4
 8046b90:	0f00      	lsrs	r0, r0, #28
 8046b92:	ea40 100c 	orr.w	r0, r0, ip, lsl #4
	u.i = 0x3FFULL << 52 | kad_xoroshiro128plus_next(d? (kad_rng_t*)d : &kad_rng_dat) >> 12;
 8046b96:	f449 1940 	orr.w	r9, r9, #3145728	@ 0x300000
	r->s[1] = s0 << 36 | s0 >> 28;
 8046b9a:	60c8      	str	r0, [r1, #12]
	return u.d - 1.0;
 8046b9c:	4b59      	ldr	r3, [pc, #356]	@ (8046d04 <kad_op_dropout+0x310>)
	r->s[1] = s0 << 36 | s0 >> 28;
 8046b9e:	608d      	str	r5, [r1, #8]
	return u.d - 1.0;
 8046ba0:	4640      	mov	r0, r8
 8046ba2:	4649      	mov	r1, r9
 8046ba4:	f7f9 fb4c 	bl	8040240 <__aeabi_dsub>
			p->x[i] = kept? q->x[i] * z : 0.0f;
 8046ba8:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8046bac:	f7f9 ff86 	bl	8040abc <__aeabi_dcmpge>
 8046bb0:	b1a0      	cbz	r0, 8046bdc <kad_op_dropout+0x1e8>
 8046bb2:	9b04      	ldr	r3, [sp, #16]
 8046bb4:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8046bb6:	4423      	add	r3, r4
 8046bb8:	edd3 7a00 	vldr	s15, [r3]
 8046bbc:	ee67 7a88 	vmul.f32	s15, s15, s16
 8046bc0:	f8da 3028 	ldr.w	r3, [sl, #40]	@ 0x28
 8046bc4:	4423      	add	r3, r4
 8046bc6:	edc3 7a00 	vstr	s15, [r3]
			if (flag) flag[i] = kept;
 8046bca:	f04f 0301 	mov.w	r3, #1
 8046bce:	f807 3b01 	strb.w	r3, [r7], #1
		for (i = 0; i < n; ++i) {
 8046bd2:	9b00      	ldr	r3, [sp, #0]
 8046bd4:	3404      	adds	r4, #4
 8046bd6:	429f      	cmp	r7, r3
 8046bd8:	d1a5      	bne.n	8046b26 <kad_op_dropout+0x132>
 8046bda:	e734      	b.n	8046a46 <kad_op_dropout+0x52>
			p->x[i] = kept? q->x[i] * z : 0.0f;
 8046bdc:	f8da 3028 	ldr.w	r3, [sl, #40]	@ 0x28
 8046be0:	4423      	add	r3, r4
 8046be2:	edc3 8a00 	vstr	s17, [r3]
		for (i = 0; i < n; ++i) {
 8046be6:	9b00      	ldr	r3, [sp, #0]
			if (flag) flag[i] = kept;
 8046be8:	f807 0b01 	strb.w	r0, [r7], #1
		for (i = 0; i < n; ++i) {
 8046bec:	429f      	cmp	r7, r3
 8046bee:	f104 0404 	add.w	r4, r4, #4
 8046bf2:	d198      	bne.n	8046b26 <kad_op_dropout+0x132>
 8046bf4:	e727      	b.n	8046a46 <kad_op_dropout+0x52>
	dst->n_d = src->n_d;
 8046bf6:	7004      	strb	r4, [r0, #0]
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 8046bf8:	e725      	b.n	8046a46 <kad_op_dropout+0x52>
 8046bfa:	eeb7 8a00 	vmov.f32	s16, #112	@ 0x3f800000  1.0
		float r = kad_is_const(q) || kad_is_var(q)? 0.0f : *p->child[1]->x, z = 1.0f / (1.0f - r);
 8046bfe:	2000      	movs	r0, #0
 8046c00:	e77f      	b.n	8046b02 <kad_op_dropout+0x10e>
			p->x[i] = kept? q->x[i] * z : 0.0f;
 8046c02:	f8da 2028 	ldr.w	r2, [sl, #40]	@ 0x28
			int kept = (kad_drand(p->ptr) >= r);
 8046c06:	f8da 3030 	ldr.w	r3, [sl, #48]	@ 0x30
			p->x[i] = kept? q->x[i] * z : 0.0f;
 8046c0a:	9204      	str	r2, [sp, #16]
 8046c0c:	4a3c      	ldr	r2, [pc, #240]	@ (8046d00 <kad_op_dropout+0x30c>)
		for (i = 0; i < n; ++i) {
 8046c0e:	463c      	mov	r4, r7
 8046c10:	2b00      	cmp	r3, #0
 8046c12:	bf18      	it	ne
 8046c14:	461a      	movne	r2, r3
			p->x[i] = kept? q->x[i] * z : 0.0f;
 8046c16:	eddf 8a39 	vldr	s17, [pc, #228]	@ 8046cfc <kad_op_dropout+0x308>
 8046c1a:	e9d2 1300 	ldrd	r1, r3, [r2]
 8046c1e:	e9d2 7502 	ldrd	r7, r5, [r2, #8]
 8046c22:	9205      	str	r2, [sp, #20]
 8046c24:	e00e      	b.n	8046c44 <kad_op_dropout+0x250>
 8046c26:	6ab3      	ldr	r3, [r6, #40]	@ 0x28
		for (i = 0; i < n; ++i) {
 8046c28:	3401      	adds	r4, #1
			p->x[i] = kept? q->x[i] * z : 0.0f;
 8046c2a:	4453      	add	r3, sl
 8046c2c:	edd3 7a00 	vldr	s15, [r3]
 8046c30:	ee68 7a27 	vmul.f32	s15, s16, s15
 8046c34:	9b04      	ldr	r3, [sp, #16]
		for (i = 0; i < n; ++i) {
 8046c36:	45a3      	cmp	fp, r4
			p->x[i] = kept? q->x[i] * z : 0.0f;
 8046c38:	449a      	add	sl, r3
 8046c3a:	edca 7a00 	vstr	s15, [sl]
		for (i = 0; i < n; ++i) {
 8046c3e:	d054      	beq.n	8046cea <kad_op_dropout+0x2f6>
	r->s[0] = (s0 << 55 | s0 >> 9) ^ s1 ^ (s1 << 14);
 8046c40:	4649      	mov	r1, r9
 8046c42:	4643      	mov	r3, r8
	const uint64_t result = s0 + s1;
 8046c44:	19c8      	adds	r0, r1, r7
 8046c46:	eb43 0205 	adc.w	r2, r3, r5
	r->s[0] = (s0 << 55 | s0 >> 9) ^ s1 ^ (s1 << 14);
 8046c4a:	ea4f 2951 	mov.w	r9, r1, lsr #9
 8046c4e:	ea4f 2853 	mov.w	r8, r3, lsr #9
	u.i = 0x3FFULL << 52 | kad_xoroshiro128plus_next(d? (kad_rng_t*)d : &kad_rng_dat) >> 12;
 8046c52:	0b00      	lsrs	r0, r0, #12
	s1 ^= s0;
 8046c54:	404f      	eors	r7, r1
	u.i = 0x3FFULL << 52 | kad_xoroshiro128plus_next(d? (kad_rng_t*)d : &kad_rng_dat) >> 12;
 8046c56:	ea40 5002 	orr.w	r0, r0, r2, lsl #20
	s1 ^= s0;
 8046c5a:	405d      	eors	r5, r3
	r->s[0] = (s0 << 55 | s0 >> 9) ^ s1 ^ (s1 << 14);
 8046c5c:	ea49 59c3 	orr.w	r9, r9, r3, lsl #23
 8046c60:	ea48 58c1 	orr.w	r8, r8, r1, lsl #23
	u.i = 0x3FFULL << 52 | kad_xoroshiro128plus_next(d? (kad_rng_t*)d : &kad_rng_dat) >> 12;
 8046c64:	0b12      	lsrs	r2, r2, #12
	r->s[0] = (s0 << 55 | s0 >> 9) ^ s1 ^ (s1 << 14);
 8046c66:	ea89 0907 	eor.w	r9, r9, r7
 8046c6a:	ea88 0805 	eor.w	r8, r8, r5
	u.i = 0x3FFULL << 52 | kad_xoroshiro128plus_next(d? (kad_rng_t*)d : &kad_rng_dat) >> 12;
 8046c6e:	f042 527f 	orr.w	r2, r2, #1069547520	@ 0x3fc00000
	r->s[0] = (s0 << 55 | s0 >> 9) ^ s1 ^ (s1 << 14);
 8046c72:	03ad      	lsls	r5, r5, #14
 8046c74:	ea45 4597 	orr.w	r5, r5, r7, lsr #18
	u.i = 0x3FFULL << 52 | kad_xoroshiro128plus_next(d? (kad_rng_t*)d : &kad_rng_dat) >> 12;
 8046c78:	f442 1240 	orr.w	r2, r2, #3145728	@ 0x300000
	r->s[0] = (s0 << 55 | s0 >> 9) ^ s1 ^ (s1 << 14);
 8046c7c:	ea89 3987 	eor.w	r9, r9, r7, lsl #14
	r->s[1] = s0 << 36 | s0 >> 28;
 8046c80:	0f0f      	lsrs	r7, r1, #28
	u.i = 0x3FFULL << 52 | kad_xoroshiro128plus_next(d? (kad_rng_t*)d : &kad_rng_dat) >> 12;
 8046c82:	9201      	str	r2, [sp, #4]
 8046c84:	9000      	str	r0, [sp, #0]
	r->s[1] = s0 << 36 | s0 >> 28;
 8046c86:	ea47 1703 	orr.w	r7, r7, r3, lsl #4
 8046c8a:	0f1b      	lsrs	r3, r3, #28
	return u.d - 1.0;
 8046c8c:	2200      	movs	r2, #0
	r->s[0] = (s0 << 55 | s0 >> 9) ^ s1 ^ (s1 << 14);
 8046c8e:	ea88 0805 	eor.w	r8, r8, r5
	r->s[1] = s0 << 36 | s0 >> 28;
 8046c92:	ea43 1501 	orr.w	r5, r3, r1, lsl #4
	return u.d - 1.0;
 8046c96:	4b1b      	ldr	r3, [pc, #108]	@ (8046d04 <kad_op_dropout+0x310>)
 8046c98:	e9dd 0100 	ldrd	r0, r1, [sp]
 8046c9c:	f7f9 fad0 	bl	8040240 <__aeabi_dsub>
 8046ca0:	4602      	mov	r2, r0
 8046ca2:	460b      	mov	r3, r1
			p->x[i] = kept? q->x[i] * z : 0.0f;
 8046ca4:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 8046ca8:	ea4f 0a84 	mov.w	sl, r4, lsl #2
 8046cac:	f7f9 fefc 	bl	8040aa8 <__aeabi_dcmple>
 8046cb0:	2800      	cmp	r0, #0
 8046cb2:	d1b8      	bne.n	8046c26 <kad_op_dropout+0x232>
 8046cb4:	9b04      	ldr	r3, [sp, #16]
		for (i = 0; i < n; ++i) {
 8046cb6:	3401      	adds	r4, #1
			p->x[i] = kept? q->x[i] * z : 0.0f;
 8046cb8:	449a      	add	sl, r3
		for (i = 0; i < n; ++i) {
 8046cba:	45a3      	cmp	fp, r4
			p->x[i] = kept? q->x[i] * z : 0.0f;
 8046cbc:	edca 8a00 	vstr	s17, [sl]
		for (i = 0; i < n; ++i) {
 8046cc0:	d1be      	bne.n	8046c40 <kad_op_dropout+0x24c>
			p->x[i] = kept? q->x[i] * z : 0.0f;
 8046cc2:	eddf 7a0e 	vldr	s15, [pc, #56]	@ 8046cfc <kad_op_dropout+0x308>
 8046cc6:	9a05      	ldr	r2, [sp, #20]
 8046cc8:	e9c2 9800 	strd	r9, r8, [r2]
 8046ccc:	e9c2 7502 	strd	r7, r5, [r2, #8]
 8046cd0:	edca 7a00 	vstr	s15, [sl]
 8046cd4:	e6b7      	b.n	8046a46 <kad_op_dropout+0x52>
		float r = kad_is_const(q) || kad_is_var(q)? 0.0f : *p->child[1]->x, z = 1.0f / (1.0f - r);
 8046cd6:	6a93      	ldr	r3, [r2, #40]	@ 0x28
 8046cd8:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 8046cdc:	edd3 7a00 	vldr	s15, [r3]
 8046ce0:	ee77 7a67 	vsub.f32	s15, s14, s15
 8046ce4:	eec7 6a27 	vdiv.f32	s13, s14, s15
 8046ce8:	e6d8      	b.n	8046a9c <kad_op_dropout+0xa8>
 8046cea:	9a05      	ldr	r2, [sp, #20]
 8046cec:	e7ec      	b.n	8046cc8 <kad_op_dropout+0x2d4>
	assert(p->child[1]->n_d == 0);
 8046cee:	f44f 61a4 	mov.w	r1, #1312	@ 0x520
 8046cf2:	4b05      	ldr	r3, [pc, #20]	@ (8046d08 <kad_op_dropout+0x314>)
 8046cf4:	4a05      	ldr	r2, [pc, #20]	@ (8046d0c <kad_op_dropout+0x318>)
 8046cf6:	4806      	ldr	r0, [pc, #24]	@ (8046d10 <kad_op_dropout+0x31c>)
 8046cf8:	f004 fd38 	bl	804b76c <__assert_func>
 8046cfc:	00000000 	.word	0x00000000
 8046d00:	20018108 	.word	0x20018108
 8046d04:	3ff00000 	.word	0x3ff00000
 8046d08:	0804e3d0 	.word	0x0804e3d0
 8046d0c:	0804e4b8 	.word	0x0804e4b8
 8046d10:	0804e328 	.word	0x0804e328

08046d14 <kad_op_cmul>:
{
 8046d14:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8046d18:	4604      	mov	r4, r0
	q[0] = p->child[0], q[1] = p->child[1];
 8046d1a:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
{
 8046d1c:	4608      	mov	r0, r1
	q[0] = p->child[0], q[1] = p->child[1];
 8046d1e:	e9d3 6500 	ldrd	r6, r5, [r3]
	n_col = q[0]->d[q[0]->n_d - 1] > q[1]->d[q[1]->n_d - 1]? q[0]->d[q[0]->n_d - 1] : q[1]->d[q[1]->n_d - 1];
 8046d22:	782f      	ldrb	r7, [r5, #0]
 8046d24:	f896 e000 	ldrb.w	lr, [r6]
 8046d28:	1cfa      	adds	r2, r7, #3
 8046d2a:	f10e 0303 	add.w	r3, lr, #3
 8046d2e:	f855 2022 	ldr.w	r2, [r5, r2, lsl #2]
 8046d32:	f856 3023 	ldr.w	r3, [r6, r3, lsl #2]
{
 8046d36:	b08f      	sub	sp, #60	@ 0x3c
	n_col = q[0]->d[q[0]->n_d - 1] > q[1]->d[q[1]->n_d - 1]? q[0]->d[q[0]->n_d - 1] : q[1]->d[q[1]->n_d - 1];
 8046d38:	429a      	cmp	r2, r3
 8046d3a:	bfb8      	it	lt
 8046d3c:	461a      	movlt	r2, r3
 8046d3e:	1e79      	subs	r1, r7, #1
 8046d40:	4691      	mov	r9, r2
	for (i = q[0]->n_d - 1; i >= 0; --i) if (n_a_col < n_col) n_a_col *= q[0]->d[i];
 8046d42:	f1be 0f00 	cmp.w	lr, #0
 8046d46:	f000 8196 	beq.w	8047076 <kad_op_cmul+0x362>
	int i, n_a_row, n_b_row, n_col, n_a_col = 1, n_b_col = 1;
 8046d4a:	2201      	movs	r2, #1
 8046d4c:	f10e 33ff 	add.w	r3, lr, #4294967295
	for (i = q[0]->n_d - 1; i >= 0; --i) if (n_a_col < n_col) n_a_col *= q[0]->d[i];
 8046d50:	f106 0810 	add.w	r8, r6, #16
 8046d54:	4591      	cmp	r9, r2
 8046d56:	dc63      	bgt.n	8046e20 <kad_op_cmul+0x10c>
	for (i = q[1]->n_d - 1; i >= 0; --i) if (n_b_col < n_col) n_b_col *= q[1]->d[i];
 8046d58:	1c4b      	adds	r3, r1, #1
 8046d5a:	f000 8198 	beq.w	804708e <kad_op_cmul+0x37a>
	int i, n_a_row, n_b_row, n_col, n_a_col = 1, n_b_col = 1;
 8046d5e:	f04f 0c01 	mov.w	ip, #1
	for (i = q[1]->n_d - 1; i >= 0; --i) if (n_b_col < n_col) n_b_col *= q[1]->d[i];
 8046d62:	4663      	mov	r3, ip
 8046d64:	f105 0810 	add.w	r8, r5, #16
 8046d68:	4599      	cmp	r9, r3
 8046d6a:	dc35      	bgt.n	8046dd8 <kad_op_cmul+0xc4>
	for (i = 0; i < p->n_d; ++i) n *= p->d[i];
 8046d6c:	469c      	mov	ip, r3
 8046d6e:	f1be 0f00 	cmp.w	lr, #0
 8046d72:	d03d      	beq.n	8046df0 <kad_op_cmul+0xdc>
 8046d74:	f1be 0f01 	cmp.w	lr, #1
 8046d78:	6931      	ldr	r1, [r6, #16]
 8046d7a:	dd0e      	ble.n	8046d9a <kad_op_cmul+0x86>
 8046d7c:	6973      	ldr	r3, [r6, #20]
 8046d7e:	f1be 0f02 	cmp.w	lr, #2
 8046d82:	fb03 f101 	mul.w	r1, r3, r1
 8046d86:	d008      	beq.n	8046d9a <kad_op_cmul+0x86>
 8046d88:	69b3      	ldr	r3, [r6, #24]
 8046d8a:	f1be 0f03 	cmp.w	lr, #3
 8046d8e:	fb03 f101 	mul.w	r1, r3, r1
 8046d92:	d002      	beq.n	8046d9a <kad_op_cmul+0x86>
 8046d94:	69f3      	ldr	r3, [r6, #28]
 8046d96:	fb03 f101 	mul.w	r1, r3, r1
	n_a_row = kad_len(q[0]) / n_a_col, n_b_row = kad_len(q[1]) / n_b_col;
 8046d9a:	fb91 f3f2 	sdiv	r3, r1, r2
 8046d9e:	9302      	str	r3, [sp, #8]
 8046da0:	b367      	cbz	r7, 8046dfc <kad_op_cmul+0xe8>
 8046da2:	2f01      	cmp	r7, #1
 8046da4:	6929      	ldr	r1, [r5, #16]
 8046da6:	d00b      	beq.n	8046dc0 <kad_op_cmul+0xac>
 8046da8:	696b      	ldr	r3, [r5, #20]
 8046daa:	2f02      	cmp	r7, #2
 8046dac:	fb03 f101 	mul.w	r1, r3, r1
 8046db0:	d006      	beq.n	8046dc0 <kad_op_cmul+0xac>
 8046db2:	69ab      	ldr	r3, [r5, #24]
 8046db4:	2f03      	cmp	r7, #3
 8046db6:	fb03 f101 	mul.w	r1, r3, r1
 8046dba:	bf1c      	itt	ne
 8046dbc:	69ef      	ldrne	r7, [r5, #28]
 8046dbe:	4379      	mulne	r1, r7
	if (action == KAD_SYNC_DIM) {
 8046dc0:	2804      	cmp	r0, #4
	n_a_row = kad_len(q[0]) / n_a_col, n_b_row = kad_len(q[1]) / n_b_col;
 8046dc2:	fb91 fafc 	sdiv	sl, r1, ip
	if (action == KAD_SYNC_DIM) {
 8046dc6:	d022      	beq.n	8046e0e <kad_op_cmul+0xfa>
	} else if (action == KAD_FORWARD) {
 8046dc8:	2802      	cmp	r0, #2
 8046dca:	d07f      	beq.n	8046ecc <kad_op_cmul+0x1b8>
	} else if (action == KAD_BACKWARD) {
 8046dcc:	2803      	cmp	r0, #3
 8046dce:	d030      	beq.n	8046e32 <kad_op_cmul+0x11e>
	return 0;
 8046dd0:	2000      	movs	r0, #0
}
 8046dd2:	b00f      	add	sp, #60	@ 0x3c
 8046dd4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	for (i = q[1]->n_d - 1; i >= 0; --i) if (n_b_col < n_col) n_b_col *= q[1]->d[i];
 8046dd8:	f858 c021 	ldr.w	ip, [r8, r1, lsl #2]
 8046ddc:	3901      	subs	r1, #1
 8046dde:	f1b1 3fff 	cmp.w	r1, #4294967295
 8046de2:	fb0c f303 	mul.w	r3, ip, r3
 8046de6:	d1bf      	bne.n	8046d68 <kad_op_cmul+0x54>
 8046de8:	469c      	mov	ip, r3
 8046dea:	f1be 0f00 	cmp.w	lr, #0
 8046dee:	d1c1      	bne.n	8046d74 <kad_op_cmul+0x60>
	int n = 1, i;
 8046df0:	2101      	movs	r1, #1
	n_a_row = kad_len(q[0]) / n_a_col, n_b_row = kad_len(q[1]) / n_b_col;
 8046df2:	fb91 f3f2 	sdiv	r3, r1, r2
 8046df6:	9302      	str	r3, [sp, #8]
	for (i = 0; i < p->n_d; ++i) n *= p->d[i];
 8046df8:	2f00      	cmp	r7, #0
 8046dfa:	d1d2      	bne.n	8046da2 <kad_op_cmul+0x8e>
 8046dfc:	f10c 0101 	add.w	r1, ip, #1
 8046e00:	2902      	cmp	r1, #2
 8046e02:	bf94      	ite	ls
 8046e04:	46e2      	movls	sl, ip
 8046e06:	f04f 0a00 	movhi.w	sl, #0
	if (action == KAD_SYNC_DIM) {
 8046e0a:	2804      	cmp	r0, #4
 8046e0c:	d1dc      	bne.n	8046dc8 <kad_op_cmul+0xb4>
		if (n_a_col != n_b_col) return -1;
 8046e0e:	4594      	cmp	ip, r2
 8046e10:	f040 8140 	bne.w	8047094 <kad_op_cmul+0x380>
		p->n_d = 2, p->d[0] = n_a_row, p->d[1] = n_b_row;
 8046e14:	2302      	movs	r3, #2
 8046e16:	9a02      	ldr	r2, [sp, #8]
 8046e18:	7023      	strb	r3, [r4, #0]
 8046e1a:	e9c4 2a04 	strd	r2, sl, [r4, #16]
 8046e1e:	e7d7      	b.n	8046dd0 <kad_op_cmul+0xbc>
	for (i = q[0]->n_d - 1; i >= 0; --i) if (n_a_col < n_col) n_a_col *= q[0]->d[i];
 8046e20:	f858 c023 	ldr.w	ip, [r8, r3, lsl #2]
 8046e24:	3b01      	subs	r3, #1
 8046e26:	f1b3 3fff 	cmp.w	r3, #4294967295
 8046e2a:	fb0c f202 	mul.w	r2, ip, r2
 8046e2e:	d093      	beq.n	8046d58 <kad_op_cmul+0x44>
 8046e30:	e790      	b.n	8046d54 <kad_op_cmul+0x40>
		if (kad_is_back(q[0]) && q[1]->x)
 8046e32:	7873      	ldrb	r3, [r6, #1]
 8046e34:	07da      	lsls	r2, r3, #31
 8046e36:	f140 80d8 	bpl.w	8046fea <kad_op_cmul+0x2d6>
 8046e3a:	6aab      	ldr	r3, [r5, #40]	@ 0x28
 8046e3c:	9303      	str	r3, [sp, #12]
 8046e3e:	2b00      	cmp	r3, #0
 8046e40:	f000 80d3 	beq.w	8046fea <kad_op_cmul+0x2d6>
		for (i = 0; i < M; ++i)
 8046e44:	9b02      	ldr	r3, [sp, #8]
 8046e46:	2b00      	cmp	r3, #0
 8046e48:	f340 80cf 	ble.w	8046fea <kad_op_cmul+0x2d6>
 8046e4c:	f1ba 0f00 	cmp.w	sl, #0
 8046e50:	f340 80cb 	ble.w	8046fea <kad_op_cmul+0x2d6>
 8046e54:	f1b9 0f00 	cmp.w	r9, #0
 8046e58:	f340 80c7 	ble.w	8046fea <kad_op_cmul+0x2d6>
			kad_sgemm_simple(0, 0, n_a_row, n_col, n_b_row, p->g, q[1]->x, q[0]->g); /* G_x <- G_y * W */
 8046e5c:	2300      	movs	r3, #0
 8046e5e:	6af7      	ldr	r7, [r6, #44]	@ 0x2c
 8046e60:	6ae2      	ldr	r2, [r4, #44]	@ 0x2c
 8046e62:	ea4f 018a 	mov.w	r1, sl, lsl #2
 8046e66:	eb07 0089 	add.w	r0, r7, r9, lsl #2
 8046e6a:	9205      	str	r2, [sp, #20]
 8046e6c:	9104      	str	r1, [sp, #16]
 8046e6e:	eb02 088a 	add.w	r8, r2, sl, lsl #2
 8046e72:	4601      	mov	r1, r0
		for (i = 0; i < M; ++i)
 8046e74:	461a      	mov	r2, r3
 8046e76:	ea4f 0b89 	mov.w	fp, r9, lsl #2
 8046e7a:	9701      	str	r7, [sp, #4]
		for (i = 0; i < M; i += x)
 8046e7c:	f04f 0e00 	mov.w	lr, #0
 8046e80:	9f05      	ldr	r7, [sp, #20]
 8046e82:	e9cd 6506 	strd	r6, r5, [sp, #24]
 8046e86:	eb07 0c83 	add.w	ip, r7, r3, lsl #2
 8046e8a:	9f01      	ldr	r7, [sp, #4]
				kad_saxpy_inlined(N, A[i*K+k], &B[k*N], &C[i*N]);
 8046e8c:	ecfc 6a01 	vldmia	ip!, {s13}
 8046e90:	463d      	mov	r5, r7
 8046e92:	9e03      	ldr	r6, [sp, #12]
 8046e94:	4476      	add	r6, lr
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 8046e96:	edd5 7a00 	vldr	s15, [r5]
 8046e9a:	ecb6 7a01 	vldmia	r6!, {s14}
 8046e9e:	eee6 7a87 	vfma.f32	s15, s13, s14
 8046ea2:	ece5 7a01 	vstmia	r5!, {s15}
 8046ea6:	428d      	cmp	r5, r1
 8046ea8:	d1f5      	bne.n	8046e96 <kad_op_cmul+0x182>
			for (k = 0; k < K; ++k)
 8046eaa:	45c4      	cmp	ip, r8
 8046eac:	44de      	add	lr, fp
 8046eae:	d1ed      	bne.n	8046e8c <kad_op_cmul+0x178>
		for (i = 0; i < M; ++i)
 8046eb0:	e9dd 6506 	ldrd	r6, r5, [sp, #24]
 8046eb4:	9f04      	ldr	r7, [sp, #16]
 8046eb6:	3201      	adds	r2, #1
 8046eb8:	44b8      	add	r8, r7
 8046eba:	9f02      	ldr	r7, [sp, #8]
 8046ebc:	4459      	add	r1, fp
 8046ebe:	42ba      	cmp	r2, r7
 8046ec0:	4453      	add	r3, sl
 8046ec2:	9001      	str	r0, [sp, #4]
 8046ec4:	f000 8091 	beq.w	8046fea <kad_op_cmul+0x2d6>
 8046ec8:	4458      	add	r0, fp
 8046eca:	e7d7      	b.n	8046e7c <kad_op_cmul+0x168>
		memset(p->x, 0, n_a_row * n_b_row * sizeof(float));
 8046ecc:	9f02      	ldr	r7, [sp, #8]
 8046ece:	2100      	movs	r1, #0
 8046ed0:	fb07 f20a 	mul.w	r2, r7, sl
 8046ed4:	6aa0      	ldr	r0, [r4, #40]	@ 0x28
 8046ed6:	0092      	lsls	r2, r2, #2
 8046ed8:	f004 ff70 	bl	804bdbc <memset>
		if (q[0]->x && q[1]->x)
 8046edc:	6ab3      	ldr	r3, [r6, #40]	@ 0x28
 8046ede:	2b00      	cmp	r3, #0
 8046ee0:	f43f af76 	beq.w	8046dd0 <kad_op_cmul+0xbc>
 8046ee4:	6aad      	ldr	r5, [r5, #40]	@ 0x28
 8046ee6:	2d00      	cmp	r5, #0
 8046ee8:	f43f af72 	beq.w	8046dd0 <kad_op_cmul+0xbc>
		for (i = 0; i < M; i += x)
 8046eec:	2f00      	cmp	r7, #0
 8046eee:	f77f af6f 	ble.w	8046dd0 <kad_op_cmul+0xbc>
 8046ef2:	f1ba 0f00 	cmp.w	sl, #0
					for (jj = j, bjj = B + j * K; jj < je; ++jj, bjj += K)
 8046ef6:	ea4f 0889 	mov.w	r8, r9, lsl #2
 8046efa:	f77f af69 	ble.w	8046dd0 <kad_op_cmul+0xbc>
			kad_sgemm_simple(0, 1, n_a_row, n_b_row, n_col, q[0]->x, q[1]->x, p->x); /* Y = X * trans(W) */
 8046efe:	2200      	movs	r2, #0
 8046f00:	ea4f 1c0a 	mov.w	ip, sl, lsl #4
 8046f04:	4661      	mov	r1, ip
 8046f06:	9304      	str	r3, [sp, #16]
 8046f08:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
 8046f0a:	9205      	str	r2, [sp, #20]
 8046f0c:	9307      	str	r3, [sp, #28]
		for (i = 0; i < M; i += x)
 8046f0e:	ebc9 1309 	rsb	r3, r9, r9, lsl #4
 8046f12:	009c      	lsls	r4, r3, #2
 8046f14:	ea4f 1389 	mov.w	r3, r9, lsl #6
 8046f18:	9308      	str	r3, [sp, #32]
 8046f1a:	ea4f 0b8a 	mov.w	fp, sl, lsl #2
 8046f1e:	9203      	str	r2, [sp, #12]
			for (j = 0; j < N; j += x) {
 8046f20:	9e02      	ldr	r6, [sp, #8]
 8046f22:	9b03      	ldr	r3, [sp, #12]
 8046f24:	4632      	mov	r2, r6
 8046f26:	f103 0010 	add.w	r0, r3, #16
				int ii, ie = M < i + x? M : i + x;
 8046f2a:	330f      	adds	r3, #15
 8046f2c:	42b3      	cmp	r3, r6
 8046f2e:	bfb8      	it	lt
 8046f30:	4602      	movlt	r2, r0
 8046f32:	900b      	str	r0, [sp, #44]	@ 0x2c
 8046f34:	46ac      	mov	ip, r5
			for (j = 0; j < N; j += x) {
 8046f36:	2300      	movs	r3, #0
 8046f38:	4620      	mov	r0, r4
 8046f3a:	4696      	mov	lr, r2
 8046f3c:	9a04      	ldr	r2, [sp, #16]
 8046f3e:	e9cd 5109 	strd	r5, r1, [sp, #36]	@ 0x24
 8046f42:	4442      	add	r2, r8
 8046f44:	9206      	str	r2, [sp, #24]
				int jj, je = N < j + x? N : j + x;
 8046f46:	461a      	mov	r2, r3
				for (ii = i; ii < ie; ++ii) { /* loop tiling */
 8046f48:	9903      	ldr	r1, [sp, #12]
			for (j = 0; j < N; j += x) {
 8046f4a:	3310      	adds	r3, #16
				int jj, je = N < j + x? N : j + x;
 8046f4c:	f102 050f 	add.w	r5, r2, #15
 8046f50:	4555      	cmp	r5, sl
 8046f52:	bfb4      	ite	lt
 8046f54:	461c      	movlt	r4, r3
 8046f56:	4654      	movge	r4, sl
				for (ii = i; ii < ie; ++ii) { /* loop tiling */
 8046f58:	458e      	cmp	lr, r1
 8046f5a:	dd33      	ble.n	8046fc4 <kad_op_cmul+0x2b0>
 8046f5c:	4294      	cmp	r4, r2
 8046f5e:	dd31      	ble.n	8046fc4 <kad_op_cmul+0x2b0>
 8046f60:	9905      	ldr	r1, [sp, #20]
 8046f62:	1b12      	subs	r2, r2, r4
 8046f64:	440c      	add	r4, r1
 8046f66:	9907      	ldr	r1, [sp, #28]
					for (jj = j, bjj = B + j * K; jj < je; ++jj, bjj += K)
 8046f68:	e9cd 3a0c 	strd	r3, sl, [sp, #48]	@ 0x30
 8046f6c:	eb01 0584 	add.w	r5, r1, r4, lsl #2
 8046f70:	4601      	mov	r1, r0
 8046f72:	9c06      	ldr	r4, [sp, #24]
 8046f74:	0097      	lsls	r7, r2, #2
 8046f76:	e9dd 2603 	ldrd	r2, r6, [sp, #12]
 8046f7a:	46e2      	mov	sl, ip
 8046f7c:	1978      	adds	r0, r7, r5
 8046f7e:	9201      	str	r2, [sp, #4]
	for (i = 0; i < n; ++i) s += x[i] * y[i];
 8046f80:	f1b9 0f00 	cmp.w	r9, #0
	float s = 0.;
 8046f84:	eddf 7a45 	vldr	s15, [pc, #276]	@ 804709c <kad_op_cmul+0x388>
	for (i = 0; i < n; ++i) s += x[i] * y[i];
 8046f88:	dd09      	ble.n	8046f9e <kad_op_cmul+0x28a>
 8046f8a:	4652      	mov	r2, sl
 8046f8c:	4633      	mov	r3, r6
 8046f8e:	ecf3 6a01 	vldmia	r3!, {s13}
 8046f92:	ecb2 7a01 	vldmia	r2!, {s14}
 8046f96:	42a3      	cmp	r3, r4
 8046f98:	eee6 7a87 	vfma.f32	s15, s13, s14
 8046f9c:	d1f7      	bne.n	8046f8e <kad_op_cmul+0x27a>
						cii[jj] += kad_sdot(K, aii, bjj);
 8046f9e:	ed90 7a00 	vldr	s14, [r0]
 8046fa2:	ee77 7a27 	vadd.f32	s15, s14, s15
 8046fa6:	ece0 7a01 	vstmia	r0!, {s15}
					for (jj = j, bjj = B + j * K; jj < je; ++jj, bjj += K)
 8046faa:	4285      	cmp	r5, r0
 8046fac:	44c2      	add	sl, r8
 8046fae:	d1e7      	bne.n	8046f80 <kad_op_cmul+0x26c>
				for (ii = i; ii < ie; ++ii) { /* loop tiling */
 8046fb0:	9a01      	ldr	r2, [sp, #4]
 8046fb2:	445d      	add	r5, fp
 8046fb4:	3201      	adds	r2, #1
 8046fb6:	4572      	cmp	r2, lr
 8046fb8:	4446      	add	r6, r8
 8046fba:	4444      	add	r4, r8
 8046fbc:	d1dd      	bne.n	8046f7a <kad_op_cmul+0x266>
 8046fbe:	e9dd 3a0c 	ldrd	r3, sl, [sp, #48]	@ 0x30
 8046fc2:	4608      	mov	r0, r1
			for (j = 0; j < N; j += x) {
 8046fc4:	9a08      	ldr	r2, [sp, #32]
 8046fc6:	4553      	cmp	r3, sl
 8046fc8:	4494      	add	ip, r2
 8046fca:	dbbc      	blt.n	8046f46 <kad_op_cmul+0x232>
 8046fcc:	e9dd 5109 	ldrd	r5, r1, [sp, #36]	@ 0x24
 8046fd0:	4604      	mov	r4, r0
		for (i = 0; i < M; i += x)
 8046fd2:	9b05      	ldr	r3, [sp, #20]
 8046fd4:	980b      	ldr	r0, [sp, #44]	@ 0x2c
 8046fd6:	440b      	add	r3, r1
 8046fd8:	9a02      	ldr	r2, [sp, #8]
 8046fda:	9305      	str	r3, [sp, #20]
 8046fdc:	9b06      	ldr	r3, [sp, #24]
 8046fde:	4290      	cmp	r0, r2
 8046fe0:	4423      	add	r3, r4
 8046fe2:	9003      	str	r0, [sp, #12]
 8046fe4:	9304      	str	r3, [sp, #16]
 8046fe6:	db9b      	blt.n	8046f20 <kad_op_cmul+0x20c>
 8046fe8:	e6f2      	b.n	8046dd0 <kad_op_cmul+0xbc>
		if (kad_is_back(q[1]) && q[0]->x)
 8046fea:	786b      	ldrb	r3, [r5, #1]
 8046fec:	07db      	lsls	r3, r3, #31
 8046fee:	f57f aeef 	bpl.w	8046dd0 <kad_op_cmul+0xbc>
 8046ff2:	6ab0      	ldr	r0, [r6, #40]	@ 0x28
 8046ff4:	2800      	cmp	r0, #0
 8046ff6:	f43f aeeb 	beq.w	8046dd0 <kad_op_cmul+0xbc>
		for (k = 0; k < K; ++k)
 8046ffa:	9b02      	ldr	r3, [sp, #8]
 8046ffc:	2b00      	cmp	r3, #0
 8046ffe:	f77f aee7 	ble.w	8046dd0 <kad_op_cmul+0xbc>
 8047002:	f1ba 0f00 	cmp.w	sl, #0
 8047006:	f77f aee3 	ble.w	8046dd0 <kad_op_cmul+0xbc>
 804700a:	f1b9 0f00 	cmp.w	r9, #0
 804700e:	f77f aedf 	ble.w	8046dd0 <kad_op_cmul+0xbc>
			kad_sgemm_simple(1, 0, n_b_row, n_col, n_a_row, p->g, q[0]->x, q[1]->g); /* G_w <- trans(G_y) * X */
 8047012:	2200      	movs	r2, #0
 8047014:	ea4f 038a 	mov.w	r3, sl, lsl #2
 8047018:	f8d4 e02c 	ldr.w	lr, [r4, #44]	@ 0x2c
 804701c:	4619      	mov	r1, r3
		for (k = 0; k < K; ++k)
 804701e:	4614      	mov	r4, r2
 8047020:	6aef      	ldr	r7, [r5, #44]	@ 0x2c
			for (i = 0; i < M; ++i)
 8047022:	ebc9 7649 	rsb	r6, r9, r9, lsl #29
 8047026:	eb07 0789 	add.w	r7, r7, r9, lsl #2
 804702a:	00f6      	lsls	r6, r6, #3
 804702c:	ea4f 0989 	mov.w	r9, r9, lsl #2
 8047030:	eb0e 058a 	add.w	r5, lr, sl, lsl #2
		for (i = 0; i < M; ++i)
 8047034:	46b8      	mov	r8, r7
 8047036:	eb0e 0b82 	add.w	fp, lr, r2, lsl #2
 804703a:	9201      	str	r2, [sp, #4]
				kad_saxpy_inlined(N, A[k*M+i], &B[k*N], &C[i*N]);
 804703c:	eba8 0209 	sub.w	r2, r8, r9
 8047040:	ecfb 6a01 	vldmia	fp!, {s13}
 8047044:	4684      	mov	ip, r0
 8047046:	4613      	mov	r3, r2
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 8047048:	edd3 7a00 	vldr	s15, [r3]
 804704c:	ecbc 7a01 	vldmia	ip!, {s14}
 8047050:	eee6 7a87 	vfma.f32	s15, s13, s14
 8047054:	ece3 7a01 	vstmia	r3!, {s15}
 8047058:	4598      	cmp	r8, r3
 804705a:	d1f5      	bne.n	8047048 <kad_op_cmul+0x334>
			for (i = 0; i < M; ++i)
 804705c:	455d      	cmp	r5, fp
 804705e:	eba2 0806 	sub.w	r8, r2, r6
 8047062:	d1eb      	bne.n	804703c <kad_op_cmul+0x328>
		for (k = 0; k < K; ++k)
 8047064:	9b02      	ldr	r3, [sp, #8]
 8047066:	9a01      	ldr	r2, [sp, #4]
 8047068:	3401      	adds	r4, #1
 804706a:	429c      	cmp	r4, r3
 804706c:	440d      	add	r5, r1
 804706e:	4448      	add	r0, r9
 8047070:	4452      	add	r2, sl
 8047072:	d1df      	bne.n	8047034 <kad_op_cmul+0x320>
 8047074:	e6ac      	b.n	8046dd0 <kad_op_cmul+0xbc>
	for (i = q[1]->n_d - 1; i >= 0; --i) if (n_b_col < n_col) n_b_col *= q[1]->d[i];
 8047076:	1c4a      	adds	r2, r1, #1
	int i, n_a_row, n_b_row, n_col, n_a_col = 1, n_b_col = 1;
 8047078:	bf18      	it	ne
 804707a:	2201      	movne	r2, #1
	for (i = q[1]->n_d - 1; i >= 0; --i) if (n_b_col < n_col) n_b_col *= q[1]->d[i];
 804707c:	f47f ae6f 	bne.w	8046d5e <kad_op_cmul+0x4a>
	n_a_row = kad_len(q[0]) / n_a_col, n_b_row = kad_len(q[1]) / n_b_col;
 8047080:	2301      	movs	r3, #1
	if (action == KAD_SYNC_DIM) {
 8047082:	2804      	cmp	r0, #4
 8047084:	469a      	mov	sl, r3
	n_a_row = kad_len(q[0]) / n_a_col, n_b_row = kad_len(q[1]) / n_b_col;
 8047086:	9302      	str	r3, [sp, #8]
	if (action == KAD_SYNC_DIM) {
 8047088:	f47f ae9e 	bne.w	8046dc8 <kad_op_cmul+0xb4>
 804708c:	e6c2      	b.n	8046e14 <kad_op_cmul+0x100>
	int i, n_a_row, n_b_row, n_col, n_a_col = 1, n_b_col = 1;
 804708e:	f04f 0c01 	mov.w	ip, #1
 8047092:	e66f      	b.n	8046d74 <kad_op_cmul+0x60>
		if (n_a_col != n_b_col) return -1;
 8047094:	f04f 30ff 	mov.w	r0, #4294967295
 8047098:	e69b      	b.n	8046dd2 <kad_op_cmul+0xbe>
 804709a:	bf00      	nop
 804709c:	00000000 	.word	0x00000000

080470a0 <kad_op_matmul>:
{
 80470a0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	q[0] = p->child[0];
 80470a4:	6b83      	ldr	r3, [r0, #56]	@ 0x38
{
 80470a6:	468c      	mov	ip, r1
	q[1] = p->child[1];
 80470a8:	e9d3 7600 	ldrd	r7, r6, [r3]
	n_a_row = q[0]->n_d == 1? 1 : q[0]->d[0];
 80470ac:	783b      	ldrb	r3, [r7, #0]
{
 80470ae:	4605      	mov	r5, r0
	n_a_row = q[0]->n_d == 1? 1 : q[0]->d[0];
 80470b0:	2b01      	cmp	r3, #1
 80470b2:	693c      	ldr	r4, [r7, #16]
	n_b_row = q[1]->n_d == 1? 1 : q[1]->d[0];
 80470b4:	7831      	ldrb	r1, [r6, #0]
{
 80470b6:	b093      	sub	sp, #76	@ 0x4c
	n_a_row = q[0]->n_d == 1? 1 : q[0]->d[0];
 80470b8:	d042      	beq.n	8047140 <kad_op_matmul+0xa0>
	n_b_row = q[1]->n_d == 1? 1 : q[1]->d[0];
 80470ba:	2901      	cmp	r1, #1
 80470bc:	d035      	beq.n	804712a <kad_op_matmul+0x8a>
 80470be:	6932      	ldr	r2, [r6, #16]
 80470c0:	9202      	str	r2, [sp, #8]
 80470c2:	2b00      	cmp	r3, #0
 80470c4:	d055      	beq.n	8047172 <kad_op_matmul+0xd2>
 80470c6:	697a      	ldr	r2, [r7, #20]
 80470c8:	2b02      	cmp	r3, #2
 80470ca:	fb04 f202 	mul.w	r2, r4, r2
 80470ce:	d007      	beq.n	80470e0 <kad_op_matmul+0x40>
 80470d0:	69b8      	ldr	r0, [r7, #24]
 80470d2:	2b03      	cmp	r3, #3
 80470d4:	fb00 f202 	mul.w	r2, r0, r2
 80470d8:	d002      	beq.n	80470e0 <kad_op_matmul+0x40>
 80470da:	69fb      	ldr	r3, [r7, #28]
 80470dc:	fb03 f202 	mul.w	r2, r3, r2
	n_a_col = kad_len(q[0]) / n_a_row;
 80470e0:	fb92 fbf4 	sdiv	fp, r2, r4
 80470e4:	2900      	cmp	r1, #0
 80470e6:	d035      	beq.n	8047154 <kad_op_matmul+0xb4>
 80470e8:	2901      	cmp	r1, #1
 80470ea:	6933      	ldr	r3, [r6, #16]
 80470ec:	d00c      	beq.n	8047108 <kad_op_matmul+0x68>
 80470ee:	6972      	ldr	r2, [r6, #20]
 80470f0:	2902      	cmp	r1, #2
 80470f2:	fb02 f303 	mul.w	r3, r2, r3
 80470f6:	d007      	beq.n	8047108 <kad_op_matmul+0x68>
 80470f8:	69b2      	ldr	r2, [r6, #24]
 80470fa:	2903      	cmp	r1, #3
 80470fc:	fb02 f303 	mul.w	r3, r2, r3
 8047100:	d002      	beq.n	8047108 <kad_op_matmul+0x68>
 8047102:	69f2      	ldr	r2, [r6, #28]
 8047104:	fb02 f303 	mul.w	r3, r2, r3
	n_b_col = kad_len(q[1]) / n_b_row;
 8047108:	9a02      	ldr	r2, [sp, #8]
	if (action == KAD_SYNC_DIM) {
 804710a:	f1bc 0f04 	cmp.w	ip, #4
	n_b_col = kad_len(q[1]) / n_b_row;
 804710e:	fb93 f9f2 	sdiv	r9, r3, r2
	if (action == KAD_SYNC_DIM) {
 8047112:	d026      	beq.n	8047162 <kad_op_matmul+0xc2>
	} else if (action == KAD_FORWARD) {
 8047114:	f1bc 0f02 	cmp.w	ip, #2
 8047118:	f000 8105 	beq.w	8047326 <kad_op_matmul+0x286>
	} else if (action == KAD_BACKWARD) {
 804711c:	f1bc 0f03 	cmp.w	ip, #3
 8047120:	d02e      	beq.n	8047180 <kad_op_matmul+0xe0>
	return 0;
 8047122:	2000      	movs	r0, #0
}
 8047124:	b013      	add	sp, #76	@ 0x4c
 8047126:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	n_b_row = q[1]->n_d == 1? 1 : q[1]->d[0];
 804712a:	9102      	str	r1, [sp, #8]
 804712c:	2b00      	cmp	r3, #0
 804712e:	d1ca      	bne.n	80470c6 <kad_op_matmul+0x26>
	n_a_col = kad_len(q[0]) / n_a_row;
 8047130:	1c63      	adds	r3, r4, #1
 8047132:	2b02      	cmp	r3, #2
 8047134:	bf94      	ite	ls
 8047136:	46a3      	movls	fp, r4
 8047138:	f04f 0b00 	movhi.w	fp, #0
 804713c:	6933      	ldr	r3, [r6, #16]
 804713e:	e7e3      	b.n	8047108 <kad_op_matmul+0x68>
	n_b_row = q[1]->n_d == 1? 1 : q[1]->d[0];
 8047140:	2901      	cmp	r1, #1
 8047142:	d018      	beq.n	8047176 <kad_op_matmul+0xd6>
 8047144:	4622      	mov	r2, r4
	n_a_row = q[0]->n_d == 1? 1 : q[0]->d[0];
 8047146:	461c      	mov	r4, r3
	n_b_row = q[1]->n_d == 1? 1 : q[1]->d[0];
 8047148:	6933      	ldr	r3, [r6, #16]
	n_a_col = kad_len(q[0]) / n_a_row;
 804714a:	fb92 fbf4 	sdiv	fp, r2, r4
	n_b_row = q[1]->n_d == 1? 1 : q[1]->d[0];
 804714e:	9302      	str	r3, [sp, #8]
 8047150:	2900      	cmp	r1, #0
 8047152:	d1c9      	bne.n	80470e8 <kad_op_matmul+0x48>
	int n = 1, i;
 8047154:	2301      	movs	r3, #1
	n_b_col = kad_len(q[1]) / n_b_row;
 8047156:	9a02      	ldr	r2, [sp, #8]
	if (action == KAD_SYNC_DIM) {
 8047158:	f1bc 0f04 	cmp.w	ip, #4
	n_b_col = kad_len(q[1]) / n_b_row;
 804715c:	fb93 f9f2 	sdiv	r9, r3, r2
	if (action == KAD_SYNC_DIM) {
 8047160:	d1d8      	bne.n	8047114 <kad_op_matmul+0x74>
		if (n_a_col != n_b_row) return -1;
 8047162:	455a      	cmp	r2, fp
 8047164:	f040 812d 	bne.w	80473c2 <kad_op_matmul+0x322>
		p->n_d = 2, p->d[0] = n_a_row, p->d[1] = n_b_col;
 8047168:	2302      	movs	r3, #2
 804716a:	e9c5 4904 	strd	r4, r9, [r5, #16]
 804716e:	702b      	strb	r3, [r5, #0]
 8047170:	e7d7      	b.n	8047122 <kad_op_matmul+0x82>
 8047172:	2201      	movs	r2, #1
 8047174:	e7b4      	b.n	80470e0 <kad_op_matmul+0x40>
	n_a_col = kad_len(q[0]) / n_a_row;
 8047176:	46a3      	mov	fp, r4
	for (i = 0; i < p->n_d; ++i) n *= p->d[i];
 8047178:	6933      	ldr	r3, [r6, #16]
	n_a_row = q[0]->n_d == 1? 1 : q[0]->d[0];
 804717a:	460c      	mov	r4, r1
	n_b_row = q[1]->n_d == 1? 1 : q[1]->d[0];
 804717c:	9102      	str	r1, [sp, #8]
 804717e:	e7c3      	b.n	8047108 <kad_op_matmul+0x68>
		if (kad_is_back(q[0]) && q[1]->x)
 8047180:	787b      	ldrb	r3, [r7, #1]
 8047182:	07da      	lsls	r2, r3, #31
 8047184:	f140 808b 	bpl.w	804729e <kad_op_matmul+0x1fe>
 8047188:	f8d6 c028 	ldr.w	ip, [r6, #40]	@ 0x28
 804718c:	f1bc 0f00 	cmp.w	ip, #0
 8047190:	f000 8085 	beq.w	804729e <kad_op_matmul+0x1fe>
		for (i = 0; i < M; i += x)
 8047194:	2c00      	cmp	r4, #0
 8047196:	f340 8082 	ble.w	804729e <kad_op_matmul+0x1fe>
 804719a:	f1bb 0f00 	cmp.w	fp, #0
					for (jj = j, bjj = B + j * K; jj < je; ++jj, bjj += K)
 804719e:	ea4f 0889 	mov.w	r8, r9, lsl #2
 80471a2:	dd7c      	ble.n	804729e <kad_op_matmul+0x1fe>
			kad_sgemm_simple(0, 1, n_a_row, n_a_col, n_b_col, p->g, q[1]->x, q[0]->g); /* G_x <- G_y * trans(W) */
 80471a4:	2100      	movs	r1, #0
		for (i = 0; i < M; i += x)
 80471a6:	ebc9 1309 	rsb	r3, r9, r9, lsl #4
 80471aa:	ea4f 0e83 	mov.w	lr, r3, lsl #2
 80471ae:	e9cd 7609 	strd	r7, r6, [sp, #36]	@ 0x24
			kad_sgemm_simple(0, 1, n_a_row, n_a_col, n_b_col, p->g, q[1]->x, q[0]->g); /* G_x <- G_y * trans(W) */
 80471b2:	9104      	str	r1, [sp, #16]
		for (i = 0; i < M; i += x)
 80471b4:	9103      	str	r1, [sp, #12]
 80471b6:	4666      	mov	r6, ip
 80471b8:	4671      	mov	r1, lr
			kad_sgemm_simple(0, 1, n_a_row, n_a_col, n_b_col, p->g, q[1]->x, q[0]->g); /* G_x <- G_y * trans(W) */
 80471ba:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80471bc:	ea4f 120b 	mov.w	r2, fp, lsl #4
 80471c0:	9307      	str	r3, [sp, #28]
 80471c2:	6aeb      	ldr	r3, [r5, #44]	@ 0x2c
 80471c4:	ea4f 0a8b 	mov.w	sl, fp, lsl #2
 80471c8:	9305      	str	r3, [sp, #20]
 80471ca:	ea4f 1389 	mov.w	r3, r9, lsl #6
 80471ce:	9308      	str	r3, [sp, #32]
 80471d0:	920b      	str	r2, [sp, #44]	@ 0x2c
			for (j = 0; j < N; j += x) {
 80471d2:	9b03      	ldr	r3, [sp, #12]
 80471d4:	46b4      	mov	ip, r6
 80471d6:	f103 0710 	add.w	r7, r3, #16
				int ii, ie = M < i + x? M : i + x;
 80471da:	330f      	adds	r3, #15
 80471dc:	42a3      	cmp	r3, r4
 80471de:	bfb4      	ite	lt
 80471e0:	46be      	movlt	lr, r7
 80471e2:	46a6      	movge	lr, r4
 80471e4:	4608      	mov	r0, r1
 80471e6:	2300      	movs	r3, #0
 80471e8:	9a05      	ldr	r2, [sp, #20]
 80471ea:	e9cd 460c 	strd	r4, r6, [sp, #48]	@ 0x30
 80471ee:	e9cd 570e 	strd	r5, r7, [sp, #56]	@ 0x38
 80471f2:	4442      	add	r2, r8
 80471f4:	9206      	str	r2, [sp, #24]
 80471f6:	461a      	mov	r2, r3
				for (ii = i; ii < ie; ++ii) { /* loop tiling */
 80471f8:	9903      	ldr	r1, [sp, #12]
 80471fa:	3310      	adds	r3, #16
				int jj, je = N < j + x? N : j + x;
 80471fc:	f102 050f 	add.w	r5, r2, #15
 8047200:	45ab      	cmp	fp, r5
 8047202:	bfd4      	ite	le
 8047204:	465c      	movle	r4, fp
 8047206:	461c      	movgt	r4, r3
				for (ii = i; ii < ie; ++ii) { /* loop tiling */
 8047208:	458e      	cmp	lr, r1
 804720a:	dd33      	ble.n	8047274 <kad_op_matmul+0x1d4>
 804720c:	4294      	cmp	r4, r2
 804720e:	dd31      	ble.n	8047274 <kad_op_matmul+0x1d4>
 8047210:	9904      	ldr	r1, [sp, #16]
 8047212:	1b12      	subs	r2, r2, r4
 8047214:	440c      	add	r4, r1
 8047216:	9907      	ldr	r1, [sp, #28]
					for (jj = j, bjj = B + j * K; jj < je; ++jj, bjj += K)
 8047218:	e9cd b310 	strd	fp, r3, [sp, #64]	@ 0x40
 804721c:	eb01 0584 	add.w	r5, r1, r4, lsl #2
 8047220:	4601      	mov	r1, r0
 8047222:	e9dd 6405 	ldrd	r6, r4, [sp, #20]
 8047226:	0097      	lsls	r7, r2, #2
 8047228:	9a03      	ldr	r2, [sp, #12]
 804722a:	46e3      	mov	fp, ip
 804722c:	19e8      	adds	r0, r5, r7
 804722e:	9201      	str	r2, [sp, #4]
	for (i = 0; i < n; ++i) s += x[i] * y[i];
 8047230:	f1b9 0f00 	cmp.w	r9, #0
	float s = 0.;
 8047234:	eddf 7a64 	vldr	s15, [pc, #400]	@ 80473c8 <kad_op_matmul+0x328>
	for (i = 0; i < n; ++i) s += x[i] * y[i];
 8047238:	dd09      	ble.n	804724e <kad_op_matmul+0x1ae>
 804723a:	465a      	mov	r2, fp
 804723c:	4633      	mov	r3, r6
 804723e:	ecf3 6a01 	vldmia	r3!, {s13}
 8047242:	ecb2 7a01 	vldmia	r2!, {s14}
 8047246:	42a3      	cmp	r3, r4
 8047248:	eee6 7a87 	vfma.f32	s15, s13, s14
 804724c:	d1f7      	bne.n	804723e <kad_op_matmul+0x19e>
						cii[jj] += kad_sdot(K, aii, bjj);
 804724e:	ed90 7a00 	vldr	s14, [r0]
 8047252:	ee77 7a27 	vadd.f32	s15, s14, s15
 8047256:	ece0 7a01 	vstmia	r0!, {s15}
					for (jj = j, bjj = B + j * K; jj < je; ++jj, bjj += K)
 804725a:	4285      	cmp	r5, r0
 804725c:	44c3      	add	fp, r8
 804725e:	d1e7      	bne.n	8047230 <kad_op_matmul+0x190>
				for (ii = i; ii < ie; ++ii) { /* loop tiling */
 8047260:	9a01      	ldr	r2, [sp, #4]
 8047262:	4455      	add	r5, sl
 8047264:	3201      	adds	r2, #1
 8047266:	4572      	cmp	r2, lr
 8047268:	4446      	add	r6, r8
 804726a:	4444      	add	r4, r8
 804726c:	d1dd      	bne.n	804722a <kad_op_matmul+0x18a>
 804726e:	e9dd b310 	ldrd	fp, r3, [sp, #64]	@ 0x40
 8047272:	4608      	mov	r0, r1
			for (j = 0; j < N; j += x) {
 8047274:	9a08      	ldr	r2, [sp, #32]
 8047276:	455b      	cmp	r3, fp
 8047278:	4494      	add	ip, r2
 804727a:	dbbc      	blt.n	80471f6 <kad_op_matmul+0x156>
 804727c:	e9dd 570e 	ldrd	r5, r7, [sp, #56]	@ 0x38
 8047280:	e9dd 460c 	ldrd	r4, r6, [sp, #48]	@ 0x30
		for (i = 0; i < M; i += x)
 8047284:	9b04      	ldr	r3, [sp, #16]
 8047286:	9a0b      	ldr	r2, [sp, #44]	@ 0x2c
 8047288:	42bc      	cmp	r4, r7
 804728a:	4413      	add	r3, r2
 804728c:	9304      	str	r3, [sp, #16]
 804728e:	9b06      	ldr	r3, [sp, #24]
 8047290:	4601      	mov	r1, r0
 8047292:	4403      	add	r3, r0
 8047294:	9703      	str	r7, [sp, #12]
 8047296:	9305      	str	r3, [sp, #20]
 8047298:	dc9b      	bgt.n	80471d2 <kad_op_matmul+0x132>
 804729a:	e9dd 7609 	ldrd	r7, r6, [sp, #36]	@ 0x24
		if (kad_is_back(q[1]) && q[0]->x)
 804729e:	7873      	ldrb	r3, [r6, #1]
 80472a0:	07db      	lsls	r3, r3, #31
 80472a2:	f57f af3e 	bpl.w	8047122 <kad_op_matmul+0x82>
 80472a6:	6abf      	ldr	r7, [r7, #40]	@ 0x28
 80472a8:	2f00      	cmp	r7, #0
 80472aa:	f43f af3a 	beq.w	8047122 <kad_op_matmul+0x82>
		for (k = 0; k < K; ++k)
 80472ae:	2c00      	cmp	r4, #0
 80472b0:	f77f af37 	ble.w	8047122 <kad_op_matmul+0x82>
 80472b4:	9902      	ldr	r1, [sp, #8]
 80472b6:	2900      	cmp	r1, #0
 80472b8:	f77f af33 	ble.w	8047122 <kad_op_matmul+0x82>
 80472bc:	f1b9 0f00 	cmp.w	r9, #0
 80472c0:	f77f af2f 	ble.w	8047122 <kad_op_matmul+0x82>
			kad_sgemm_simple(1, 0, n_b_row, n_b_col, n_a_row, q[0]->x, p->g, q[1]->g); /* G_y <- trans(A) * G_y */
 80472c4:	2200      	movs	r2, #0
 80472c6:	6af3      	ldr	r3, [r6, #44]	@ 0x2c
 80472c8:	f8d5 e02c 	ldr.w	lr, [r5, #44]	@ 0x2c
 80472cc:	eb03 0c89 	add.w	ip, r3, r9, lsl #2
 80472d0:	008b      	lsls	r3, r1, #2
 80472d2:	eb07 0581 	add.w	r5, r7, r1, lsl #2
		for (k = 0; k < K; ++k)
 80472d6:	4610      	mov	r0, r2
 80472d8:	4619      	mov	r1, r3
			for (i = 0; i < M; ++i)
 80472da:	ebc9 7649 	rsb	r6, r9, r9, lsl #29
 80472de:	00f6      	lsls	r6, r6, #3
 80472e0:	ea4f 0989 	mov.w	r9, r9, lsl #2
		for (i = 0; i < M; i += x)
 80472e4:	46e2      	mov	sl, ip
 80472e6:	eb07 0b82 	add.w	fp, r7, r2, lsl #2
 80472ea:	9201      	str	r2, [sp, #4]
				kad_saxpy_inlined(N, A[k*M+i], &B[k*N], &C[i*N]);
 80472ec:	ebaa 0209 	sub.w	r2, sl, r9
 80472f0:	ecfb 6a01 	vldmia	fp!, {s13}
 80472f4:	46f0      	mov	r8, lr
 80472f6:	4613      	mov	r3, r2
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 80472f8:	edd3 7a00 	vldr	s15, [r3]
 80472fc:	ecb8 7a01 	vldmia	r8!, {s14}
 8047300:	eee6 7a87 	vfma.f32	s15, s13, s14
 8047304:	ece3 7a01 	vstmia	r3!, {s15}
 8047308:	459a      	cmp	sl, r3
 804730a:	d1f5      	bne.n	80472f8 <kad_op_matmul+0x258>
			for (i = 0; i < M; ++i)
 804730c:	455d      	cmp	r5, fp
 804730e:	eba2 0a06 	sub.w	sl, r2, r6
 8047312:	d1eb      	bne.n	80472ec <kad_op_matmul+0x24c>
		for (k = 0; k < K; ++k)
 8047314:	9a01      	ldr	r2, [sp, #4]
 8047316:	9b02      	ldr	r3, [sp, #8]
 8047318:	3001      	adds	r0, #1
 804731a:	4284      	cmp	r4, r0
 804731c:	440d      	add	r5, r1
 804731e:	44ce      	add	lr, r9
 8047320:	441a      	add	r2, r3
 8047322:	d1df      	bne.n	80472e4 <kad_op_matmul+0x244>
 8047324:	e6fd      	b.n	8047122 <kad_op_matmul+0x82>
		memset(p->x, 0, n_a_row * n_b_col * sizeof(float));
 8047326:	fb04 f209 	mul.w	r2, r4, r9
 804732a:	2100      	movs	r1, #0
 804732c:	6aa8      	ldr	r0, [r5, #40]	@ 0x28
 804732e:	0092      	lsls	r2, r2, #2
 8047330:	f004 fd44 	bl	804bdbc <memset>
		if (q[0]->x && q[1]->x)
 8047334:	6abf      	ldr	r7, [r7, #40]	@ 0x28
 8047336:	2f00      	cmp	r7, #0
 8047338:	f43f aef3 	beq.w	8047122 <kad_op_matmul+0x82>
 804733c:	f8d6 a028 	ldr.w	sl, [r6, #40]	@ 0x28
 8047340:	f1ba 0f00 	cmp.w	sl, #0
 8047344:	f43f aeed 	beq.w	8047122 <kad_op_matmul+0x82>
		for (i = 0; i < M; ++i)
 8047348:	2c00      	cmp	r4, #0
 804734a:	f77f aeea 	ble.w	8047122 <kad_op_matmul+0x82>
 804734e:	f1bb 0f00 	cmp.w	fp, #0
 8047352:	f77f aee6 	ble.w	8047122 <kad_op_matmul+0x82>
 8047356:	f1b9 0f00 	cmp.w	r9, #0
 804735a:	f77f aee2 	ble.w	8047122 <kad_op_matmul+0x82>
			kad_sgemm_simple(0, 0, n_a_row, n_b_col, n_a_col, q[0]->x, q[1]->x, p->x); /* Y = X * W */
 804735e:	2300      	movs	r3, #0
 8047360:	f8d5 e028 	ldr.w	lr, [r5, #40]	@ 0x28
 8047364:	ea4f 028b 	mov.w	r2, fp, lsl #2
 8047368:	eb0e 0089 	add.w	r0, lr, r9, lsl #2
 804736c:	ea4f 0c89 	mov.w	ip, r9, lsl #2
 8047370:	4601      	mov	r1, r0
		for (i = 0; i < M; ++i)
 8047372:	461d      	mov	r5, r3
 8047374:	46a0      	mov	r8, r4
 8047376:	4691      	mov	r9, r2
 8047378:	eb07 068b 	add.w	r6, r7, fp, lsl #2
	int n = 1, i;
 804737c:	2400      	movs	r4, #0
 804737e:	e9cd 8701 	strd	r8, r7, [sp, #4]
 8047382:	eb07 0283 	add.w	r2, r7, r3, lsl #2
				kad_saxpy_inlined(N, A[i*K+k], &B[k*N], &C[i*N]);
 8047386:	ecf2 6a01 	vldmia	r2!, {s13}
 804738a:	4677      	mov	r7, lr
 804738c:	eb0a 0804 	add.w	r8, sl, r4
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 8047390:	edd7 7a00 	vldr	s15, [r7]
 8047394:	ecb8 7a01 	vldmia	r8!, {s14}
 8047398:	eee6 7a87 	vfma.f32	s15, s13, s14
 804739c:	ece7 7a01 	vstmia	r7!, {s15}
 80473a0:	428f      	cmp	r7, r1
 80473a2:	d1f5      	bne.n	8047390 <kad_op_matmul+0x2f0>
			for (k = 0; k < K; ++k)
 80473a4:	42b2      	cmp	r2, r6
 80473a6:	4464      	add	r4, ip
 80473a8:	d1ed      	bne.n	8047386 <kad_op_matmul+0x2e6>
		for (i = 0; i < M; ++i)
 80473aa:	e9dd 8701 	ldrd	r8, r7, [sp, #4]
 80473ae:	3501      	adds	r5, #1
 80473b0:	4545      	cmp	r5, r8
 80473b2:	4686      	mov	lr, r0
 80473b4:	444e      	add	r6, r9
 80473b6:	4461      	add	r1, ip
 80473b8:	445b      	add	r3, fp
 80473ba:	f43f aeb2 	beq.w	8047122 <kad_op_matmul+0x82>
 80473be:	4460      	add	r0, ip
 80473c0:	e7dc      	b.n	804737c <kad_op_matmul+0x2dc>
		if (n_a_col != n_b_row) return -1;
 80473c2:	f04f 30ff 	mov.w	r0, #4294967295
 80473c6:	e6ad      	b.n	8047124 <kad_op_matmul+0x84>
 80473c8:	00000000 	.word	0x00000000

080473cc <kad_op_conv1d>:
{
 80473cc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	kad_node_t *q = p->child[0], *w = p->child[1];
 80473d0:	6b83      	ldr	r3, [r0, #56]	@ 0x38
{
 80473d2:	b09f      	sub	sp, #124	@ 0x7c
	kad_node_t *q = p->child[0], *w = p->child[1];
 80473d4:	681a      	ldr	r2, [r3, #0]
 80473d6:	685e      	ldr	r6, [r3, #4]
	if (action == KAD_FORWARD || action == KAD_BACKWARD) { /* allocate working space */
 80473d8:	1e8b      	subs	r3, r1, #2
 80473da:	2b01      	cmp	r3, #1
{
 80473dc:	460c      	mov	r4, r1
	conv_conf_t *aux = (conv_conf_t*)p->ptr;
 80473de:	f8d0 b030 	ldr.w	fp, [r0, #48]	@ 0x30
{
 80473e2:	900d      	str	r0, [sp, #52]	@ 0x34
	kad_node_t *q = p->child[0], *w = p->child[1];
 80473e4:	9204      	str	r2, [sp, #16]
	if (action == KAD_FORWARD || action == KAD_BACKWARD) { /* allocate working space */
 80473e6:	d93c      	bls.n	8047462 <kad_op_conv1d+0x96>
	if (action == KAD_SYNC_DIM) {
 80473e8:	2904      	cmp	r1, #4
 80473ea:	d014      	beq.n	8047416 <kad_op_conv1d+0x4a>
	float *t = 0, *q1 = 0, *w1 = 0, *x_padded = 0;
 80473ec:	2300      	movs	r3, #0
 80473ee:	9300      	str	r3, [sp, #0]
 80473f0:	9309      	str	r3, [sp, #36]	@ 0x24
 80473f2:	930b      	str	r3, [sp, #44]	@ 0x2c
 80473f4:	930f      	str	r3, [sp, #60]	@ 0x3c
	free(t); free(q1); free(w1); free(x_padded);
 80473f6:	980f      	ldr	r0, [sp, #60]	@ 0x3c
 80473f8:	f004 f9fa 	bl	804b7f0 <free>
 80473fc:	980b      	ldr	r0, [sp, #44]	@ 0x2c
 80473fe:	f004 f9f7 	bl	804b7f0 <free>
 8047402:	9809      	ldr	r0, [sp, #36]	@ 0x24
 8047404:	f004 f9f4 	bl	804b7f0 <free>
 8047408:	9800      	ldr	r0, [sp, #0]
 804740a:	f004 f9f1 	bl	804b7f0 <free>
	return 0;
 804740e:	2000      	movs	r0, #0
}
 8047410:	b01f      	add	sp, #124	@ 0x7c
 8047412:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (q->n_d != 3 || w->n_d != 3) return -1;
 8047416:	7813      	ldrb	r3, [r2, #0]
 8047418:	4610      	mov	r0, r2
 804741a:	2b03      	cmp	r3, #3
 804741c:	f040 8558 	bne.w	8047ed0 <kad_op_conv1d+0xb04>
 8047420:	7833      	ldrb	r3, [r6, #0]
 8047422:	2b03      	cmp	r3, #3
 8047424:	f040 8554 	bne.w	8047ed0 <kad_op_conv1d+0xb04>
		if (q->d[1] != w->d[1]) return -1; /* unmatched input channels */
 8047428:	6951      	ldr	r1, [r2, #20]
 804742a:	6972      	ldr	r2, [r6, #20]
 804742c:	4291      	cmp	r1, r2
 804742e:	f040 854f 	bne.w	8047ed0 <kad_op_conv1d+0xb04>
		p->n_d = 3;
 8047432:	990d      	ldr	r1, [sp, #52]	@ 0x34
 8047434:	700b      	strb	r3, [r1, #0]
		p->d[0] = q->d[0], p->d[1] = w->d[0], p->d[2] = conv_out_size(q->d[2], aux);
 8047436:	6983      	ldr	r3, [r0, #24]
 8047438:	6902      	ldr	r2, [r0, #16]
 804743a:	4608      	mov	r0, r1
 804743c:	610a      	str	r2, [r1, #16]
 804743e:	f8db 2000 	ldr.w	r2, [fp]
 8047442:	6931      	ldr	r1, [r6, #16]
 8047444:	1a9b      	subs	r3, r3, r2
 8047446:	f8db 2008 	ldr.w	r2, [fp, #8]
 804744a:	6141      	str	r1, [r0, #20]
 804744c:	f8db 100c 	ldr.w	r1, [fp, #12]
 8047450:	4413      	add	r3, r2
 8047452:	f8db 2004 	ldr.w	r2, [fp, #4]
 8047456:	440b      	add	r3, r1
 8047458:	fb93 f3f2 	sdiv	r3, r3, r2
 804745c:	3301      	adds	r3, #1
 804745e:	6183      	str	r3, [r0, #24]
 8047460:	e7c4      	b.n	80473ec <kad_op_conv1d+0x20>
		if (w->d[2] * w->d[1] < 32) {
 8047462:	69b3      	ldr	r3, [r6, #24]
 8047464:	6972      	ldr	r2, [r6, #20]
 8047466:	9303      	str	r3, [sp, #12]
 8047468:	fb02 f303 	mul.w	r3, r2, r3
 804746c:	2b1f      	cmp	r3, #31
 804746e:	9205      	str	r2, [sp, #20]
 8047470:	9311      	str	r3, [sp, #68]	@ 0x44
 8047472:	f340 81be 	ble.w	80477f2 <kad_op_conv1d+0x426>
	for (i = 0; i < p->n_d; ++i) n *= p->d[i];
 8047476:	9b04      	ldr	r3, [sp, #16]
 8047478:	781a      	ldrb	r2, [r3, #0]
 804747a:	2a00      	cmp	r2, #0
 804747c:	f000 8270 	beq.w	8047960 <kad_op_conv1d+0x594>
 8047480:	2a01      	cmp	r2, #1
 8047482:	6918      	ldr	r0, [r3, #16]
 8047484:	d00b      	beq.n	804749e <kad_op_conv1d+0xd2>
 8047486:	6959      	ldr	r1, [r3, #20]
 8047488:	2a02      	cmp	r2, #2
 804748a:	fb01 f000 	mul.w	r0, r1, r0
 804748e:	d006      	beq.n	804749e <kad_op_conv1d+0xd2>
 8047490:	6999      	ldr	r1, [r3, #24]
 8047492:	2a03      	cmp	r2, #3
 8047494:	fb01 f000 	mul.w	r0, r1, r0
 8047498:	bf1c      	itt	ne
 804749a:	69da      	ldrne	r2, [r3, #28]
 804749c:	4350      	mulne	r0, r2
			q1 = (float*)malloc(kad_len(q) * sizeof(float));
 804749e:	0080      	lsls	r0, r0, #2
 80474a0:	f004 f99e 	bl	804b7e0 <malloc>
 80474a4:	7832      	ldrb	r2, [r6, #0]
 80474a6:	900b      	str	r0, [sp, #44]	@ 0x2c
 80474a8:	2a00      	cmp	r2, #0
 80474aa:	f000 8257 	beq.w	804795c <kad_op_conv1d+0x590>
 80474ae:	2a01      	cmp	r2, #1
 80474b0:	6930      	ldr	r0, [r6, #16]
 80474b2:	d00b      	beq.n	80474cc <kad_op_conv1d+0x100>
 80474b4:	9b05      	ldr	r3, [sp, #20]
 80474b6:	2a02      	cmp	r2, #2
 80474b8:	fb03 f000 	mul.w	r0, r3, r0
 80474bc:	d006      	beq.n	80474cc <kad_op_conv1d+0x100>
 80474be:	9b03      	ldr	r3, [sp, #12]
 80474c0:	2a03      	cmp	r2, #3
 80474c2:	fb03 f000 	mul.w	r0, r3, r0
 80474c6:	bf1c      	itt	ne
 80474c8:	69f2      	ldrne	r2, [r6, #28]
 80474ca:	4350      	mulne	r0, r2
			w1 = (float*)malloc(kad_len(w) * sizeof(float));
 80474cc:	0080      	lsls	r0, r0, #2
 80474ce:	f004 f987 	bl	804b7e0 <malloc>
			x_padded = aux->pad[0] + aux->pad[1] > 0? (float*)calloc((q->d[2] + aux->pad[0] + aux->pad[1]) * q->d[1], sizeof(float)) : 0;
 80474d2:	e9db 3202 	ldrd	r3, r2, [fp, #8]
 80474d6:	1899      	adds	r1, r3, r2
 80474d8:	2900      	cmp	r1, #0
			w1 = (float*)malloc(kad_len(w) * sizeof(float));
 80474da:	9009      	str	r0, [sp, #36]	@ 0x24
			x_padded = aux->pad[0] + aux->pad[1] > 0? (float*)calloc((q->d[2] + aux->pad[0] + aux->pad[1]) * q->d[1], sizeof(float)) : 0;
 80474dc:	f300 8113 	bgt.w	8047706 <kad_op_conv1d+0x33a>
 80474e0:	2300      	movs	r3, #0
			algo_switch = 1;
 80474e2:	2701      	movs	r7, #1
			x_padded = aux->pad[0] + aux->pad[1] > 0? (float*)calloc((q->d[2] + aux->pad[0] + aux->pad[1]) * q->d[1], sizeof(float)) : 0;
 80474e4:	9300      	str	r3, [sp, #0]
	float *t = 0, *q1 = 0, *w1 = 0, *x_padded = 0;
 80474e6:	930f      	str	r3, [sp, #60]	@ 0x3c
	} else if (action == KAD_FORWARD) {
 80474e8:	2c02      	cmp	r4, #2
 80474ea:	f040 811d 	bne.w	8047728 <kad_op_conv1d+0x35c>
		conv_rot180(w->d[0] * w->d[1], w->d[2], w->x);
 80474ee:	6934      	ldr	r4, [r6, #16]
 80474f0:	9b05      	ldr	r3, [sp, #20]
 80474f2:	fb04 f303 	mul.w	r3, r4, r3
	for (i = 0; i < d0; ++i) {
 80474f6:	2b00      	cmp	r3, #0
		conv_rot180(w->d[0] * w->d[1], w->d[2], w->x);
 80474f8:	461c      	mov	r4, r3
	for (i = 0; i < d0; ++i) {
 80474fa:	dd1a      	ble.n	8047532 <kad_op_conv1d+0x166>
		for (j = 0; j < d1>>1; ++j)
 80474fc:	9b03      	ldr	r3, [sp, #12]
 80474fe:	1059      	asrs	r1, r3, #1
 8047500:	2900      	cmp	r1, #0
 8047502:	dd16      	ble.n	8047532 <kad_op_conv1d+0x166>
	for (i = 0; i < d0; ++i) {
 8047504:	2500      	movs	r5, #0
 8047506:	6ab0      	ldr	r0, [r6, #40]	@ 0x28
 8047508:	ea4f 0c83 	mov.w	ip, r3, lsl #2
 804750c:	eb00 0181 	add.w	r1, r0, r1, lsl #2
		for (j = 0; j < d1>>1; ++j)
 8047510:	4603      	mov	r3, r0
 8047512:	4460      	add	r0, ip
	for (i = 0; i < d0; ++i) {
 8047514:	4602      	mov	r2, r0
			tmp = xi[j], xi[j] = xi[d1-1-j], xi[d1-1-j] = tmp; 
 8047516:	f852 8d04 	ldr.w	r8, [r2, #-4]!
 804751a:	f8d3 e000 	ldr.w	lr, [r3]
 804751e:	f843 8b04 	str.w	r8, [r3], #4
		for (j = 0; j < d1>>1; ++j)
 8047522:	4299      	cmp	r1, r3
			tmp = xi[j], xi[j] = xi[d1-1-j], xi[d1-1-j] = tmp; 
 8047524:	f8c2 e000 	str.w	lr, [r2]
		for (j = 0; j < d1>>1; ++j)
 8047528:	d1f5      	bne.n	8047516 <kad_op_conv1d+0x14a>
	for (i = 0; i < d0; ++i) {
 804752a:	3501      	adds	r5, #1
 804752c:	42ac      	cmp	r4, r5
 804752e:	4461      	add	r1, ip
 8047530:	d1ee      	bne.n	8047510 <kad_op_conv1d+0x144>
 8047532:	9b0d      	ldr	r3, [sp, #52]	@ 0x34
 8047534:	7819      	ldrb	r1, [r3, #0]
		memset(p->x, 0, kad_len(p) * sizeof(float));
 8047536:	6a98      	ldr	r0, [r3, #40]	@ 0x28
 8047538:	2900      	cmp	r1, #0
 804753a:	f000 824c 	beq.w	80479d6 <kad_op_conv1d+0x60a>
 804753e:	2901      	cmp	r1, #1
 8047540:	461c      	mov	r4, r3
 8047542:	691a      	ldr	r2, [r3, #16]
 8047544:	d00b      	beq.n	804755e <kad_op_conv1d+0x192>
 8047546:	695b      	ldr	r3, [r3, #20]
 8047548:	2902      	cmp	r1, #2
 804754a:	fb03 f202 	mul.w	r2, r3, r2
 804754e:	d006      	beq.n	804755e <kad_op_conv1d+0x192>
 8047550:	69a3      	ldr	r3, [r4, #24]
 8047552:	2903      	cmp	r1, #3
 8047554:	fb03 f202 	mul.w	r2, r3, r2
 8047558:	bf1c      	itt	ne
 804755a:	69e3      	ldrne	r3, [r4, #28]
 804755c:	435a      	mulne	r2, r3
 804755e:	0092      	lsls	r2, r2, #2
 8047560:	2100      	movs	r1, #0
 8047562:	f004 fc2b 	bl	804bdbc <memset>
			conv1d_loop1(q->x, w->x, p->x, t, process_row_for);
 8047566:	9b04      	ldr	r3, [sp, #16]
		if (!algo_switch) { /* this is the first algorithm */
 8047568:	2f00      	cmp	r7, #0
 804756a:	f040 8710 	bne.w	804838e <kad_op_conv1d+0xfc2>
			conv1d_loop1(q->x, w->x, p->x, t, process_row_for);
 804756e:	691c      	ldr	r4, [r3, #16]
 8047570:	6ab0      	ldr	r0, [r6, #40]	@ 0x28
 8047572:	69b3      	ldr	r3, [r6, #24]
 8047574:	6932      	ldr	r2, [r6, #16]
 8047576:	6971      	ldr	r1, [r6, #20]
 8047578:	2c00      	cmp	r4, #0
 804757a:	9305      	str	r3, [sp, #20]
 804757c:	900e      	str	r0, [sp, #56]	@ 0x38
 804757e:	920a      	str	r2, [sp, #40]	@ 0x28
 8047580:	9102      	str	r1, [sp, #8]
 8047582:	f340 81d7 	ble.w	8047934 <kad_op_conv1d+0x568>
 8047586:	2a00      	cmp	r2, #0
 8047588:	f340 81d4 	ble.w	8047934 <kad_op_conv1d+0x568>
 804758c:	2900      	cmp	r1, #0
 804758e:	f77f af32 	ble.w	80473f6 <kad_op_conv1d+0x2a>
 8047592:	461a      	mov	r2, r3
 8047594:	fb01 f303 	mul.w	r3, r1, r3
 8047598:	009b      	lsls	r3, r3, #2
 804759a:	9314      	str	r3, [sp, #80]	@ 0x50
 804759c:	4613      	mov	r3, r2
 804759e:	46be      	mov	lr, r7
 80475a0:	0092      	lsls	r2, r2, #2
 80475a2:	9f0f      	ldr	r7, [sp, #60]	@ 0x3c
 80475a4:	9206      	str	r2, [sp, #24]
 80475a6:	eb00 0683 	add.w	r6, r0, r3, lsl #2
 80475aa:	f04f 0c00 	mov.w	ip, #0
 80475ae:	465b      	mov	r3, fp
 80475b0:	e9cd 4615 	strd	r4, r6, [sp, #84]	@ 0x54
 80475b4:	960c      	str	r6, [sp, #48]	@ 0x30
 80475b6:	f8cd e040 	str.w	lr, [sp, #64]	@ 0x40
 80475ba:	9e0d      	ldr	r6, [sp, #52]	@ 0x34
 80475bc:	f8dd e010 	ldr.w	lr, [sp, #16]
 80475c0:	9810      	ldr	r0, [sp, #64]	@ 0x40
 80475c2:	f8de 1014 	ldr.w	r1, [lr, #20]
 80475c6:	6972      	ldr	r2, [r6, #20]
 80475c8:	fb00 f101 	mul.w	r1, r0, r1
 80475cc:	fb02 c200 	mla	r2, r2, r0, ip
 80475d0:	f8de 0018 	ldr.w	r0, [lr, #24]
 80475d4:	69b5      	ldr	r5, [r6, #24]
 80475d6:	fb00 f401 	mul.w	r4, r0, r1
 80475da:	fb05 f202 	mul.w	r2, r5, r2
 80475de:	0081      	lsls	r1, r0, #2
 80475e0:	9101      	str	r1, [sp, #4]
 80475e2:	6ab0      	ldr	r0, [r6, #40]	@ 0x28
 80475e4:	f8de 1028 	ldr.w	r1, [lr, #40]	@ 0x28
 80475e8:	eb00 0982 	add.w	r9, r0, r2, lsl #2
 80475ec:	eb01 0184 	add.w	r1, r1, r4, lsl #2
 80475f0:	eb00 0485 	add.w	r4, r0, r5, lsl #2
 80475f4:	eb04 0482 	add.w	r4, r4, r2, lsl #2
 80475f8:	9a0c      	ldr	r2, [sp, #48]	@ 0x30
 80475fa:	f04f 0a00 	mov.w	sl, #0
 80475fe:	4690      	mov	r8, r2
 8047600:	9806      	ldr	r0, [sp, #24]
 8047602:	e9cd ec11 	strd	lr, ip, [sp, #68]	@ 0x44
 8047606:	9503      	str	r5, [sp, #12]
 8047608:	eba2 0b00 	sub.w	fp, r2, r0
 804760c:	eb07 0585 	add.w	r5, r7, r5, lsl #2
 8047610:	9613      	str	r6, [sp, #76]	@ 0x4c
 8047612:	9a00      	ldr	r2, [sp, #0]
 8047614:	460e      	mov	r6, r1
 8047616:	b152      	cbz	r2, 804762e <kad_op_conv1d+0x262>
 8047618:	689e      	ldr	r6, [r3, #8]
 804761a:	9308      	str	r3, [sp, #32]
 804761c:	eb02 0686 	add.w	r6, r2, r6, lsl #2
 8047620:	4630      	mov	r0, r6
 8047622:	9a01      	ldr	r2, [sp, #4]
 8047624:	9107      	str	r1, [sp, #28]
 8047626:	f004 fcc6 	bl	804bfb6 <memcpy>
 804762a:	e9dd 1307 	ldrd	r1, r3, [sp, #28]
 804762e:	6858      	ldr	r0, [r3, #4]
 8047630:	9a05      	ldr	r2, [sp, #20]
 8047632:	2801      	cmp	r0, #1
 8047634:	f340 80bc 	ble.w	80477b0 <kad_op_conv1d+0x3e4>
 8047638:	2a00      	cmp	r2, #0
 804763a:	dd27      	ble.n	804768c <kad_op_conv1d+0x2c0>
 804763c:	46dc      	mov	ip, fp
 804763e:	689a      	ldr	r2, [r3, #8]
 8047640:	0080      	lsls	r0, r0, #2
 8047642:	ebc2 7282 	rsb	r2, r2, r2, lsl #30
 8047646:	eb06 0682 	add.w	r6, r6, r2, lsl #2
 804764a:	9a03      	ldr	r2, [sp, #12]
 804764c:	2a00      	cmp	r2, #0
 804764e:	f340 80a7 	ble.w	80477a0 <kad_op_conv1d+0x3d4>
 8047652:	4632      	mov	r2, r6
 8047654:	46be      	mov	lr, r7
 8047656:	edd2 7a00 	vldr	s15, [r2]
 804765a:	ecee 7a01 	vstmia	lr!, {s15}
 804765e:	45ae      	cmp	lr, r5
 8047660:	4402      	add	r2, r0
 8047662:	d1f8      	bne.n	8047656 <kad_op_conv1d+0x28a>
 8047664:	eddc 6a00 	vldr	s13, [ip]
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 8047668:	464a      	mov	r2, r9
			conv1d_loop1(q->x, w->x, p->x, t, process_row_for);
 804766a:	46be      	mov	lr, r7
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 804766c:	edd2 7a00 	vldr	s15, [r2]
 8047670:	ecbe 7a01 	vldmia	lr!, {s14}
 8047674:	eee6 7a87 	vfma.f32	s15, s13, s14
 8047678:	ece2 7a01 	vstmia	r2!, {s15}
 804767c:	4294      	cmp	r4, r2
 804767e:	d1f5      	bne.n	804766c <kad_op_conv1d+0x2a0>
			conv1d_loop1(q->x, w->x, p->x, t, process_row_for);
 8047680:	f10c 0c04 	add.w	ip, ip, #4
 8047684:	45c4      	cmp	ip, r8
 8047686:	f106 0604 	add.w	r6, r6, #4
 804768a:	d1e2      	bne.n	8047652 <kad_op_conv1d+0x286>
 804768c:	9a06      	ldr	r2, [sp, #24]
 804768e:	f10a 0a01 	add.w	sl, sl, #1
 8047692:	4490      	add	r8, r2
 8047694:	4493      	add	fp, r2
 8047696:	9a01      	ldr	r2, [sp, #4]
 8047698:	4411      	add	r1, r2
 804769a:	9a02      	ldr	r2, [sp, #8]
 804769c:	4592      	cmp	sl, r2
 804769e:	d1b8      	bne.n	8047612 <kad_op_conv1d+0x246>
 80476a0:	e9dd ec11 	ldrd	lr, ip, [sp, #68]	@ 0x44
 80476a4:	9a0c      	ldr	r2, [sp, #48]	@ 0x30
 80476a6:	9914      	ldr	r1, [sp, #80]	@ 0x50
 80476a8:	f10c 0c01 	add.w	ip, ip, #1
 80476ac:	440a      	add	r2, r1
 80476ae:	920c      	str	r2, [sp, #48]	@ 0x30
 80476b0:	9a0a      	ldr	r2, [sp, #40]	@ 0x28
 80476b2:	9e13      	ldr	r6, [sp, #76]	@ 0x4c
 80476b4:	4594      	cmp	ip, r2
 80476b6:	d183      	bne.n	80475c0 <kad_op_conv1d+0x1f4>
 80476b8:	e9dd 4615 	ldrd	r4, r6, [sp, #84]	@ 0x54
 80476bc:	f8dd e040 	ldr.w	lr, [sp, #64]	@ 0x40
 80476c0:	469b      	mov	fp, r3
 80476c2:	f10e 0e01 	add.w	lr, lr, #1
 80476c6:	45a6      	cmp	lr, r4
 80476c8:	f47f af6f 	bne.w	80475aa <kad_op_conv1d+0x1de>
		conv_rot180(w->d[0] * w->d[1], w->d[2], w->x);
 80476cc:	fb0a f60c 	mul.w	r6, sl, ip
		for (j = 0; j < d1>>1; ++j)
 80476d0:	9b05      	ldr	r3, [sp, #20]
 80476d2:	1059      	asrs	r1, r3, #1
 80476d4:	2900      	cmp	r1, #0
 80476d6:	f77f ae8e 	ble.w	80473f6 <kad_op_conv1d+0x2a>
	for (i = 0; i < d0; ++i) {
 80476da:	2700      	movs	r7, #0
 80476dc:	9d0e      	ldr	r5, [sp, #56]	@ 0x38
 80476de:	ea4f 0c83 	mov.w	ip, r3, lsl #2
 80476e2:	eb05 0181 	add.w	r1, r5, r1, lsl #2
		for (j = 0; j < d1>>1; ++j)
 80476e6:	462b      	mov	r3, r5
 80476e8:	4465      	add	r5, ip
	for (i = 0; i < d0; ++i) {
 80476ea:	462a      	mov	r2, r5
			tmp = xi[j], xi[j] = xi[d1-1-j], xi[d1-1-j] = tmp; 
 80476ec:	f852 4d04 	ldr.w	r4, [r2, #-4]!
 80476f0:	6818      	ldr	r0, [r3, #0]
 80476f2:	f843 4b04 	str.w	r4, [r3], #4
		for (j = 0; j < d1>>1; ++j)
 80476f6:	428b      	cmp	r3, r1
			tmp = xi[j], xi[j] = xi[d1-1-j], xi[d1-1-j] = tmp; 
 80476f8:	6010      	str	r0, [r2, #0]
		for (j = 0; j < d1>>1; ++j)
 80476fa:	d1f7      	bne.n	80476ec <kad_op_conv1d+0x320>
	for (i = 0; i < d0; ++i) {
 80476fc:	3701      	adds	r7, #1
 80476fe:	42b7      	cmp	r7, r6
 8047700:	4461      	add	r1, ip
 8047702:	d1f0      	bne.n	80476e6 <kad_op_conv1d+0x31a>
 8047704:	e677      	b.n	80473f6 <kad_op_conv1d+0x2a>
			x_padded = aux->pad[0] + aux->pad[1] > 0? (float*)calloc((q->d[2] + aux->pad[0] + aux->pad[1]) * q->d[1], sizeof(float)) : 0;
 8047706:	9804      	ldr	r0, [sp, #16]
			algo_switch = 1;
 8047708:	2701      	movs	r7, #1
			x_padded = aux->pad[0] + aux->pad[1] > 0? (float*)calloc((q->d[2] + aux->pad[0] + aux->pad[1]) * q->d[1], sizeof(float)) : 0;
 804770a:	6981      	ldr	r1, [r0, #24]
 804770c:	6940      	ldr	r0, [r0, #20]
 804770e:	440b      	add	r3, r1
 8047710:	4413      	add	r3, r2
 8047712:	fb03 f000 	mul.w	r0, r3, r0
 8047716:	2104      	movs	r1, #4
 8047718:	f004 f846 	bl	804b7a8 <calloc>
	float *t = 0, *q1 = 0, *w1 = 0, *x_padded = 0;
 804771c:	2300      	movs	r3, #0
	} else if (action == KAD_FORWARD) {
 804771e:	2c02      	cmp	r4, #2
	float *t = 0, *q1 = 0, *w1 = 0, *x_padded = 0;
 8047720:	930f      	str	r3, [sp, #60]	@ 0x3c
			x_padded = aux->pad[0] + aux->pad[1] > 0? (float*)calloc((q->d[2] + aux->pad[0] + aux->pad[1]) * q->d[1], sizeof(float)) : 0;
 8047722:	9000      	str	r0, [sp, #0]
	} else if (action == KAD_FORWARD) {
 8047724:	f43f aee3 	beq.w	80474ee <kad_op_conv1d+0x122>
		if (kad_is_back(p->child[0])) { /* backprop to the input array */
 8047728:	9b04      	ldr	r3, [sp, #16]
 804772a:	785b      	ldrb	r3, [r3, #1]
 804772c:	07d9      	lsls	r1, r3, #31
 804772e:	f100 8119 	bmi.w	8047964 <kad_op_conv1d+0x598>
		if (kad_is_back(p->child[1])) { /* backprop to the weight matrix */
 8047732:	7873      	ldrb	r3, [r6, #1]
 8047734:	07da      	lsls	r2, r3, #31
 8047736:	f57f ae5e 	bpl.w	80473f6 <kad_op_conv1d+0x2a>
			conv_rot180(w->d[0] * w->d[1], w->d[2], w->g);
 804773a:	6933      	ldr	r3, [r6, #16]
 804773c:	9a05      	ldr	r2, [sp, #20]
 804773e:	9308      	str	r3, [sp, #32]
 8047740:	fb03 f302 	mul.w	r3, r3, r2
	for (i = 0; i < d0; ++i) {
 8047744:	2b00      	cmp	r3, #0
			conv_rot180(w->d[0] * w->d[1], w->d[2], w->g);
 8047746:	f8d6 902c 	ldr.w	r9, [r6, #44]	@ 0x2c
 804774a:	930e      	str	r3, [sp, #56]	@ 0x38
	for (i = 0; i < d0; ++i) {
 804774c:	f340 8261 	ble.w	8047c12 <kad_op_conv1d+0x846>
		for (j = 0; j < d1>>1; ++j)
 8047750:	9903      	ldr	r1, [sp, #12]
 8047752:	104b      	asrs	r3, r1, #1
 8047754:	2b00      	cmp	r3, #0
 8047756:	f340 83bf 	ble.w	8047ed8 <kad_op_conv1d+0xb0c>
 804775a:	0089      	lsls	r1, r1, #2
 804775c:	464a      	mov	r2, r9
	for (i = 0; i < d0; ++i) {
 804775e:	2500      	movs	r5, #0
 8047760:	468c      	mov	ip, r1
 8047762:	9102      	str	r1, [sp, #8]
 8047764:	eb09 0083 	add.w	r0, r9, r3, lsl #2
		for (j = 0; j < d1>>1; ++j)
 8047768:	4611      	mov	r1, r2
 804776a:	4462      	add	r2, ip
	for (i = 0; i < d0; ++i) {
 804776c:	4614      	mov	r4, r2
			tmp = xi[j], xi[j] = xi[d1-1-j], xi[d1-1-j] = tmp; 
 804776e:	f854 8d04 	ldr.w	r8, [r4, #-4]!
 8047772:	f8d1 e000 	ldr.w	lr, [r1]
 8047776:	f841 8b04 	str.w	r8, [r1], #4
		for (j = 0; j < d1>>1; ++j)
 804777a:	4288      	cmp	r0, r1
			tmp = xi[j], xi[j] = xi[d1-1-j], xi[d1-1-j] = tmp; 
 804777c:	f8c4 e000 	str.w	lr, [r4]
		for (j = 0; j < d1>>1; ++j)
 8047780:	d1f5      	bne.n	804776e <kad_op_conv1d+0x3a2>
	for (i = 0; i < d0; ++i) {
 8047782:	990e      	ldr	r1, [sp, #56]	@ 0x38
 8047784:	3501      	adds	r5, #1
 8047786:	42a9      	cmp	r1, r5
 8047788:	4460      	add	r0, ip
 804778a:	d1ed      	bne.n	8047768 <kad_op_conv1d+0x39c>
				conv1d_loop1(q->g, w->x, p->g, t, process_row_back_x);
 804778c:	9a04      	ldr	r2, [sp, #16]
 804778e:	6912      	ldr	r2, [r2, #16]
			if (!algo_switch) {
 8047790:	2f00      	cmp	r7, #0
 8047792:	f040 8492 	bne.w	80480ba <kad_op_conv1d+0xcee>
				conv1d_loop1(q->x, w->g, p->g, t, process_row_back_w);
 8047796:	2a00      	cmp	r2, #0
 8047798:	f300 83a6 	bgt.w	8047ee8 <kad_op_conv1d+0xb1c>
 804779c:	f000 bc4e 	b.w	804803c <kad_op_conv1d+0xc70>
			conv1d_loop1(q->x, w->x, p->x, t, process_row_for);
 80477a0:	f10c 0c04 	add.w	ip, ip, #4
 80477a4:	45c4      	cmp	ip, r8
 80477a6:	f106 0604 	add.w	r6, r6, #4
 80477aa:	f47f af4e 	bne.w	804764a <kad_op_conv1d+0x27e>
 80477ae:	e76d      	b.n	804768c <kad_op_conv1d+0x2c0>
 80477b0:	2a00      	cmp	r2, #0
 80477b2:	f77f af6b 	ble.w	804768c <kad_op_conv1d+0x2c0>
 80477b6:	9803      	ldr	r0, [sp, #12]
 80477b8:	689a      	ldr	r2, [r3, #8]
 80477ba:	2800      	cmp	r0, #0
 80477bc:	f77f af66 	ble.w	804768c <kad_op_conv1d+0x2c0>
 80477c0:	46de      	mov	lr, fp
 80477c2:	ebc2 7282 	rsb	r2, r2, r2, lsl #30
 80477c6:	ea4f 0c82 	mov.w	ip, r2, lsl #2
 80477ca:	ecfe 6a01 	vldmia	lr!, {s13}
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 80477ce:	464a      	mov	r2, r9
 80477d0:	eb06 000c 	add.w	r0, r6, ip
 80477d4:	edd2 7a00 	vldr	s15, [r2]
 80477d8:	ecb0 7a01 	vldmia	r0!, {s14}
 80477dc:	eee6 7a87 	vfma.f32	s15, s13, s14
 80477e0:	ece2 7a01 	vstmia	r2!, {s15}
 80477e4:	42a2      	cmp	r2, r4
 80477e6:	d1f5      	bne.n	80477d4 <kad_op_conv1d+0x408>
			conv1d_loop1(q->x, w->x, p->x, t, process_row_for);
 80477e8:	45f0      	cmp	r8, lr
 80477ea:	f10c 0c04 	add.w	ip, ip, #4
 80477ee:	d1ec      	bne.n	80477ca <kad_op_conv1d+0x3fe>
 80477f0:	e74c      	b.n	804768c <kad_op_conv1d+0x2c0>
			t = (float*)malloc(p->d[2] * sizeof(float));
 80477f2:	9b0d      	ldr	r3, [sp, #52]	@ 0x34
 80477f4:	6998      	ldr	r0, [r3, #24]
 80477f6:	0080      	lsls	r0, r0, #2
 80477f8:	f003 fff2 	bl	804b7e0 <malloc>
			x_padded = aux->pad[0] + aux->pad[1] > 0? (float*)calloc(q->d[2] + aux->pad[0] + aux->pad[1], sizeof(float)) : 0;
 80477fc:	e9db 3202 	ldrd	r3, r2, [fp, #8]
 8047800:	1899      	adds	r1, r3, r2
 8047802:	2900      	cmp	r1, #0
			t = (float*)malloc(p->d[2] * sizeof(float));
 8047804:	900f      	str	r0, [sp, #60]	@ 0x3c
			x_padded = aux->pad[0] + aux->pad[1] > 0? (float*)calloc(q->d[2] + aux->pad[0] + aux->pad[1], sizeof(float)) : 0;
 8047806:	f300 809d 	bgt.w	8047944 <kad_op_conv1d+0x578>
	int algo_switch = 0;
 804780a:	2700      	movs	r7, #0
			x_padded = aux->pad[0] + aux->pad[1] > 0? (float*)calloc(q->d[2] + aux->pad[0] + aux->pad[1], sizeof(float)) : 0;
 804780c:	9700      	str	r7, [sp, #0]
	float *t = 0, *q1 = 0, *w1 = 0, *x_padded = 0;
 804780e:	9709      	str	r7, [sp, #36]	@ 0x24
 8047810:	970b      	str	r7, [sp, #44]	@ 0x2c
 8047812:	e669      	b.n	80474e8 <kad_op_conv1d+0x11c>
	for (k = 0; k < d[0]; ++k)
 8047814:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 8047816:	f10e 0e01 	add.w	lr, lr, #1
 804781a:	459e      	cmp	lr, r3
 804781c:	44b4      	add	ip, r6
 804781e:	4417      	add	r7, r2
 8047820:	f2c0 860a 	blt.w	8048438 <kad_op_conv1d+0x106c>
 8047824:	4611      	mov	r1, r2
			conv1d_loop2(q1, w1, p->x, (*_yy += kad_sdot(m, _ww, _xx)));
 8047826:	f8db 3004 	ldr.w	r3, [fp, #4]
 804782a:	fb03 f209 	mul.w	r2, r3, r9
 804782e:	9b05      	ldr	r3, [sp, #20]
 8047830:	fb01 f303 	mul.w	r3, r1, r3
 8047834:	9901      	ldr	r1, [sp, #4]
 8047836:	2900      	cmp	r1, #0
 8047838:	dd7c      	ble.n	8047934 <kad_op_conv1d+0x568>
 804783a:	ea4f 0882 	mov.w	r8, r2, lsl #2
 804783e:	9a0a      	ldr	r2, [sp, #40]	@ 0x28
 8047840:	2a00      	cmp	r2, #0
 8047842:	dd77      	ble.n	8047934 <kad_op_conv1d+0x568>
 8047844:	2500      	movs	r5, #0
 8047846:	009a      	lsls	r2, r3, #2
 8047848:	920c      	str	r2, [sp, #48]	@ 0x30
 804784a:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 804784c:	462e      	mov	r6, r5
 804784e:	eb02 0e83 	add.w	lr, r2, r3, lsl #2
 8047852:	462a      	mov	r2, r5
 8047854:	461d      	mov	r5, r3
 8047856:	980d      	ldr	r0, [sp, #52]	@ 0x34
 8047858:	6943      	ldr	r3, [r0, #20]
			conv1d_loop1(q->x, w->x, p->x, t, process_row_for);
 804785a:	6987      	ldr	r7, [r0, #24]
			conv1d_loop2(q1, w1, p->x, (*_yy += kad_sdot(m, _ww, _xx)));
 804785c:	fb03 f406 	mul.w	r4, r3, r6
			conv1d_loop1(q->x, w->x, p->x, t, process_row_for);
 8047860:	9b04      	ldr	r3, [sp, #16]
 8047862:	fb07 f404 	mul.w	r4, r7, r4
 8047866:	699b      	ldr	r3, [r3, #24]
 8047868:	e9cd 6210 	strd	r6, r2, [sp, #64]	@ 0x40
			conv1d_loop2(q1, w1, p->x, (*_yy += kad_sdot(m, _ww, _xx)));
 804786c:	fb03 f102 	mul.w	r1, r3, r2
 8047870:	fb09 fc03 	mul.w	ip, r9, r3
 8047874:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 8047876:	f8dd a024 	ldr.w	sl, [sp, #36]	@ 0x24
 804787a:	eb03 0181 	add.w	r1, r3, r1, lsl #2
 804787e:	ea4f 038c 	mov.w	r3, ip, lsl #2
 8047882:	9307      	str	r3, [sp, #28]
 8047884:	6a83      	ldr	r3, [r0, #40]	@ 0x28
 8047886:	f8cd e048 	str.w	lr, [sp, #72]	@ 0x48
 804788a:	eb03 0384 	add.w	r3, r3, r4, lsl #2
 804788e:	9c00      	ldr	r4, [sp, #0]
 8047890:	9303      	str	r3, [sp, #12]
 8047892:	4623      	mov	r3, r4
 8047894:	2c00      	cmp	r4, #0
 8047896:	bf08      	it	eq
 8047898:	460b      	moveq	r3, r1
 804789a:	9308      	str	r3, [sp, #32]
 804789c:	2300      	movs	r3, #0
 804789e:	9306      	str	r3, [sp, #24]
 80478a0:	00bb      	lsls	r3, r7, #2
 80478a2:	930d      	str	r3, [sp, #52]	@ 0x34
 80478a4:	4674      	mov	r4, lr
 80478a6:	4603      	mov	r3, r0
 80478a8:	9800      	ldr	r0, [sp, #0]
 80478aa:	9e03      	ldr	r6, [sp, #12]
 80478ac:	b160      	cbz	r0, 80478c8 <kad_op_conv1d+0x4fc>
 80478ae:	f8db 2008 	ldr.w	r2, [fp, #8]
 80478b2:	9314      	str	r3, [sp, #80]	@ 0x50
 80478b4:	fb02 f209 	mul.w	r2, r2, r9
 80478b8:	eb00 0082 	add.w	r0, r0, r2, lsl #2
 80478bc:	9a07      	ldr	r2, [sp, #28]
 80478be:	9113      	str	r1, [sp, #76]	@ 0x4c
 80478c0:	f004 fb79 	bl	804bfb6 <memcpy>
 80478c4:	e9dd 1313 	ldrd	r1, r3, [sp, #76]	@ 0x4c
 80478c8:	2f00      	cmp	r7, #0
 80478ca:	dd1c      	ble.n	8047906 <kad_op_conv1d+0x53a>
 80478cc:	f04f 0c00 	mov.w	ip, #0
 80478d0:	f8dd e020 	ldr.w	lr, [sp, #32]
	for (i = 0; i < n; ++i) s += x[i] * y[i];
 80478d4:	2d00      	cmp	r5, #0
	float s = 0.;
 80478d6:	eddf 7aba 	vldr	s15, [pc, #744]	@ 8047bc0 <kad_op_conv1d+0x7f4>
	for (i = 0; i < n; ++i) s += x[i] * y[i];
 80478da:	dd09      	ble.n	80478f0 <kad_op_conv1d+0x524>
 80478dc:	4670      	mov	r0, lr
 80478de:	4652      	mov	r2, sl
 80478e0:	ecf2 6a01 	vldmia	r2!, {s13}
 80478e4:	ecb0 7a01 	vldmia	r0!, {s14}
 80478e8:	4294      	cmp	r4, r2
 80478ea:	eee6 7a87 	vfma.f32	s15, s13, s14
 80478ee:	d1f7      	bne.n	80478e0 <kad_op_conv1d+0x514>
			conv1d_loop2(q1, w1, p->x, (*_yy += kad_sdot(m, _ww, _xx)));
 80478f0:	ed96 7a00 	vldr	s14, [r6]
 80478f4:	ee77 7a27 	vadd.f32	s15, s14, s15
 80478f8:	f10c 0c01 	add.w	ip, ip, #1
 80478fc:	45bc      	cmp	ip, r7
 80478fe:	ece6 7a01 	vstmia	r6!, {s15}
 8047902:	44c6      	add	lr, r8
 8047904:	d1e6      	bne.n	80478d4 <kad_op_conv1d+0x508>
 8047906:	9803      	ldr	r0, [sp, #12]
 8047908:	9e0d      	ldr	r6, [sp, #52]	@ 0x34
 804790a:	9a06      	ldr	r2, [sp, #24]
 804790c:	4430      	add	r0, r6
 804790e:	9003      	str	r0, [sp, #12]
 8047910:	980c      	ldr	r0, [sp, #48]	@ 0x30
 8047912:	3201      	adds	r2, #1
 8047914:	4482      	add	sl, r0
 8047916:	4404      	add	r4, r0
 8047918:	980a      	ldr	r0, [sp, #40]	@ 0x28
 804791a:	9206      	str	r2, [sp, #24]
 804791c:	4282      	cmp	r2, r0
 804791e:	d1c3      	bne.n	80478a8 <kad_op_conv1d+0x4dc>
 8047920:	e9dd 6210 	ldrd	r6, r2, [sp, #64]	@ 0x40
 8047924:	4618      	mov	r0, r3
 8047926:	9b01      	ldr	r3, [sp, #4]
 8047928:	3601      	adds	r6, #1
 804792a:	429e      	cmp	r6, r3
 804792c:	f8dd e048 	ldr.w	lr, [sp, #72]	@ 0x48
 8047930:	444a      	add	r2, r9
 8047932:	d191      	bne.n	8047858 <kad_op_conv1d+0x48c>
		conv_rot180(w->d[0] * w->d[1], w->d[2], w->x);
 8047934:	9e0a      	ldr	r6, [sp, #40]	@ 0x28
 8047936:	9b02      	ldr	r3, [sp, #8]
 8047938:	fb03 f606 	mul.w	r6, r3, r6
	for (i = 0; i < d0; ++i) {
 804793c:	2e00      	cmp	r6, #0
 804793e:	f73f aec7 	bgt.w	80476d0 <kad_op_conv1d+0x304>
 8047942:	e558      	b.n	80473f6 <kad_op_conv1d+0x2a>
			x_padded = aux->pad[0] + aux->pad[1] > 0? (float*)calloc(q->d[2] + aux->pad[0] + aux->pad[1], sizeof(float)) : 0;
 8047944:	9904      	ldr	r1, [sp, #16]
	int algo_switch = 0;
 8047946:	2700      	movs	r7, #0
			x_padded = aux->pad[0] + aux->pad[1] > 0? (float*)calloc(q->d[2] + aux->pad[0] + aux->pad[1], sizeof(float)) : 0;
 8047948:	6989      	ldr	r1, [r1, #24]
 804794a:	440b      	add	r3, r1
 804794c:	1898      	adds	r0, r3, r2
 804794e:	2104      	movs	r1, #4
 8047950:	f003 ff2a 	bl	804b7a8 <calloc>
	float *t = 0, *q1 = 0, *w1 = 0, *x_padded = 0;
 8047954:	9709      	str	r7, [sp, #36]	@ 0x24
			x_padded = aux->pad[0] + aux->pad[1] > 0? (float*)calloc(q->d[2] + aux->pad[0] + aux->pad[1], sizeof(float)) : 0;
 8047956:	9000      	str	r0, [sp, #0]
	float *t = 0, *q1 = 0, *w1 = 0, *x_padded = 0;
 8047958:	970b      	str	r7, [sp, #44]	@ 0x2c
 804795a:	e5c5      	b.n	80474e8 <kad_op_conv1d+0x11c>
 804795c:	2004      	movs	r0, #4
 804795e:	e5b6      	b.n	80474ce <kad_op_conv1d+0x102>
 8047960:	2004      	movs	r0, #4
 8047962:	e59d      	b.n	80474a0 <kad_op_conv1d+0xd4>
			conv_rot180(w->d[0] * w->d[1], w->d[2], w->x);
 8047964:	6933      	ldr	r3, [r6, #16]
 8047966:	9a05      	ldr	r2, [sp, #20]
 8047968:	9308      	str	r3, [sp, #32]
 804796a:	fb03 f302 	mul.w	r3, r3, r2
	for (i = 0; i < d0; ++i) {
 804796e:	2b00      	cmp	r3, #0
			conv_rot180(w->d[0] * w->d[1], w->d[2], w->x);
 8047970:	f8d6 8028 	ldr.w	r8, [r6, #40]	@ 0x28
 8047974:	930e      	str	r3, [sp, #56]	@ 0x38
	for (i = 0; i < d0; ++i) {
 8047976:	f340 8298 	ble.w	8047eaa <kad_op_conv1d+0xade>
		for (j = 0; j < d1>>1; ++j)
 804797a:	9a03      	ldr	r2, [sp, #12]
 804797c:	1053      	asrs	r3, r2, #1
 804797e:	2b00      	cmp	r3, #0
 8047980:	dd2b      	ble.n	80479da <kad_op_conv1d+0x60e>
 8047982:	0092      	lsls	r2, r2, #2
 8047984:	4641      	mov	r1, r8
	for (i = 0; i < d0; ++i) {
 8047986:	2500      	movs	r5, #0
 8047988:	4694      	mov	ip, r2
 804798a:	9202      	str	r2, [sp, #8]
 804798c:	eb08 0483 	add.w	r4, r8, r3, lsl #2
		for (j = 0; j < d1>>1; ++j)
 8047990:	460a      	mov	r2, r1
 8047992:	4461      	add	r1, ip
	for (i = 0; i < d0; ++i) {
 8047994:	4608      	mov	r0, r1
			tmp = xi[j], xi[j] = xi[d1-1-j], xi[d1-1-j] = tmp; 
 8047996:	f850 9d04 	ldr.w	r9, [r0, #-4]!
 804799a:	f8d2 e000 	ldr.w	lr, [r2]
 804799e:	f842 9b04 	str.w	r9, [r2], #4
		for (j = 0; j < d1>>1; ++j)
 80479a2:	42a2      	cmp	r2, r4
			tmp = xi[j], xi[j] = xi[d1-1-j], xi[d1-1-j] = tmp; 
 80479a4:	f8c0 e000 	str.w	lr, [r0]
		for (j = 0; j < d1>>1; ++j)
 80479a8:	d1f5      	bne.n	8047996 <kad_op_conv1d+0x5ca>
	for (i = 0; i < d0; ++i) {
 80479aa:	eb02 040c 	add.w	r4, r2, ip
 80479ae:	9a0e      	ldr	r2, [sp, #56]	@ 0x38
 80479b0:	3501      	adds	r5, #1
 80479b2:	42aa      	cmp	r2, r5
 80479b4:	d1ec      	bne.n	8047990 <kad_op_conv1d+0x5c4>
			if (!algo_switch) {
 80479b6:	2f00      	cmp	r7, #0
 80479b8:	f040 8138 	bne.w	8047c2c <kad_op_conv1d+0x860>
				conv1d_loop1(q->g, w->x, p->g, t, process_row_back_x);
 80479bc:	9a04      	ldr	r2, [sp, #16]
 80479be:	6912      	ldr	r2, [r2, #16]
 80479c0:	2a00      	cmp	r2, #0
 80479c2:	f340 80e5 	ble.w	8047b90 <kad_op_conv1d+0x7c4>
 80479c6:	9a08      	ldr	r2, [sp, #32]
 80479c8:	2a00      	cmp	r2, #0
 80479ca:	f340 80e1 	ble.w	8047b90 <kad_op_conv1d+0x7c4>
 80479ce:	9a05      	ldr	r2, [sp, #20]
 80479d0:	2a00      	cmp	r2, #0
 80479d2:	dc14      	bgt.n	80479fe <kad_op_conv1d+0x632>
 80479d4:	e0dc      	b.n	8047b90 <kad_op_conv1d+0x7c4>
 80479d6:	2204      	movs	r2, #4
 80479d8:	e5c2      	b.n	8047560 <kad_op_conv1d+0x194>
			if (!algo_switch) {
 80479da:	2f00      	cmp	r7, #0
 80479dc:	f040 8126 	bne.w	8047c2c <kad_op_conv1d+0x860>
				conv1d_loop1(q->g, w->x, p->g, t, process_row_back_x);
 80479e0:	9b04      	ldr	r3, [sp, #16]
 80479e2:	691b      	ldr	r3, [r3, #16]
 80479e4:	2b00      	cmp	r3, #0
 80479e6:	f77f aea4 	ble.w	8047732 <kad_op_conv1d+0x366>
 80479ea:	9b08      	ldr	r3, [sp, #32]
 80479ec:	2b00      	cmp	r3, #0
 80479ee:	f77f aea0 	ble.w	8047732 <kad_op_conv1d+0x366>
 80479f2:	9b05      	ldr	r3, [sp, #20]
 80479f4:	2b00      	cmp	r3, #0
 80479f6:	f77f ae9c 	ble.w	8047732 <kad_op_conv1d+0x366>
 80479fa:	0093      	lsls	r3, r2, #2
 80479fc:	9302      	str	r3, [sp, #8]
 80479fe:	2000      	movs	r0, #0
 8047a00:	e9cd 6716 	strd	r6, r7, [sp, #88]	@ 0x58
 8047a04:	4607      	mov	r7, r0
 8047a06:	9b11      	ldr	r3, [sp, #68]	@ 0x44
 8047a08:	f8cd b01c 	str.w	fp, [sp, #28]
 8047a0c:	ea4f 0c83 	mov.w	ip, r3, lsl #2
 8047a10:	9b02      	ldr	r3, [sp, #8]
 8047a12:	f8dd e010 	ldr.w	lr, [sp, #16]
 8047a16:	eb08 0903 	add.w	r9, r8, r3
 8047a1a:	46cb      	mov	fp, r9
 8047a1c:	f8dd 903c 	ldr.w	r9, [sp, #60]	@ 0x3c
 8047a20:	f8cd 8054 	str.w	r8, [sp, #84]	@ 0x54
 8047a24:	463e      	mov	r6, r7
 8047a26:	465d      	mov	r5, fp
 8047a28:	2000      	movs	r0, #0
 8047a2a:	4677      	mov	r7, lr
 8047a2c:	f8cd b060 	str.w	fp, [sp, #96]	@ 0x60
 8047a30:	9c0d      	ldr	r4, [sp, #52]	@ 0x34
				conv1d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _ww, _xx));
 8047a32:	69b9      	ldr	r1, [r7, #24]
			t = (float*)malloc(p->d[2] * sizeof(float));
 8047a34:	f8d4 8018 	ldr.w	r8, [r4, #24]
				conv1d_loop1(q->g, w->x, p->g, t, process_row_back_x);
 8047a38:	f8d4 a02c 	ldr.w	sl, [r4, #44]	@ 0x2c
 8047a3c:	6963      	ldr	r3, [r4, #20]
 8047a3e:	2400      	movs	r4, #0
 8047a40:	fb03 0206 	mla	r2, r3, r6, r0
 8047a44:	fb08 f202 	mul.w	r2, r8, r2
 8047a48:	940a      	str	r4, [sp, #40]	@ 0x28
 8047a4a:	0094      	lsls	r4, r2, #2
 8047a4c:	eb0a 0282 	add.w	r2, sl, r2, lsl #2
 8047a50:	9213      	str	r2, [sp, #76]	@ 0x4c
 8047a52:	9a02      	ldr	r2, [sp, #8]
 8047a54:	697b      	ldr	r3, [r7, #20]
 8047a56:	1aaa      	subs	r2, r5, r2
 8047a58:	9206      	str	r2, [sp, #24]
 8047a5a:	ea4f 0288 	mov.w	r2, r8, lsl #2
 8047a5e:	9201      	str	r2, [sp, #4]
 8047a60:	4652      	mov	r2, sl
 8047a62:	46aa      	mov	sl, r5
 8047a64:	4693      	mov	fp, r2
 8047a66:	fb06 f303 	mul.w	r3, r6, r3
 8047a6a:	fb01 f303 	mul.w	r3, r1, r3
 8047a6e:	0089      	lsls	r1, r1, #2
 8047a70:	910c      	str	r1, [sp, #48]	@ 0x30
 8047a72:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
 8047a74:	e9cd 5719 	strd	r5, r7, [sp, #100]	@ 0x64
 8047a78:	eb01 0183 	add.w	r1, r1, r3, lsl #2
 8047a7c:	e9cd 601b 	strd	r6, r0, [sp, #108]	@ 0x6c
 8047a80:	ebc8 7388 	rsb	r3, r8, r8, lsl #30
 8047a84:	009b      	lsls	r3, r3, #2
 8047a86:	9412      	str	r4, [sp, #72]	@ 0x48
 8047a88:	f8cd c074 	str.w	ip, [sp, #116]	@ 0x74
 8047a8c:	eb09 0488 	add.w	r4, r9, r8, lsl #2
 8047a90:	9314      	str	r3, [sp, #80]	@ 0x50
 8047a92:	9b00      	ldr	r3, [sp, #0]
 8047a94:	460d      	mov	r5, r1
 8047a96:	b14b      	cbz	r3, 8047aac <kad_op_conv1d+0x6e0>
 8047a98:	9a07      	ldr	r2, [sp, #28]
 8047a9a:	9110      	str	r1, [sp, #64]	@ 0x40
 8047a9c:	6895      	ldr	r5, [r2, #8]
 8047a9e:	9a0c      	ldr	r2, [sp, #48]	@ 0x30
 8047aa0:	eb03 0585 	add.w	r5, r3, r5, lsl #2
 8047aa4:	4628      	mov	r0, r5
 8047aa6:	f004 fa86 	bl	804bfb6 <memcpy>
 8047aaa:	9910      	ldr	r1, [sp, #64]	@ 0x40
 8047aac:	9b07      	ldr	r3, [sp, #28]
 8047aae:	685e      	ldr	r6, [r3, #4]
 8047ab0:	9b03      	ldr	r3, [sp, #12]
 8047ab2:	2e01      	cmp	r6, #1
 8047ab4:	f340 8086 	ble.w	8047bc4 <kad_op_conv1d+0x7f8>
 8047ab8:	2b00      	cmp	r3, #0
 8047aba:	dd36      	ble.n	8047b2a <kad_op_conv1d+0x75e>
 8047abc:	e9dd 7306 	ldrd	r7, r3, [sp, #24]
 8047ac0:	689a      	ldr	r2, [r3, #8]
 8047ac2:	464b      	mov	r3, r9
 8047ac4:	ebc2 7282 	rsb	r2, r2, r2, lsl #30
 8047ac8:	f8dd 9048 	ldr.w	r9, [sp, #72]	@ 0x48
 8047acc:	00b6      	lsls	r6, r6, #2
 8047ace:	eb05 0582 	add.w	r5, r5, r2, lsl #2
 8047ad2:	9110      	str	r1, [sp, #64]	@ 0x40
 8047ad4:	4618      	mov	r0, r3
 8047ad6:	9a01      	ldr	r2, [sp, #4]
 8047ad8:	2100      	movs	r1, #0
 8047ada:	f004 f96f 	bl	804bdbc <memset>
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 8047ade:	f1b8 0f00 	cmp.w	r8, #0
				conv1d_loop1(q->g, w->x, p->g, t, process_row_back_x);
 8047ae2:	4603      	mov	r3, r0
 8047ae4:	ecf7 6a01 	vldmia	r7!, {s13}
 8047ae8:	462a      	mov	r2, r5
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 8047aea:	dd18      	ble.n	8047b1e <kad_op_conv1d+0x752>
 8047aec:	4601      	mov	r1, r0
 8047aee:	eb0b 0009 	add.w	r0, fp, r9
 8047af2:	edd1 7a00 	vldr	s15, [r1]
 8047af6:	ecb0 7a01 	vldmia	r0!, {s14}
 8047afa:	eee6 7a87 	vfma.f32	s15, s13, s14
 8047afe:	ece1 7a01 	vstmia	r1!, {s15}
 8047b02:	428c      	cmp	r4, r1
 8047b04:	d1f5      	bne.n	8047af2 <kad_op_conv1d+0x726>
 8047b06:	4619      	mov	r1, r3
				conv1d_loop1(q->g, w->x, p->g, t, process_row_back_x);
 8047b08:	edd2 7a00 	vldr	s15, [r2]
 8047b0c:	ecb1 7a01 	vldmia	r1!, {s14}
 8047b10:	ee77 7a87 	vadd.f32	s15, s15, s14
 8047b14:	428c      	cmp	r4, r1
 8047b16:	edc2 7a00 	vstr	s15, [r2]
 8047b1a:	4432      	add	r2, r6
 8047b1c:	d1f4      	bne.n	8047b08 <kad_op_conv1d+0x73c>
 8047b1e:	45ba      	cmp	sl, r7
 8047b20:	f105 0504 	add.w	r5, r5, #4
 8047b24:	d1d6      	bne.n	8047ad4 <kad_op_conv1d+0x708>
 8047b26:	4699      	mov	r9, r3
 8047b28:	9910      	ldr	r1, [sp, #64]	@ 0x40
 8047b2a:	9a02      	ldr	r2, [sp, #8]
 8047b2c:	9806      	ldr	r0, [sp, #24]
 8047b2e:	4492      	add	sl, r2
 8047b30:	4410      	add	r0, r2
 8047b32:	9a0c      	ldr	r2, [sp, #48]	@ 0x30
 8047b34:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 8047b36:	4411      	add	r1, r2
 8047b38:	9a05      	ldr	r2, [sp, #20]
 8047b3a:	3301      	adds	r3, #1
 8047b3c:	429a      	cmp	r2, r3
 8047b3e:	930a      	str	r3, [sp, #40]	@ 0x28
 8047b40:	9006      	str	r0, [sp, #24]
 8047b42:	d1a6      	bne.n	8047a92 <kad_op_conv1d+0x6c6>
 8047b44:	e9dd 601b 	ldrd	r6, r0, [sp, #108]	@ 0x6c
 8047b48:	e9dd 5719 	ldrd	r5, r7, [sp, #100]	@ 0x64
 8047b4c:	9b08      	ldr	r3, [sp, #32]
 8047b4e:	f8dd c074 	ldr.w	ip, [sp, #116]	@ 0x74
 8047b52:	3001      	adds	r0, #1
 8047b54:	4283      	cmp	r3, r0
 8047b56:	4465      	add	r5, ip
 8047b58:	f47f af6a 	bne.w	8047a30 <kad_op_conv1d+0x664>
 8047b5c:	46be      	mov	lr, r7
 8047b5e:	4637      	mov	r7, r6
 8047b60:	f8de 3010 	ldr.w	r3, [lr, #16]
 8047b64:	3701      	adds	r7, #1
 8047b66:	42bb      	cmp	r3, r7
 8047b68:	f8dd b060 	ldr.w	fp, [sp, #96]	@ 0x60
 8047b6c:	f73f af5a 	bgt.w	8047a24 <kad_op_conv1d+0x658>
 8047b70:	e9dd 6716 	ldrd	r6, r7, [sp, #88]	@ 0x58
 8047b74:	f8dd 8054 	ldr.w	r8, [sp, #84]	@ 0x54
 8047b78:	f8dd b01c 	ldr.w	fp, [sp, #28]
	for (i = 0; i < d0; ++i) {
 8047b7c:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
 8047b7e:	2b00      	cmp	r3, #0
 8047b80:	dd41      	ble.n	8047c06 <kad_op_conv1d+0x83a>
		for (j = 0; j < d1>>1; ++j)
 8047b82:	9a03      	ldr	r2, [sp, #12]
 8047b84:	1053      	asrs	r3, r2, #1
 8047b86:	2b00      	cmp	r3, #0
 8047b88:	f77f add3 	ble.w	8047732 <kad_op_conv1d+0x366>
 8047b8c:	0092      	lsls	r2, r2, #2
 8047b8e:	9202      	str	r2, [sp, #8]
 8047b90:	4642      	mov	r2, r8
	for (k = 0; k < d[0]; ++k)
 8047b92:	2000      	movs	r0, #0
 8047b94:	9d02      	ldr	r5, [sp, #8]
 8047b96:	eb08 0383 	add.w	r3, r8, r3, lsl #2
		for (j = 0; j < d1>>1; ++j)
 8047b9a:	4611      	mov	r1, r2
 8047b9c:	442a      	add	r2, r5
	for (k = 0; k < d[0]; ++k)
 8047b9e:	4614      	mov	r4, r2
			tmp = xi[j], xi[j] = xi[d1-1-j], xi[d1-1-j] = tmp; 
 8047ba0:	f854 ed04 	ldr.w	lr, [r4, #-4]!
 8047ba4:	f8d1 c000 	ldr.w	ip, [r1]
 8047ba8:	f841 eb04 	str.w	lr, [r1], #4
		for (j = 0; j < d1>>1; ++j)
 8047bac:	428b      	cmp	r3, r1
			tmp = xi[j], xi[j] = xi[d1-1-j], xi[d1-1-j] = tmp; 
 8047bae:	f8c4 c000 	str.w	ip, [r4]
		for (j = 0; j < d1>>1; ++j)
 8047bb2:	d1f5      	bne.n	8047ba0 <kad_op_conv1d+0x7d4>
	for (i = 0; i < d0; ++i) {
 8047bb4:	990e      	ldr	r1, [sp, #56]	@ 0x38
 8047bb6:	3001      	adds	r0, #1
 8047bb8:	4281      	cmp	r1, r0
 8047bba:	442b      	add	r3, r5
 8047bbc:	d1ed      	bne.n	8047b9a <kad_op_conv1d+0x7ce>
 8047bbe:	e5b8      	b.n	8047732 <kad_op_conv1d+0x366>
 8047bc0:	00000000 	.word	0x00000000
				conv1d_loop1(q->g, w->x, p->g, t, process_row_back_x);
 8047bc4:	2b00      	cmp	r3, #0
 8047bc6:	ddb0      	ble.n	8047b2a <kad_op_conv1d+0x75e>
 8047bc8:	9b07      	ldr	r3, [sp, #28]
 8047bca:	f1b8 0f00 	cmp.w	r8, #0
 8047bce:	689a      	ldr	r2, [r3, #8]
 8047bd0:	ddab      	ble.n	8047b2a <kad_op_conv1d+0x75e>
 8047bd2:	e9dd 7313 	ldrd	r7, r3, [sp, #76]	@ 0x4c
 8047bd6:	eba8 0202 	sub.w	r2, r8, r2
 8047bda:	9e06      	ldr	r6, [sp, #24]
 8047bdc:	eb05 0582 	add.w	r5, r5, r2, lsl #2
 8047be0:	ecf6 6a01 	vldmia	r6!, {s13}
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 8047be4:	4638      	mov	r0, r7
 8047be6:	195a      	adds	r2, r3, r5
 8047be8:	edd2 7a00 	vldr	s15, [r2]
 8047bec:	ecb0 7a01 	vldmia	r0!, {s14}
 8047bf0:	eee6 7a87 	vfma.f32	s15, s13, s14
 8047bf4:	ece2 7a01 	vstmia	r2!, {s15}
 8047bf8:	42aa      	cmp	r2, r5
 8047bfa:	d1f5      	bne.n	8047be8 <kad_op_conv1d+0x81c>
				conv1d_loop1(q->g, w->x, p->g, t, process_row_back_x);
 8047bfc:	4556      	cmp	r6, sl
 8047bfe:	f105 0504 	add.w	r5, r5, #4
 8047c02:	d1ed      	bne.n	8047be0 <kad_op_conv1d+0x814>
 8047c04:	e791      	b.n	8047b2a <kad_op_conv1d+0x75e>
		if (kad_is_back(p->child[1])) { /* backprop to the weight matrix */
 8047c06:	7873      	ldrb	r3, [r6, #1]
 8047c08:	07db      	lsls	r3, r3, #31
 8047c0a:	f57f abf4 	bpl.w	80473f6 <kad_op_conv1d+0x2a>
			conv_rot180(w->d[0] * w->d[1], w->d[2], w->g);
 8047c0e:	f8d6 902c 	ldr.w	r9, [r6, #44]	@ 0x2c
			if (!algo_switch) {
 8047c12:	2f00      	cmp	r7, #0
 8047c14:	f040 8251 	bne.w	80480ba <kad_op_conv1d+0xcee>
				conv1d_loop1(q->x, w->g, p->g, t, process_row_back_w);
 8047c18:	9b04      	ldr	r3, [sp, #16]
 8047c1a:	691b      	ldr	r3, [r3, #16]
 8047c1c:	2b00      	cmp	r3, #0
 8047c1e:	f77f abea 	ble.w	80473f6 <kad_op_conv1d+0x2a>
 8047c22:	9b08      	ldr	r3, [sp, #32]
 8047c24:	2b00      	cmp	r3, #0
 8047c26:	f300 8163 	bgt.w	8047ef0 <kad_op_conv1d+0xb24>
 8047c2a:	e1fb      	b.n	8048024 <kad_op_conv1d+0xc58>
 8047c2c:	9b04      	ldr	r3, [sp, #16]
 8047c2e:	781a      	ldrb	r2, [r3, #0]
 8047c30:	2a00      	cmp	r2, #0
 8047c32:	f000 8138 	beq.w	8047ea6 <kad_op_conv1d+0xada>
 8047c36:	2a01      	cmp	r2, #1
 8047c38:	4618      	mov	r0, r3
 8047c3a:	691b      	ldr	r3, [r3, #16]
 8047c3c:	d00b      	beq.n	8047c56 <kad_op_conv1d+0x88a>
 8047c3e:	6941      	ldr	r1, [r0, #20]
 8047c40:	2a02      	cmp	r2, #2
 8047c42:	fb01 f303 	mul.w	r3, r1, r3
 8047c46:	d006      	beq.n	8047c56 <kad_op_conv1d+0x88a>
 8047c48:	6981      	ldr	r1, [r0, #24]
 8047c4a:	2a03      	cmp	r2, #3
 8047c4c:	fb01 f303 	mul.w	r3, r1, r3
 8047c50:	bf1c      	itt	ne
 8047c52:	69c2      	ldrne	r2, [r0, #28]
 8047c54:	4353      	mulne	r3, r2
				memset(q1, 0, kad_len(q) * sizeof(float));
 8047c56:	009a      	lsls	r2, r3, #2
 8047c58:	2100      	movs	r1, #0
 8047c5a:	980b      	ldr	r0, [sp, #44]	@ 0x2c
 8047c5c:	f004 f8ae 	bl	804bdbc <memset>
	for (k = 0; k < d[0]; ++k)
 8047c60:	9b08      	ldr	r3, [sp, #32]
 8047c62:	2b00      	cmp	r3, #0
 8047c64:	f340 8118 	ble.w	8047e98 <kad_op_conv1d+0xacc>
		for (j = 0; j < d[1]; ++j)
 8047c68:	f8d6 e014 	ldr.w	lr, [r6, #20]
 8047c6c:	f1be 0f00 	cmp.w	lr, #0
 8047c70:	dd39      	ble.n	8047ce6 <kad_op_conv1d+0x91a>
			for (i = 0; i < d[2]; ++i)
 8047c72:	f04f 0900 	mov.w	r9, #0
	for (k = 0; k < d[0]; ++k)
 8047c76:	464a      	mov	r2, r9
			for (i = 0; i < d[2]; ++i)
 8047c78:	f8d6 c018 	ldr.w	ip, [r6, #24]
 8047c7c:	ea4f 008e 	mov.w	r0, lr, lsl #2
 8047c80:	ea4f 038c 	mov.w	r3, ip, lsl #2
 8047c84:	9301      	str	r3, [sp, #4]
 8047c86:	f8cd b008 	str.w	fp, [sp, #8]
		for (j = 0; j < d[1]; ++j)
 8047c8a:	f1bc 0f00 	cmp.w	ip, #0
				y[(k * d[2] + i) * d[1] + j] = x[(k * d[1] + j) * d[2] + i];
 8047c8e:	fb0c f502 	mul.w	r5, ip, r2
 8047c92:	dd21      	ble.n	8047cd8 <kad_op_conv1d+0x90c>
		for (j = 0; j < d[1]; ++j)
 8047c94:	f04f 0b00 	mov.w	fp, #0
 8047c98:	fb0c f109 	mul.w	r1, ip, r9
 8047c9c:	fb0e f505 	mul.w	r5, lr, r5
 8047ca0:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8047ca2:	eb0c 0a01 	add.w	sl, ip, r1
 8047ca6:	eb03 0585 	add.w	r5, r3, r5, lsl #2
 8047caa:	eb08 048a 	add.w	r4, r8, sl, lsl #2
			for (i = 0; i < d[2]; ++i)
 8047cae:	eb08 0381 	add.w	r3, r8, r1, lsl #2
 8047cb2:	4629      	mov	r1, r5
				y[(k * d[2] + i) * d[1] + j] = x[(k * d[1] + j) * d[2] + i];
 8047cb4:	ecf3 7a01 	vldmia	r3!, {s15}
			for (i = 0; i < d[2]; ++i)
 8047cb8:	42a3      	cmp	r3, r4
				y[(k * d[2] + i) * d[1] + j] = x[(k * d[1] + j) * d[2] + i];
 8047cba:	edc1 7a00 	vstr	s15, [r1]
			for (i = 0; i < d[2]; ++i)
 8047cbe:	4401      	add	r1, r0
 8047cc0:	d1f8      	bne.n	8047cb4 <kad_op_conv1d+0x8e8>
		for (j = 0; j < d[1]; ++j)
 8047cc2:	9b01      	ldr	r3, [sp, #4]
 8047cc4:	f10b 0b01 	add.w	fp, fp, #1
 8047cc8:	45f3      	cmp	fp, lr
 8047cca:	4651      	mov	r1, sl
 8047ccc:	f105 0504 	add.w	r5, r5, #4
 8047cd0:	441c      	add	r4, r3
 8047cd2:	d001      	beq.n	8047cd8 <kad_op_conv1d+0x90c>
 8047cd4:	44e2      	add	sl, ip
 8047cd6:	e7ea      	b.n	8047cae <kad_op_conv1d+0x8e2>
	for (k = 0; k < d[0]; ++k)
 8047cd8:	9b08      	ldr	r3, [sp, #32]
 8047cda:	3201      	adds	r2, #1
 8047cdc:	4293      	cmp	r3, r2
 8047cde:	44f1      	add	r9, lr
 8047ce0:	d1d3      	bne.n	8047c8a <kad_op_conv1d+0x8be>
				conv1d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _ww, _xx));
 8047ce2:	f8dd b008 	ldr.w	fp, [sp, #8]
 8047ce6:	9a04      	ldr	r2, [sp, #16]
 8047ce8:	6953      	ldr	r3, [r2, #20]
 8047cea:	f8d2 9010 	ldr.w	r9, [r2, #16]
 8047cee:	4619      	mov	r1, r3
 8047cf0:	9302      	str	r3, [sp, #8]
 8047cf2:	f8db 3004 	ldr.w	r3, [fp, #4]
 8047cf6:	f1b9 0f00 	cmp.w	r9, #0
 8047cfa:	fb01 f303 	mul.w	r3, r1, r3
 8047cfe:	f77f af3d 	ble.w	8047b7c <kad_op_conv1d+0x7b0>
 8047d02:	2100      	movs	r1, #0
 8047d04:	46b6      	mov	lr, r6
 8047d06:	468a      	mov	sl, r1
 8047d08:	46bc      	mov	ip, r7
 8047d0a:	009c      	lsls	r4, r3, #2
 8047d0c:	9b11      	ldr	r3, [sp, #68]	@ 0x44
 8047d0e:	9a0d      	ldr	r2, [sp, #52]	@ 0x34
 8047d10:	009b      	lsls	r3, r3, #2
 8047d12:	9101      	str	r1, [sp, #4]
 8047d14:	9306      	str	r3, [sp, #24]
 8047d16:	f8cd 8028 	str.w	r8, [sp, #40]	@ 0x28
 8047d1a:	6953      	ldr	r3, [r2, #20]
			t = (float*)malloc(p->d[2] * sizeof(float));
 8047d1c:	6995      	ldr	r5, [r2, #24]
				conv1d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _ww, _xx));
 8047d1e:	fb03 f30a 	mul.w	r3, r3, sl
 8047d22:	fb05 f303 	mul.w	r3, r5, r3
 8047d26:	6ad7      	ldr	r7, [r2, #44]	@ 0x2c
 8047d28:	f8cd a030 	str.w	sl, [sp, #48]	@ 0x30
 8047d2c:	eb07 0783 	add.w	r7, r7, r3, lsl #2
 8047d30:	00ab      	lsls	r3, r5, #2
 8047d32:	9307      	str	r3, [sp, #28]
 8047d34:	f8cd 9040 	str.w	r9, [sp, #64]	@ 0x40
 8047d38:	f04f 0800 	mov.w	r8, #0
 8047d3c:	4673      	mov	r3, lr
 8047d3e:	46e1      	mov	r9, ip
 8047d40:	4692      	mov	sl, r2
 8047d42:	9e09      	ldr	r6, [sp, #36]	@ 0x24
 8047d44:	9a04      	ldr	r2, [sp, #16]
 8047d46:	9901      	ldr	r1, [sp, #4]
 8047d48:	6992      	ldr	r2, [r2, #24]
 8047d4a:	980b      	ldr	r0, [sp, #44]	@ 0x2c
 8047d4c:	fb02 f101 	mul.w	r1, r2, r1
 8047d50:	eb00 0181 	add.w	r1, r0, r1, lsl #2
 8047d54:	9800      	ldr	r0, [sp, #0]
 8047d56:	b178      	cbz	r0, 8047d78 <kad_op_conv1d+0x9ac>
 8047d58:	f8db 0008 	ldr.w	r0, [fp, #8]
 8047d5c:	9312      	str	r3, [sp, #72]	@ 0x48
 8047d5e:	9b02      	ldr	r3, [sp, #8]
 8047d60:	fb03 f202 	mul.w	r2, r3, r2
 8047d64:	fb03 f000 	mul.w	r0, r3, r0
 8047d68:	9b00      	ldr	r3, [sp, #0]
 8047d6a:	0092      	lsls	r2, r2, #2
 8047d6c:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 8047d70:	f004 f921 	bl	804bfb6 <memcpy>
 8047d74:	9900      	ldr	r1, [sp, #0]
 8047d76:	9b12      	ldr	r3, [sp, #72]	@ 0x48
 8047d78:	2d00      	cmp	r5, #0
 8047d7a:	dd1f      	ble.n	8047dbc <kad_op_conv1d+0x9f0>
 8047d7c:	9a11      	ldr	r2, [sp, #68]	@ 0x44
 8047d7e:	2a00      	cmp	r2, #0
 8047d80:	dd1c      	ble.n	8047dbc <kad_op_conv1d+0x9f0>
 8047d82:	46be      	mov	lr, r7
 8047d84:	f04f 0c00 	mov.w	ip, #0
 8047d88:	9a06      	ldr	r2, [sp, #24]
 8047d8a:	f8cd 8048 	str.w	r8, [sp, #72]	@ 0x48
 8047d8e:	1888      	adds	r0, r1, r2
 8047d90:	ecfe 6a01 	vldmia	lr!, {s13}
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 8047d94:	460a      	mov	r2, r1
				conv1d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _ww, _xx));
 8047d96:	46b0      	mov	r8, r6
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 8047d98:	edd2 7a00 	vldr	s15, [r2]
 8047d9c:	ecb8 7a01 	vldmia	r8!, {s14}
 8047da0:	eee6 7a87 	vfma.f32	s15, s13, s14
 8047da4:	ece2 7a01 	vstmia	r2!, {s15}
 8047da8:	4282      	cmp	r2, r0
 8047daa:	d1f5      	bne.n	8047d98 <kad_op_conv1d+0x9cc>
				conv1d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _ww, _xx));
 8047dac:	f10c 0c01 	add.w	ip, ip, #1
 8047db0:	45ac      	cmp	ip, r5
 8047db2:	4421      	add	r1, r4
 8047db4:	4420      	add	r0, r4
 8047db6:	d1eb      	bne.n	8047d90 <kad_op_conv1d+0x9c4>
 8047db8:	f8dd 8048 	ldr.w	r8, [sp, #72]	@ 0x48
 8047dbc:	9a06      	ldr	r2, [sp, #24]
 8047dbe:	f108 0801 	add.w	r8, r8, #1
 8047dc2:	4416      	add	r6, r2
 8047dc4:	9a07      	ldr	r2, [sp, #28]
 8047dc6:	4417      	add	r7, r2
 8047dc8:	9a08      	ldr	r2, [sp, #32]
 8047dca:	4542      	cmp	r2, r8
 8047dcc:	d1ba      	bne.n	8047d44 <kad_op_conv1d+0x978>
 8047dce:	4652      	mov	r2, sl
 8047dd0:	f8dd a030 	ldr.w	sl, [sp, #48]	@ 0x30
 8047dd4:	46cc      	mov	ip, r9
 8047dd6:	f8dd 9040 	ldr.w	r9, [sp, #64]	@ 0x40
 8047dda:	f10a 0a01 	add.w	sl, sl, #1
 8047dde:	469e      	mov	lr, r3
 8047de0:	e9dd 3101 	ldrd	r3, r1, [sp, #4]
 8047de4:	45ca      	cmp	sl, r9
 8047de6:	440b      	add	r3, r1
 8047de8:	9301      	str	r3, [sp, #4]
 8047dea:	d196      	bne.n	8047d1a <kad_op_conv1d+0x94e>
 8047dec:	4676      	mov	r6, lr
 8047dee:	4667      	mov	r7, ip
 8047df0:	f8dd 8028 	ldr.w	r8, [sp, #40]	@ 0x28
		for (j = 0; j < d[1]; ++j)
 8047df4:	9b04      	ldr	r3, [sp, #16]
 8047df6:	f8d3 e014 	ldr.w	lr, [r3, #20]
				conv1d_add_2to1(q->d, q1, q->g);
 8047dfa:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 8047dfc:	f1be 0f00 	cmp.w	lr, #0
 8047e00:	9202      	str	r2, [sp, #8]
	for (k = 0; k < d[0]; ++k)
 8047e02:	f77f aebb 	ble.w	8047b7c <kad_op_conv1d+0x7b0>
			for (i = 0; i < d[2]; ++i)
 8047e06:	f04f 0a00 	mov.w	sl, #0
 8047e0a:	f8d3 c018 	ldr.w	ip, [r3, #24]
	for (k = 0; k < d[0]; ++k)
 8047e0e:	4652      	mov	r2, sl
 8047e10:	ea4f 038c 	mov.w	r3, ip, lsl #2
 8047e14:	9306      	str	r3, [sp, #24]
 8047e16:	465b      	mov	r3, fp
 8047e18:	ea4f 008e 	mov.w	r0, lr, lsl #2
 8047e1c:	f8cd 801c 	str.w	r8, [sp, #28]
		for (j = 0; j < d[1]; ++j)
 8047e20:	f1bc 0f00 	cmp.w	ip, #0
				x[(k * d[1] + j) * d[2] + i] += y[(k * d[2] + i) * d[1] + j];
 8047e24:	fb0c f502 	mul.w	r5, ip, r2
 8047e28:	dd2e      	ble.n	8047e88 <kad_op_conv1d+0xabc>
		for (j = 0; j < d[1]; ++j)
 8047e2a:	f04f 0b00 	mov.w	fp, #0
 8047e2e:	fb0e f505 	mul.w	r5, lr, r5
 8047e32:	990b      	ldr	r1, [sp, #44]	@ 0x2c
 8047e34:	9c02      	ldr	r4, [sp, #8]
 8047e36:	eb01 0585 	add.w	r5, r1, r5, lsl #2
 8047e3a:	fb0c f10a 	mul.w	r1, ip, sl
 8047e3e:	eb0c 0801 	add.w	r8, ip, r1
 8047e42:	eb04 0488 	add.w	r4, r4, r8, lsl #2
 8047e46:	f8cd 9028 	str.w	r9, [sp, #40]	@ 0x28
 8047e4a:	9301      	str	r3, [sp, #4]
				conv1d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _ww, _xx));
 8047e4c:	46a9      	mov	r9, r5
 8047e4e:	9b02      	ldr	r3, [sp, #8]
 8047e50:	eb03 0181 	add.w	r1, r3, r1, lsl #2
 8047e54:	9b01      	ldr	r3, [sp, #4]
				x[(k * d[1] + j) * d[2] + i] += y[(k * d[2] + i) * d[1] + j];
 8047e56:	ed91 7a00 	vldr	s14, [r1]
 8047e5a:	edd9 7a00 	vldr	s15, [r9]
 8047e5e:	ee77 7a87 	vadd.f32	s15, s15, s14
 8047e62:	ece1 7a01 	vstmia	r1!, {s15}
			for (i = 0; i < d[2]; ++i)
 8047e66:	42a1      	cmp	r1, r4
 8047e68:	4481      	add	r9, r0
 8047e6a:	d1f4      	bne.n	8047e56 <kad_op_conv1d+0xa8a>
		for (j = 0; j < d[1]; ++j)
 8047e6c:	9906      	ldr	r1, [sp, #24]
 8047e6e:	f10b 0b01 	add.w	fp, fp, #1
 8047e72:	45f3      	cmp	fp, lr
 8047e74:	440c      	add	r4, r1
 8047e76:	9301      	str	r3, [sp, #4]
 8047e78:	4641      	mov	r1, r8
 8047e7a:	f105 0504 	add.w	r5, r5, #4
 8047e7e:	d001      	beq.n	8047e84 <kad_op_conv1d+0xab8>
 8047e80:	44e0      	add	r8, ip
 8047e82:	e7e3      	b.n	8047e4c <kad_op_conv1d+0xa80>
 8047e84:	f8dd 9028 	ldr.w	r9, [sp, #40]	@ 0x28
	for (k = 0; k < d[0]; ++k)
 8047e88:	3201      	adds	r2, #1
 8047e8a:	4591      	cmp	r9, r2
 8047e8c:	44f2      	add	sl, lr
 8047e8e:	d1c7      	bne.n	8047e20 <kad_op_conv1d+0xa54>
 8047e90:	469b      	mov	fp, r3
 8047e92:	f8dd 801c 	ldr.w	r8, [sp, #28]
 8047e96:	e671      	b.n	8047b7c <kad_op_conv1d+0x7b0>
				conv1d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _ww, _xx));
 8047e98:	9b04      	ldr	r3, [sp, #16]
 8047e9a:	f8d3 9010 	ldr.w	r9, [r3, #16]
 8047e9e:	f1b9 0f00 	cmp.w	r9, #0
 8047ea2:	dca7      	bgt.n	8047df4 <kad_op_conv1d+0xa28>
 8047ea4:	e66a      	b.n	8047b7c <kad_op_conv1d+0x7b0>
 8047ea6:	2204      	movs	r2, #4
 8047ea8:	e6d6      	b.n	8047c58 <kad_op_conv1d+0x88c>
			if (!algo_switch) {
 8047eaa:	2f00      	cmp	r7, #0
 8047eac:	f47f aebe 	bne.w	8047c2c <kad_op_conv1d+0x860>
				conv1d_loop1(q->g, w->x, p->g, t, process_row_back_x);
 8047eb0:	9b04      	ldr	r3, [sp, #16]
 8047eb2:	691b      	ldr	r3, [r3, #16]
 8047eb4:	2b00      	cmp	r3, #0
 8047eb6:	f77f aea6 	ble.w	8047c06 <kad_op_conv1d+0x83a>
 8047eba:	9b08      	ldr	r3, [sp, #32]
 8047ebc:	2b00      	cmp	r3, #0
 8047ebe:	f77f aea2 	ble.w	8047c06 <kad_op_conv1d+0x83a>
 8047ec2:	2a00      	cmp	r2, #0
 8047ec4:	f77f ae9f 	ble.w	8047c06 <kad_op_conv1d+0x83a>
 8047ec8:	9b03      	ldr	r3, [sp, #12]
 8047eca:	009b      	lsls	r3, r3, #2
 8047ecc:	9302      	str	r3, [sp, #8]
 8047ece:	e596      	b.n	80479fe <kad_op_conv1d+0x632>
		if (q->n_d != 3 || w->n_d != 3) return -1;
 8047ed0:	f04f 30ff 	mov.w	r0, #4294967295
 8047ed4:	f7ff ba9c 	b.w	8047410 <kad_op_conv1d+0x44>
				conv1d_loop1(q->g, w->x, p->g, t, process_row_back_x);
 8047ed8:	9a04      	ldr	r2, [sp, #16]
 8047eda:	6912      	ldr	r2, [r2, #16]
			if (!algo_switch) {
 8047edc:	2f00      	cmp	r7, #0
 8047ede:	f040 80ec 	bne.w	80480ba <kad_op_conv1d+0xcee>
				conv1d_loop1(q->x, w->g, p->g, t, process_row_back_w);
 8047ee2:	2a00      	cmp	r2, #0
 8047ee4:	f77f aa87 	ble.w	80473f6 <kad_op_conv1d+0x2a>
 8047ee8:	9a08      	ldr	r2, [sp, #32]
 8047eea:	2a00      	cmp	r2, #0
 8047eec:	f340 80a0 	ble.w	8048030 <kad_op_conv1d+0xc64>
 8047ef0:	9b05      	ldr	r3, [sp, #20]
 8047ef2:	2b00      	cmp	r3, #0
 8047ef4:	f340 8096 	ble.w	8048024 <kad_op_conv1d+0xc58>
 8047ef8:	f04f 0c00 	mov.w	ip, #0
 8047efc:	9b11      	ldr	r3, [sp, #68]	@ 0x44
 8047efe:	f8dd e010 	ldr.w	lr, [sp, #16]
 8047f02:	009b      	lsls	r3, r3, #2
 8047f04:	930a      	str	r3, [sp, #40]	@ 0x28
 8047f06:	9b03      	ldr	r3, [sp, #12]
 8047f08:	f8dd a03c 	ldr.w	sl, [sp, #60]	@ 0x3c
 8047f0c:	009b      	lsls	r3, r3, #2
 8047f0e:	9302      	str	r3, [sp, #8]
 8047f10:	2000      	movs	r0, #0
 8047f12:	464a      	mov	r2, r9
 8047f14:	4673      	mov	r3, lr
 8047f16:	f8cd 9030 	str.w	r9, [sp, #48]	@ 0x30
 8047f1a:	9d0d      	ldr	r5, [sp, #52]	@ 0x34
 8047f1c:	695c      	ldr	r4, [r3, #20]
			t = (float*)malloc(p->d[2] * sizeof(float));
 8047f1e:	69af      	ldr	r7, [r5, #24]
				conv1d_loop1(q->x, w->g, p->g, t, process_row_back_w);
 8047f20:	6969      	ldr	r1, [r5, #20]
				conv1d_loop1(q->g, w->x, p->g, t, process_row_back_x);
 8047f22:	f8d5 902c 	ldr.w	r9, [r5, #44]	@ 0x2c
				conv1d_loop1(q->x, w->g, p->g, t, process_row_back_w);
 8047f26:	2500      	movs	r5, #0
 8047f28:	fb04 f40c 	mul.w	r4, r4, ip
 8047f2c:	fb01 080c 	mla	r8, r1, ip, r0
				conv1d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _ww, _xx));
 8047f30:	6999      	ldr	r1, [r3, #24]
				conv1d_loop1(q->x, w->g, p->g, t, process_row_back_w);
 8047f32:	fb07 f808 	mul.w	r8, r7, r8
 8047f36:	fb01 f404 	mul.w	r4, r1, r4
 8047f3a:	0089      	lsls	r1, r1, #2
 8047f3c:	9106      	str	r1, [sp, #24]
 8047f3e:	6a99      	ldr	r1, [r3, #40]	@ 0x28
 8047f40:	9504      	str	r5, [sp, #16]
 8047f42:	e9cd 3010 	strd	r3, r0, [sp, #64]	@ 0x40
 8047f46:	9d02      	ldr	r5, [sp, #8]
 8047f48:	e9cd c212 	strd	ip, r2, [sp, #72]	@ 0x48
 8047f4c:	eb01 0184 	add.w	r1, r1, r4, lsl #2
 8047f50:	eb09 0487 	add.w	r4, r9, r7, lsl #2
 8047f54:	eb04 0488 	add.w	r4, r4, r8, lsl #2
 8047f58:	1956      	adds	r6, r2, r5
 8047f5a:	ea4f 0888 	mov.w	r8, r8, lsl #2
 8047f5e:	9201      	str	r2, [sp, #4]
 8047f60:	eb0a 0587 	add.w	r5, sl, r7, lsl #2
 8047f64:	9a00      	ldr	r2, [sp, #0]
 8047f66:	460b      	mov	r3, r1
 8047f68:	b152      	cbz	r2, 8047f80 <kad_op_conv1d+0xbb4>
 8047f6a:	f8db 3008 	ldr.w	r3, [fp, #8]
 8047f6e:	9107      	str	r1, [sp, #28]
 8047f70:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 8047f74:	4618      	mov	r0, r3
 8047f76:	9a06      	ldr	r2, [sp, #24]
 8047f78:	f004 f81d 	bl	804bfb6 <memcpy>
 8047f7c:	4603      	mov	r3, r0
 8047f7e:	9907      	ldr	r1, [sp, #28]
 8047f80:	f8db 2004 	ldr.w	r2, [fp, #4]
 8047f84:	2a01      	cmp	r2, #1
 8047f86:	dd73      	ble.n	8048070 <kad_op_conv1d+0xca4>
 8047f88:	9803      	ldr	r0, [sp, #12]
 8047f8a:	2800      	cmp	r0, #0
 8047f8c:	dd2a      	ble.n	8047fe4 <kad_op_conv1d+0xc18>
 8047f8e:	f8db 0008 	ldr.w	r0, [fp, #8]
 8047f92:	f8dd c004 	ldr.w	ip, [sp, #4]
 8047f96:	ebc0 7080 	rsb	r0, r0, r0, lsl #30
 8047f9a:	0092      	lsls	r2, r2, #2
 8047f9c:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 8047fa0:	2f00      	cmp	r7, #0
 8047fa2:	4603      	mov	r3, r0
 8047fa4:	dd61      	ble.n	804806a <kad_op_conv1d+0xc9e>
 8047fa6:	46d6      	mov	lr, sl
 8047fa8:	edd3 7a00 	vldr	s15, [r3]
 8047fac:	ecee 7a01 	vstmia	lr!, {s15}
 8047fb0:	4575      	cmp	r5, lr
 8047fb2:	4413      	add	r3, r2
 8047fb4:	d1f8      	bne.n	8047fa8 <kad_op_conv1d+0xbdc>
	float s = 0.;
 8047fb6:	eddf 7ab3 	vldr	s15, [pc, #716]	@ 8048284 <kad_op_conv1d+0xeb8>
				conv1d_loop1(q->x, w->g, p->g, t, process_row_back_w);
 8047fba:	46d6      	mov	lr, sl
 8047fbc:	eb09 0308 	add.w	r3, r9, r8
	for (i = 0; i < n; ++i) s += x[i] * y[i];
 8047fc0:	ecf3 6a01 	vldmia	r3!, {s13}
 8047fc4:	ecbe 7a01 	vldmia	lr!, {s14}
 8047fc8:	429c      	cmp	r4, r3
 8047fca:	eee6 7a87 	vfma.f32	s15, s13, s14
 8047fce:	d1f7      	bne.n	8047fc0 <kad_op_conv1d+0xbf4>
				conv1d_loop1(q->x, w->g, p->g, t, process_row_back_w);
 8047fd0:	ed9c 7a00 	vldr	s14, [ip]
 8047fd4:	ee77 7a27 	vadd.f32	s15, s14, s15
 8047fd8:	ecec 7a01 	vstmia	ip!, {s15}
 8047fdc:	4566      	cmp	r6, ip
 8047fde:	f100 0004 	add.w	r0, r0, #4
 8047fe2:	d1dd      	bne.n	8047fa0 <kad_op_conv1d+0xbd4>
 8047fe4:	e9dd 2001 	ldrd	r2, r0, [sp, #4]
 8047fe8:	4402      	add	r2, r0
 8047fea:	9201      	str	r2, [sp, #4]
 8047fec:	9a06      	ldr	r2, [sp, #24]
 8047fee:	9b04      	ldr	r3, [sp, #16]
 8047ff0:	4411      	add	r1, r2
 8047ff2:	9a05      	ldr	r2, [sp, #20]
 8047ff4:	3301      	adds	r3, #1
 8047ff6:	429a      	cmp	r2, r3
 8047ff8:	9304      	str	r3, [sp, #16]
 8047ffa:	4406      	add	r6, r0
 8047ffc:	d1b2      	bne.n	8047f64 <kad_op_conv1d+0xb98>
 8047ffe:	e9dd c212 	ldrd	ip, r2, [sp, #72]	@ 0x48
 8048002:	e9dd 3010 	ldrd	r3, r0, [sp, #64]	@ 0x40
 8048006:	990a      	ldr	r1, [sp, #40]	@ 0x28
 8048008:	3001      	adds	r0, #1
 804800a:	440a      	add	r2, r1
 804800c:	9908      	ldr	r1, [sp, #32]
 804800e:	4288      	cmp	r0, r1
 8048010:	d183      	bne.n	8047f1a <kad_op_conv1d+0xb4e>
 8048012:	469e      	mov	lr, r3
 8048014:	691b      	ldr	r3, [r3, #16]
 8048016:	f10c 0c01 	add.w	ip, ip, #1
 804801a:	4563      	cmp	r3, ip
 804801c:	f8dd 9030 	ldr.w	r9, [sp, #48]	@ 0x30
 8048020:	f73f af76 	bgt.w	8047f10 <kad_op_conv1d+0xb44>
	for (i = 0; i < d0; ++i) {
 8048024:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
 8048026:	2b00      	cmp	r3, #0
 8048028:	f77f a9e5 	ble.w	80473f6 <kad_op_conv1d+0x2a>
 804802c:	9b03      	ldr	r3, [sp, #12]
 804802e:	105b      	asrs	r3, r3, #1
 8048030:	2b00      	cmp	r3, #0
 8048032:	f77f a9e0 	ble.w	80473f6 <kad_op_conv1d+0x2a>
 8048036:	9a03      	ldr	r2, [sp, #12]
 8048038:	0092      	lsls	r2, r2, #2
 804803a:	9202      	str	r2, [sp, #8]
 804803c:	464a      	mov	r2, r9
	for (k = 0; k < d[0]; ++k)
 804803e:	2000      	movs	r0, #0
 8048040:	9d02      	ldr	r5, [sp, #8]
 8048042:	eb09 0383 	add.w	r3, r9, r3, lsl #2
		for (j = 0; j < d1>>1; ++j)
 8048046:	4611      	mov	r1, r2
 8048048:	442a      	add	r2, r5
	for (k = 0; k < d[0]; ++k)
 804804a:	4614      	mov	r4, r2
			tmp = xi[j], xi[j] = xi[d1-1-j], xi[d1-1-j] = tmp; 
 804804c:	f854 7d04 	ldr.w	r7, [r4, #-4]!
 8048050:	680e      	ldr	r6, [r1, #0]
 8048052:	f841 7b04 	str.w	r7, [r1], #4
		for (j = 0; j < d1>>1; ++j)
 8048056:	428b      	cmp	r3, r1
			tmp = xi[j], xi[j] = xi[d1-1-j], xi[d1-1-j] = tmp; 
 8048058:	6026      	str	r6, [r4, #0]
		for (j = 0; j < d1>>1; ++j)
 804805a:	d1f7      	bne.n	804804c <kad_op_conv1d+0xc80>
	for (i = 0; i < d0; ++i) {
 804805c:	990e      	ldr	r1, [sp, #56]	@ 0x38
 804805e:	3001      	adds	r0, #1
 8048060:	4281      	cmp	r1, r0
 8048062:	442b      	add	r3, r5
 8048064:	d1ef      	bne.n	8048046 <kad_op_conv1d+0xc7a>
 8048066:	f7ff b9c6 	b.w	80473f6 <kad_op_conv1d+0x2a>
	float s = 0.;
 804806a:	eddf 7a86 	vldr	s15, [pc, #536]	@ 8048284 <kad_op_conv1d+0xeb8>
 804806e:	e7af      	b.n	8047fd0 <kad_op_conv1d+0xc04>
				conv1d_loop1(q->x, w->g, p->g, t, process_row_back_w);
 8048070:	9a03      	ldr	r2, [sp, #12]
 8048072:	2a00      	cmp	r2, #0
 8048074:	ddb6      	ble.n	8047fe4 <kad_op_conv1d+0xc18>
 8048076:	f8db 2008 	ldr.w	r2, [fp, #8]
 804807a:	9801      	ldr	r0, [sp, #4]
 804807c:	ebc2 7282 	rsb	r2, r2, r2, lsl #30
 8048080:	ea4f 0e82 	mov.w	lr, r2, lsl #2
	for (i = 0; i < n; ++i) s += x[i] * y[i];
 8048084:	2f00      	cmp	r7, #0
	float s = 0.;
 8048086:	eddf 7a7f 	vldr	s15, [pc, #508]	@ 8048284 <kad_op_conv1d+0xeb8>
	for (i = 0; i < n; ++i) s += x[i] * y[i];
 804808a:	dd0b      	ble.n	80480a4 <kad_op_conv1d+0xcd8>
 804808c:	eb09 0208 	add.w	r2, r9, r8
 8048090:	eb03 0c0e 	add.w	ip, r3, lr
 8048094:	ecf2 6a01 	vldmia	r2!, {s13}
 8048098:	ecbc 7a01 	vldmia	ip!, {s14}
 804809c:	4294      	cmp	r4, r2
 804809e:	eee6 7a87 	vfma.f32	s15, s13, s14
 80480a2:	d1f7      	bne.n	8048094 <kad_op_conv1d+0xcc8>
				conv1d_loop1(q->x, w->g, p->g, t, process_row_back_w);
 80480a4:	ed90 7a00 	vldr	s14, [r0]
 80480a8:	ee77 7a27 	vadd.f32	s15, s14, s15
 80480ac:	ece0 7a01 	vstmia	r0!, {s15}
 80480b0:	4286      	cmp	r6, r0
 80480b2:	f10e 0e04 	add.w	lr, lr, #4
 80480b6:	d1e5      	bne.n	8048084 <kad_op_conv1d+0xcb8>
 80480b8:	e794      	b.n	8047fe4 <kad_op_conv1d+0xc18>
	for (k = 0; k < d[0]; ++k)
 80480ba:	9b04      	ldr	r3, [sp, #16]
 80480bc:	691a      	ldr	r2, [r3, #16]
				conv1d_move_1to2(q->d, q->x, q1);
 80480be:	6a99      	ldr	r1, [r3, #40]	@ 0x28
	for (k = 0; k < d[0]; ++k)
 80480c0:	2a00      	cmp	r2, #0
 80480c2:	9202      	str	r2, [sp, #8]
				conv1d_move_1to2(q->d, q->x, q1);
 80480c4:	9101      	str	r1, [sp, #4]
	for (k = 0; k < d[0]; ++k)
 80480c6:	f340 814b 	ble.w	8048360 <kad_op_conv1d+0xf94>
		for (j = 0; j < d[1]; ++j)
 80480ca:	f8d3 c014 	ldr.w	ip, [r3, #20]
 80480ce:	f1bc 0f00 	cmp.w	ip, #0
 80480d2:	dd33      	ble.n	804813c <kad_op_conv1d+0xd70>
			for (i = 0; i < d[2]; ++i)
 80480d4:	f04f 0800 	mov.w	r8, #0
	for (k = 0; k < d[0]; ++k)
 80480d8:	4642      	mov	r2, r8
			for (i = 0; i < d[2]; ++i)
 80480da:	699f      	ldr	r7, [r3, #24]
 80480dc:	ea4f 0e8c 	mov.w	lr, ip, lsl #2
 80480e0:	00bb      	lsls	r3, r7, #2
 80480e2:	9306      	str	r3, [sp, #24]
		for (j = 0; j < d[1]; ++j)
 80480e4:	2f00      	cmp	r7, #0
				y[(k * d[2] + i) * d[1] + j] = x[(k * d[1] + j) * d[2] + i];
 80480e6:	fb07 f402 	mul.w	r4, r7, r2
 80480ea:	dd22      	ble.n	8048132 <kad_op_conv1d+0xd66>
		for (j = 0; j < d[1]; ++j)
 80480ec:	f04f 0a00 	mov.w	sl, #0
 80480f0:	fb0c f404 	mul.w	r4, ip, r4
 80480f4:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 80480f6:	9901      	ldr	r1, [sp, #4]
 80480f8:	eb03 0484 	add.w	r4, r3, r4, lsl #2
 80480fc:	fb07 f308 	mul.w	r3, r7, r8
 8048100:	19dd      	adds	r5, r3, r7
 8048102:	eb01 0085 	add.w	r0, r1, r5, lsl #2
			for (i = 0; i < d[2]; ++i)
 8048106:	9901      	ldr	r1, [sp, #4]
 8048108:	eb01 0383 	add.w	r3, r1, r3, lsl #2
				conv1d_loop1(q->x, w->g, p->g, t, process_row_back_w);
 804810c:	4621      	mov	r1, r4
				y[(k * d[2] + i) * d[1] + j] = x[(k * d[1] + j) * d[2] + i];
 804810e:	ecf3 7a01 	vldmia	r3!, {s15}
			for (i = 0; i < d[2]; ++i)
 8048112:	4298      	cmp	r0, r3
				y[(k * d[2] + i) * d[1] + j] = x[(k * d[1] + j) * d[2] + i];
 8048114:	edc1 7a00 	vstr	s15, [r1]
			for (i = 0; i < d[2]; ++i)
 8048118:	4471      	add	r1, lr
 804811a:	d1f8      	bne.n	804810e <kad_op_conv1d+0xd42>
		for (j = 0; j < d[1]; ++j)
 804811c:	9b06      	ldr	r3, [sp, #24]
 804811e:	f10a 0a01 	add.w	sl, sl, #1
 8048122:	45e2      	cmp	sl, ip
 8048124:	4418      	add	r0, r3
 8048126:	f104 0404 	add.w	r4, r4, #4
 804812a:	462b      	mov	r3, r5
 804812c:	d001      	beq.n	8048132 <kad_op_conv1d+0xd66>
 804812e:	443d      	add	r5, r7
 8048130:	e7e9      	b.n	8048106 <kad_op_conv1d+0xd3a>
	for (k = 0; k < d[0]; ++k)
 8048132:	9b02      	ldr	r3, [sp, #8]
 8048134:	3201      	adds	r2, #1
 8048136:	429a      	cmp	r2, r3
 8048138:	44e0      	add	r8, ip
 804813a:	d1d3      	bne.n	80480e4 <kad_op_conv1d+0xd18>
 804813c:	7832      	ldrb	r2, [r6, #0]
 804813e:	4613      	mov	r3, r2
 8048140:	2a00      	cmp	r2, #0
 8048142:	f000 811a 	beq.w	804837a <kad_op_conv1d+0xfae>
 8048146:	2b01      	cmp	r3, #1
 8048148:	f000 8115 	beq.w	8048376 <kad_op_conv1d+0xfaa>
 804814c:	990e      	ldr	r1, [sp, #56]	@ 0x38
 804814e:	2b02      	cmp	r3, #2
 8048150:	460a      	mov	r2, r1
 8048152:	d007      	beq.n	8048164 <kad_op_conv1d+0xd98>
 8048154:	9903      	ldr	r1, [sp, #12]
 8048156:	2b03      	cmp	r3, #3
 8048158:	fb01 f202 	mul.w	r2, r1, r2
 804815c:	d002      	beq.n	8048164 <kad_op_conv1d+0xd98>
 804815e:	69f3      	ldr	r3, [r6, #28]
 8048160:	fb03 f202 	mul.w	r2, r3, r2
				memset(w1, 0, kad_len(w) * sizeof(float));
 8048164:	0092      	lsls	r2, r2, #2
 8048166:	2100      	movs	r1, #0
 8048168:	9809      	ldr	r0, [sp, #36]	@ 0x24
 804816a:	f003 fe27 	bl	804bdbc <memset>
				conv1d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _xx, _ww));
 804816e:	9b04      	ldr	r3, [sp, #16]
 8048170:	9a02      	ldr	r2, [sp, #8]
 8048172:	f8d3 8014 	ldr.w	r8, [r3, #20]
 8048176:	f8db 3004 	ldr.w	r3, [fp, #4]
 804817a:	2a00      	cmp	r2, #0
 804817c:	fb03 f308 	mul.w	r3, r3, r8
 8048180:	f340 80f5 	ble.w	804836e <kad_op_conv1d+0xfa2>
 8048184:	009a      	lsls	r2, r3, #2
 8048186:	9207      	str	r2, [sp, #28]
 8048188:	9a08      	ldr	r2, [sp, #32]
 804818a:	2a00      	cmp	r2, #0
 804818c:	f77f af4a 	ble.w	8048024 <kad_op_conv1d+0xc58>
 8048190:	2000      	movs	r0, #0
 8048192:	00db      	lsls	r3, r3, #3
 8048194:	9313      	str	r3, [sp, #76]	@ 0x4c
 8048196:	9b11      	ldr	r3, [sp, #68]	@ 0x44
 8048198:	e9cd 9b16 	strd	r9, fp, [sp, #88]	@ 0x58
 804819c:	009a      	lsls	r2, r3, #2
 804819e:	9210      	str	r2, [sp, #64]	@ 0x40
 80481a0:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 80481a2:	4605      	mov	r5, r0
 80481a4:	eb02 0c83 	add.w	ip, r2, r3, lsl #2
 80481a8:	4682      	mov	sl, r0
 80481aa:	46e3      	mov	fp, ip
 80481ac:	990d      	ldr	r1, [sp, #52]	@ 0x34
				conv1d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _ww, _xx));
 80481ae:	9b04      	ldr	r3, [sp, #16]
				conv1d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _xx, _ww));
 80481b0:	9a0b      	ldr	r2, [sp, #44]	@ 0x2c
				conv1d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _ww, _xx));
 80481b2:	6998      	ldr	r0, [r3, #24]
				conv1d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _xx, _ww));
 80481b4:	694b      	ldr	r3, [r1, #20]
 80481b6:	fb00 f40a 	mul.w	r4, r0, sl
 80481ba:	fb08 f000 	mul.w	r0, r8, r0
 80481be:	eb02 0484 	add.w	r4, r2, r4, lsl #2
 80481c2:	0082      	lsls	r2, r0, #2
 80481c4:	920c      	str	r2, [sp, #48]	@ 0x30
 80481c6:	9a00      	ldr	r2, [sp, #0]
 80481c8:	fb05 f303 	mul.w	r3, r5, r3
 80481cc:	4610      	mov	r0, r2
 80481ce:	2a00      	cmp	r2, #0
 80481d0:	bf08      	it	eq
 80481d2:	4620      	moveq	r0, r4
			t = (float*)malloc(p->d[2] * sizeof(float));
 80481d4:	698f      	ldr	r7, [r1, #24]
 80481d6:	4602      	mov	r2, r0
 80481d8:	9006      	str	r0, [sp, #24]
 80481da:	fb07 f003 	mul.w	r0, r7, r3
 80481de:	6acb      	ldr	r3, [r1, #44]	@ 0x2c
				conv1d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _xx, _ww));
 80481e0:	9414      	str	r4, [sp, #80]	@ 0x50
 80481e2:	eb03 0380 	add.w	r3, r3, r0, lsl #2
 80481e6:	9301      	str	r3, [sp, #4]
 80481e8:	2300      	movs	r3, #0
 80481ea:	465c      	mov	r4, fp
 80481ec:	460e      	mov	r6, r1
 80481ee:	930a      	str	r3, [sp, #40]	@ 0x28
 80481f0:	00bb      	lsls	r3, r7, #2
 80481f2:	930d      	str	r3, [sp, #52]	@ 0x34
 80481f4:	1e7b      	subs	r3, r7, #1
 80481f6:	9315      	str	r3, [sp, #84]	@ 0x54
 80481f8:	9b07      	ldr	r3, [sp, #28]
 80481fa:	e9cd 5a18 	strd	r5, sl, [sp, #96]	@ 0x60
 80481fe:	18d3      	adds	r3, r2, r3
 8048200:	f8dd 9024 	ldr.w	r9, [sp, #36]	@ 0x24
 8048204:	9312      	str	r3, [sp, #72]	@ 0x48
 8048206:	e9dd 2500 	ldrd	r2, r5, [sp]
 804820a:	b14a      	cbz	r2, 8048220 <kad_op_conv1d+0xe54>
 804820c:	9b17      	ldr	r3, [sp, #92]	@ 0x5c
 804820e:	9914      	ldr	r1, [sp, #80]	@ 0x50
 8048210:	689b      	ldr	r3, [r3, #8]
 8048212:	fb03 f308 	mul.w	r3, r3, r8
 8048216:	eb02 0083 	add.w	r0, r2, r3, lsl #2
 804821a:	9a0c      	ldr	r2, [sp, #48]	@ 0x30
 804821c:	f003 fecb 	bl	804bfb6 <memcpy>
 8048220:	2f00      	cmp	r7, #0
 8048222:	dd46      	ble.n	80482b2 <kad_op_conv1d+0xee6>
 8048224:	9b11      	ldr	r3, [sp, #68]	@ 0x44
 8048226:	2b00      	cmp	r3, #0
 8048228:	dd43      	ble.n	80482b2 <kad_op_conv1d+0xee6>
 804822a:	2f02      	cmp	r7, #2
 804822c:	f340 8095 	ble.w	804835a <kad_op_conv1d+0xf8e>
 8048230:	2301      	movs	r3, #1
 8048232:	9901      	ldr	r1, [sp, #4]
 8048234:	f8dd a048 	ldr.w	sl, [sp, #72]	@ 0x48
 8048238:	9a06      	ldr	r2, [sp, #24]
 804823a:	f101 0e04 	add.w	lr, r1, #4
 804823e:	ed5e 5a01 	vldr	s11, [lr, #-4]
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 8048242:	ed95 6a01 	vldr	s12, [r5, #4]
				conv1d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _xx, _ww));
 8048246:	46d4      	mov	ip, sl
 8048248:	4610      	mov	r0, r2
 804824a:	4649      	mov	r1, r9
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 804824c:	edd1 7a00 	vldr	s15, [r1]
 8048250:	ecf0 6a01 	vldmia	r0!, {s13}
 8048254:	ecbc 7a01 	vldmia	ip!, {s14}
 8048258:	eee5 7aa6 	vfma.f32	s15, s11, s13
 804825c:	eee7 7a06 	vfma.f32	s15, s14, s12
 8048260:	ece1 7a01 	vstmia	r1!, {s15}
 8048264:	428c      	cmp	r4, r1
 8048266:	d1f1      	bne.n	804824c <kad_op_conv1d+0xe80>
				conv1d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _xx, _ww));
 8048268:	9913      	ldr	r1, [sp, #76]	@ 0x4c
 804826a:	9815      	ldr	r0, [sp, #84]	@ 0x54
 804826c:	440a      	add	r2, r1
 804826e:	448a      	add	sl, r1
 8048270:	1c99      	adds	r1, r3, #2
 8048272:	4281      	cmp	r1, r0
 8048274:	f105 0508 	add.w	r5, r5, #8
 8048278:	f10e 0e08 	add.w	lr, lr, #8
 804827c:	da04      	bge.n	8048288 <kad_op_conv1d+0xebc>
 804827e:	460b      	mov	r3, r1
 8048280:	e7dd      	b.n	804823e <kad_op_conv1d+0xe72>
 8048282:	bf00      	nop
 8048284:	00000000 	.word	0x00000000
 8048288:	3301      	adds	r3, #1
 804828a:	f8dd c01c 	ldr.w	ip, [sp, #28]
 804828e:	ecf5 6a01 	vldmia	r5!, {s13}
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 8048292:	4610      	mov	r0, r2
				conv1d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _xx, _ww));
 8048294:	4649      	mov	r1, r9
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 8048296:	edd1 7a00 	vldr	s15, [r1]
 804829a:	ecb0 7a01 	vldmia	r0!, {s14}
 804829e:	eee7 7a26 	vfma.f32	s15, s14, s13
 80482a2:	ece1 7a01 	vstmia	r1!, {s15}
 80482a6:	428c      	cmp	r4, r1
 80482a8:	d1f5      	bne.n	8048296 <kad_op_conv1d+0xeca>
				conv1d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _xx, _ww));
 80482aa:	3301      	adds	r3, #1
 80482ac:	429f      	cmp	r7, r3
 80482ae:	4462      	add	r2, ip
 80482b0:	dced      	bgt.n	804828e <kad_op_conv1d+0xec2>
 80482b2:	9a10      	ldr	r2, [sp, #64]	@ 0x40
 80482b4:	990d      	ldr	r1, [sp, #52]	@ 0x34
 80482b6:	4491      	add	r9, r2
 80482b8:	4414      	add	r4, r2
 80482ba:	9a01      	ldr	r2, [sp, #4]
 80482bc:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 80482be:	440a      	add	r2, r1
 80482c0:	9201      	str	r2, [sp, #4]
 80482c2:	9a08      	ldr	r2, [sp, #32]
 80482c4:	3301      	adds	r3, #1
 80482c6:	4293      	cmp	r3, r2
 80482c8:	930a      	str	r3, [sp, #40]	@ 0x28
 80482ca:	d19c      	bne.n	8048206 <kad_op_conv1d+0xe3a>
 80482cc:	e9dd 5a18 	ldrd	r5, sl, [sp, #96]	@ 0x60
 80482d0:	9b02      	ldr	r3, [sp, #8]
 80482d2:	3501      	adds	r5, #1
 80482d4:	429d      	cmp	r5, r3
 80482d6:	4631      	mov	r1, r6
 80482d8:	44c2      	add	sl, r8
 80482da:	f47f af68 	bne.w	80481ae <kad_op_conv1d+0xde2>
 80482de:	f8dd 9058 	ldr.w	r9, [sp, #88]	@ 0x58
 80482e2:	9b05      	ldr	r3, [sp, #20]
 80482e4:	2b00      	cmp	r3, #0
 80482e6:	f77f ae9d 	ble.w	8048024 <kad_op_conv1d+0xc58>
 80482ea:	9f03      	ldr	r7, [sp, #12]
 80482ec:	2f00      	cmp	r7, #0
 80482ee:	f77f a882 	ble.w	80473f6 <kad_op_conv1d+0x2a>
		for (j = 0; j < d[1]; ++j)
 80482f2:	2000      	movs	r0, #0
 80482f4:	4698      	mov	r8, r3
 80482f6:	4684      	mov	ip, r0
	for (k = 0; k < d[0]; ++k)
 80482f8:	4686      	mov	lr, r0
 80482fa:	00ba      	lsls	r2, r7, #2
 80482fc:	9202      	str	r2, [sp, #8]
 80482fe:	009c      	lsls	r4, r3, #2
		for (j = 0; j < d[1]; ++j)
 8048300:	f04f 0a00 	mov.w	sl, #0
 8048304:	fb07 f300 	mul.w	r3, r7, r0
 8048308:	fb08 f50c 	mul.w	r5, r8, ip
 804830c:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 804830e:	18fe      	adds	r6, r7, r3
 8048310:	eb02 0585 	add.w	r5, r2, r5, lsl #2
 8048314:	eb09 0186 	add.w	r1, r9, r6, lsl #2
				conv1d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _xx, _ww));
 8048318:	462a      	mov	r2, r5
 804831a:	eb09 0383 	add.w	r3, r9, r3, lsl #2
				x[(k * d[1] + j) * d[2] + i] += y[(k * d[2] + i) * d[1] + j];
 804831e:	ed93 7a00 	vldr	s14, [r3]
 8048322:	edd2 7a00 	vldr	s15, [r2]
 8048326:	ee77 7a87 	vadd.f32	s15, s15, s14
 804832a:	ece3 7a01 	vstmia	r3!, {s15}
			for (i = 0; i < d[2]; ++i)
 804832e:	4299      	cmp	r1, r3
 8048330:	4422      	add	r2, r4
 8048332:	d1f4      	bne.n	804831e <kad_op_conv1d+0xf52>
		for (j = 0; j < d[1]; ++j)
 8048334:	9b02      	ldr	r3, [sp, #8]
 8048336:	f10a 0a01 	add.w	sl, sl, #1
 804833a:	45d0      	cmp	r8, sl
 804833c:	4419      	add	r1, r3
 804833e:	f105 0504 	add.w	r5, r5, #4
 8048342:	4633      	mov	r3, r6
 8048344:	d001      	beq.n	804834a <kad_op_conv1d+0xf7e>
 8048346:	443e      	add	r6, r7
 8048348:	e7e6      	b.n	8048318 <kad_op_conv1d+0xf4c>
	for (k = 0; k < d[0]; ++k)
 804834a:	9b08      	ldr	r3, [sp, #32]
 804834c:	f10e 0e01 	add.w	lr, lr, #1
 8048350:	4573      	cmp	r3, lr
 8048352:	44bc      	add	ip, r7
 8048354:	4440      	add	r0, r8
 8048356:	d1d3      	bne.n	8048300 <kad_op_conv1d+0xf34>
 8048358:	e664      	b.n	8048024 <kad_op_conv1d+0xc58>
				conv1d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _xx, _ww));
 804835a:	2300      	movs	r3, #0
 804835c:	9a06      	ldr	r2, [sp, #24]
 804835e:	e794      	b.n	804828a <kad_op_conv1d+0xebe>
 8048360:	7832      	ldrb	r2, [r6, #0]
 8048362:	4613      	mov	r3, r2
 8048364:	2a00      	cmp	r2, #0
 8048366:	f47f aeee 	bne.w	8048146 <kad_op_conv1d+0xd7a>
				memset(w1, 0, kad_len(w) * sizeof(float));
 804836a:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 804836c:	601a      	str	r2, [r3, #0]
	for (k = 0; k < d[0]; ++k)
 804836e:	9b08      	ldr	r3, [sp, #32]
 8048370:	2b00      	cmp	r3, #0
 8048372:	dcb6      	bgt.n	80482e2 <kad_op_conv1d+0xf16>
 8048374:	e656      	b.n	8048024 <kad_op_conv1d+0xc58>
 8048376:	9a08      	ldr	r2, [sp, #32]
 8048378:	e6f4      	b.n	8048164 <kad_op_conv1d+0xd98>
				memset(w1, 0, kad_len(w) * sizeof(float));
 804837a:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 804837c:	601a      	str	r2, [r3, #0]
				conv1d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _xx, _ww));
 804837e:	9b04      	ldr	r3, [sp, #16]
 8048380:	f8d3 8014 	ldr.w	r8, [r3, #20]
 8048384:	f8db 3004 	ldr.w	r3, [fp, #4]
 8048388:	fb03 f308 	mul.w	r3, r3, r8
 804838c:	e6fa      	b.n	8048184 <kad_op_conv1d+0xdb8>
			conv1d_loop1(q->x, w->x, p->x, t, process_row_for);
 804838e:	69b1      	ldr	r1, [r6, #24]
	for (k = 0; k < d[0]; ++k)
 8048390:	691a      	ldr	r2, [r3, #16]
			conv1d_loop1(q->x, w->x, p->x, t, process_row_for);
 8048392:	9105      	str	r1, [sp, #20]
 8048394:	6ab1      	ldr	r1, [r6, #40]	@ 0x28
	for (k = 0; k < d[0]; ++k)
 8048396:	2a00      	cmp	r2, #0
			conv1d_loop1(q->x, w->x, p->x, t, process_row_for);
 8048398:	910e      	str	r1, [sp, #56]	@ 0x38
 804839a:	6931      	ldr	r1, [r6, #16]
			conv1d_move_1to2(q->d, q->x, q1);
 804839c:	f8d3 8028 	ldr.w	r8, [r3, #40]	@ 0x28
			conv1d_loop1(q->x, w->x, p->x, t, process_row_for);
 80483a0:	910a      	str	r1, [sp, #40]	@ 0x28
 80483a2:	6971      	ldr	r1, [r6, #20]
	for (k = 0; k < d[0]; ++k)
 80483a4:	9201      	str	r2, [sp, #4]
			conv1d_loop1(q->x, w->x, p->x, t, process_row_for);
 80483a6:	9102      	str	r1, [sp, #8]
	for (k = 0; k < d[0]; ++k)
 80483a8:	dd7f      	ble.n	80484aa <kad_op_conv1d+0x10de>
		for (j = 0; j < d[1]; ++j)
 80483aa:	f8d3 9014 	ldr.w	r9, [r3, #20]
 80483ae:	f1b9 0f00 	cmp.w	r9, #0
 80483b2:	dd2f      	ble.n	8048414 <kad_op_conv1d+0x1048>
			for (i = 0; i < d[2]; ++i)
 80483b4:	f04f 0c00 	mov.w	ip, #0
	for (k = 0; k < d[0]; ++k)
 80483b8:	46e6      	mov	lr, ip
			for (i = 0; i < d[2]; ++i)
 80483ba:	699f      	ldr	r7, [r3, #24]
 80483bc:	ea4f 0089 	mov.w	r0, r9, lsl #2
 80483c0:	ea4f 0a87 	mov.w	sl, r7, lsl #2
		for (j = 0; j < d[1]; ++j)
 80483c4:	2f00      	cmp	r7, #0
				y[(k * d[2] + i) * d[1] + j] = x[(k * d[1] + j) * d[2] + i];
 80483c6:	fb07 f10e 	mul.w	r1, r7, lr
 80483ca:	dd1d      	ble.n	8048408 <kad_op_conv1d+0x103c>
		for (j = 0; j < d[1]; ++j)
 80483cc:	2500      	movs	r5, #0
 80483ce:	fb09 f101 	mul.w	r1, r9, r1
 80483d2:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 80483d4:	eb03 0181 	add.w	r1, r3, r1, lsl #2
 80483d8:	fb07 f30c 	mul.w	r3, r7, ip
 80483dc:	18fc      	adds	r4, r7, r3
 80483de:	eb08 0284 	add.w	r2, r8, r4, lsl #2
			conv1d_loop1(q->x, w->x, p->x, t, process_row_for);
 80483e2:	460e      	mov	r6, r1
 80483e4:	eb08 0383 	add.w	r3, r8, r3, lsl #2
				y[(k * d[2] + i) * d[1] + j] = x[(k * d[1] + j) * d[2] + i];
 80483e8:	ecf3 7a01 	vldmia	r3!, {s15}
			for (i = 0; i < d[2]; ++i)
 80483ec:	429a      	cmp	r2, r3
				y[(k * d[2] + i) * d[1] + j] = x[(k * d[1] + j) * d[2] + i];
 80483ee:	edc6 7a00 	vstr	s15, [r6]
			for (i = 0; i < d[2]; ++i)
 80483f2:	4406      	add	r6, r0
 80483f4:	d1f8      	bne.n	80483e8 <kad_op_conv1d+0x101c>
		for (j = 0; j < d[1]; ++j)
 80483f6:	3501      	adds	r5, #1
 80483f8:	454d      	cmp	r5, r9
 80483fa:	4623      	mov	r3, r4
 80483fc:	f101 0104 	add.w	r1, r1, #4
 8048400:	4452      	add	r2, sl
 8048402:	d001      	beq.n	8048408 <kad_op_conv1d+0x103c>
 8048404:	443c      	add	r4, r7
 8048406:	e7ec      	b.n	80483e2 <kad_op_conv1d+0x1016>
	for (k = 0; k < d[0]; ++k)
 8048408:	9b01      	ldr	r3, [sp, #4]
 804840a:	f10e 0e01 	add.w	lr, lr, #1
 804840e:	459e      	cmp	lr, r3
 8048410:	44cc      	add	ip, r9
 8048412:	d1d7      	bne.n	80483c4 <kad_op_conv1d+0xff8>
 8048414:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 8048416:	2b00      	cmp	r3, #0
 8048418:	f77f aa8c 	ble.w	8047934 <kad_op_conv1d+0x568>
 804841c:	9b02      	ldr	r3, [sp, #8]
 804841e:	2b00      	cmp	r3, #0
 8048420:	dd39      	ble.n	8048496 <kad_op_conv1d+0x10ca>
 8048422:	9b05      	ldr	r3, [sp, #20]
 8048424:	2b00      	cmp	r3, #0
 8048426:	dd2c      	ble.n	8048482 <kad_op_conv1d+0x10b6>
		for (j = 0; j < d[1]; ++j)
 8048428:	2700      	movs	r7, #0
 804842a:	46bc      	mov	ip, r7
	for (k = 0; k < d[0]; ++k)
 804842c:	46be      	mov	lr, r7
 804842e:	9e05      	ldr	r6, [sp, #20]
 8048430:	9b02      	ldr	r3, [sp, #8]
 8048432:	ea4f 0886 	mov.w	r8, r6, lsl #2
 8048436:	0098      	lsls	r0, r3, #2
		for (j = 0; j < d[1]; ++j)
 8048438:	f04f 0a00 	mov.w	sl, #0
 804843c:	9a02      	ldr	r2, [sp, #8]
 804843e:	fb06 f307 	mul.w	r3, r6, r7
 8048442:	fb02 f40c 	mul.w	r4, r2, ip
 8048446:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 8048448:	18f5      	adds	r5, r6, r3
 804844a:	eb02 0484 	add.w	r4, r2, r4, lsl #2
 804844e:	9a0e      	ldr	r2, [sp, #56]	@ 0x38
 8048450:	eb02 0185 	add.w	r1, r2, r5, lsl #2
			for (i = 0; i < d[2]; ++i)
 8048454:	9a0e      	ldr	r2, [sp, #56]	@ 0x38
 8048456:	eb02 0383 	add.w	r3, r2, r3, lsl #2
	for (k = 0; k < d[0]; ++k)
 804845a:	4622      	mov	r2, r4
				y[(k * d[2] + i) * d[1] + j] = x[(k * d[1] + j) * d[2] + i];
 804845c:	ecf3 7a01 	vldmia	r3!, {s15}
			for (i = 0; i < d[2]; ++i)
 8048460:	4299      	cmp	r1, r3
				y[(k * d[2] + i) * d[1] + j] = x[(k * d[1] + j) * d[2] + i];
 8048462:	edc2 7a00 	vstr	s15, [r2]
			for (i = 0; i < d[2]; ++i)
 8048466:	4402      	add	r2, r0
 8048468:	d1f8      	bne.n	804845c <kad_op_conv1d+0x1090>
		for (j = 0; j < d[1]; ++j)
 804846a:	9a02      	ldr	r2, [sp, #8]
 804846c:	f10a 0a01 	add.w	sl, sl, #1
 8048470:	4592      	cmp	sl, r2
 8048472:	462b      	mov	r3, r5
 8048474:	f104 0404 	add.w	r4, r4, #4
 8048478:	4441      	add	r1, r8
 804847a:	f43f a9cb 	beq.w	8047814 <kad_op_conv1d+0x448>
 804847e:	4435      	add	r5, r6
 8048480:	e7e8      	b.n	8048454 <kad_op_conv1d+0x1088>
			conv1d_loop2(q1, w1, p->x, (*_yy += kad_sdot(m, _ww, _xx)));
 8048482:	f8db 3004 	ldr.w	r3, [fp, #4]
 8048486:	9902      	ldr	r1, [sp, #8]
 8048488:	fb03 f209 	mul.w	r2, r3, r9
 804848c:	9b05      	ldr	r3, [sp, #20]
 804848e:	fb01 f303 	mul.w	r3, r1, r3
 8048492:	f7ff b9d2 	b.w	804783a <kad_op_conv1d+0x46e>
 8048496:	4619      	mov	r1, r3
 8048498:	f8db 3004 	ldr.w	r3, [fp, #4]
 804849c:	fb03 f209 	mul.w	r2, r3, r9
 80484a0:	9b05      	ldr	r3, [sp, #20]
 80484a2:	fb01 f303 	mul.w	r3, r1, r3
 80484a6:	f7ff b9c8 	b.w	804783a <kad_op_conv1d+0x46e>
	for (k = 0; k < d[0]; ++k)
 80484aa:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 80484ac:	2b00      	cmp	r3, #0
 80484ae:	f77f aa41 	ble.w	8047934 <kad_op_conv1d+0x568>
 80484b2:	2900      	cmp	r1, #0
 80484b4:	f77e af9f 	ble.w	80473f6 <kad_op_conv1d+0x2a>
 80484b8:	9b05      	ldr	r3, [sp, #20]
 80484ba:	2b00      	cmp	r3, #0
 80484bc:	f77f aa3a 	ble.w	8047934 <kad_op_conv1d+0x568>
			conv1d_loop1(q->x, w->x, p->x, t, process_row_for);
 80484c0:	9b04      	ldr	r3, [sp, #16]
 80484c2:	f8d3 9014 	ldr.w	r9, [r3, #20]
 80484c6:	e7af      	b.n	8048428 <kad_op_conv1d+0x105c>

080484c8 <kad_op_conv2d>:
{
 80484c8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	kad_node_t *q = p->child[0], *w = p->child[1];
 80484cc:	6b83      	ldr	r3, [r0, #56]	@ 0x38
{
 80484ce:	4682      	mov	sl, r0
	kad_node_t *q = p->child[0], *w = p->child[1];
 80484d0:	e9d3 9600 	ldrd	r9, r6, [r3]
	if (action == KAD_FORWARD || action == KAD_BACKWARD) { /* allocate working space */
 80484d4:	1e8b      	subs	r3, r1, #2
 80484d6:	2b01      	cmp	r3, #1
{
 80484d8:	460c      	mov	r4, r1
	conv_conf_t *aux = (conv_conf_t*)p->ptr;
 80484da:	f8d0 b030 	ldr.w	fp, [r0, #48]	@ 0x30
{
 80484de:	b0a3      	sub	sp, #140	@ 0x8c
	if (action == KAD_FORWARD || action == KAD_BACKWARD) { /* allocate working space */
 80484e0:	d917      	bls.n	8048512 <kad_op_conv2d+0x4a>
	if (action == KAD_SYNC_DIM) {
 80484e2:	2904      	cmp	r1, #4
 80484e4:	f000 80a2 	beq.w	804862c <kad_op_conv2d+0x164>
	float *t = 0, *q1 = 0, *w1 = 0, *x_padded = 0;
 80484e8:	2300      	movs	r3, #0
 80484ea:	9301      	str	r3, [sp, #4]
 80484ec:	9309      	str	r3, [sp, #36]	@ 0x24
 80484ee:	930c      	str	r3, [sp, #48]	@ 0x30
 80484f0:	9310      	str	r3, [sp, #64]	@ 0x40
	free(t); free(q1); free(w1); free(x_padded);
 80484f2:	9810      	ldr	r0, [sp, #64]	@ 0x40
 80484f4:	f003 f97c 	bl	804b7f0 <free>
 80484f8:	980c      	ldr	r0, [sp, #48]	@ 0x30
 80484fa:	f003 f979 	bl	804b7f0 <free>
 80484fe:	9809      	ldr	r0, [sp, #36]	@ 0x24
 8048500:	f003 f976 	bl	804b7f0 <free>
 8048504:	9801      	ldr	r0, [sp, #4]
 8048506:	f003 f973 	bl	804b7f0 <free>
	return 0;
 804850a:	2000      	movs	r0, #0
}
 804850c:	b023      	add	sp, #140	@ 0x8c
 804850e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (w->d[3] * w->d[1] < 16) {
 8048512:	69f3      	ldr	r3, [r6, #28]
 8048514:	6972      	ldr	r2, [r6, #20]
 8048516:	9303      	str	r3, [sp, #12]
 8048518:	fb02 f303 	mul.w	r3, r2, r3
 804851c:	2b0f      	cmp	r3, #15
 804851e:	9208      	str	r2, [sp, #32]
 8048520:	9312      	str	r3, [sp, #72]	@ 0x48
 8048522:	f340 80bb 	ble.w	804869c <kad_op_conv2d+0x1d4>
 8048526:	f899 2000 	ldrb.w	r2, [r9]
 804852a:	2a00      	cmp	r2, #0
 804852c:	f000 8410 	beq.w	8048d50 <kad_op_conv2d+0x888>
 8048530:	2a01      	cmp	r2, #1
 8048532:	f8d9 0010 	ldr.w	r0, [r9, #16]
 8048536:	d00e      	beq.n	8048556 <kad_op_conv2d+0x8e>
 8048538:	f8d9 1014 	ldr.w	r1, [r9, #20]
 804853c:	2a02      	cmp	r2, #2
 804853e:	fb01 f000 	mul.w	r0, r1, r0
 8048542:	d008      	beq.n	8048556 <kad_op_conv2d+0x8e>
 8048544:	f8d9 1018 	ldr.w	r1, [r9, #24]
 8048548:	2a03      	cmp	r2, #3
 804854a:	fb01 f000 	mul.w	r0, r1, r0
 804854e:	bf1c      	itt	ne
 8048550:	f8d9 201c 	ldrne.w	r2, [r9, #28]
 8048554:	4350      	mulne	r0, r2
			q1 = (float*)malloc(kad_len(q) * sizeof(float));
 8048556:	0080      	lsls	r0, r0, #2
 8048558:	f003 f942 	bl	804b7e0 <malloc>
 804855c:	7832      	ldrb	r2, [r6, #0]
 804855e:	900c      	str	r0, [sp, #48]	@ 0x30
 8048560:	2a00      	cmp	r2, #0
 8048562:	f000 83f3 	beq.w	8048d4c <kad_op_conv2d+0x884>
 8048566:	2a01      	cmp	r2, #1
 8048568:	6930      	ldr	r0, [r6, #16]
 804856a:	d00b      	beq.n	8048584 <kad_op_conv2d+0xbc>
 804856c:	9b08      	ldr	r3, [sp, #32]
 804856e:	2a02      	cmp	r2, #2
 8048570:	fb03 f000 	mul.w	r0, r3, r0
 8048574:	d006      	beq.n	8048584 <kad_op_conv2d+0xbc>
 8048576:	69b1      	ldr	r1, [r6, #24]
 8048578:	2a03      	cmp	r2, #3
 804857a:	fb01 f000 	mul.w	r0, r1, r0
 804857e:	bf1c      	itt	ne
 8048580:	9b03      	ldrne	r3, [sp, #12]
 8048582:	4358      	mulne	r0, r3
			w1 = (float*)malloc(kad_len(w) * sizeof(float));
 8048584:	0080      	lsls	r0, r0, #2
 8048586:	f003 f92b 	bl	804b7e0 <malloc>
			x_padded = aux[1].pad[0] + aux[1].pad[1] > 0? (float*)calloc((q->d[3] + aux[1].pad[0] + aux[1].pad[1]) * q->d[1], sizeof(float)) : 0;
 804858a:	e9db 3206 	ldrd	r3, r2, [fp, #24]
 804858e:	1899      	adds	r1, r3, r2
 8048590:	2900      	cmp	r1, #0
			w1 = (float*)malloc(kad_len(w) * sizeof(float));
 8048592:	9009      	str	r0, [sp, #36]	@ 0x24
			x_padded = aux[1].pad[0] + aux[1].pad[1] > 0? (float*)calloc((q->d[3] + aux[1].pad[0] + aux[1].pad[1]) * q->d[1], sizeof(float)) : 0;
 8048594:	f300 83ca 	bgt.w	8048d2c <kad_op_conv2d+0x864>
 8048598:	2300      	movs	r3, #0
	} else if (action == KAD_FORWARD) {
 804859a:	2c02      	cmp	r4, #2
			algo_switch = 1;
 804859c:	f04f 0701 	mov.w	r7, #1
			x_padded = aux[1].pad[0] + aux[1].pad[1] > 0? (float*)calloc((q->d[3] + aux[1].pad[0] + aux[1].pad[1]) * q->d[1], sizeof(float)) : 0;
 80485a0:	9301      	str	r3, [sp, #4]
	float *t = 0, *q1 = 0, *w1 = 0, *x_padded = 0;
 80485a2:	9310      	str	r3, [sp, #64]	@ 0x40
	} else if (action == KAD_FORWARD) {
 80485a4:	f000 808c 	beq.w	80486c0 <kad_op_conv2d+0x1f8>
		if (kad_is_back(p->child[0])) { /* backprop to the input array */
 80485a8:	f899 3001 	ldrb.w	r3, [r9, #1]
 80485ac:	07d9      	lsls	r1, r3, #31
 80485ae:	f100 8379 	bmi.w	8048ca4 <kad_op_conv2d+0x7dc>
		if (kad_is_back(p->child[1])) { /* backprop to the weight matrix */
 80485b2:	7873      	ldrb	r3, [r6, #1]
 80485b4:	07da      	lsls	r2, r3, #31
 80485b6:	d59c      	bpl.n	80484f2 <kad_op_conv2d+0x2a>
			conv_rot180(w->d[0] * w->d[1], w->d[2] * w->d[3], w->g);
 80485b8:	6933      	ldr	r3, [r6, #16]
 80485ba:	9908      	ldr	r1, [sp, #32]
 80485bc:	69b2      	ldr	r2, [r6, #24]
 80485be:	fb03 f501 	mul.w	r5, r3, r1
 80485c2:	9307      	str	r3, [sp, #28]
 80485c4:	9b03      	ldr	r3, [sp, #12]
	for (i = 0; i < d0; ++i) {
 80485c6:	2d00      	cmp	r5, #0
			conv_rot180(w->d[0] * w->d[1], w->d[2] * w->d[3], w->g);
 80485c8:	fb02 f003 	mul.w	r0, r2, r3
 80485cc:	f8d6 802c 	ldr.w	r8, [r6, #44]	@ 0x2c
 80485d0:	9205      	str	r2, [sp, #20]
 80485d2:	901c      	str	r0, [sp, #112]	@ 0x70
	for (i = 0; i < d0; ++i) {
 80485d4:	f340 86cf 	ble.w	8049376 <kad_op_conv2d+0xeae>
		for (j = 0; j < d1>>1; ++j)
 80485d8:	1043      	asrs	r3, r0, #1
 80485da:	2b00      	cmp	r3, #0
 80485dc:	f340 86d4 	ble.w	8049388 <kad_op_conv2d+0xec0>
 80485e0:	4642      	mov	r2, r8
	for (i = 0; i < d0; ++i) {
 80485e2:	2100      	movs	r1, #0
 80485e4:	ea4f 0c80 	mov.w	ip, r0, lsl #2
 80485e8:	ea4f 0e83 	mov.w	lr, r3, lsl #2
		for (j = 0; j < d1>>1; ++j)
 80485ec:	4610      	mov	r0, r2
 80485ee:	4462      	add	r2, ip
 80485f0:	eb00 040e 	add.w	r4, r0, lr
 80485f4:	9400      	str	r4, [sp, #0]
 80485f6:	4614      	mov	r4, r2
 80485f8:	9302      	str	r3, [sp, #8]
			tmp = xi[j], xi[j] = xi[d1-1-j], xi[d1-1-j] = tmp; 
 80485fa:	ed34 7a01 	vldmdb	r4!, {s14}
 80485fe:	edd0 7a00 	vldr	s15, [r0]
 8048602:	eca0 7a01 	vstmia	r0!, {s14}
		for (j = 0; j < d1>>1; ++j)
 8048606:	9b00      	ldr	r3, [sp, #0]
			tmp = xi[j], xi[j] = xi[d1-1-j], xi[d1-1-j] = tmp; 
 8048608:	edc4 7a00 	vstr	s15, [r4]
		for (j = 0; j < d1>>1; ++j)
 804860c:	4283      	cmp	r3, r0
 804860e:	d1f4      	bne.n	80485fa <kad_op_conv2d+0x132>
	for (i = 0; i < d0; ++i) {
 8048610:	3101      	adds	r1, #1
 8048612:	428d      	cmp	r5, r1
 8048614:	9b02      	ldr	r3, [sp, #8]
 8048616:	d1e9      	bne.n	80485ec <kad_op_conv2d+0x124>
				conv2d_loop1(q->g, w->x, p->g, t, process_row_back_x);
 8048618:	f8d9 2010 	ldr.w	r2, [r9, #16]
			if (!algo_switch) {
 804861c:	2f00      	cmp	r7, #0
 804861e:	f040 87fd 	bne.w	804961c <kad_op_conv2d+0x1154>
				conv2d_loop1(q->x, w->g, p->g, t, process_row_back_w);
 8048622:	2a00      	cmp	r2, #0
 8048624:	f300 86b8 	bgt.w	8049398 <kad_op_conv2d+0xed0>
 8048628:	f000 bfbb 	b.w	80495a2 <kad_op_conv2d+0x10da>
		if (q->n_d != 4 || w->n_d != 4) return -1;
 804862c:	f899 3000 	ldrb.w	r3, [r9]
 8048630:	2b04      	cmp	r3, #4
 8048632:	f040 8391 	bne.w	8048d58 <kad_op_conv2d+0x890>
 8048636:	7833      	ldrb	r3, [r6, #0]
 8048638:	2b04      	cmp	r3, #4
 804863a:	f040 838d 	bne.w	8048d58 <kad_op_conv2d+0x890>
		if (q->d[1] != w->d[1]) return -1; /* unmatched input channels */
 804863e:	f8d9 1014 	ldr.w	r1, [r9, #20]
 8048642:	6972      	ldr	r2, [r6, #20]
 8048644:	4291      	cmp	r1, r2
 8048646:	f040 8387 	bne.w	8048d58 <kad_op_conv2d+0x890>
		p->n_d = 4;
 804864a:	7003      	strb	r3, [r0, #0]
		p->d[0] = q->d[0], p->d[1] = w->d[0], p->d[2] = conv_out_size(q->d[2], &aux[0]), p->d[3] = conv_out_size(q->d[3], &aux[1]);
 804864c:	f8d9 3010 	ldr.w	r3, [r9, #16]
 8048650:	6103      	str	r3, [r0, #16]
 8048652:	6931      	ldr	r1, [r6, #16]
 8048654:	e9d9 2306 	ldrd	r2, r3, [r9, #24]
 8048658:	6141      	str	r1, [r0, #20]
 804865a:	f8db 1000 	ldr.w	r1, [fp]
 804865e:	f8db 001c 	ldr.w	r0, [fp, #28]
 8048662:	1a52      	subs	r2, r2, r1
 8048664:	f8db 1008 	ldr.w	r1, [fp, #8]
 8048668:	440a      	add	r2, r1
 804866a:	f8db 100c 	ldr.w	r1, [fp, #12]
 804866e:	440a      	add	r2, r1
 8048670:	f8db 1004 	ldr.w	r1, [fp, #4]
 8048674:	fb92 f2f1 	sdiv	r2, r2, r1
 8048678:	f8db 1010 	ldr.w	r1, [fp, #16]
 804867c:	3201      	adds	r2, #1
 804867e:	1a5b      	subs	r3, r3, r1
 8048680:	f8db 1018 	ldr.w	r1, [fp, #24]
 8048684:	440b      	add	r3, r1
 8048686:	f8db 1014 	ldr.w	r1, [fp, #20]
 804868a:	4403      	add	r3, r0
 804868c:	fb93 f3f1 	sdiv	r3, r3, r1
 8048690:	3301      	adds	r3, #1
 8048692:	f8ca 2018 	str.w	r2, [sl, #24]
 8048696:	f8ca 301c 	str.w	r3, [sl, #28]
 804869a:	e725      	b.n	80484e8 <kad_op_conv2d+0x20>
			t = (float*)malloc(p->d[3] * sizeof(float));
 804869c:	69c0      	ldr	r0, [r0, #28]
 804869e:	0080      	lsls	r0, r0, #2
 80486a0:	f003 f89e 	bl	804b7e0 <malloc>
			x_padded = aux[1].pad[0] + aux[1].pad[1] > 0? (float*)calloc(q->d[3] + aux[1].pad[0] + aux[1].pad[1], sizeof(float)) : 0;
 80486a4:	e9db 3206 	ldrd	r3, r2, [fp, #24]
 80486a8:	1899      	adds	r1, r3, r2
 80486aa:	2900      	cmp	r1, #0
			t = (float*)malloc(p->d[3] * sizeof(float));
 80486ac:	9010      	str	r0, [sp, #64]	@ 0x40
			x_padded = aux[1].pad[0] + aux[1].pad[1] > 0? (float*)calloc(q->d[3] + aux[1].pad[0] + aux[1].pad[1], sizeof(float)) : 0;
 80486ae:	f300 82ed 	bgt.w	8048c8c <kad_op_conv2d+0x7c4>
	int algo_switch = 0;
 80486b2:	2700      	movs	r7, #0
			x_padded = aux[1].pad[0] + aux[1].pad[1] > 0? (float*)calloc(q->d[3] + aux[1].pad[0] + aux[1].pad[1], sizeof(float)) : 0;
 80486b4:	9701      	str	r7, [sp, #4]
	float *t = 0, *q1 = 0, *w1 = 0, *x_padded = 0;
 80486b6:	9709      	str	r7, [sp, #36]	@ 0x24
 80486b8:	970c      	str	r7, [sp, #48]	@ 0x30
	} else if (action == KAD_FORWARD) {
 80486ba:	2c02      	cmp	r4, #2
 80486bc:	f47f af74 	bne.w	80485a8 <kad_op_conv2d+0xe0>
		conv_rot180(w->d[0] * w->d[1], w->d[2] * w->d[3], w->x);
 80486c0:	6931      	ldr	r1, [r6, #16]
 80486c2:	9b08      	ldr	r3, [sp, #32]
 80486c4:	9a03      	ldr	r2, [sp, #12]
 80486c6:	fb01 f303 	mul.w	r3, r1, r3
 80486ca:	4619      	mov	r1, r3
 80486cc:	69b3      	ldr	r3, [r6, #24]
	for (i = 0; i < d0; ++i) {
 80486ce:	2900      	cmp	r1, #0
		conv_rot180(w->d[0] * w->d[1], w->d[2] * w->d[3], w->x);
 80486d0:	fb03 f202 	mul.w	r2, r3, r2
 80486d4:	4613      	mov	r3, r2
	for (i = 0; i < d0; ++i) {
 80486d6:	dd1a      	ble.n	804870e <kad_op_conv2d+0x246>
		for (j = 0; j < d1>>1; ++j)
 80486d8:	1052      	asrs	r2, r2, #1
 80486da:	2a00      	cmp	r2, #0
 80486dc:	dd17      	ble.n	804870e <kad_op_conv2d+0x246>
	for (i = 0; i < d0; ++i) {
 80486de:	2000      	movs	r0, #0
 80486e0:	ea4f 0e82 	mov.w	lr, r2, lsl #2
 80486e4:	6ab2      	ldr	r2, [r6, #40]	@ 0x28
 80486e6:	ea4f 0c83 	mov.w	ip, r3, lsl #2
		for (j = 0; j < d1>>1; ++j)
 80486ea:	4613      	mov	r3, r2
 80486ec:	4462      	add	r2, ip
	for (i = 0; i < d0; ++i) {
 80486ee:	4614      	mov	r4, r2
 80486f0:	eb03 050e 	add.w	r5, r3, lr
			tmp = xi[j], xi[j] = xi[d1-1-j], xi[d1-1-j] = tmp; 
 80486f4:	ed74 7a01 	vldmdb	r4!, {s15}
 80486f8:	f8d3 8000 	ldr.w	r8, [r3]
 80486fc:	ece3 7a01 	vstmia	r3!, {s15}
		for (j = 0; j < d1>>1; ++j)
 8048700:	429d      	cmp	r5, r3
			tmp = xi[j], xi[j] = xi[d1-1-j], xi[d1-1-j] = tmp; 
 8048702:	f8c4 8000 	str.w	r8, [r4]
		for (j = 0; j < d1>>1; ++j)
 8048706:	d1f5      	bne.n	80486f4 <kad_op_conv2d+0x22c>
	for (i = 0; i < d0; ++i) {
 8048708:	3001      	adds	r0, #1
 804870a:	4281      	cmp	r1, r0
 804870c:	d1ed      	bne.n	80486ea <kad_op_conv2d+0x222>
 804870e:	f89a 1000 	ldrb.w	r1, [sl]
		memset(p->x, 0, kad_len(p) * sizeof(float));
 8048712:	f8da 0028 	ldr.w	r0, [sl, #40]	@ 0x28
 8048716:	2900      	cmp	r1, #0
 8048718:	f000 831c 	beq.w	8048d54 <kad_op_conv2d+0x88c>
 804871c:	2901      	cmp	r1, #1
 804871e:	f8da 2010 	ldr.w	r2, [sl, #16]
 8048722:	d00e      	beq.n	8048742 <kad_op_conv2d+0x27a>
 8048724:	f8da 3014 	ldr.w	r3, [sl, #20]
 8048728:	2902      	cmp	r1, #2
 804872a:	fb03 f202 	mul.w	r2, r3, r2
 804872e:	d008      	beq.n	8048742 <kad_op_conv2d+0x27a>
 8048730:	f8da 3018 	ldr.w	r3, [sl, #24]
 8048734:	2903      	cmp	r1, #3
 8048736:	fb03 f202 	mul.w	r2, r3, r2
 804873a:	bf1c      	itt	ne
 804873c:	f8da 301c 	ldrne.w	r3, [sl, #28]
 8048740:	435a      	mulne	r2, r3
 8048742:	0092      	lsls	r2, r2, #2
 8048744:	2100      	movs	r1, #0
 8048746:	f003 fb39 	bl	804bdbc <memset>
			conv2d_loop1(q->x, w->x, p->x, t, process_row_for);
 804874a:	f8d9 8010 	ldr.w	r8, [r9, #16]
		if (!algo_switch) { /* this is the first algorithm */
 804874e:	2f00      	cmp	r7, #0
 8048750:	f041 810e 	bne.w	8049970 <kad_op_conv2d+0x14a8>
			conv2d_loop1(q->x, w->x, p->x, t, process_row_for);
 8048754:	6ab3      	ldr	r3, [r6, #40]	@ 0x28
 8048756:	f1b8 0f00 	cmp.w	r8, #0
 804875a:	930b      	str	r3, [sp, #44]	@ 0x2c
 804875c:	69f3      	ldr	r3, [r6, #28]
 804875e:	6931      	ldr	r1, [r6, #16]
 8048760:	9304      	str	r3, [sp, #16]
 8048762:	e9d6 3e05 	ldrd	r3, lr, [r6, #20]
 8048766:	930a      	str	r3, [sp, #40]	@ 0x28
 8048768:	f340 8286 	ble.w	8048c78 <kad_op_conv2d+0x7b0>
 804876c:	2900      	cmp	r1, #0
 804876e:	f340 8283 	ble.w	8048c78 <kad_op_conv2d+0x7b0>
 8048772:	2b00      	cmp	r3, #0
 8048774:	f77f aebd 	ble.w	80484f2 <kad_op_conv2d+0x2a>
 8048778:	f1be 0f00 	cmp.w	lr, #0
 804877c:	f341 80f1 	ble.w	8049962 <kad_op_conv2d+0x149a>
 8048780:	9a04      	ldr	r2, [sp, #16]
 8048782:	9707      	str	r7, [sp, #28]
 8048784:	fb02 f40e 	mul.w	r4, r2, lr
 8048788:	00a6      	lsls	r6, r4, #2
 804878a:	4637      	mov	r7, r6
 804878c:	f8cd a04c 	str.w	sl, [sp, #76]	@ 0x4c
 8048790:	460d      	mov	r5, r1
 8048792:	4676      	mov	r6, lr
 8048794:	46a2      	mov	sl, r4
 8048796:	ebc2 7342 	rsb	r3, r2, r2, lsl #29
 804879a:	00db      	lsls	r3, r3, #3
 804879c:	9311      	str	r3, [sp, #68]	@ 0x44
 804879e:	4643      	mov	r3, r8
 80487a0:	46c8      	mov	r8, r9
 80487a2:	f8dd 9040 	ldr.w	r9, [sp, #64]	@ 0x40
 80487a6:	0092      	lsls	r2, r2, #2
 80487a8:	2100      	movs	r1, #0
 80487aa:	462c      	mov	r4, r5
 80487ac:	460d      	mov	r5, r1
 80487ae:	4638      	mov	r0, r7
 80487b0:	9f13      	ldr	r7, [sp, #76]	@ 0x4c
 80487b2:	9106      	str	r1, [sp, #24]
 80487b4:	9314      	str	r3, [sp, #80]	@ 0x50
 80487b6:	fb06 f305 	mul.w	r3, r6, r5
 80487ba:	990b      	ldr	r1, [sp, #44]	@ 0x2c
 80487bc:	9612      	str	r6, [sp, #72]	@ 0x48
 80487be:	fb02 1303 	mla	r3, r2, r3, r1
 80487c2:	2100      	movs	r1, #0
 80487c4:	4413      	add	r3, r2
 80487c6:	f8cd a05c 	str.w	sl, [sp, #92]	@ 0x5c
 80487ca:	4686      	mov	lr, r0
 80487cc:	461e      	mov	r6, r3
 80487ce:	4692      	mov	sl, r2
 80487d0:	9105      	str	r1, [sp, #20]
 80487d2:	9515      	str	r5, [sp, #84]	@ 0x54
 80487d4:	9416      	str	r4, [sp, #88]	@ 0x58
 80487d6:	69bb      	ldr	r3, [r7, #24]
 80487d8:	461a      	mov	r2, r3
 80487da:	2a00      	cmp	r2, #0
 80487dc:	9303      	str	r3, [sp, #12]
 80487de:	f8db 3008 	ldr.w	r3, [fp, #8]
 80487e2:	f340 8090 	ble.w	8048906 <kad_op_conv2d+0x43e>
 80487e6:	4635      	mov	r5, r6
 80487e8:	9a12      	ldr	r2, [sp, #72]	@ 0x48
 80487ea:	e9cd e618 	strd	lr, r6, [sp, #96]	@ 0x60
 80487ee:	425c      	negs	r4, r3
 80487f0:	1ad3      	subs	r3, r2, r3
 80487f2:	930f      	str	r3, [sp, #60]	@ 0x3c
 80487f4:	eba5 030a 	sub.w	r3, r5, sl
 80487f8:	2c00      	cmp	r4, #0
 80487fa:	4626      	mov	r6, r4
 80487fc:	9308      	str	r3, [sp, #32]
 80487fe:	db78      	blt.n	80488f2 <kad_op_conv2d+0x42a>
 8048800:	2300      	movs	r3, #0
 8048802:	e9cd 4a0d 	strd	r4, sl, [sp, #52]	@ 0x34
 8048806:	9300      	str	r3, [sp, #0]
 8048808:	f8d8 3018 	ldr.w	r3, [r8, #24]
 804880c:	9302      	str	r3, [sp, #8]
 804880e:	9b02      	ldr	r3, [sp, #8]
 8048810:	429e      	cmp	r6, r3
 8048812:	da6c      	bge.n	80488ee <kad_op_conv2d+0x426>
 8048814:	9a07      	ldr	r2, [sp, #28]
 8048816:	f8d8 3014 	ldr.w	r3, [r8, #20]
 804881a:	9905      	ldr	r1, [sp, #20]
 804881c:	9806      	ldr	r0, [sp, #24]
 804881e:	fb03 1102 	mla	r1, r3, r2, r1
 8048822:	9b02      	ldr	r3, [sp, #8]
 8048824:	f8d7 a01c 	ldr.w	sl, [r7, #28]
 8048828:	fb03 6101 	mla	r1, r3, r1, r6
 804882c:	697b      	ldr	r3, [r7, #20]
 804882e:	6abc      	ldr	r4, [r7, #40]	@ 0x28
 8048830:	fb03 0002 	mla	r0, r3, r2, r0
 8048834:	9b00      	ldr	r3, [sp, #0]
 8048836:	9a03      	ldr	r2, [sp, #12]
 8048838:	fb02 3000 	mla	r0, r2, r0, r3
 804883c:	f8d8 201c 	ldr.w	r2, [r8, #28]
 8048840:	fb0a f000 	mul.w	r0, sl, r0
 8048844:	fb02 f101 	mul.w	r1, r2, r1
 8048848:	f8d8 3028 	ldr.w	r3, [r8, #40]	@ 0x28
 804884c:	eb04 0480 	add.w	r4, r4, r0, lsl #2
 8048850:	9801      	ldr	r0, [sp, #4]
 8048852:	eb03 0181 	add.w	r1, r3, r1, lsl #2
 8048856:	b140      	cbz	r0, 804886a <kad_op_conv2d+0x3a2>
 8048858:	f8db 3018 	ldr.w	r3, [fp, #24]
 804885c:	0092      	lsls	r2, r2, #2
 804885e:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 8048862:	4618      	mov	r0, r3
 8048864:	f003 fba7 	bl	804bfb6 <memcpy>
 8048868:	4601      	mov	r1, r0
 804886a:	f8db 2014 	ldr.w	r2, [fp, #20]
 804886e:	9b04      	ldr	r3, [sp, #16]
 8048870:	2a01      	cmp	r2, #1
 8048872:	f340 808e 	ble.w	8048992 <kad_op_conv2d+0x4ca>
 8048876:	2b00      	cmp	r3, #0
 8048878:	dd2c      	ble.n	80488d4 <kad_op_conv2d+0x40c>
 804887a:	f8db 3018 	ldr.w	r3, [fp, #24]
 804887e:	f8dd e020 	ldr.w	lr, [sp, #32]
 8048882:	ebc3 7383 	rsb	r3, r3, r3, lsl #30
 8048886:	eb01 0c83 	add.w	ip, r1, r3, lsl #2
 804888a:	0092      	lsls	r2, r2, #2
 804888c:	eb09 018a 	add.w	r1, r9, sl, lsl #2
 8048890:	eb04 008a 	add.w	r0, r4, sl, lsl #2
 8048894:	f1ba 0f00 	cmp.w	sl, #0
 8048898:	dd74      	ble.n	8048984 <kad_op_conv2d+0x4bc>
 804889a:	4663      	mov	r3, ip
 804889c:	46ca      	mov	sl, r9
 804889e:	edd3 7a00 	vldr	s15, [r3]
 80488a2:	ecea 7a01 	vstmia	sl!, {s15}
 80488a6:	4551      	cmp	r1, sl
 80488a8:	4413      	add	r3, r2
 80488aa:	d1f8      	bne.n	804889e <kad_op_conv2d+0x3d6>
 80488ac:	edde 6a00 	vldr	s13, [lr]
 80488b0:	46ca      	mov	sl, r9
 80488b2:	4623      	mov	r3, r4
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 80488b4:	edd3 7a00 	vldr	s15, [r3]
 80488b8:	ecba 7a01 	vldmia	sl!, {s14}
 80488bc:	eee6 7a87 	vfma.f32	s15, s13, s14
 80488c0:	ece3 7a01 	vstmia	r3!, {s15}
 80488c4:	4283      	cmp	r3, r0
 80488c6:	d1f5      	bne.n	80488b4 <kad_op_conv2d+0x3ec>
			conv2d_loop1(q->x, w->x, p->x, t, process_row_for);
 80488c8:	f10e 0e04 	add.w	lr, lr, #4
 80488cc:	4575      	cmp	r5, lr
 80488ce:	f10c 0c04 	add.w	ip, ip, #4
 80488d2:	d1e2      	bne.n	804889a <kad_op_conv2d+0x3d2>
 80488d4:	9b00      	ldr	r3, [sp, #0]
 80488d6:	3301      	adds	r3, #1
 80488d8:	461a      	mov	r2, r3
 80488da:	9300      	str	r3, [sp, #0]
 80488dc:	f8db 3004 	ldr.w	r3, [fp, #4]
 80488e0:	441e      	add	r6, r3
 80488e2:	4613      	mov	r3, r2
 80488e4:	9a03      	ldr	r2, [sp, #12]
 80488e6:	4293      	cmp	r3, r2
 80488e8:	d001      	beq.n	80488ee <kad_op_conv2d+0x426>
 80488ea:	2e00      	cmp	r6, #0
 80488ec:	da8f      	bge.n	804880e <kad_op_conv2d+0x346>
 80488ee:	e9dd 4a0d 	ldrd	r4, sl, [sp, #52]	@ 0x34
 80488f2:	9b08      	ldr	r3, [sp, #32]
 80488f4:	9a11      	ldr	r2, [sp, #68]	@ 0x44
 80488f6:	3401      	adds	r4, #1
 80488f8:	1a9d      	subs	r5, r3, r2
 80488fa:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
 80488fc:	429c      	cmp	r4, r3
 80488fe:	f47f af79 	bne.w	80487f4 <kad_op_conv2d+0x32c>
 8048902:	e9dd e618 	ldrd	lr, r6, [sp, #96]	@ 0x60
 8048906:	9b05      	ldr	r3, [sp, #20]
 8048908:	9a0a      	ldr	r2, [sp, #40]	@ 0x28
 804890a:	3301      	adds	r3, #1
 804890c:	4293      	cmp	r3, r2
 804890e:	9305      	str	r3, [sp, #20]
 8048910:	4476      	add	r6, lr
 8048912:	f47f af60 	bne.w	80487d6 <kad_op_conv2d+0x30e>
 8048916:	4619      	mov	r1, r3
 8048918:	9b06      	ldr	r3, [sp, #24]
 804891a:	9c16      	ldr	r4, [sp, #88]	@ 0x58
 804891c:	3301      	adds	r3, #1
 804891e:	9d15      	ldr	r5, [sp, #84]	@ 0x54
 8048920:	42a3      	cmp	r3, r4
 8048922:	4652      	mov	r2, sl
 8048924:	4670      	mov	r0, lr
 8048926:	9e12      	ldr	r6, [sp, #72]	@ 0x48
 8048928:	f8dd a05c 	ldr.w	sl, [sp, #92]	@ 0x5c
 804892c:	9306      	str	r3, [sp, #24]
 804892e:	440d      	add	r5, r1
 8048930:	f47f af41 	bne.w	80487b6 <kad_op_conv2d+0x2ee>
 8048934:	9907      	ldr	r1, [sp, #28]
 8048936:	9b14      	ldr	r3, [sp, #80]	@ 0x50
 8048938:	3101      	adds	r1, #1
 804893a:	428b      	cmp	r3, r1
 804893c:	4677      	mov	r7, lr
 804893e:	4625      	mov	r5, r4
 8048940:	9107      	str	r1, [sp, #28]
 8048942:	f47f af31 	bne.w	80487a8 <kad_op_conv2d+0x2e0>
		conv_rot180(w->d[0] * w->d[1], w->d[2] * w->d[3], w->x);
 8048946:	e9dd 3105 	ldrd	r3, r1, [sp, #20]
 804894a:	4654      	mov	r4, sl
 804894c:	fb03 f101 	mul.w	r1, r3, r1
		for (j = 0; j < d1>>1; ++j)
 8048950:	1063      	asrs	r3, r4, #1
 8048952:	2b00      	cmp	r3, #0
 8048954:	f77f adcd 	ble.w	80484f2 <kad_op_conv2d+0x2a>
	for (i = 0; i < d0; ++i) {
 8048958:	2500      	movs	r5, #0
 804895a:	980b      	ldr	r0, [sp, #44]	@ 0x2c
 804895c:	00a4      	lsls	r4, r4, #2
 804895e:	009a      	lsls	r2, r3, #2
		for (j = 0; j < d1>>1; ++j)
 8048960:	4603      	mov	r3, r0
 8048962:	4420      	add	r0, r4
	for (i = 0; i < d0; ++i) {
 8048964:	4606      	mov	r6, r0
 8048966:	18d7      	adds	r7, r2, r3
			tmp = xi[j], xi[j] = xi[d1-1-j], xi[d1-1-j] = tmp; 
 8048968:	f856 ed04 	ldr.w	lr, [r6, #-4]!
 804896c:	f8d3 c000 	ldr.w	ip, [r3]
 8048970:	f843 eb04 	str.w	lr, [r3], #4
		for (j = 0; j < d1>>1; ++j)
 8048974:	42bb      	cmp	r3, r7
			tmp = xi[j], xi[j] = xi[d1-1-j], xi[d1-1-j] = tmp; 
 8048976:	f8c6 c000 	str.w	ip, [r6]
		for (j = 0; j < d1>>1; ++j)
 804897a:	d1f5      	bne.n	8048968 <kad_op_conv2d+0x4a0>
	for (i = 0; i < d0; ++i) {
 804897c:	3501      	adds	r5, #1
 804897e:	428d      	cmp	r5, r1
 8048980:	d1ee      	bne.n	8048960 <kad_op_conv2d+0x498>
 8048982:	e5b6      	b.n	80484f2 <kad_op_conv2d+0x2a>
			conv2d_loop1(q->x, w->x, p->x, t, process_row_for);
 8048984:	f10e 0e04 	add.w	lr, lr, #4
 8048988:	45ae      	cmp	lr, r5
 804898a:	f10c 0c04 	add.w	ip, ip, #4
 804898e:	d181      	bne.n	8048894 <kad_op_conv2d+0x3cc>
 8048990:	e7a0      	b.n	80488d4 <kad_op_conv2d+0x40c>
 8048992:	2b00      	cmp	r3, #0
 8048994:	dd9e      	ble.n	80488d4 <kad_op_conv2d+0x40c>
 8048996:	f1ba 0f00 	cmp.w	sl, #0
 804899a:	f8db 3018 	ldr.w	r3, [fp, #24]
 804899e:	dd99      	ble.n	80488d4 <kad_op_conv2d+0x40c>
 80489a0:	ebc3 7383 	rsb	r3, r3, r3, lsl #30
 80489a4:	f8dd c020 	ldr.w	ip, [sp, #32]
 80489a8:	009b      	lsls	r3, r3, #2
 80489aa:	eb04 0a8a 	add.w	sl, r4, sl, lsl #2
 80489ae:	ecfc 6a01 	vldmia	ip!, {s13}
 80489b2:	4622      	mov	r2, r4
 80489b4:	18c8      	adds	r0, r1, r3
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 80489b6:	edd2 7a00 	vldr	s15, [r2]
 80489ba:	ecb0 7a01 	vldmia	r0!, {s14}
 80489be:	eee6 7a87 	vfma.f32	s15, s13, s14
 80489c2:	ece2 7a01 	vstmia	r2!, {s15}
 80489c6:	4552      	cmp	r2, sl
 80489c8:	d1f5      	bne.n	80489b6 <kad_op_conv2d+0x4ee>
			conv2d_loop1(q->x, w->x, p->x, t, process_row_for);
 80489ca:	4565      	cmp	r5, ip
 80489cc:	f103 0304 	add.w	r3, r3, #4
 80489d0:	d1ed      	bne.n	80489ae <kad_op_conv2d+0x4e6>
 80489d2:	e77f      	b.n	80488d4 <kad_op_conv2d+0x40c>
		for (j = 0; j < d[1]; ++j)
 80489d4:	3201      	adds	r2, #1
 80489d6:	4562      	cmp	r2, ip
 80489d8:	4438      	add	r0, r7
 80489da:	f040 87fc 	bne.w	80499d6 <kad_op_conv2d+0x150e>
	for (i = 0; i < d[0]; ++i)
 80489de:	3601      	adds	r6, #1
 80489e0:	4546      	cmp	r6, r8
 80489e2:	4465      	add	r5, ip
 80489e4:	f040 87e2 	bne.w	80499ac <kad_op_conv2d+0x14e4>
 80489e8:	464b      	mov	r3, r9
 80489ea:	2c00      	cmp	r4, #0
 80489ec:	46f1      	mov	r9, lr
 80489ee:	4621      	mov	r1, r4
 80489f0:	469e      	mov	lr, r3
 80489f2:	f340 8141 	ble.w	8048c78 <kad_op_conv2d+0x7b0>
 80489f6:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 80489f8:	2b00      	cmp	r3, #0
 80489fa:	f341 8025 	ble.w	8049a48 <kad_op_conv2d+0x1580>
 80489fe:	f1be 0f00 	cmp.w	lr, #0
 8048a02:	f341 8021 	ble.w	8049a48 <kad_op_conv2d+0x1580>
 8048a06:	9b04      	ldr	r3, [sp, #16]
 8048a08:	2b00      	cmp	r3, #0
 8048a0a:	f341 8018 	ble.w	8049a3e <kad_op_conv2d+0x1576>
 8048a0e:	461a      	mov	r2, r3
		for (j = 0; j < d[1]; ++j)
 8048a10:	2400      	movs	r4, #0
 8048a12:	9d0a      	ldr	r5, [sp, #40]	@ 0x28
 8048a14:	0096      	lsls	r6, r2, #2
 8048a16:	fb05 f303 	mul.w	r3, r5, r3
 8048a1a:	9600      	str	r6, [sp, #0]
 8048a1c:	9e0b      	ldr	r6, [sp, #44]	@ 0x2c
 8048a1e:	fb0e f002 	mul.w	r0, lr, r2
 8048a22:	eb06 0782 	add.w	r7, r6, r2, lsl #2
 8048a26:	009a      	lsls	r2, r3, #2
 8048a28:	e9cd c807 	strd	ip, r8, [sp, #28]
 8048a2c:	9202      	str	r2, [sp, #8]
	for (i = 0; i < d[0]; ++i)
 8048a2e:	4626      	mov	r6, r4
 8048a30:	00aa      	lsls	r2, r5, #2
 8048a32:	46d0      	mov	r8, sl
		for (j = 0; j < d[1]; ++j)
 8048a34:	4625      	mov	r5, r4
 8048a36:	469c      	mov	ip, r3
 8048a38:	e9cd b905 	strd	fp, r9, [sp, #20]
 8048a3c:	9203      	str	r2, [sp, #12]
 8048a3e:	f04f 0a00 	mov.w	sl, #0
 8048a42:	4689      	mov	r9, r1
 8048a44:	9a04      	ldr	r2, [sp, #16]
 8048a46:	e9cd 640d 	strd	r6, r4, [sp, #52]	@ 0x34
 8048a4a:	fb02 f305 	mul.w	r3, r2, r5
 8048a4e:	9a0a      	ldr	r2, [sp, #40]	@ 0x28
 8048a50:	950f      	str	r5, [sp, #60]	@ 0x3c
 8048a52:	fb02 f303 	mul.w	r3, r2, r3
 8048a56:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 8048a58:	eb02 0b83 	add.w	fp, r2, r3, lsl #2
 8048a5c:	fb0e f304 	mul.w	r3, lr, r4
 8048a60:	9a04      	ldr	r2, [sp, #16]
 8048a62:	fb02 f303 	mul.w	r3, r2, r3
	for (i = 0; i < d[0]; ++i)
 8048a66:	461d      	mov	r5, r3
 8048a68:	465c      	mov	r4, fp
			for (k = 0; k < d[2]; ++k) {
 8048a6a:	2100      	movs	r1, #0
 8048a6c:	eb07 0283 	add.w	r2, r7, r3, lsl #2
 8048a70:	f8cd a044 	str.w	sl, [sp, #68]	@ 0x44
 8048a74:	46a2      	mov	sl, r4
 8048a76:	9e0b      	ldr	r6, [sp, #44]	@ 0x2c
 8048a78:	9312      	str	r3, [sp, #72]	@ 0x48
 8048a7a:	eb06 0685 	add.w	r6, r6, r5, lsl #2
					y[(ik + l) * d[1] + j] = x[ijk + l];
 8048a7e:	ecf6 7a01 	vldmia	r6!, {s15}
				for (l = 0; l < d[3]; ++l)
 8048a82:	9b03      	ldr	r3, [sp, #12]
 8048a84:	42b2      	cmp	r2, r6
					y[(ik + l) * d[1] + j] = x[ijk + l];
 8048a86:	edca 7a00 	vstr	s15, [sl]
				for (l = 0; l < d[3]; ++l)
 8048a8a:	449a      	add	sl, r3
 8048a8c:	d1f7      	bne.n	8048a7e <kad_op_conv2d+0x5b6>
			for (k = 0; k < d[2]; ++k) {
 8048a8e:	9e02      	ldr	r6, [sp, #8]
 8048a90:	3101      	adds	r1, #1
 8048a92:	4434      	add	r4, r6
 8048a94:	9e04      	ldr	r6, [sp, #16]
 8048a96:	4571      	cmp	r1, lr
 8048a98:	4435      	add	r5, r6
 8048a9a:	9e00      	ldr	r6, [sp, #0]
 8048a9c:	9b12      	ldr	r3, [sp, #72]	@ 0x48
 8048a9e:	4432      	add	r2, r6
 8048aa0:	d1e8      	bne.n	8048a74 <kad_op_conv2d+0x5ac>
		for (j = 0; j < d[1]; ++j)
 8048aa2:	f8dd a044 	ldr.w	sl, [sp, #68]	@ 0x44
 8048aa6:	9a0a      	ldr	r2, [sp, #40]	@ 0x28
 8048aa8:	f10a 0a01 	add.w	sl, sl, #1
 8048aac:	4592      	cmp	sl, r2
 8048aae:	f10b 0b04 	add.w	fp, fp, #4
 8048ab2:	4403      	add	r3, r0
 8048ab4:	d1d7      	bne.n	8048a66 <kad_op_conv2d+0x59e>
	for (i = 0; i < d[0]; ++i)
 8048ab6:	e9dd 640d 	ldrd	r6, r4, [sp, #52]	@ 0x34
 8048aba:	9d0f      	ldr	r5, [sp, #60]	@ 0x3c
 8048abc:	3601      	adds	r6, #1
 8048abe:	454e      	cmp	r6, r9
 8048ac0:	4649      	mov	r1, r9
 8048ac2:	4475      	add	r5, lr
 8048ac4:	4414      	add	r4, r2
 8048ac6:	dbba      	blt.n	8048a3e <kad_op_conv2d+0x576>
 8048ac8:	e9dd b905 	ldrd	fp, r9, [sp, #20]
 8048acc:	46c2      	mov	sl, r8
 8048ace:	4663      	mov	r3, ip
 8048ad0:	f8dd 8020 	ldr.w	r8, [sp, #32]
 8048ad4:	f8dd c01c 	ldr.w	ip, [sp, #28]
			conv2d_loop2(q1, w1, p->x, (*_yy += kad_sdot(m, _ww, _xx)));
 8048ad8:	461f      	mov	r7, r3
 8048ada:	f8db 3014 	ldr.w	r3, [fp, #20]
 8048ade:	f1b8 0f00 	cmp.w	r8, #0
 8048ae2:	fb03 f30c 	mul.w	r3, r3, ip
 8048ae6:	f340 80c7 	ble.w	8048c78 <kad_op_conv2d+0x7b0>
 8048aea:	009b      	lsls	r3, r3, #2
 8048aec:	2900      	cmp	r1, #0
 8048aee:	9312      	str	r3, [sp, #72]	@ 0x48
 8048af0:	f340 80c2 	ble.w	8048c78 <kad_op_conv2d+0x7b0>
 8048af4:	f1be 0f00 	cmp.w	lr, #0
 8048af8:	f340 80be 	ble.w	8048c78 <kad_op_conv2d+0x7b0>
 8048afc:	fb07 f30e 	mul.w	r3, r7, lr
 8048b00:	009a      	lsls	r2, r3, #2
 8048b02:	2300      	movs	r3, #0
 8048b04:	9300      	str	r3, [sp, #0]
 8048b06:	460b      	mov	r3, r1
 8048b08:	00b8      	lsls	r0, r7, #2
 8048b0a:	4601      	mov	r1, r0
 8048b0c:	f8cd b008 	str.w	fp, [sp, #8]
 8048b10:	f8cd 9034 	str.w	r9, [sp, #52]	@ 0x34
 8048b14:	46bb      	mov	fp, r7
 8048b16:	4644      	mov	r4, r8
 8048b18:	46f1      	mov	r9, lr
 8048b1a:	4618      	mov	r0, r3
 8048b1c:	f8cd c038 	str.w	ip, [sp, #56]	@ 0x38
 8048b20:	f8cd a00c 	str.w	sl, [sp, #12]
 8048b24:	f04f 0e00 	mov.w	lr, #0
 8048b28:	460d      	mov	r5, r1
 8048b2a:	4682      	mov	sl, r0
 8048b2c:	f8dd 8024 	ldr.w	r8, [sp, #36]	@ 0x24
 8048b30:	9f12      	ldr	r7, [sp, #72]	@ 0x48
 8048b32:	9414      	str	r4, [sp, #80]	@ 0x50
			conv2d_loop1(q->x, w->x, p->x, t, process_row_for);
 8048b34:	9b03      	ldr	r3, [sp, #12]
 8048b36:	9902      	ldr	r1, [sp, #8]
 8048b38:	699b      	ldr	r3, [r3, #24]
 8048b3a:	6888      	ldr	r0, [r1, #8]
 8048b3c:	2b00      	cmp	r3, #0
 8048b3e:	9308      	str	r3, [sp, #32]
 8048b40:	f340 8087 	ble.w	8048c52 <kad_op_conv2d+0x78a>
 8048b44:	4643      	mov	r3, r8
 8048b46:	4246      	negs	r6, r0
 8048b48:	eba9 0000 	sub.w	r0, r9, r0
 8048b4c:	e9cd 2815 	strd	r2, r8, [sp, #84]	@ 0x54
 8048b50:	e9cd a917 	strd	sl, r9, [sp, #92]	@ 0x5c
 8048b54:	eb08 0405 	add.w	r4, r8, r5
 8048b58:	46ac      	mov	ip, r5
 8048b5a:	4680      	mov	r8, r0
 8048b5c:	4699      	mov	r9, r3
 8048b5e:	f8cd e03c 	str.w	lr, [sp, #60]	@ 0x3c
			conv2d_loop2(q1, w1, p->x, (*_yy += kad_sdot(m, _ww, _xx)));
 8048b62:	2e00      	cmp	r6, #0
 8048b64:	46b2      	mov	sl, r6
 8048b66:	db68      	blt.n	8048c3a <kad_op_conv2d+0x772>
 8048b68:	2500      	movs	r5, #0
			conv2d_loop1(q->x, w->x, p->x, t, process_row_for);
 8048b6a:	9b0d      	ldr	r3, [sp, #52]	@ 0x34
			conv2d_loop2(q1, w1, p->x, (*_yy += kad_sdot(m, _ww, _xx)));
 8048b6c:	9a00      	ldr	r2, [sp, #0]
			conv2d_loop1(q->x, w->x, p->x, t, process_row_for);
 8048b6e:	699b      	ldr	r3, [r3, #24]
 8048b70:	e9cd 8c05 	strd	r8, ip, [sp, #20]
 8048b74:	9313      	str	r3, [sp, #76]	@ 0x4c
			conv2d_loop2(q1, w1, p->x, (*_yy += kad_sdot(m, _ww, _xx)));
 8048b76:	fb03 f302 	mul.w	r3, r3, r2
 8048b7a:	9311      	str	r3, [sp, #68]	@ 0x44
 8048b7c:	9b03      	ldr	r3, [sp, #12]
 8048b7e:	9607      	str	r6, [sp, #28]
 8048b80:	9a13      	ldr	r2, [sp, #76]	@ 0x4c
 8048b82:	4592      	cmp	sl, r2
 8048b84:	da56      	bge.n	8048c34 <kad_op_conv2d+0x76c>
 8048b86:	990f      	ldr	r1, [sp, #60]	@ 0x3c
 8048b88:	9800      	ldr	r0, [sp, #0]
 8048b8a:	695a      	ldr	r2, [r3, #20]
 8048b8c:	9e0e      	ldr	r6, [sp, #56]	@ 0x38
 8048b8e:	fb02 1200 	mla	r2, r2, r0, r1
 8048b92:	9908      	ldr	r1, [sp, #32]
 8048b94:	f8d3 801c 	ldr.w	r8, [r3, #28]
 8048b98:	fb01 5202 	mla	r2, r1, r2, r5
 8048b9c:	990d      	ldr	r1, [sp, #52]	@ 0x34
 8048b9e:	fb08 f202 	mul.w	r2, r8, r2
 8048ba2:	69c8      	ldr	r0, [r1, #28]
 8048ba4:	9911      	ldr	r1, [sp, #68]	@ 0x44
 8048ba6:	4451      	add	r1, sl
 8048ba8:	fb00 f101 	mul.w	r1, r0, r1
 8048bac:	fb06 f101 	mul.w	r1, r6, r1
 8048bb0:	9e0c      	ldr	r6, [sp, #48]	@ 0x30
 8048bb2:	eb06 0181 	add.w	r1, r6, r1, lsl #2
 8048bb6:	6a9e      	ldr	r6, [r3, #40]	@ 0x28
 8048bb8:	eb06 0682 	add.w	r6, r6, r2, lsl #2
 8048bbc:	9a01      	ldr	r2, [sp, #4]
 8048bbe:	b17a      	cbz	r2, 8048be0 <kad_op_conv2d+0x718>
 8048bc0:	9319      	str	r3, [sp, #100]	@ 0x64
 8048bc2:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
 8048bc4:	fb03 f200 	mul.w	r2, r3, r0
 8048bc8:	9802      	ldr	r0, [sp, #8]
 8048bca:	0092      	lsls	r2, r2, #2
 8048bcc:	6980      	ldr	r0, [r0, #24]
 8048bce:	fb03 f000 	mul.w	r0, r3, r0
 8048bd2:	9b01      	ldr	r3, [sp, #4]
 8048bd4:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 8048bd8:	f003 f9ed 	bl	804bfb6 <memcpy>
 8048bdc:	9901      	ldr	r1, [sp, #4]
 8048bde:	9b19      	ldr	r3, [sp, #100]	@ 0x64
 8048be0:	f1b8 0f00 	cmp.w	r8, #0
 8048be4:	bfc8      	it	gt
 8048be6:	f04f 0c00 	movgt.w	ip, #0
 8048bea:	dd19      	ble.n	8048c20 <kad_op_conv2d+0x758>
	for (i = 0; i < n; ++i) s += x[i] * y[i];
 8048bec:	f1bb 0f00 	cmp.w	fp, #0
	float s = 0.;
 8048bf0:	eddf 7a5b 	vldr	s15, [pc, #364]	@ 8048d60 <kad_op_conv2d+0x898>
	for (i = 0; i < n; ++i) s += x[i] * y[i];
 8048bf4:	dd09      	ble.n	8048c0a <kad_op_conv2d+0x742>
 8048bf6:	4608      	mov	r0, r1
 8048bf8:	464a      	mov	r2, r9
 8048bfa:	ecf2 6a01 	vldmia	r2!, {s13}
 8048bfe:	ecb0 7a01 	vldmia	r0!, {s14}
 8048c02:	4294      	cmp	r4, r2
 8048c04:	eee6 7a87 	vfma.f32	s15, s13, s14
 8048c08:	d1f7      	bne.n	8048bfa <kad_op_conv2d+0x732>
			conv2d_loop2(q1, w1, p->x, (*_yy += kad_sdot(m, _ww, _xx)));
 8048c0a:	ed96 7a00 	vldr	s14, [r6]
 8048c0e:	ee77 7a27 	vadd.f32	s15, s14, s15
 8048c12:	f10c 0c01 	add.w	ip, ip, #1
 8048c16:	45e0      	cmp	r8, ip
 8048c18:	ece6 7a01 	vstmia	r6!, {s15}
 8048c1c:	4439      	add	r1, r7
 8048c1e:	d1e5      	bne.n	8048bec <kad_op_conv2d+0x724>
 8048c20:	9a02      	ldr	r2, [sp, #8]
 8048c22:	3501      	adds	r5, #1
 8048c24:	6852      	ldr	r2, [r2, #4]
 8048c26:	4492      	add	sl, r2
 8048c28:	9a08      	ldr	r2, [sp, #32]
 8048c2a:	4295      	cmp	r5, r2
 8048c2c:	d002      	beq.n	8048c34 <kad_op_conv2d+0x76c>
 8048c2e:	f1ba 0f00 	cmp.w	sl, #0
 8048c32:	daa5      	bge.n	8048b80 <kad_op_conv2d+0x6b8>
 8048c34:	9e07      	ldr	r6, [sp, #28]
 8048c36:	e9dd 8c05 	ldrd	r8, ip, [sp, #20]
 8048c3a:	3601      	adds	r6, #1
 8048c3c:	45b0      	cmp	r8, r6
 8048c3e:	44e1      	add	r9, ip
 8048c40:	4464      	add	r4, ip
 8048c42:	d18e      	bne.n	8048b62 <kad_op_conv2d+0x69a>
 8048c44:	e9dd 2815 	ldrd	r2, r8, [sp, #84]	@ 0x54
 8048c48:	e9dd a917 	ldrd	sl, r9, [sp, #92]	@ 0x5c
 8048c4c:	4665      	mov	r5, ip
 8048c4e:	f8dd e03c 	ldr.w	lr, [sp, #60]	@ 0x3c
 8048c52:	f10e 0e01 	add.w	lr, lr, #1
 8048c56:	45d6      	cmp	lr, sl
 8048c58:	4490      	add	r8, r2
 8048c5a:	f47f af6b 	bne.w	8048b34 <kad_op_conv2d+0x66c>
 8048c5e:	9b00      	ldr	r3, [sp, #0]
 8048c60:	9c14      	ldr	r4, [sp, #80]	@ 0x50
 8048c62:	3301      	adds	r3, #1
 8048c64:	42a3      	cmp	r3, r4
 8048c66:	4650      	mov	r0, sl
 8048c68:	4629      	mov	r1, r5
 8048c6a:	f8dd a00c 	ldr.w	sl, [sp, #12]
 8048c6e:	9300      	str	r3, [sp, #0]
 8048c70:	f47f af56 	bne.w	8048b20 <kad_op_conv2d+0x658>
 8048c74:	4601      	mov	r1, r0
 8048c76:	46ce      	mov	lr, r9
		conv_rot180(w->d[0] * w->d[1], w->d[2] * w->d[3], w->x);
 8048c78:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 8048c7a:	fb03 f101 	mul.w	r1, r3, r1
	for (i = 0; i < d0; ++i) {
 8048c7e:	2900      	cmp	r1, #0
 8048c80:	f77f ac37 	ble.w	80484f2 <kad_op_conv2d+0x2a>
		conv_rot180(w->d[0] * w->d[1], w->d[2] * w->d[3], w->x);
 8048c84:	9b04      	ldr	r3, [sp, #16]
 8048c86:	fb03 f40e 	mul.w	r4, r3, lr
 8048c8a:	e661      	b.n	8048950 <kad_op_conv2d+0x488>
			x_padded = aux[1].pad[0] + aux[1].pad[1] > 0? (float*)calloc(q->d[3] + aux[1].pad[0] + aux[1].pad[1], sizeof(float)) : 0;
 8048c8c:	f8d9 101c 	ldr.w	r1, [r9, #28]
	int algo_switch = 0;
 8048c90:	2700      	movs	r7, #0
			x_padded = aux[1].pad[0] + aux[1].pad[1] > 0? (float*)calloc(q->d[3] + aux[1].pad[0] + aux[1].pad[1], sizeof(float)) : 0;
 8048c92:	440b      	add	r3, r1
 8048c94:	1898      	adds	r0, r3, r2
 8048c96:	2104      	movs	r1, #4
 8048c98:	f002 fd86 	bl	804b7a8 <calloc>
	float *t = 0, *q1 = 0, *w1 = 0, *x_padded = 0;
 8048c9c:	9709      	str	r7, [sp, #36]	@ 0x24
			x_padded = aux[1].pad[0] + aux[1].pad[1] > 0? (float*)calloc(q->d[3] + aux[1].pad[0] + aux[1].pad[1], sizeof(float)) : 0;
 8048c9e:	9001      	str	r0, [sp, #4]
	float *t = 0, *q1 = 0, *w1 = 0, *x_padded = 0;
 8048ca0:	970c      	str	r7, [sp, #48]	@ 0x30
 8048ca2:	e50a      	b.n	80486ba <kad_op_conv2d+0x1f2>
			conv_rot180(w->d[0] * w->d[1], w->d[2] * w->d[3], w->x);
 8048ca4:	6933      	ldr	r3, [r6, #16]
 8048ca6:	9908      	ldr	r1, [sp, #32]
 8048ca8:	69b2      	ldr	r2, [r6, #24]
 8048caa:	fb03 f501 	mul.w	r5, r3, r1
 8048cae:	9307      	str	r3, [sp, #28]
 8048cb0:	9b03      	ldr	r3, [sp, #12]
 8048cb2:	9205      	str	r2, [sp, #20]
 8048cb4:	fb02 f803 	mul.w	r8, r2, r3
 8048cb8:	6ab2      	ldr	r2, [r6, #40]	@ 0x28
	for (i = 0; i < d0; ++i) {
 8048cba:	2d00      	cmp	r5, #0
			conv_rot180(w->d[0] * w->d[1], w->d[2] * w->d[3], w->x);
 8048cbc:	9213      	str	r2, [sp, #76]	@ 0x4c
 8048cbe:	f8cd 8070 	str.w	r8, [sp, #112]	@ 0x70
	for (i = 0; i < d0; ++i) {
 8048cc2:	f340 8342 	ble.w	804934a <kad_op_conv2d+0xe82>
		for (j = 0; j < d1>>1; ++j)
 8048cc6:	ea4f 0368 	mov.w	r3, r8, asr #1
 8048cca:	2b00      	cmp	r3, #0
 8048ccc:	dd4a      	ble.n	8048d64 <kad_op_conv2d+0x89c>
	for (i = 0; i < d0; ++i) {
 8048cce:	2100      	movs	r1, #0
 8048cd0:	ea4f 0c88 	mov.w	ip, r8, lsl #2
 8048cd4:	ea4f 0e83 	mov.w	lr, r3, lsl #2
		for (j = 0; j < d1>>1; ++j)
 8048cd8:	4610      	mov	r0, r2
 8048cda:	4462      	add	r2, ip
 8048cdc:	eb0e 0400 	add.w	r4, lr, r0
 8048ce0:	9400      	str	r4, [sp, #0]
 8048ce2:	4614      	mov	r4, r2
 8048ce4:	9302      	str	r3, [sp, #8]
			tmp = xi[j], xi[j] = xi[d1-1-j], xi[d1-1-j] = tmp; 
 8048ce6:	ed34 7a01 	vldmdb	r4!, {s14}
 8048cea:	edd0 7a00 	vldr	s15, [r0]
 8048cee:	eca0 7a01 	vstmia	r0!, {s14}
		for (j = 0; j < d1>>1; ++j)
 8048cf2:	9b00      	ldr	r3, [sp, #0]
			tmp = xi[j], xi[j] = xi[d1-1-j], xi[d1-1-j] = tmp; 
 8048cf4:	edc4 7a00 	vstr	s15, [r4]
		for (j = 0; j < d1>>1; ++j)
 8048cf8:	4298      	cmp	r0, r3
 8048cfa:	d1f4      	bne.n	8048ce6 <kad_op_conv2d+0x81e>
	for (i = 0; i < d0; ++i) {
 8048cfc:	3101      	adds	r1, #1
 8048cfe:	428d      	cmp	r5, r1
 8048d00:	9b02      	ldr	r3, [sp, #8]
 8048d02:	d1e9      	bne.n	8048cd8 <kad_op_conv2d+0x810>
			if (!algo_switch) {
 8048d04:	2f00      	cmp	r7, #0
 8048d06:	f040 8190 	bne.w	804902a <kad_op_conv2d+0xb62>
				conv2d_loop1(q->g, w->x, p->g, t, process_row_back_x);
 8048d0a:	f8d9 2010 	ldr.w	r2, [r9, #16]
 8048d0e:	2a00      	cmp	r2, #0
 8048d10:	f340 8150 	ble.w	8048fb4 <kad_op_conv2d+0xaec>
 8048d14:	9a07      	ldr	r2, [sp, #28]
 8048d16:	2a00      	cmp	r2, #0
 8048d18:	f340 814c 	ble.w	8048fb4 <kad_op_conv2d+0xaec>
 8048d1c:	9a08      	ldr	r2, [sp, #32]
 8048d1e:	2a00      	cmp	r2, #0
 8048d20:	f340 8148 	ble.w	8048fb4 <kad_op_conv2d+0xaec>
 8048d24:	9a05      	ldr	r2, [sp, #20]
 8048d26:	2a00      	cmp	r2, #0
 8048d28:	dc2f      	bgt.n	8048d8a <kad_op_conv2d+0x8c2>
 8048d2a:	e143      	b.n	8048fb4 <kad_op_conv2d+0xaec>
			x_padded = aux[1].pad[0] + aux[1].pad[1] > 0? (float*)calloc((q->d[3] + aux[1].pad[0] + aux[1].pad[1]) * q->d[1], sizeof(float)) : 0;
 8048d2c:	f8d9 101c 	ldr.w	r1, [r9, #28]
 8048d30:	f8d9 0014 	ldr.w	r0, [r9, #20]
 8048d34:	440b      	add	r3, r1
 8048d36:	4413      	add	r3, r2
 8048d38:	fb03 f000 	mul.w	r0, r3, r0
 8048d3c:	2104      	movs	r1, #4
 8048d3e:	f002 fd33 	bl	804b7a8 <calloc>
	float *t = 0, *q1 = 0, *w1 = 0, *x_padded = 0;
 8048d42:	2300      	movs	r3, #0
			algo_switch = 1;
 8048d44:	2701      	movs	r7, #1
	float *t = 0, *q1 = 0, *w1 = 0, *x_padded = 0;
 8048d46:	9310      	str	r3, [sp, #64]	@ 0x40
			x_padded = aux[1].pad[0] + aux[1].pad[1] > 0? (float*)calloc((q->d[3] + aux[1].pad[0] + aux[1].pad[1]) * q->d[1], sizeof(float)) : 0;
 8048d48:	9001      	str	r0, [sp, #4]
	if (action == KAD_SYNC_DIM) {
 8048d4a:	e4b6      	b.n	80486ba <kad_op_conv2d+0x1f2>
 8048d4c:	2004      	movs	r0, #4
 8048d4e:	e41a      	b.n	8048586 <kad_op_conv2d+0xbe>
 8048d50:	2004      	movs	r0, #4
 8048d52:	e401      	b.n	8048558 <kad_op_conv2d+0x90>
 8048d54:	2204      	movs	r2, #4
 8048d56:	e4f5      	b.n	8048744 <kad_op_conv2d+0x27c>
		if (q->n_d != 4 || w->n_d != 4) return -1;
 8048d58:	f04f 30ff 	mov.w	r0, #4294967295
 8048d5c:	f7ff bbd6 	b.w	804850c <kad_op_conv2d+0x44>
 8048d60:	00000000 	.word	0x00000000
			if (!algo_switch) {
 8048d64:	2f00      	cmp	r7, #0
 8048d66:	f040 8160 	bne.w	804902a <kad_op_conv2d+0xb62>
				conv2d_loop1(q->g, w->x, p->g, t, process_row_back_x);
 8048d6a:	f8d9 3010 	ldr.w	r3, [r9, #16]
 8048d6e:	2b00      	cmp	r3, #0
 8048d70:	f77f ac1f 	ble.w	80485b2 <kad_op_conv2d+0xea>
 8048d74:	9b07      	ldr	r3, [sp, #28]
 8048d76:	2b00      	cmp	r3, #0
 8048d78:	f77f ac1b 	ble.w	80485b2 <kad_op_conv2d+0xea>
 8048d7c:	2900      	cmp	r1, #0
 8048d7e:	f77f ac18 	ble.w	80485b2 <kad_op_conv2d+0xea>
 8048d82:	9b05      	ldr	r3, [sp, #20]
 8048d84:	2b00      	cmp	r3, #0
 8048d86:	f77f ac14 	ble.w	80485b2 <kad_op_conv2d+0xea>
 8048d8a:	2300      	movs	r3, #0
 8048d8c:	930a      	str	r3, [sp, #40]	@ 0x28
 8048d8e:	9b03      	ldr	r3, [sp, #12]
 8048d90:	ea4f 0488 	mov.w	r4, r8, lsl #2
 8048d94:	009a      	lsls	r2, r3, #2
 8048d96:	f8cd 9050 	str.w	r9, [sp, #80]	@ 0x50
 8048d9a:	f8cd a038 	str.w	sl, [sp, #56]	@ 0x38
 8048d9e:	46a9      	mov	r9, r5
 8048da0:	46ba      	mov	sl, r7
 8048da2:	4615      	mov	r5, r2
 8048da4:	4632      	mov	r2, r6
 8048da6:	4626      	mov	r6, r4
 8048da8:	f8cd b074 	str.w	fp, [sp, #116]	@ 0x74
 8048dac:	f8dd b040 	ldr.w	fp, [sp, #64]	@ 0x40
 8048db0:	2400      	movs	r4, #0
 8048db2:	4647      	mov	r7, r8
 8048db4:	940b      	str	r4, [sp, #44]	@ 0x2c
 8048db6:	9b05      	ldr	r3, [sp, #20]
 8048db8:	9913      	ldr	r1, [sp, #76]	@ 0x4c
 8048dba:	fb03 f304 	mul.w	r3, r3, r4
 8048dbe:	fb05 1303 	mla	r3, r5, r3, r1
 8048dc2:	eb03 0805 	add.w	r8, r3, r5
 8048dc6:	2300      	movs	r3, #0
 8048dc8:	46a6      	mov	lr, r4
 8048dca:	462c      	mov	r4, r5
 8048dcc:	4645      	mov	r5, r8
 8048dce:	46b8      	mov	r8, r7
 8048dd0:	930d      	str	r3, [sp, #52]	@ 0x34
 8048dd2:	9b1d      	ldr	r3, [sp, #116]	@ 0x74
 8048dd4:	f8cd a078 	str.w	sl, [sp, #120]	@ 0x78
 8048dd8:	990e      	ldr	r1, [sp, #56]	@ 0x38
 8048dda:	6989      	ldr	r1, [r1, #24]
 8048ddc:	4608      	mov	r0, r1
 8048dde:	2800      	cmp	r0, #0
 8048de0:	9106      	str	r1, [sp, #24]
				conv2d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _ww, _xx));
 8048de2:	6899      	ldr	r1, [r3, #8]
 8048de4:	f340 80b6 	ble.w	8048f54 <kad_op_conv2d+0xa8c>
 8048de8:	9805      	ldr	r0, [sp, #20]
 8048dea:	424f      	negs	r7, r1
 8048dec:	1a41      	subs	r1, r0, r1
				conv2d_loop1(q->g, w->x, p->g, t, process_row_back_x);
 8048dee:	9803      	ldr	r0, [sp, #12]
 8048df0:	e9cd 261f 	strd	r2, r6, [sp, #124]	@ 0x7c
 8048df4:	ebc0 7c40 	rsb	ip, r0, r0, lsl #29
 8048df8:	f8cd 9084 	str.w	r9, [sp, #132]	@ 0x84
 8048dfc:	46aa      	mov	sl, r5
 8048dfe:	46a1      	mov	r9, r4
 8048e00:	460e      	mov	r6, r1
 8048e02:	4664      	mov	r4, ip
 8048e04:	2f00      	cmp	r7, #0
 8048e06:	9700      	str	r7, [sp, #0]
 8048e08:	ebaa 0c09 	sub.w	ip, sl, r9
 8048e0c:	f2c0 8097 	blt.w	8048f3e <kad_op_conv2d+0xa76>
 8048e10:	2200      	movs	r2, #0
 8048e12:	e9cd 9715 	strd	r9, r7, [sp, #84]	@ 0x54
 8048e16:	e9cd 5618 	strd	r5, r6, [sp, #96]	@ 0x60
 8048e1a:	e9cd 841a 	strd	r8, r4, [sp, #104]	@ 0x68
 8048e1e:	9302      	str	r3, [sp, #8]
 8048e20:	9b14      	ldr	r3, [sp, #80]	@ 0x50
 8048e22:	9204      	str	r2, [sp, #16]
 8048e24:	f8cd e05c 	str.w	lr, [sp, #92]	@ 0x5c
 8048e28:	f8cd c03c 	str.w	ip, [sp, #60]	@ 0x3c
 8048e2c:	6999      	ldr	r1, [r3, #24]
 8048e2e:	9a00      	ldr	r2, [sp, #0]
 8048e30:	4291      	cmp	r1, r2
 8048e32:	dd79      	ble.n	8048f28 <kad_op_conv2d+0xa60>
 8048e34:	980d      	ldr	r0, [sp, #52]	@ 0x34
 8048e36:	9c0a      	ldr	r4, [sp, #40]	@ 0x28
 8048e38:	695a      	ldr	r2, [r3, #20]
 8048e3a:	9d0b      	ldr	r5, [sp, #44]	@ 0x2c
 8048e3c:	fb02 0204 	mla	r2, r2, r4, r0
 8048e40:	9800      	ldr	r0, [sp, #0]
 8048e42:	6ade      	ldr	r6, [r3, #44]	@ 0x2c
 8048e44:	fb01 0102 	mla	r1, r1, r2, r0
 8048e48:	980e      	ldr	r0, [sp, #56]	@ 0x38
 8048e4a:	6942      	ldr	r2, [r0, #20]
 8048e4c:	f8d0 801c 	ldr.w	r8, [r0, #28]
 8048e50:	fb02 5404 	mla	r4, r2, r4, r5
 8048e54:	9a04      	ldr	r2, [sp, #16]
 8048e56:	9d06      	ldr	r5, [sp, #24]
 8048e58:	6ac0      	ldr	r0, [r0, #44]	@ 0x2c
 8048e5a:	fb05 2404 	mla	r4, r5, r4, r2
 8048e5e:	69da      	ldr	r2, [r3, #28]
 8048e60:	fb08 f404 	mul.w	r4, r8, r4
 8048e64:	fb02 f501 	mul.w	r5, r2, r1
 8048e68:	eb00 0984 	add.w	r9, r0, r4, lsl #2
 8048e6c:	9801      	ldr	r0, [sp, #4]
 8048e6e:	eb06 0185 	add.w	r1, r6, r5, lsl #2
 8048e72:	b150      	cbz	r0, 8048e8a <kad_op_conv2d+0x9c2>
 8048e74:	9311      	str	r3, [sp, #68]	@ 0x44
 8048e76:	9b02      	ldr	r3, [sp, #8]
 8048e78:	0092      	lsls	r2, r2, #2
 8048e7a:	699d      	ldr	r5, [r3, #24]
 8048e7c:	eb00 0585 	add.w	r5, r0, r5, lsl #2
 8048e80:	4628      	mov	r0, r5
 8048e82:	f003 f898 	bl	804bfb6 <memcpy>
 8048e86:	4629      	mov	r1, r5
 8048e88:	9b11      	ldr	r3, [sp, #68]	@ 0x44
 8048e8a:	9a02      	ldr	r2, [sp, #8]
 8048e8c:	6956      	ldr	r6, [r2, #20]
 8048e8e:	9a03      	ldr	r2, [sp, #12]
 8048e90:	2e01      	cmp	r6, #1
 8048e92:	f340 80a7 	ble.w	8048fe4 <kad_op_conv2d+0xb1c>
 8048e96:	2a00      	cmp	r2, #0
 8048e98:	dd39      	ble.n	8048f0e <kad_op_conv2d+0xa46>
 8048e9a:	9a02      	ldr	r2, [sp, #8]
 8048e9c:	eb0b 0488 	add.w	r4, fp, r8, lsl #2
 8048ea0:	6992      	ldr	r2, [r2, #24]
 8048ea2:	9311      	str	r3, [sp, #68]	@ 0x44
 8048ea4:	ebc2 7282 	rsb	r2, r2, r2, lsl #30
 8048ea8:	eb01 0582 	add.w	r5, r1, r2, lsl #2
 8048eac:	ea4f 0288 	mov.w	r2, r8, lsl #2
 8048eb0:	465b      	mov	r3, fp
 8048eb2:	46cb      	mov	fp, r9
 8048eb4:	4691      	mov	r9, r2
				conv2d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _ww, _xx));
 8048eb6:	9f0f      	ldr	r7, [sp, #60]	@ 0x3c
				conv2d_loop1(q->g, w->x, p->g, t, process_row_back_x);
 8048eb8:	00b6      	lsls	r6, r6, #2
 8048eba:	464a      	mov	r2, r9
 8048ebc:	4618      	mov	r0, r3
 8048ebe:	2100      	movs	r1, #0
 8048ec0:	f002 ff7c 	bl	804bdbc <memset>
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 8048ec4:	f1b8 0f00 	cmp.w	r8, #0
				conv2d_loop1(q->g, w->x, p->g, t, process_row_back_x);
 8048ec8:	4603      	mov	r3, r0
 8048eca:	ecf7 6a01 	vldmia	r7!, {s13}
 8048ece:	462a      	mov	r2, r5
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 8048ed0:	dd17      	ble.n	8048f02 <kad_op_conv2d+0xa3a>
 8048ed2:	4658      	mov	r0, fp
 8048ed4:	4619      	mov	r1, r3
 8048ed6:	edd1 7a00 	vldr	s15, [r1]
 8048eda:	ecb0 7a01 	vldmia	r0!, {s14}
 8048ede:	eee6 7a87 	vfma.f32	s15, s13, s14
 8048ee2:	ece1 7a01 	vstmia	r1!, {s15}
 8048ee6:	428c      	cmp	r4, r1
 8048ee8:	d1f5      	bne.n	8048ed6 <kad_op_conv2d+0xa0e>
 8048eea:	4619      	mov	r1, r3
				conv2d_loop1(q->g, w->x, p->g, t, process_row_back_x);
 8048eec:	edd2 7a00 	vldr	s15, [r2]
 8048ef0:	ecb1 7a01 	vldmia	r1!, {s14}
 8048ef4:	ee77 7a87 	vadd.f32	s15, s15, s14
 8048ef8:	42a1      	cmp	r1, r4
 8048efa:	edc2 7a00 	vstr	s15, [r2]
 8048efe:	4432      	add	r2, r6
 8048f00:	d1f4      	bne.n	8048eec <kad_op_conv2d+0xa24>
 8048f02:	4557      	cmp	r7, sl
 8048f04:	f105 0504 	add.w	r5, r5, #4
 8048f08:	d1d7      	bne.n	8048eba <kad_op_conv2d+0x9f2>
 8048f0a:	469b      	mov	fp, r3
 8048f0c:	9b11      	ldr	r3, [sp, #68]	@ 0x44
 8048f0e:	9a02      	ldr	r2, [sp, #8]
 8048f10:	9800      	ldr	r0, [sp, #0]
 8048f12:	6852      	ldr	r2, [r2, #4]
 8048f14:	9904      	ldr	r1, [sp, #16]
 8048f16:	4410      	add	r0, r2
 8048f18:	9a06      	ldr	r2, [sp, #24]
 8048f1a:	3101      	adds	r1, #1
 8048f1c:	4291      	cmp	r1, r2
 8048f1e:	9104      	str	r1, [sp, #16]
 8048f20:	9000      	str	r0, [sp, #0]
 8048f22:	d001      	beq.n	8048f28 <kad_op_conv2d+0xa60>
 8048f24:	2800      	cmp	r0, #0
 8048f26:	da81      	bge.n	8048e2c <kad_op_conv2d+0x964>
 8048f28:	f8dd e05c 	ldr.w	lr, [sp, #92]	@ 0x5c
 8048f2c:	9b02      	ldr	r3, [sp, #8]
 8048f2e:	f8dd c03c 	ldr.w	ip, [sp, #60]	@ 0x3c
 8048f32:	e9dd 9715 	ldrd	r9, r7, [sp, #84]	@ 0x54
 8048f36:	e9dd 5618 	ldrd	r5, r6, [sp, #96]	@ 0x60
 8048f3a:	e9dd 841a 	ldrd	r8, r4, [sp, #104]	@ 0x68
 8048f3e:	3701      	adds	r7, #1
 8048f40:	42be      	cmp	r6, r7
 8048f42:	ebac 0ac4 	sub.w	sl, ip, r4, lsl #3
 8048f46:	f47f af5d 	bne.w	8048e04 <kad_op_conv2d+0x93c>
 8048f4a:	e9dd 261f 	ldrd	r2, r6, [sp, #124]	@ 0x7c
 8048f4e:	464c      	mov	r4, r9
 8048f50:	f8dd 9084 	ldr.w	r9, [sp, #132]	@ 0x84
 8048f54:	990d      	ldr	r1, [sp, #52]	@ 0x34
 8048f56:	9808      	ldr	r0, [sp, #32]
 8048f58:	3101      	adds	r1, #1
 8048f5a:	4288      	cmp	r0, r1
 8048f5c:	910d      	str	r1, [sp, #52]	@ 0x34
 8048f5e:	4435      	add	r5, r6
 8048f60:	f47f af3a 	bne.w	8048dd8 <kad_op_conv2d+0x910>
 8048f64:	4625      	mov	r5, r4
 8048f66:	4674      	mov	r4, lr
 8048f68:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 8048f6a:	9907      	ldr	r1, [sp, #28]
 8048f6c:	3301      	adds	r3, #1
 8048f6e:	4299      	cmp	r1, r3
 8048f70:	4647      	mov	r7, r8
 8048f72:	f8dd a078 	ldr.w	sl, [sp, #120]	@ 0x78
 8048f76:	930b      	str	r3, [sp, #44]	@ 0x2c
 8048f78:	4404      	add	r4, r0
 8048f7a:	f47f af1c 	bne.w	8048db6 <kad_op_conv2d+0x8ee>
 8048f7e:	9b14      	ldr	r3, [sp, #80]	@ 0x50
 8048f80:	990a      	ldr	r1, [sp, #40]	@ 0x28
 8048f82:	691b      	ldr	r3, [r3, #16]
 8048f84:	3101      	adds	r1, #1
 8048f86:	428b      	cmp	r3, r1
 8048f88:	910a      	str	r1, [sp, #40]	@ 0x28
 8048f8a:	f73f af11 	bgt.w	8048db0 <kad_op_conv2d+0x8e8>
 8048f8e:	4616      	mov	r6, r2
 8048f90:	4657      	mov	r7, sl
 8048f92:	464d      	mov	r5, r9
 8048f94:	f8dd b074 	ldr.w	fp, [sp, #116]	@ 0x74
 8048f98:	f8dd a038 	ldr.w	sl, [sp, #56]	@ 0x38
 8048f9c:	f8dd 9050 	ldr.w	r9, [sp, #80]	@ 0x50
	for (i = 0; i < d0; ++i) {
 8048fa0:	2d00      	cmp	r5, #0
 8048fa2:	f340 81e2 	ble.w	804936a <kad_op_conv2d+0xea2>
		for (j = 0; j < d1>>1; ++j)
 8048fa6:	ea4f 0368 	mov.w	r3, r8, asr #1
 8048faa:	2b00      	cmp	r3, #0
 8048fac:	f77f ab01 	ble.w	80485b2 <kad_op_conv2d+0xea>
 8048fb0:	ea4f 0c88 	mov.w	ip, r8, lsl #2
				conv2d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _ww, _xx));
 8048fb4:	2100      	movs	r1, #0
 8048fb6:	9a13      	ldr	r2, [sp, #76]	@ 0x4c
 8048fb8:	ea4f 0e83 	mov.w	lr, r3, lsl #2
		for (j = 0; j < d1>>1; ++j)
 8048fbc:	4613      	mov	r3, r2
 8048fbe:	4462      	add	r2, ip
				conv2d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _ww, _xx));
 8048fc0:	4610      	mov	r0, r2
 8048fc2:	eb0e 0403 	add.w	r4, lr, r3
			tmp = xi[j], xi[j] = xi[d1-1-j], xi[d1-1-j] = tmp; 
 8048fc6:	ed70 7a01 	vldmdb	r0!, {s15}
 8048fca:	f8d3 8000 	ldr.w	r8, [r3]
 8048fce:	ece3 7a01 	vstmia	r3!, {s15}
		for (j = 0; j < d1>>1; ++j)
 8048fd2:	42a3      	cmp	r3, r4
			tmp = xi[j], xi[j] = xi[d1-1-j], xi[d1-1-j] = tmp; 
 8048fd4:	f8c0 8000 	str.w	r8, [r0]
		for (j = 0; j < d1>>1; ++j)
 8048fd8:	d1f5      	bne.n	8048fc6 <kad_op_conv2d+0xafe>
	for (i = 0; i < d0; ++i) {
 8048fda:	3101      	adds	r1, #1
 8048fdc:	428d      	cmp	r5, r1
 8048fde:	d1ed      	bne.n	8048fbc <kad_op_conv2d+0xaf4>
 8048fe0:	f7ff bae7 	b.w	80485b2 <kad_op_conv2d+0xea>
				conv2d_loop1(q->g, w->x, p->g, t, process_row_back_x);
 8048fe4:	2a00      	cmp	r2, #0
 8048fe6:	dd92      	ble.n	8048f0e <kad_op_conv2d+0xa46>
 8048fe8:	9a02      	ldr	r2, [sp, #8]
 8048fea:	f1b8 0f00 	cmp.w	r8, #0
 8048fee:	6992      	ldr	r2, [r2, #24]
 8048ff0:	dd8d      	ble.n	8048f0e <kad_op_conv2d+0xa46>
 8048ff2:	eba8 0202 	sub.w	r2, r8, r2
 8048ff6:	9d0f      	ldr	r5, [sp, #60]	@ 0x3c
 8048ff8:	ebc8 7888 	rsb	r8, r8, r8, lsl #30
 8048ffc:	eb01 0082 	add.w	r0, r1, r2, lsl #2
 8049000:	ea4f 0488 	mov.w	r4, r8, lsl #2
 8049004:	ecf5 6a01 	vldmia	r5!, {s13}
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 8049008:	4649      	mov	r1, r9
 804900a:	1822      	adds	r2, r4, r0
 804900c:	edd2 7a00 	vldr	s15, [r2]
 8049010:	ecb1 7a01 	vldmia	r1!, {s14}
 8049014:	eee6 7a87 	vfma.f32	s15, s13, s14
 8049018:	ece2 7a01 	vstmia	r2!, {s15}
 804901c:	4282      	cmp	r2, r0
 804901e:	d1f5      	bne.n	804900c <kad_op_conv2d+0xb44>
				conv2d_loop1(q->g, w->x, p->g, t, process_row_back_x);
 8049020:	45aa      	cmp	sl, r5
 8049022:	f100 0004 	add.w	r0, r0, #4
 8049026:	d1ed      	bne.n	8049004 <kad_op_conv2d+0xb3c>
 8049028:	e771      	b.n	8048f0e <kad_op_conv2d+0xa46>
 804902a:	f899 2000 	ldrb.w	r2, [r9]
 804902e:	2a00      	cmp	r2, #0
 8049030:	f000 8167 	beq.w	8049302 <kad_op_conv2d+0xe3a>
 8049034:	2a01      	cmp	r2, #1
 8049036:	f8d9 3010 	ldr.w	r3, [r9, #16]
 804903a:	d00e      	beq.n	804905a <kad_op_conv2d+0xb92>
 804903c:	f8d9 1014 	ldr.w	r1, [r9, #20]
 8049040:	2a02      	cmp	r2, #2
 8049042:	fb01 f303 	mul.w	r3, r1, r3
 8049046:	d008      	beq.n	804905a <kad_op_conv2d+0xb92>
 8049048:	f8d9 1018 	ldr.w	r1, [r9, #24]
 804904c:	2a03      	cmp	r2, #3
 804904e:	fb01 f303 	mul.w	r3, r1, r3
 8049052:	bf1c      	itt	ne
 8049054:	f8d9 201c 	ldrne.w	r2, [r9, #28]
 8049058:	4353      	mulne	r3, r2
				memset(q1, 0, kad_len(q) * sizeof(float));
 804905a:	009a      	lsls	r2, r3, #2
 804905c:	2100      	movs	r1, #0
 804905e:	980c      	ldr	r0, [sp, #48]	@ 0x30
 8049060:	f002 feac 	bl	804bdbc <memset>
	for (i = 0; i < d[0]; ++i)
 8049064:	9b07      	ldr	r3, [sp, #28]
 8049066:	2b00      	cmp	r3, #0
 8049068:	f340 8143 	ble.w	80492f2 <kad_op_conv2d+0xe2a>
		for (j = 0; j < d[1]; ++j)
 804906c:	f8d6 e014 	ldr.w	lr, [r6, #20]
 8049070:	f1be 0f00 	cmp.w	lr, #0
 8049074:	f340 8147 	ble.w	8049306 <kad_op_conv2d+0xe3e>
 8049078:	9a05      	ldr	r2, [sp, #20]
 804907a:	2a00      	cmp	r2, #0
 804907c:	f340 8139 	ble.w	80492f2 <kad_op_conv2d+0xe2a>
				int ik = (i * d[2] + k) * d[3], ijk = ((i * d[1] + j) * d[2] + k) * d[3];
 8049080:	2000      	movs	r0, #0
 8049082:	69f1      	ldr	r1, [r6, #28]
 8049084:	ea4f 038e 	mov.w	r3, lr, lsl #2
 8049088:	9300      	str	r3, [sp, #0]
 804908a:	fb0e f301 	mul.w	r3, lr, r1
 804908e:	009b      	lsls	r3, r3, #2
 8049090:	9304      	str	r3, [sp, #16]
 8049092:	008b      	lsls	r3, r1, #2
 8049094:	930a      	str	r3, [sp, #40]	@ 0x28
 8049096:	f8cd 802c 	str.w	r8, [sp, #44]	@ 0x2c
 804909a:	465b      	mov	r3, fp
 804909c:	4604      	mov	r4, r0
 804909e:	46cb      	mov	fp, r9
	for (i = 0; i < d[0]; ++i)
 80490a0:	4684      	mov	ip, r0
 80490a2:	46b9      	mov	r9, r7
 80490a4:	4690      	mov	r8, r2
 80490a6:	462f      	mov	r7, r5
		for (j = 0; j < d[1]; ++j)
 80490a8:	fb00 f201 	mul.w	r2, r0, r1
 80490ac:	fb0e f202 	mul.w	r2, lr, r2
 80490b0:	9206      	str	r2, [sp, #24]
 80490b2:	2200      	movs	r2, #0
 80490b4:	fb08 f504 	mul.w	r5, r8, r4
			for (k = 0; k < d[2]; ++k) {
 80490b8:	2900      	cmp	r1, #0
 80490ba:	dd32      	ble.n	8049122 <kad_op_conv2d+0xc5a>
 80490bc:	f8cd 9050 	str.w	r9, [sp, #80]	@ 0x50
 80490c0:	46a1      	mov	r9, r4
 80490c2:	e9cd 3b0d 	strd	r3, fp, [sp, #52]	@ 0x34
 80490c6:	960f      	str	r6, [sp, #60]	@ 0x3c
 80490c8:	f8cd c044 	str.w	ip, [sp, #68]	@ 0x44
 80490cc:	f04f 0c00 	mov.w	ip, #0
 80490d0:	9c06      	ldr	r4, [sp, #24]
 80490d2:	9e09      	ldr	r6, [sp, #36]	@ 0x24
 80490d4:	fb05 f301 	mul.w	r3, r5, r1
 80490d8:	1914      	adds	r4, r2, r4
 80490da:	eb06 0484 	add.w	r4, r6, r4, lsl #2
 80490de:	9402      	str	r4, [sp, #8]
 80490e0:	9c13      	ldr	r4, [sp, #76]	@ 0x4c
 80490e2:	18ce      	adds	r6, r1, r3
 80490e4:	eb04 0b86 	add.w	fp, r4, r6, lsl #2
 80490e8:	9c02      	ldr	r4, [sp, #8]
 80490ea:	9215      	str	r2, [sp, #84]	@ 0x54
				for (l = 0; l < d[3]; ++l)
 80490ec:	9a13      	ldr	r2, [sp, #76]	@ 0x4c
			for (k = 0; k < d[2]; ++k) {
 80490ee:	9102      	str	r1, [sp, #8]
 80490f0:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 80490f4:	4622      	mov	r2, r4
					y[(ik + l) * d[1] + j] = x[ijk + l];
 80490f6:	ecf3 7a01 	vldmia	r3!, {s15}
				for (l = 0; l < d[3]; ++l)
 80490fa:	9900      	ldr	r1, [sp, #0]
 80490fc:	455b      	cmp	r3, fp
					y[(ik + l) * d[1] + j] = x[ijk + l];
 80490fe:	edc2 7a00 	vstr	s15, [r2]
				for (l = 0; l < d[3]; ++l)
 8049102:	440a      	add	r2, r1
 8049104:	d1f7      	bne.n	80490f6 <kad_op_conv2d+0xc2e>
			for (k = 0; k < d[2]; ++k) {
 8049106:	9a04      	ldr	r2, [sp, #16]
 8049108:	f10c 0c01 	add.w	ip, ip, #1
 804910c:	4414      	add	r4, r2
 804910e:	9a0a      	ldr	r2, [sp, #40]	@ 0x28
 8049110:	45e0      	cmp	r8, ip
 8049112:	eb03 0b02 	add.w	fp, r3, r2
 8049116:	9902      	ldr	r1, [sp, #8]
 8049118:	4633      	mov	r3, r6
 804911a:	f000 8107 	beq.w	804932c <kad_op_conv2d+0xe64>
 804911e:	440e      	add	r6, r1
 8049120:	e7e4      	b.n	80490ec <kad_op_conv2d+0xc24>
		for (j = 0; j < d[1]; ++j)
 8049122:	3201      	adds	r2, #1
 8049124:	4572      	cmp	r2, lr
 8049126:	4445      	add	r5, r8
 8049128:	d1c6      	bne.n	80490b8 <kad_op_conv2d+0xbf0>
	for (i = 0; i < d[0]; ++i)
 804912a:	9a07      	ldr	r2, [sp, #28]
 804912c:	f10c 0c01 	add.w	ip, ip, #1
 8049130:	4562      	cmp	r2, ip
 8049132:	4474      	add	r4, lr
 8049134:	4440      	add	r0, r8
 8049136:	d1b7      	bne.n	80490a8 <kad_op_conv2d+0xbe0>
				conv2d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _ww, _xx));
 8049138:	463d      	mov	r5, r7
 804913a:	464f      	mov	r7, r9
 804913c:	46d9      	mov	r9, fp
 804913e:	469b      	mov	fp, r3
 8049140:	f8d9 3014 	ldr.w	r3, [r9, #20]
 8049144:	f8d9 4010 	ldr.w	r4, [r9, #16]
 8049148:	461a      	mov	r2, r3
 804914a:	9304      	str	r3, [sp, #16]
 804914c:	f8db 3014 	ldr.w	r3, [fp, #20]
 8049150:	2c00      	cmp	r4, #0
 8049152:	fb02 f303 	mul.w	r3, r2, r3
 8049156:	f8dd 802c 	ldr.w	r8, [sp, #44]	@ 0x2c
 804915a:	f340 80ca 	ble.w	80492f2 <kad_op_conv2d+0xe2a>
 804915e:	009b      	lsls	r3, r3, #2
 8049160:	4618      	mov	r0, r3
 8049162:	f04f 0e00 	mov.w	lr, #0
 8049166:	9912      	ldr	r1, [sp, #72]	@ 0x48
 8049168:	9b05      	ldr	r3, [sp, #20]
 804916a:	f8cd b008 	str.w	fp, [sp, #8]
 804916e:	fb03 f301 	mul.w	r3, r3, r1
 8049172:	009a      	lsls	r2, r3, #2
 8049174:	9616      	str	r6, [sp, #88]	@ 0x58
 8049176:	008b      	lsls	r3, r1, #2
 8049178:	46f3      	mov	fp, lr
 804917a:	4639      	mov	r1, r7
 804917c:	4616      	mov	r6, r2
 804917e:	462f      	mov	r7, r5
 8049180:	4645      	mov	r5, r8
 8049182:	4680      	mov	r8, r0
 8049184:	9311      	str	r3, [sp, #68]	@ 0x44
 8049186:	f8cd 9028 	str.w	r9, [sp, #40]	@ 0x28
 804918a:	2300      	movs	r3, #0
 804918c:	f8cd b050 	str.w	fp, [sp, #80]	@ 0x50
 8049190:	46ab      	mov	fp, r5
 8049192:	f8dd 9024 	ldr.w	r9, [sp, #36]	@ 0x24
 8049196:	9306      	str	r3, [sp, #24]
 8049198:	9417      	str	r4, [sp, #92]	@ 0x5c
				conv2d_loop1(q->g, w->x, p->g, t, process_row_back_x);
 804919a:	f8da 3018 	ldr.w	r3, [sl, #24]
				conv2d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _ww, _xx));
 804919e:	9a02      	ldr	r2, [sp, #8]
 80491a0:	2b00      	cmp	r3, #0
 80491a2:	6890      	ldr	r0, [r2, #8]
				conv2d_loop1(q->g, w->x, p->g, t, process_row_back_x);
 80491a4:	930f      	str	r3, [sp, #60]	@ 0x3c
 80491a6:	f340 808b 	ble.w	80492c0 <kad_op_conv2d+0xdf8>
 80491aa:	9b05      	ldr	r3, [sp, #20]
 80491ac:	4632      	mov	r2, r6
 80491ae:	eba3 0c00 	sub.w	ip, r3, r0
 80491b2:	463b      	mov	r3, r7
 80491b4:	464c      	mov	r4, r9
 80491b6:	4667      	mov	r7, ip
 80491b8:	465e      	mov	r6, fp
 80491ba:	469c      	mov	ip, r3
 80491bc:	4245      	negs	r5, r0
 80491be:	f8cd 9060 	str.w	r9, [sp, #96]	@ 0x60
				conv2d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _ww, _xx));
 80491c2:	2d00      	cmp	r5, #0
 80491c4:	46a9      	mov	r9, r5
 80491c6:	db71      	blt.n	80492ac <kad_op_conv2d+0xde4>
 80491c8:	970e      	str	r7, [sp, #56]	@ 0x38
 80491ca:	f04f 0b00 	mov.w	fp, #0
 80491ce:	4613      	mov	r3, r2
 80491d0:	4667      	mov	r7, ip
 80491d2:	910b      	str	r1, [sp, #44]	@ 0x2c
 80491d4:	950d      	str	r5, [sp, #52]	@ 0x34
 80491d6:	9400      	str	r4, [sp, #0]
 80491d8:	9a0a      	ldr	r2, [sp, #40]	@ 0x28
 80491da:	6991      	ldr	r1, [r2, #24]
 80491dc:	4549      	cmp	r1, r9
 80491de:	dd5f      	ble.n	80492a0 <kad_op_conv2d+0xdd8>
 80491e0:	9814      	ldr	r0, [sp, #80]	@ 0x50
 80491e2:	9d06      	ldr	r5, [sp, #24]
 80491e4:	f8da 2014 	ldr.w	r2, [sl, #20]
 80491e8:	fb00 9101 	mla	r1, r0, r1, r9
 80491ec:	fb02 5200 	mla	r2, r2, r0, r5
 80491f0:	980f      	ldr	r0, [sp, #60]	@ 0x3c
 80491f2:	9d04      	ldr	r5, [sp, #16]
 80491f4:	fb00 b002 	mla	r0, r0, r2, fp
 80491f8:	9a0a      	ldr	r2, [sp, #40]	@ 0x28
 80491fa:	f8da 402c 	ldr.w	r4, [sl, #44]	@ 0x2c
 80491fe:	69d2      	ldr	r2, [r2, #28]
 8049200:	fb02 f101 	mul.w	r1, r2, r1
 8049204:	fb05 f101 	mul.w	r1, r5, r1
 8049208:	9d0c      	ldr	r5, [sp, #48]	@ 0x30
 804920a:	eb05 0181 	add.w	r1, r5, r1, lsl #2
 804920e:	f8da 501c 	ldr.w	r5, [sl, #28]
 8049212:	fb05 f000 	mul.w	r0, r5, r0
 8049216:	eb04 0080 	add.w	r0, r4, r0, lsl #2
 804921a:	9015      	str	r0, [sp, #84]	@ 0x54
 804921c:	9801      	ldr	r0, [sp, #4]
 804921e:	b178      	cbz	r0, 8049240 <kad_op_conv2d+0xd78>
 8049220:	9c02      	ldr	r4, [sp, #8]
 8049222:	9319      	str	r3, [sp, #100]	@ 0x64
 8049224:	69a0      	ldr	r0, [r4, #24]
 8049226:	9b04      	ldr	r3, [sp, #16]
 8049228:	9c01      	ldr	r4, [sp, #4]
 804922a:	fb03 f202 	mul.w	r2, r3, r2
 804922e:	fb03 f000 	mul.w	r0, r3, r0
 8049232:	0092      	lsls	r2, r2, #2
 8049234:	eb04 0080 	add.w	r0, r4, r0, lsl #2
 8049238:	f002 febd 	bl	804bfb6 <memcpy>
 804923c:	4621      	mov	r1, r4
 804923e:	9b19      	ldr	r3, [sp, #100]	@ 0x64
 8049240:	2d00      	cmp	r5, #0
 8049242:	dd22      	ble.n	804928a <kad_op_conv2d+0xdc2>
 8049244:	9a12      	ldr	r2, [sp, #72]	@ 0x48
 8049246:	2a00      	cmp	r2, #0
 8049248:	dd1f      	ble.n	804928a <kad_op_conv2d+0xdc2>
 804924a:	f04f 0c00 	mov.w	ip, #0
 804924e:	9a11      	ldr	r2, [sp, #68]	@ 0x44
 8049250:	9c00      	ldr	r4, [sp, #0]
 8049252:	f8dd e054 	ldr.w	lr, [sp, #84]	@ 0x54
 8049256:	1888      	adds	r0, r1, r2
 8049258:	f8cd b054 	str.w	fp, [sp, #84]	@ 0x54
 804925c:	ecfe 6a01 	vldmia	lr!, {s13}
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 8049260:	460a      	mov	r2, r1
				conv2d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _ww, _xx));
 8049262:	46a3      	mov	fp, r4
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 8049264:	edd2 7a00 	vldr	s15, [r2]
 8049268:	ecbb 7a01 	vldmia	fp!, {s14}
 804926c:	eee6 7a87 	vfma.f32	s15, s13, s14
 8049270:	ece2 7a01 	vstmia	r2!, {s15}
 8049274:	4282      	cmp	r2, r0
 8049276:	d1f5      	bne.n	8049264 <kad_op_conv2d+0xd9c>
				conv2d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _ww, _xx));
 8049278:	f10c 0c01 	add.w	ip, ip, #1
 804927c:	4565      	cmp	r5, ip
 804927e:	4441      	add	r1, r8
 8049280:	4440      	add	r0, r8
 8049282:	d1eb      	bne.n	804925c <kad_op_conv2d+0xd94>
 8049284:	f8dd b054 	ldr.w	fp, [sp, #84]	@ 0x54
 8049288:	9400      	str	r4, [sp, #0]
 804928a:	9a02      	ldr	r2, [sp, #8]
 804928c:	f10b 0b01 	add.w	fp, fp, #1
 8049290:	6852      	ldr	r2, [r2, #4]
 8049292:	4491      	add	r9, r2
 8049294:	9a0f      	ldr	r2, [sp, #60]	@ 0x3c
 8049296:	4593      	cmp	fp, r2
 8049298:	d002      	beq.n	80492a0 <kad_op_conv2d+0xdd8>
 804929a:	f1b9 0f00 	cmp.w	r9, #0
 804929e:	da9b      	bge.n	80491d8 <kad_op_conv2d+0xd10>
 80492a0:	461a      	mov	r2, r3
 80492a2:	46bc      	mov	ip, r7
 80492a4:	990b      	ldr	r1, [sp, #44]	@ 0x2c
 80492a6:	9d0d      	ldr	r5, [sp, #52]	@ 0x34
 80492a8:	9c00      	ldr	r4, [sp, #0]
 80492aa:	9f0e      	ldr	r7, [sp, #56]	@ 0x38
 80492ac:	9b11      	ldr	r3, [sp, #68]	@ 0x44
 80492ae:	3501      	adds	r5, #1
 80492b0:	42bd      	cmp	r5, r7
 80492b2:	441c      	add	r4, r3
 80492b4:	d185      	bne.n	80491c2 <kad_op_conv2d+0xcfa>
 80492b6:	46b3      	mov	fp, r6
 80492b8:	4667      	mov	r7, ip
 80492ba:	4616      	mov	r6, r2
 80492bc:	f8dd 9060 	ldr.w	r9, [sp, #96]	@ 0x60
 80492c0:	9b06      	ldr	r3, [sp, #24]
 80492c2:	9a07      	ldr	r2, [sp, #28]
 80492c4:	3301      	adds	r3, #1
 80492c6:	429a      	cmp	r2, r3
 80492c8:	9306      	str	r3, [sp, #24]
 80492ca:	44b1      	add	r9, r6
 80492cc:	f47f af65 	bne.w	804919a <kad_op_conv2d+0xcd2>
 80492d0:	465d      	mov	r5, fp
 80492d2:	f8dd b050 	ldr.w	fp, [sp, #80]	@ 0x50
 80492d6:	9c17      	ldr	r4, [sp, #92]	@ 0x5c
 80492d8:	f10b 0b01 	add.w	fp, fp, #1
 80492dc:	455c      	cmp	r4, fp
 80492de:	f47f af54 	bne.w	804918a <kad_op_conv2d+0xcc2>
 80492e2:	46a8      	mov	r8, r5
 80492e4:	463d      	mov	r5, r7
 80492e6:	460f      	mov	r7, r1
 80492e8:	f8dd b008 	ldr.w	fp, [sp, #8]
 80492ec:	f8dd 9028 	ldr.w	r9, [sp, #40]	@ 0x28
 80492f0:	9e16      	ldr	r6, [sp, #88]	@ 0x58
				conv2d_add_3to1(q->d, q1, q->g);
 80492f2:	990c      	ldr	r1, [sp, #48]	@ 0x30
 80492f4:	f8d9 202c 	ldr.w	r2, [r9, #44]	@ 0x2c
 80492f8:	f109 0010 	add.w	r0, r9, #16
 80492fc:	f7f9 fd3c 	bl	8042d78 <conv2d_add_3to1>
 8049300:	e64e      	b.n	8048fa0 <kad_op_conv2d+0xad8>
 8049302:	2204      	movs	r2, #4
 8049304:	e6aa      	b.n	804905c <kad_op_conv2d+0xb94>
				conv2d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _ww, _xx));
 8049306:	f8d9 3014 	ldr.w	r3, [r9, #20]
 804930a:	f8d9 4010 	ldr.w	r4, [r9, #16]
 804930e:	461a      	mov	r2, r3
 8049310:	9304      	str	r3, [sp, #16]
 8049312:	f8db 3014 	ldr.w	r3, [fp, #20]
 8049316:	2c00      	cmp	r4, #0
 8049318:	fb02 f303 	mul.w	r3, r2, r3
 804931c:	dde9      	ble.n	80492f2 <kad_op_conv2d+0xe2a>
 804931e:	009b      	lsls	r3, r3, #2
 8049320:	4618      	mov	r0, r3
 8049322:	9b05      	ldr	r3, [sp, #20]
 8049324:	2b00      	cmp	r3, #0
 8049326:	f73f af1c 	bgt.w	8049162 <kad_op_conv2d+0xc9a>
 804932a:	e7e2      	b.n	80492f2 <kad_op_conv2d+0xe2a>
		for (j = 0; j < d[1]; ++j)
 804932c:	9a15      	ldr	r2, [sp, #84]	@ 0x54
 804932e:	4445      	add	r5, r8
 8049330:	3201      	adds	r2, #1
 8049332:	4596      	cmp	lr, r2
 8049334:	f47f aeca 	bne.w	80490cc <kad_op_conv2d+0xc04>
 8049338:	e9dd 3b0d 	ldrd	r3, fp, [sp, #52]	@ 0x34
 804933c:	464c      	mov	r4, r9
 804933e:	9e0f      	ldr	r6, [sp, #60]	@ 0x3c
 8049340:	f8dd c044 	ldr.w	ip, [sp, #68]	@ 0x44
 8049344:	f8dd 9050 	ldr.w	r9, [sp, #80]	@ 0x50
 8049348:	e6ef      	b.n	804912a <kad_op_conv2d+0xc62>
			if (!algo_switch) {
 804934a:	2f00      	cmp	r7, #0
 804934c:	f47f ae6d 	bne.w	804902a <kad_op_conv2d+0xb62>
				conv2d_loop1(q->g, w->x, p->g, t, process_row_back_x);
 8049350:	f8d9 3010 	ldr.w	r3, [r9, #16]
 8049354:	2b00      	cmp	r3, #0
 8049356:	dd08      	ble.n	804936a <kad_op_conv2d+0xea2>
 8049358:	9b07      	ldr	r3, [sp, #28]
 804935a:	2b00      	cmp	r3, #0
 804935c:	dd05      	ble.n	804936a <kad_op_conv2d+0xea2>
 804935e:	2900      	cmp	r1, #0
 8049360:	dd03      	ble.n	804936a <kad_op_conv2d+0xea2>
 8049362:	9b05      	ldr	r3, [sp, #20]
 8049364:	2b00      	cmp	r3, #0
 8049366:	f73f ad10 	bgt.w	8048d8a <kad_op_conv2d+0x8c2>
		if (kad_is_back(p->child[1])) { /* backprop to the weight matrix */
 804936a:	7873      	ldrb	r3, [r6, #1]
 804936c:	07db      	lsls	r3, r3, #31
 804936e:	f57f a8c0 	bpl.w	80484f2 <kad_op_conv2d+0x2a>
			conv_rot180(w->d[0] * w->d[1], w->d[2] * w->d[3], w->g);
 8049372:	f8d6 802c 	ldr.w	r8, [r6, #44]	@ 0x2c
			if (!algo_switch) {
 8049376:	2f00      	cmp	r7, #0
 8049378:	f040 8150 	bne.w	804961c <kad_op_conv2d+0x1154>
				conv2d_loop1(q->x, w->g, p->g, t, process_row_back_w);
 804937c:	f8d9 3010 	ldr.w	r3, [r9, #16]
 8049380:	2b00      	cmp	r3, #0
 8049382:	dc09      	bgt.n	8049398 <kad_op_conv2d+0xed0>
 8049384:	f7ff b8b5 	b.w	80484f2 <kad_op_conv2d+0x2a>
				conv2d_loop1(q->g, w->x, p->g, t, process_row_back_x);
 8049388:	f8d9 3010 	ldr.w	r3, [r9, #16]
			if (!algo_switch) {
 804938c:	2f00      	cmp	r7, #0
 804938e:	f040 8145 	bne.w	804961c <kad_op_conv2d+0x1154>
				conv2d_loop1(q->x, w->g, p->g, t, process_row_back_w);
 8049392:	2b00      	cmp	r3, #0
 8049394:	f77f a8ad 	ble.w	80484f2 <kad_op_conv2d+0x2a>
 8049398:	9b07      	ldr	r3, [sp, #28]
 804939a:	2b00      	cmp	r3, #0
 804939c:	f340 80f7 	ble.w	804958e <kad_op_conv2d+0x10c6>
 80493a0:	9b08      	ldr	r3, [sp, #32]
 80493a2:	2b00      	cmp	r3, #0
 80493a4:	f340 80f3 	ble.w	804958e <kad_op_conv2d+0x10c6>
 80493a8:	9805      	ldr	r0, [sp, #20]
 80493aa:	2800      	cmp	r0, #0
 80493ac:	f340 80ef 	ble.w	804958e <kad_op_conv2d+0x10c6>
 80493b0:	9a03      	ldr	r2, [sp, #12]
 80493b2:	4646      	mov	r6, r8
 80493b4:	0093      	lsls	r3, r2, #2
 80493b6:	ebc2 7242 	rsb	r2, r2, r2, lsl #29
 80493ba:	00d1      	lsls	r1, r2, #3
 80493bc:	2200      	movs	r2, #0
 80493be:	468c      	mov	ip, r1
 80493c0:	fb03 f700 	mul.w	r7, r3, r0
 80493c4:	f8cd a054 	str.w	sl, [sp, #84]	@ 0x54
 80493c8:	46ca      	mov	sl, r9
 80493ca:	f8dd 9040 	ldr.w	r9, [sp, #64]	@ 0x40
 80493ce:	9206      	str	r2, [sp, #24]
 80493d0:	2400      	movs	r4, #0
 80493d2:	f8dd 8014 	ldr.w	r8, [sp, #20]
 80493d6:	940a      	str	r4, [sp, #40]	@ 0x28
 80493d8:	fb08 f204 	mul.w	r2, r8, r4
 80493dc:	fb03 6202 	mla	r2, r3, r2, r6
 80493e0:	2100      	movs	r1, #0
 80493e2:	441a      	add	r2, r3
 80493e4:	e9cd 6416 	strd	r6, r4, [sp, #88]	@ 0x58
 80493e8:	4614      	mov	r4, r2
 80493ea:	461a      	mov	r2, r3
 80493ec:	46c6      	mov	lr, r8
 80493ee:	f8dd 8054 	ldr.w	r8, [sp, #84]	@ 0x54
 80493f2:	910b      	str	r1, [sp, #44]	@ 0x2c
 80493f4:	9714      	str	r7, [sp, #80]	@ 0x50
 80493f6:	9518      	str	r5, [sp, #96]	@ 0x60
				conv2d_loop1(q->g, w->x, p->g, t, process_row_back_x);
 80493f8:	f8d8 3018 	ldr.w	r3, [r8, #24]
 80493fc:	4619      	mov	r1, r3
 80493fe:	2900      	cmp	r1, #0
 8049400:	9302      	str	r3, [sp, #8]
				conv2d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _ww, _xx));
 8049402:	f8db 3008 	ldr.w	r3, [fp, #8]
 8049406:	f340 80a1 	ble.w	804954c <kad_op_conv2d+0x1084>
 804940a:	425d      	negs	r5, r3
 804940c:	ebae 0303 	sub.w	r3, lr, r3
				conv2d_loop1(q->g, w->x, p->g, t, process_row_back_x);
 8049410:	4627      	mov	r7, r4
 8049412:	e9cd e419 	strd	lr, r4, [sp, #100]	@ 0x64
 8049416:	4666      	mov	r6, ip
 8049418:	462c      	mov	r4, r5
 804941a:	4615      	mov	r5, r2
 804941c:	461a      	mov	r2, r3
				conv2d_loop1(q->x, w->g, p->g, t, process_row_back_w);
 804941e:	1b79      	subs	r1, r7, r5
 8049420:	2c00      	cmp	r4, #0
 8049422:	4623      	mov	r3, r4
 8049424:	910d      	str	r1, [sp, #52]	@ 0x34
 8049426:	f2c0 8086 	blt.w	8049536 <kad_op_conv2d+0x106e>
 804942a:	2100      	movs	r1, #0
 804942c:	e9cd 4511 	strd	r4, r5, [sp, #68]	@ 0x44
 8049430:	9100      	str	r1, [sp, #0]
				conv2d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _ww, _xx));
 8049432:	f8da 1018 	ldr.w	r1, [sl, #24]
 8049436:	920f      	str	r2, [sp, #60]	@ 0x3c
 8049438:	9104      	str	r1, [sp, #16]
 804943a:	9613      	str	r6, [sp, #76]	@ 0x4c
				conv2d_loop1(q->x, w->g, p->g, t, process_row_back_w);
 804943c:	9a04      	ldr	r2, [sp, #16]
 804943e:	4293      	cmp	r3, r2
 8049440:	da75      	bge.n	804952e <kad_op_conv2d+0x1066>
 8049442:	9906      	ldr	r1, [sp, #24]
 8049444:	f8da 2014 	ldr.w	r2, [sl, #20]
 8049448:	980b      	ldr	r0, [sp, #44]	@ 0x2c
 804944a:	f8d8 401c 	ldr.w	r4, [r8, #28]
 804944e:	fb02 0501 	mla	r5, r2, r1, r0
 8049452:	9a04      	ldr	r2, [sp, #16]
 8049454:	980a      	ldr	r0, [sp, #40]	@ 0x28
 8049456:	fb02 3505 	mla	r5, r2, r5, r3
 804945a:	f8d8 2014 	ldr.w	r2, [r8, #20]
 804945e:	fb02 0001 	mla	r0, r2, r1, r0
 8049462:	9a00      	ldr	r2, [sp, #0]
 8049464:	9902      	ldr	r1, [sp, #8]
 8049466:	fb01 2000 	mla	r0, r1, r0, r2
 804946a:	f8da 201c 	ldr.w	r2, [sl, #28]
 804946e:	fb04 f000 	mul.w	r0, r4, r0
 8049472:	fb02 f505 	mul.w	r5, r2, r5
 8049476:	f8da 1028 	ldr.w	r1, [sl, #40]	@ 0x28
 804947a:	eb01 0185 	add.w	r1, r1, r5, lsl #2
 804947e:	f8d8 502c 	ldr.w	r5, [r8, #44]	@ 0x2c
 8049482:	eb05 0580 	add.w	r5, r5, r0, lsl #2
 8049486:	9801      	ldr	r0, [sp, #4]
 8049488:	b150      	cbz	r0, 80494a0 <kad_op_conv2d+0xfd8>
 804948a:	f8db 6018 	ldr.w	r6, [fp, #24]
 804948e:	0092      	lsls	r2, r2, #2
 8049490:	eb00 0686 	add.w	r6, r0, r6, lsl #2
 8049494:	4630      	mov	r0, r6
 8049496:	930e      	str	r3, [sp, #56]	@ 0x38
 8049498:	f002 fd8d 	bl	804bfb6 <memcpy>
 804949c:	4631      	mov	r1, r6
 804949e:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
 80494a0:	f8db 2014 	ldr.w	r2, [fp, #20]
 80494a4:	2a01      	cmp	r2, #1
 80494a6:	f340 8093 	ble.w	80495d0 <kad_op_conv2d+0x1108>
 80494aa:	9803      	ldr	r0, [sp, #12]
 80494ac:	2800      	cmp	r0, #0
 80494ae:	dd31      	ble.n	8049514 <kad_op_conv2d+0x104c>
 80494b0:	f8db 0018 	ldr.w	r0, [fp, #24]
 80494b4:	f8dd c034 	ldr.w	ip, [sp, #52]	@ 0x34
 80494b8:	ebc0 7080 	rsb	r0, r0, r0, lsl #30
 80494bc:	eb01 0680 	add.w	r6, r1, r0, lsl #2
 80494c0:	0092      	lsls	r2, r2, #2
 80494c2:	eb09 0084 	add.w	r0, r9, r4, lsl #2
 80494c6:	eb05 0184 	add.w	r1, r5, r4, lsl #2
 80494ca:	f8cd b038 	str.w	fp, [sp, #56]	@ 0x38
 80494ce:	2c00      	cmp	r4, #0
 80494d0:	46b6      	mov	lr, r6
 80494d2:	dd7a      	ble.n	80495ca <kad_op_conv2d+0x1102>
 80494d4:	46cb      	mov	fp, r9
 80494d6:	edde 7a00 	vldr	s15, [lr]
 80494da:	eceb 7a01 	vstmia	fp!, {s15}
 80494de:	4558      	cmp	r0, fp
 80494e0:	4496      	add	lr, r2
 80494e2:	d1f8      	bne.n	80494d6 <kad_op_conv2d+0x100e>
	float s = 0.;
 80494e4:	eddf 7a7b 	vldr	s15, [pc, #492]	@ 80496d4 <kad_op_conv2d+0x120c>
 80494e8:	46cb      	mov	fp, r9
 80494ea:	46ae      	mov	lr, r5
	for (i = 0; i < n; ++i) s += x[i] * y[i];
 80494ec:	ecfe 6a01 	vldmia	lr!, {s13}
 80494f0:	ecbb 7a01 	vldmia	fp!, {s14}
 80494f4:	4571      	cmp	r1, lr
 80494f6:	eee6 7a87 	vfma.f32	s15, s13, s14
 80494fa:	d1f7      	bne.n	80494ec <kad_op_conv2d+0x1024>
				conv2d_loop1(q->x, w->g, p->g, t, process_row_back_w);
 80494fc:	ed9c 7a00 	vldr	s14, [ip]
 8049500:	ee77 7a27 	vadd.f32	s15, s14, s15
 8049504:	ecec 7a01 	vstmia	ip!, {s15}
 8049508:	4567      	cmp	r7, ip
 804950a:	f106 0604 	add.w	r6, r6, #4
 804950e:	d1de      	bne.n	80494ce <kad_op_conv2d+0x1006>
 8049510:	f8dd b038 	ldr.w	fp, [sp, #56]	@ 0x38
 8049514:	9a00      	ldr	r2, [sp, #0]
 8049516:	3201      	adds	r2, #1
 8049518:	4611      	mov	r1, r2
 804951a:	9200      	str	r2, [sp, #0]
 804951c:	f8db 2004 	ldr.w	r2, [fp, #4]
 8049520:	4413      	add	r3, r2
 8049522:	460a      	mov	r2, r1
 8049524:	9902      	ldr	r1, [sp, #8]
 8049526:	428a      	cmp	r2, r1
 8049528:	d001      	beq.n	804952e <kad_op_conv2d+0x1066>
 804952a:	2b00      	cmp	r3, #0
 804952c:	da86      	bge.n	804943c <kad_op_conv2d+0xf74>
 804952e:	9a0f      	ldr	r2, [sp, #60]	@ 0x3c
 8049530:	9e13      	ldr	r6, [sp, #76]	@ 0x4c
 8049532:	e9dd 4511 	ldrd	r4, r5, [sp, #68]	@ 0x44
 8049536:	9b0d      	ldr	r3, [sp, #52]	@ 0x34
 8049538:	3401      	adds	r4, #1
 804953a:	42a2      	cmp	r2, r4
 804953c:	eba3 0706 	sub.w	r7, r3, r6
 8049540:	f47f af6d 	bne.w	804941e <kad_op_conv2d+0xf56>
 8049544:	e9dd e419 	ldrd	lr, r4, [sp, #100]	@ 0x64
 8049548:	462a      	mov	r2, r5
 804954a:	46b4      	mov	ip, r6
 804954c:	9914      	ldr	r1, [sp, #80]	@ 0x50
 804954e:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 8049550:	440c      	add	r4, r1
 8049552:	9908      	ldr	r1, [sp, #32]
 8049554:	3301      	adds	r3, #1
 8049556:	4299      	cmp	r1, r3
 8049558:	930b      	str	r3, [sp, #44]	@ 0x2c
 804955a:	f47f af4d 	bne.w	80493f8 <kad_op_conv2d+0xf30>
 804955e:	e9dd 6416 	ldrd	r6, r4, [sp, #88]	@ 0x58
 8049562:	4613      	mov	r3, r2
 8049564:	9a0a      	ldr	r2, [sp, #40]	@ 0x28
 8049566:	440c      	add	r4, r1
 8049568:	9907      	ldr	r1, [sp, #28]
 804956a:	3201      	adds	r2, #1
 804956c:	428a      	cmp	r2, r1
 804956e:	46f0      	mov	r8, lr
 8049570:	9f14      	ldr	r7, [sp, #80]	@ 0x50
 8049572:	9d18      	ldr	r5, [sp, #96]	@ 0x60
 8049574:	920a      	str	r2, [sp, #40]	@ 0x28
 8049576:	f47f af2f 	bne.w	80493d8 <kad_op_conv2d+0xf10>
 804957a:	9a06      	ldr	r2, [sp, #24]
 804957c:	3201      	adds	r2, #1
 804957e:	4611      	mov	r1, r2
 8049580:	9206      	str	r2, [sp, #24]
 8049582:	f8da 2010 	ldr.w	r2, [sl, #16]
 8049586:	428a      	cmp	r2, r1
 8049588:	f73f af22 	bgt.w	80493d0 <kad_op_conv2d+0xf08>
 804958c:	46b0      	mov	r8, r6
	for (i = 0; i < d0; ++i) {
 804958e:	2d00      	cmp	r5, #0
 8049590:	f77e afaf 	ble.w	80484f2 <kad_op_conv2d+0x2a>
		for (j = 0; j < d1>>1; ++j)
 8049594:	9a1c      	ldr	r2, [sp, #112]	@ 0x70
 8049596:	1053      	asrs	r3, r2, #1
 8049598:	2b00      	cmp	r3, #0
 804959a:	f77e afaa 	ble.w	80484f2 <kad_op_conv2d+0x2a>
 804959e:	ea4f 0c82 	mov.w	ip, r2, lsl #2
 80495a2:	4641      	mov	r1, r8
				conv2d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _xx, _ww));
 80495a4:	2000      	movs	r0, #0
 80495a6:	009b      	lsls	r3, r3, #2
		for (j = 0; j < d1>>1; ++j)
 80495a8:	460a      	mov	r2, r1
 80495aa:	4461      	add	r1, ip
				conv2d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _xx, _ww));
 80495ac:	460c      	mov	r4, r1
 80495ae:	18d6      	adds	r6, r2, r3
			tmp = xi[j], xi[j] = xi[d1-1-j], xi[d1-1-j] = tmp; 
 80495b0:	f854 ed04 	ldr.w	lr, [r4, #-4]!
 80495b4:	6817      	ldr	r7, [r2, #0]
 80495b6:	f842 eb04 	str.w	lr, [r2], #4
		for (j = 0; j < d1>>1; ++j)
 80495ba:	4296      	cmp	r6, r2
			tmp = xi[j], xi[j] = xi[d1-1-j], xi[d1-1-j] = tmp; 
 80495bc:	6027      	str	r7, [r4, #0]
		for (j = 0; j < d1>>1; ++j)
 80495be:	d1f7      	bne.n	80495b0 <kad_op_conv2d+0x10e8>
	for (i = 0; i < d0; ++i) {
 80495c0:	3001      	adds	r0, #1
 80495c2:	4285      	cmp	r5, r0
 80495c4:	d1f0      	bne.n	80495a8 <kad_op_conv2d+0x10e0>
 80495c6:	f7fe bf94 	b.w	80484f2 <kad_op_conv2d+0x2a>
	float s = 0.;
 80495ca:	eddf 7a42 	vldr	s15, [pc, #264]	@ 80496d4 <kad_op_conv2d+0x120c>
 80495ce:	e795      	b.n	80494fc <kad_op_conv2d+0x1034>
				conv2d_loop1(q->x, w->g, p->g, t, process_row_back_w);
 80495d0:	9a03      	ldr	r2, [sp, #12]
 80495d2:	2a00      	cmp	r2, #0
 80495d4:	dd9e      	ble.n	8049514 <kad_op_conv2d+0x104c>
 80495d6:	f8db 2018 	ldr.w	r2, [fp, #24]
 80495da:	9e0d      	ldr	r6, [sp, #52]	@ 0x34
 80495dc:	ebc2 7282 	rsb	r2, r2, r2, lsl #30
 80495e0:	ea4f 0e82 	mov.w	lr, r2, lsl #2
 80495e4:	eb05 0c84 	add.w	ip, r5, r4, lsl #2
	for (i = 0; i < n; ++i) s += x[i] * y[i];
 80495e8:	2c00      	cmp	r4, #0
	float s = 0.;
 80495ea:	eddf 7a3a 	vldr	s15, [pc, #232]	@ 80496d4 <kad_op_conv2d+0x120c>
	for (i = 0; i < n; ++i) s += x[i] * y[i];
 80495ee:	dd0a      	ble.n	8049606 <kad_op_conv2d+0x113e>
 80495f0:	462a      	mov	r2, r5
 80495f2:	eb01 000e 	add.w	r0, r1, lr
 80495f6:	ecf2 6a01 	vldmia	r2!, {s13}
 80495fa:	ecb0 7a01 	vldmia	r0!, {s14}
 80495fe:	4594      	cmp	ip, r2
 8049600:	eee6 7a87 	vfma.f32	s15, s13, s14
 8049604:	d1f7      	bne.n	80495f6 <kad_op_conv2d+0x112e>
				conv2d_loop1(q->x, w->g, p->g, t, process_row_back_w);
 8049606:	ed96 7a00 	vldr	s14, [r6]
 804960a:	ee77 7a27 	vadd.f32	s15, s14, s15
 804960e:	ece6 7a01 	vstmia	r6!, {s15}
 8049612:	42b7      	cmp	r7, r6
 8049614:	f10e 0e04 	add.w	lr, lr, #4
 8049618:	d1e6      	bne.n	80495e8 <kad_op_conv2d+0x1120>
 804961a:	e77b      	b.n	8049514 <kad_op_conv2d+0x104c>
	for (i = 0; i < d[0]; ++i)
 804961c:	f8d9 3010 	ldr.w	r3, [r9, #16]
				conv2d_move_1to3(q->d, q->x, q1);
 8049620:	f8d9 2028 	ldr.w	r2, [r9, #40]	@ 0x28
	for (i = 0; i < d[0]; ++i)
 8049624:	2b00      	cmp	r3, #0
 8049626:	9304      	str	r3, [sp, #16]
				conv2d_move_1to3(q->d, q->x, q1);
 8049628:	9202      	str	r2, [sp, #8]
	for (i = 0; i < d[0]; ++i)
 804962a:	f340 8192 	ble.w	8049952 <kad_op_conv2d+0x148a>
		for (j = 0; j < d[1]; ++j)
 804962e:	f8d9 7014 	ldr.w	r7, [r9, #20]
 8049632:	2f00      	cmp	r7, #0
 8049634:	dd5a      	ble.n	80496ec <kad_op_conv2d+0x1224>
			for (k = 0; k < d[2]; ++k) {
 8049636:	f04f 0c00 	mov.w	ip, #0
	for (i = 0; i < d[0]; ++i)
 804963a:	46e6      	mov	lr, ip
 804963c:	00bb      	lsls	r3, r7, #2
			for (k = 0; k < d[2]; ++k) {
 804963e:	f8d9 0018 	ldr.w	r0, [r9, #24]
 8049642:	930b      	str	r3, [sp, #44]	@ 0x2c
		for (j = 0; j < d[1]; ++j)
 8049644:	2800      	cmp	r0, #0
				int ik = (i * d[2] + k) * d[3], ijk = ((i * d[1] + j) * d[2] + k) * d[3];
 8049646:	fb00 f20e 	mul.w	r2, r0, lr
 804964a:	dd49      	ble.n	80496e0 <kad_op_conv2d+0x1218>
 804964c:	f8d9 301c 	ldr.w	r3, [r9, #28]
 8049650:	fb00 f40c 	mul.w	r4, r0, ip
 8049654:	fb03 f202 	mul.w	r2, r3, r2
 8049658:	fb07 f202 	mul.w	r2, r7, r2
 804965c:	9208      	str	r2, [sp, #32]
 804965e:	fb03 f207 	mul.w	r2, r3, r7
 8049662:	0092      	lsls	r2, r2, #2
 8049664:	920a      	str	r2, [sp, #40]	@ 0x28
		for (j = 0; j < d[1]; ++j)
 8049666:	2200      	movs	r2, #0
 8049668:	0099      	lsls	r1, r3, #2
 804966a:	9106      	str	r1, [sp, #24]
			for (k = 0; k < d[2]; ++k) {
 804966c:	2b00      	cmp	r3, #0
 804966e:	dd33      	ble.n	80496d8 <kad_op_conv2d+0x1210>
 8049670:	e9cd 8c0d 	strd	r8, ip, [sp, #52]	@ 0x34
 8049674:	f8cd b03c 	str.w	fp, [sp, #60]	@ 0x3c
 8049678:	f8cd 9044 	str.w	r9, [sp, #68]	@ 0x44
 804967c:	9600      	str	r6, [sp, #0]
 804967e:	f04f 0900 	mov.w	r9, #0
 8049682:	fb04 fb03 	mul.w	fp, r4, r3
 8049686:	9e08      	ldr	r6, [sp, #32]
 8049688:	990c      	ldr	r1, [sp, #48]	@ 0x30
 804968a:	4416      	add	r6, r2
 804968c:	eb01 0686 	add.w	r6, r1, r6, lsl #2
 8049690:	9902      	ldr	r1, [sp, #8]
 8049692:	eb0b 0c03 	add.w	ip, fp, r3
 8049696:	eb01 088c 	add.w	r8, r1, ip, lsl #2
 804969a:	9900      	ldr	r1, [sp, #0]
 804969c:	9413      	str	r4, [sp, #76]	@ 0x4c
				for (l = 0; l < d[3]; ++l)
 804969e:	9c02      	ldr	r4, [sp, #8]
			for (k = 0; k < d[2]; ++k) {
 80496a0:	9300      	str	r3, [sp, #0]
 80496a2:	eb04 048b 	add.w	r4, r4, fp, lsl #2
 80496a6:	46b3      	mov	fp, r6
					y[(ik + l) * d[1] + j] = x[ijk + l];
 80496a8:	ecf4 7a01 	vldmia	r4!, {s15}
				for (l = 0; l < d[3]; ++l)
 80496ac:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 80496ae:	45a0      	cmp	r8, r4
					y[(ik + l) * d[1] + j] = x[ijk + l];
 80496b0:	edcb 7a00 	vstr	s15, [fp]
				for (l = 0; l < d[3]; ++l)
 80496b4:	449b      	add	fp, r3
 80496b6:	d1f7      	bne.n	80496a8 <kad_op_conv2d+0x11e0>
			for (k = 0; k < d[2]; ++k) {
 80496b8:	9c0a      	ldr	r4, [sp, #40]	@ 0x28
 80496ba:	f109 0901 	add.w	r9, r9, #1
 80496be:	4426      	add	r6, r4
 80496c0:	9c06      	ldr	r4, [sp, #24]
 80496c2:	4581      	cmp	r9, r0
 80496c4:	46e3      	mov	fp, ip
 80496c6:	9b00      	ldr	r3, [sp, #0]
 80496c8:	44a0      	add	r8, r4
 80496ca:	f000 8133 	beq.w	8049934 <kad_op_conv2d+0x146c>
 80496ce:	449c      	add	ip, r3
 80496d0:	e7e5      	b.n	804969e <kad_op_conv2d+0x11d6>
 80496d2:	bf00      	nop
 80496d4:	00000000 	.word	0x00000000
		for (j = 0; j < d[1]; ++j)
 80496d8:	3201      	adds	r2, #1
 80496da:	42ba      	cmp	r2, r7
 80496dc:	4404      	add	r4, r0
 80496de:	d1c5      	bne.n	804966c <kad_op_conv2d+0x11a4>
	for (i = 0; i < d[0]; ++i)
 80496e0:	9b04      	ldr	r3, [sp, #16]
 80496e2:	f10e 0e01 	add.w	lr, lr, #1
 80496e6:	459e      	cmp	lr, r3
 80496e8:	44bc      	add	ip, r7
 80496ea:	d1ab      	bne.n	8049644 <kad_op_conv2d+0x117c>
 80496ec:	7832      	ldrb	r2, [r6, #0]
 80496ee:	4613      	mov	r3, r2
 80496f0:	2a00      	cmp	r2, #0
 80496f2:	f000 8116 	beq.w	8049922 <kad_op_conv2d+0x145a>
 80496f6:	2b01      	cmp	r3, #1
 80496f8:	f000 8111 	beq.w	804991e <kad_op_conv2d+0x1456>
 80496fc:	2b02      	cmp	r3, #2
 80496fe:	462a      	mov	r2, r5
 8049700:	d007      	beq.n	8049712 <kad_op_conv2d+0x124a>
 8049702:	9a05      	ldr	r2, [sp, #20]
 8049704:	2b03      	cmp	r3, #3
 8049706:	fb02 f205 	mul.w	r2, r2, r5
 804970a:	d002      	beq.n	8049712 <kad_op_conv2d+0x124a>
 804970c:	9b03      	ldr	r3, [sp, #12]
 804970e:	fb03 f202 	mul.w	r2, r3, r2
				memset(w1, 0, kad_len(w) * sizeof(float));
 8049712:	0092      	lsls	r2, r2, #2
 8049714:	2100      	movs	r1, #0
 8049716:	9809      	ldr	r0, [sp, #36]	@ 0x24
 8049718:	f002 fb50 	bl	804bdbc <memset>
				conv2d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _xx, _ww));
 804971c:	9a04      	ldr	r2, [sp, #16]
 804971e:	f8d9 7014 	ldr.w	r7, [r9, #20]
 8049722:	f8db 3014 	ldr.w	r3, [fp, #20]
 8049726:	2a00      	cmp	r2, #0
 8049728:	fb07 f303 	mul.w	r3, r7, r3
 804972c:	f340 80ee 	ble.w	804990c <kad_op_conv2d+0x1444>
 8049730:	009a      	lsls	r2, r3, #2
 8049732:	9214      	str	r2, [sp, #80]	@ 0x50
 8049734:	9a07      	ldr	r2, [sp, #28]
 8049736:	2a00      	cmp	r2, #0
 8049738:	f340 80e8 	ble.w	804990c <kad_op_conv2d+0x1444>
 804973c:	9905      	ldr	r1, [sp, #20]
 804973e:	2900      	cmp	r1, #0
 8049740:	f340 80e4 	ble.w	804990c <kad_op_conv2d+0x1444>
 8049744:	00db      	lsls	r3, r3, #3
 8049746:	9315      	str	r3, [sp, #84]	@ 0x54
 8049748:	9b12      	ldr	r3, [sp, #72]	@ 0x48
 804974a:	9718      	str	r7, [sp, #96]	@ 0x60
 804974c:	009a      	lsls	r2, r3, #2
 804974e:	fb02 f101 	mul.w	r1, r2, r1
 8049752:	2300      	movs	r3, #0
 8049754:	4647      	mov	r7, r8
 8049756:	f8cd b00c 	str.w	fp, [sp, #12]
 804975a:	4688      	mov	r8, r1
 804975c:	46d3      	mov	fp, sl
 804975e:	462c      	mov	r4, r5
 8049760:	9300      	str	r3, [sp, #0]
 8049762:	f8cd 903c 	str.w	r9, [sp, #60]	@ 0x3c
 8049766:	4641      	mov	r1, r8
 8049768:	4692      	mov	sl, r2
 804976a:	2000      	movs	r0, #0
 804976c:	463a      	mov	r2, r7
 804976e:	46d8      	mov	r8, fp
 8049770:	9d09      	ldr	r5, [sp, #36]	@ 0x24
				conv2d_loop1(q->g, w->x, p->g, t, process_row_back_x);
 8049772:	f8d8 7018 	ldr.w	r7, [r8, #24]
				conv2d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _ww, _xx));
 8049776:	9b03      	ldr	r3, [sp, #12]
 8049778:	2f00      	cmp	r7, #0
 804977a:	689b      	ldr	r3, [r3, #8]
				conv2d_loop1(q->g, w->x, p->g, t, process_row_back_x);
 804977c:	970e      	str	r7, [sp, #56]	@ 0x38
 804977e:	f340 80b2 	ble.w	80498e6 <kad_op_conv2d+0x141e>
 8049782:	9f05      	ldr	r7, [sp, #20]
 8049784:	f1c3 0b00 	rsb	fp, r3, #0
 8049788:	1afb      	subs	r3, r7, r3
 804978a:	46a9      	mov	r9, r5
 804978c:	e9cd 151a 	strd	r1, r5, [sp, #104]	@ 0x68
 8049790:	eb05 070a 	add.w	r7, r5, sl
 8049794:	461d      	mov	r5, r3
 8049796:	9619      	str	r6, [sp, #100]	@ 0x64
 8049798:	9011      	str	r0, [sp, #68]	@ 0x44
				conv2d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _xx, _ww));
 804979a:	f1bb 0f00 	cmp.w	fp, #0
 804979e:	465e      	mov	r6, fp
 80497a0:	f2c0 8096 	blt.w	80498d0 <kad_op_conv2d+0x1408>
 80497a4:	2100      	movs	r1, #0
				conv2d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _ww, _xx));
 80497a6:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
				conv2d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _xx, _ww));
 80497a8:	9102      	str	r1, [sp, #8]
				conv2d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _ww, _xx));
 80497aa:	699b      	ldr	r3, [r3, #24]
				conv2d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _xx, _ww));
 80497ac:	9900      	ldr	r1, [sp, #0]
				conv2d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _ww, _xx));
 80497ae:	9316      	str	r3, [sp, #88]	@ 0x58
				conv2d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _xx, _ww));
 80497b0:	fb03 f301 	mul.w	r3, r3, r1
 80497b4:	e9cd ba0a 	strd	fp, sl, [sp, #40]	@ 0x28
 80497b8:	940d      	str	r4, [sp, #52]	@ 0x34
 80497ba:	9c14      	ldr	r4, [sp, #80]	@ 0x50
 80497bc:	9313      	str	r3, [sp, #76]	@ 0x4c
 80497be:	9206      	str	r2, [sp, #24]
 80497c0:	9508      	str	r5, [sp, #32]
 80497c2:	9b16      	ldr	r3, [sp, #88]	@ 0x58
 80497c4:	429e      	cmp	r6, r3
 80497c6:	da7e      	bge.n	80498c6 <kad_op_conv2d+0x13fe>
 80497c8:	9a11      	ldr	r2, [sp, #68]	@ 0x44
 80497ca:	9900      	ldr	r1, [sp, #0]
 80497cc:	f8d8 3014 	ldr.w	r3, [r8, #20]
 80497d0:	9818      	ldr	r0, [sp, #96]	@ 0x60
 80497d2:	fb03 2301 	mla	r3, r3, r1, r2
 80497d6:	9a02      	ldr	r2, [sp, #8]
 80497d8:	990e      	ldr	r1, [sp, #56]	@ 0x38
 80497da:	f8d8 a01c 	ldr.w	sl, [r8, #28]
 80497de:	fb01 2303 	mla	r3, r1, r3, r2
 80497e2:	9a0f      	ldr	r2, [sp, #60]	@ 0x3c
 80497e4:	9913      	ldr	r1, [sp, #76]	@ 0x4c
 80497e6:	69d2      	ldr	r2, [r2, #28]
 80497e8:	4431      	add	r1, r6
 80497ea:	fb02 f101 	mul.w	r1, r2, r1
 80497ee:	fb00 f101 	mul.w	r1, r0, r1
 80497f2:	fb0a f303 	mul.w	r3, sl, r3
 80497f6:	9d0c      	ldr	r5, [sp, #48]	@ 0x30
 80497f8:	eb05 0181 	add.w	r1, r5, r1, lsl #2
 80497fc:	f8d8 502c 	ldr.w	r5, [r8, #44]	@ 0x2c
 8049800:	eb05 0583 	add.w	r5, r5, r3, lsl #2
 8049804:	9b01      	ldr	r3, [sp, #4]
 8049806:	b163      	cbz	r3, 8049822 <kad_op_conv2d+0x135a>
 8049808:	9b03      	ldr	r3, [sp, #12]
 804980a:	fb00 f202 	mul.w	r2, r0, r2
 804980e:	699b      	ldr	r3, [r3, #24]
 8049810:	0092      	lsls	r2, r2, #2
 8049812:	fb00 f303 	mul.w	r3, r0, r3
 8049816:	9801      	ldr	r0, [sp, #4]
 8049818:	eb00 0083 	add.w	r0, r0, r3, lsl #2
 804981c:	f002 fbcb 	bl	804bfb6 <memcpy>
 8049820:	9901      	ldr	r1, [sp, #4]
 8049822:	f1ba 0f00 	cmp.w	sl, #0
 8049826:	dd42      	ble.n	80498ae <kad_op_conv2d+0x13e6>
 8049828:	9b12      	ldr	r3, [sp, #72]	@ 0x48
 804982a:	2b00      	cmp	r3, #0
 804982c:	dd3f      	ble.n	80498ae <kad_op_conv2d+0x13e6>
 804982e:	f10a 33ff 	add.w	r3, sl, #4294967295
 8049832:	f1ba 0f02 	cmp.w	sl, #2
 8049836:	9317      	str	r3, [sp, #92]	@ 0x5c
 8049838:	dd6f      	ble.n	804991a <kad_op_conv2d+0x1452>
 804983a:	2301      	movs	r3, #1
 804983c:	f105 0b04 	add.w	fp, r5, #4
 8049840:	eb01 0e04 	add.w	lr, r1, r4
 8049844:	ed5b 5a01 	vldr	s11, [fp, #-4]
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 8049848:	ed95 6a01 	vldr	s12, [r5, #4]
				conv2d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _xx, _ww));
 804984c:	46f4      	mov	ip, lr
 804984e:	4608      	mov	r0, r1
 8049850:	464a      	mov	r2, r9
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 8049852:	edd2 7a00 	vldr	s15, [r2]
 8049856:	ecf0 6a01 	vldmia	r0!, {s13}
 804985a:	ecbc 7a01 	vldmia	ip!, {s14}
 804985e:	eee5 7aa6 	vfma.f32	s15, s11, s13
 8049862:	eee7 7a06 	vfma.f32	s15, s14, s12
 8049866:	ece2 7a01 	vstmia	r2!, {s15}
 804986a:	4297      	cmp	r7, r2
 804986c:	d1f1      	bne.n	8049852 <kad_op_conv2d+0x138a>
				conv2d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _xx, _ww));
 804986e:	9a15      	ldr	r2, [sp, #84]	@ 0x54
 8049870:	9817      	ldr	r0, [sp, #92]	@ 0x5c
 8049872:	4411      	add	r1, r2
 8049874:	4496      	add	lr, r2
 8049876:	1c9a      	adds	r2, r3, #2
 8049878:	4282      	cmp	r2, r0
 804987a:	f105 0508 	add.w	r5, r5, #8
 804987e:	f10b 0b08 	add.w	fp, fp, #8
 8049882:	da01      	bge.n	8049888 <kad_op_conv2d+0x13c0>
 8049884:	4613      	mov	r3, r2
 8049886:	e7dd      	b.n	8049844 <kad_op_conv2d+0x137c>
 8049888:	3301      	adds	r3, #1
 804988a:	ecf5 6a01 	vldmia	r5!, {s13}
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 804988e:	4608      	mov	r0, r1
				conv2d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _xx, _ww));
 8049890:	464a      	mov	r2, r9
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 8049892:	edd2 7a00 	vldr	s15, [r2]
 8049896:	ecb0 7a01 	vldmia	r0!, {s14}
 804989a:	eee7 7a26 	vfma.f32	s15, s14, s13
 804989e:	ece2 7a01 	vstmia	r2!, {s15}
 80498a2:	4297      	cmp	r7, r2
 80498a4:	d1f5      	bne.n	8049892 <kad_op_conv2d+0x13ca>
				conv2d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _xx, _ww));
 80498a6:	3301      	adds	r3, #1
 80498a8:	459a      	cmp	sl, r3
 80498aa:	4421      	add	r1, r4
 80498ac:	dced      	bgt.n	804988a <kad_op_conv2d+0x13c2>
 80498ae:	9b03      	ldr	r3, [sp, #12]
 80498b0:	9a02      	ldr	r2, [sp, #8]
 80498b2:	685b      	ldr	r3, [r3, #4]
 80498b4:	3201      	adds	r2, #1
 80498b6:	441e      	add	r6, r3
 80498b8:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
 80498ba:	9202      	str	r2, [sp, #8]
 80498bc:	429a      	cmp	r2, r3
 80498be:	d002      	beq.n	80498c6 <kad_op_conv2d+0x13fe>
 80498c0:	2e00      	cmp	r6, #0
 80498c2:	f6bf af7e 	bge.w	80497c2 <kad_op_conv2d+0x12fa>
 80498c6:	9a06      	ldr	r2, [sp, #24]
 80498c8:	9d08      	ldr	r5, [sp, #32]
 80498ca:	9c0d      	ldr	r4, [sp, #52]	@ 0x34
 80498cc:	e9dd ba0a 	ldrd	fp, sl, [sp, #40]	@ 0x28
 80498d0:	f10b 0b01 	add.w	fp, fp, #1
 80498d4:	455d      	cmp	r5, fp
 80498d6:	44d1      	add	r9, sl
 80498d8:	4457      	add	r7, sl
 80498da:	f47f af5e 	bne.w	804979a <kad_op_conv2d+0x12d2>
 80498de:	e9dd 151a 	ldrd	r1, r5, [sp, #104]	@ 0x68
 80498e2:	9e19      	ldr	r6, [sp, #100]	@ 0x64
 80498e4:	9811      	ldr	r0, [sp, #68]	@ 0x44
 80498e6:	9b07      	ldr	r3, [sp, #28]
 80498e8:	3001      	adds	r0, #1
 80498ea:	4298      	cmp	r0, r3
 80498ec:	440d      	add	r5, r1
 80498ee:	f47f af40 	bne.w	8049772 <kad_op_conv2d+0x12aa>
 80498f2:	9b00      	ldr	r3, [sp, #0]
 80498f4:	46c3      	mov	fp, r8
 80498f6:	4688      	mov	r8, r1
 80498f8:	9904      	ldr	r1, [sp, #16]
 80498fa:	3301      	adds	r3, #1
 80498fc:	428b      	cmp	r3, r1
 80498fe:	4617      	mov	r7, r2
 8049900:	9300      	str	r3, [sp, #0]
 8049902:	4652      	mov	r2, sl
 8049904:	f47f af2f 	bne.w	8049766 <kad_op_conv2d+0x129e>
 8049908:	46b8      	mov	r8, r7
 804990a:	4625      	mov	r5, r4
				conv2d_add_3to1(w->d, w1, w->g);
 804990c:	4642      	mov	r2, r8
 804990e:	9909      	ldr	r1, [sp, #36]	@ 0x24
 8049910:	f106 0010 	add.w	r0, r6, #16
 8049914:	f7f9 fa30 	bl	8042d78 <conv2d_add_3to1>
 8049918:	e639      	b.n	804958e <kad_op_conv2d+0x10c6>
				conv2d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _xx, _ww));
 804991a:	2300      	movs	r3, #0
 804991c:	e7b5      	b.n	804988a <kad_op_conv2d+0x13c2>
 804991e:	9a07      	ldr	r2, [sp, #28]
 8049920:	e6f7      	b.n	8049712 <kad_op_conv2d+0x124a>
				memset(w1, 0, kad_len(w) * sizeof(float));
 8049922:	9b09      	ldr	r3, [sp, #36]	@ 0x24
				conv2d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _xx, _ww));
 8049924:	f8d9 7014 	ldr.w	r7, [r9, #20]
				memset(w1, 0, kad_len(w) * sizeof(float));
 8049928:	601a      	str	r2, [r3, #0]
				conv2d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _xx, _ww));
 804992a:	f8db 3014 	ldr.w	r3, [fp, #20]
 804992e:	fb07 f303 	mul.w	r3, r7, r3
 8049932:	e6fd      	b.n	8049730 <kad_op_conv2d+0x1268>
		for (j = 0; j < d[1]; ++j)
 8049934:	9c13      	ldr	r4, [sp, #76]	@ 0x4c
 8049936:	3201      	adds	r2, #1
 8049938:	4297      	cmp	r7, r2
 804993a:	9100      	str	r1, [sp, #0]
 804993c:	4404      	add	r4, r0
 804993e:	f47f ae9e 	bne.w	804967e <kad_op_conv2d+0x11b6>
 8049942:	e9dd 8c0d 	ldrd	r8, ip, [sp, #52]	@ 0x34
 8049946:	460e      	mov	r6, r1
 8049948:	f8dd b03c 	ldr.w	fp, [sp, #60]	@ 0x3c
 804994c:	f8dd 9044 	ldr.w	r9, [sp, #68]	@ 0x44
 8049950:	e6c6      	b.n	80496e0 <kad_op_conv2d+0x1218>
 8049952:	7832      	ldrb	r2, [r6, #0]
 8049954:	4613      	mov	r3, r2
 8049956:	2a00      	cmp	r2, #0
 8049958:	f47f aecd 	bne.w	80496f6 <kad_op_conv2d+0x122e>
				memset(w1, 0, kad_len(w) * sizeof(float));
 804995c:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 804995e:	601a      	str	r2, [r3, #0]
				conv2d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _xx, _ww));
 8049960:	e7d4      	b.n	804990c <kad_op_conv2d+0x1444>
		conv_rot180(w->d[0] * w->d[1], w->d[2] * w->d[3], w->x);
 8049962:	fb03 f101 	mul.w	r1, r3, r1
 8049966:	9b04      	ldr	r3, [sp, #16]
 8049968:	fb0e f403 	mul.w	r4, lr, r3
	for (i = 0; i < d0; ++i) {
 804996c:	f7fe bff0 	b.w	8048950 <kad_op_conv2d+0x488>
			conv2d_move_1to3(q->d, q->x, q1);
 8049970:	f8d9 3028 	ldr.w	r3, [r9, #40]	@ 0x28
	for (i = 0; i < d[0]; ++i)
 8049974:	f1b8 0f00 	cmp.w	r8, #0
			conv2d_move_1to3(q->d, q->x, q1);
 8049978:	9300      	str	r3, [sp, #0]
			conv2d_loop1(q->x, w->x, p->x, t, process_row_for);
 804997a:	6ab3      	ldr	r3, [r6, #40]	@ 0x28
 804997c:	6931      	ldr	r1, [r6, #16]
 804997e:	930b      	str	r3, [sp, #44]	@ 0x2c
 8049980:	69f3      	ldr	r3, [r6, #28]
 8049982:	9304      	str	r3, [sp, #16]
 8049984:	e9d6 3e05 	ldrd	r3, lr, [r6, #20]
 8049988:	930a      	str	r3, [sp, #40]	@ 0x28
	for (i = 0; i < d[0]; ++i)
 804998a:	dd7a      	ble.n	8049a82 <kad_op_conv2d+0x15ba>
		for (j = 0; j < d[1]; ++j)
 804998c:	f8d9 c014 	ldr.w	ip, [r9, #20]
 8049990:	f1bc 0f00 	cmp.w	ip, #0
 8049994:	dd70      	ble.n	8049a78 <kad_op_conv2d+0x15b0>
 8049996:	ea4f 038c 	mov.w	r3, ip, lsl #2
			for (k = 0; k < d[2]; ++k) {
 804999a:	2500      	movs	r5, #0
 804999c:	9307      	str	r3, [sp, #28]
 804999e:	4673      	mov	r3, lr
 80499a0:	f8d9 7018 	ldr.w	r7, [r9, #24]
 80499a4:	46ce      	mov	lr, r9
	for (i = 0; i < d[0]; ++i)
 80499a6:	462e      	mov	r6, r5
 80499a8:	460c      	mov	r4, r1
 80499aa:	4699      	mov	r9, r3
		for (j = 0; j < d[1]; ++j)
 80499ac:	2f00      	cmp	r7, #0
				int ik = (i * d[2] + k) * d[3], ijk = ((i * d[1] + j) * d[2] + k) * d[3];
 80499ae:	fb07 f206 	mul.w	r2, r7, r6
 80499b2:	f77f a814 	ble.w	80489de <kad_op_conv2d+0x516>
 80499b6:	f8de 301c 	ldr.w	r3, [lr, #28]
 80499ba:	fb07 f005 	mul.w	r0, r7, r5
 80499be:	fb03 f202 	mul.w	r2, r3, r2
 80499c2:	fb0c f202 	mul.w	r2, ip, r2
 80499c6:	9203      	str	r2, [sp, #12]
 80499c8:	fb0c f203 	mul.w	r2, ip, r3
 80499cc:	0092      	lsls	r2, r2, #2
 80499ce:	9205      	str	r2, [sp, #20]
		for (j = 0; j < d[1]; ++j)
 80499d0:	2200      	movs	r2, #0
 80499d2:	0099      	lsls	r1, r3, #2
 80499d4:	9102      	str	r1, [sp, #8]
			for (k = 0; k < d[2]; ++k) {
 80499d6:	2b00      	cmp	r3, #0
 80499d8:	f77e affc 	ble.w	80489d4 <kad_op_conv2d+0x50c>
 80499dc:	4629      	mov	r1, r5
 80499de:	e9cd e60d 	strd	lr, r6, [sp, #52]	@ 0x34
 80499e2:	f8cd b020 	str.w	fp, [sp, #32]
 80499e6:	f8cd 803c 	str.w	r8, [sp, #60]	@ 0x3c
 80499ea:	f04f 0800 	mov.w	r8, #0
 80499ee:	9d03      	ldr	r5, [sp, #12]
 80499f0:	9e0c      	ldr	r6, [sp, #48]	@ 0x30
 80499f2:	fb00 fb03 	mul.w	fp, r0, r3
 80499f6:	1955      	adds	r5, r2, r5
 80499f8:	eb06 0585 	add.w	r5, r6, r5, lsl #2
 80499fc:	9506      	str	r5, [sp, #24]
 80499fe:	9d00      	ldr	r5, [sp, #0]
 8049a00:	eb03 060b 	add.w	r6, r3, fp
 8049a04:	eb05 0e86 	add.w	lr, r5, r6, lsl #2
 8049a08:	9d06      	ldr	r5, [sp, #24]
 8049a0a:	9211      	str	r2, [sp, #68]	@ 0x44
				for (l = 0; l < d[3]; ++l)
 8049a0c:	9a00      	ldr	r2, [sp, #0]
			for (k = 0; k < d[2]; ++k) {
 8049a0e:	9306      	str	r3, [sp, #24]
 8049a10:	eb02 028b 	add.w	r2, r2, fp, lsl #2
 8049a14:	46ab      	mov	fp, r5
					y[(ik + l) * d[1] + j] = x[ijk + l];
 8049a16:	ecf2 7a01 	vldmia	r2!, {s15}
				for (l = 0; l < d[3]; ++l)
 8049a1a:	9b07      	ldr	r3, [sp, #28]
 8049a1c:	4596      	cmp	lr, r2
					y[(ik + l) * d[1] + j] = x[ijk + l];
 8049a1e:	edcb 7a00 	vstr	s15, [fp]
				for (l = 0; l < d[3]; ++l)
 8049a22:	449b      	add	fp, r3
 8049a24:	d1f7      	bne.n	8049a16 <kad_op_conv2d+0x154e>
			for (k = 0; k < d[2]; ++k) {
 8049a26:	9a05      	ldr	r2, [sp, #20]
 8049a28:	f108 0801 	add.w	r8, r8, #1
 8049a2c:	4415      	add	r5, r2
 8049a2e:	9a02      	ldr	r2, [sp, #8]
 8049a30:	45b8      	cmp	r8, r7
 8049a32:	46b3      	mov	fp, r6
 8049a34:	9b06      	ldr	r3, [sp, #24]
 8049a36:	4496      	add	lr, r2
 8049a38:	d010      	beq.n	8049a5c <kad_op_conv2d+0x1594>
 8049a3a:	441e      	add	r6, r3
 8049a3c:	e7e6      	b.n	8049a0c <kad_op_conv2d+0x1544>
 8049a3e:	9a0a      	ldr	r2, [sp, #40]	@ 0x28
 8049a40:	fb02 f303 	mul.w	r3, r2, r3
 8049a44:	f7ff b848 	b.w	8048ad8 <kad_op_conv2d+0x610>
 8049a48:	4618      	mov	r0, r3
			conv2d_loop2(q1, w1, p->x, (*_yy += kad_sdot(m, _ww, _xx)));
 8049a4a:	9a04      	ldr	r2, [sp, #16]
 8049a4c:	f8db 3014 	ldr.w	r3, [fp, #20]
 8049a50:	fb00 f702 	mul.w	r7, r0, r2
 8049a54:	fb03 f30c 	mul.w	r3, r3, ip
 8049a58:	f7ff b847 	b.w	8048aea <kad_op_conv2d+0x622>
		for (j = 0; j < d[1]; ++j)
 8049a5c:	9a11      	ldr	r2, [sp, #68]	@ 0x44
 8049a5e:	4438      	add	r0, r7
 8049a60:	3201      	adds	r2, #1
 8049a62:	4594      	cmp	ip, r2
 8049a64:	d1c1      	bne.n	80499ea <kad_op_conv2d+0x1522>
 8049a66:	e9dd e60d 	ldrd	lr, r6, [sp, #52]	@ 0x34
 8049a6a:	460d      	mov	r5, r1
 8049a6c:	f8dd b020 	ldr.w	fp, [sp, #32]
 8049a70:	f8dd 803c 	ldr.w	r8, [sp, #60]	@ 0x3c
 8049a74:	f7fe bfb3 	b.w	80489de <kad_op_conv2d+0x516>
	for (i = 0; i < d[0]; ++i)
 8049a78:	2900      	cmp	r1, #0
 8049a7a:	f73e afbc 	bgt.w	80489f6 <kad_op_conv2d+0x52e>
 8049a7e:	f7ff b8fb 	b.w	8048c78 <kad_op_conv2d+0x7b0>
 8049a82:	2900      	cmp	r1, #0
 8049a84:	f77f a8f8 	ble.w	8048c78 <kad_op_conv2d+0x7b0>
 8049a88:	2b00      	cmp	r3, #0
 8049a8a:	f77e ad32 	ble.w	80484f2 <kad_op_conv2d+0x2a>
 8049a8e:	f1be 0f00 	cmp.w	lr, #0
 8049a92:	f77f a8f1 	ble.w	8048c78 <kad_op_conv2d+0x7b0>
			conv2d_loop1(q->x, w->x, p->x, t, process_row_for);
 8049a96:	f8d9 c014 	ldr.w	ip, [r9, #20]
 8049a9a:	f7fe bfb4 	b.w	8048a06 <kad_op_conv2d+0x53e>
 8049a9e:	bf00      	nop

08049aa0 <kad_const>:
{
 8049aa0:	b40e      	push	{r1, r2, r3}
 8049aa2:	b5f0      	push	{r4, r5, r6, r7, lr}
 8049aa4:	b082      	sub	sp, #8
 8049aa6:	ad07      	add	r5, sp, #28
 8049aa8:	f855 6b04 	ldr.w	r6, [r5], #4
	if (n_d > KAD_MAX_DIM) return 0;
 8049aac:	2e04      	cmp	r6, #4
	va_start(ap, n_d); p = kad_vleaf(KAD_CONST, x, 0, n_d, ap); va_end(ap);
 8049aae:	9501      	str	r5, [sp, #4]
	if (n_d > KAD_MAX_DIM) return 0;
 8049ab0:	dc1d      	bgt.n	8049aee <kad_const+0x4e>
 8049ab2:	4607      	mov	r7, r0
	p = (kad_node_t*)calloc(1, sizeof(kad_node_t));
 8049ab4:	2140      	movs	r1, #64	@ 0x40
 8049ab6:	2001      	movs	r0, #1
 8049ab8:	f001 fe76 	bl	804b7a8 <calloc>
	heapSize += 1 * sizeof(kad_node_t);
 8049abc:	4a0d      	ldr	r2, [pc, #52]	@ (8049af4 <kad_const+0x54>)
	for (i = 0; i < n_d; ++i)
 8049abe:	2e00      	cmp	r6, #0
	heapSize += 1 * sizeof(kad_node_t);
 8049ac0:	6813      	ldr	r3, [r2, #0]
	p = (kad_node_t*)calloc(1, sizeof(kad_node_t));
 8049ac2:	4604      	mov	r4, r0
	heapSize += 1 * sizeof(kad_node_t);
 8049ac4:	f103 0340 	add.w	r3, r3, #64	@ 0x40
 8049ac8:	6013      	str	r3, [r2, #0]
	p->n_d = n_d;
 8049aca:	7006      	strb	r6, [r0, #0]
	for (i = 0; i < n_d; ++i)
 8049acc:	dd04      	ble.n	8049ad8 <kad_const+0x38>
		p->d[i] = va_arg(ap, int32_t);
 8049ace:	4629      	mov	r1, r5
 8049ad0:	00b2      	lsls	r2, r6, #2
 8049ad2:	3010      	adds	r0, #16
 8049ad4:	f002 fa6f 	bl	804bfb6 <memcpy>
	p->x = x, p->g = g, p->flag = flag;
 8049ad8:	2200      	movs	r2, #0
 8049ada:	2302      	movs	r3, #2
 8049adc:	e9c4 720a 	strd	r7, r2, [r4, #40]	@ 0x28
 8049ae0:	7063      	strb	r3, [r4, #1]
}
 8049ae2:	4620      	mov	r0, r4
 8049ae4:	b002      	add	sp, #8
 8049ae6:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
 8049aea:	b003      	add	sp, #12
 8049aec:	4770      	bx	lr
	if (n_d > KAD_MAX_DIM) return 0;
 8049aee:	2400      	movs	r4, #0
	return p;
 8049af0:	e7f7      	b.n	8049ae2 <kad_const+0x42>
 8049af2:	bf00      	nop
 8049af4:	20018344 	.word	0x20018344

08049af8 <kad_feed>:
{
 8049af8:	b40f      	push	{r0, r1, r2, r3}
 8049afa:	b570      	push	{r4, r5, r6, lr}
 8049afc:	b082      	sub	sp, #8
 8049afe:	ad06      	add	r5, sp, #24
 8049b00:	f855 6b04 	ldr.w	r6, [r5], #4
	if (n_d > KAD_MAX_DIM) return 0;
 8049b04:	2e04      	cmp	r6, #4
	va_start(ap, n_d); p = kad_vleaf(0, 0, 0, n_d, ap); va_end(ap);
 8049b06:	9501      	str	r5, [sp, #4]
	if (n_d > KAD_MAX_DIM) return 0;
 8049b08:	dc1d      	bgt.n	8049b46 <kad_feed+0x4e>
	p = (kad_node_t*)calloc(1, sizeof(kad_node_t));
 8049b0a:	2140      	movs	r1, #64	@ 0x40
 8049b0c:	2001      	movs	r0, #1
 8049b0e:	f001 fe4b 	bl	804b7a8 <calloc>
	heapSize += 1 * sizeof(kad_node_t);
 8049b12:	4a0e      	ldr	r2, [pc, #56]	@ (8049b4c <kad_feed+0x54>)
	for (i = 0; i < n_d; ++i)
 8049b14:	2e00      	cmp	r6, #0
	heapSize += 1 * sizeof(kad_node_t);
 8049b16:	6813      	ldr	r3, [r2, #0]
	p = (kad_node_t*)calloc(1, sizeof(kad_node_t));
 8049b18:	4604      	mov	r4, r0
	heapSize += 1 * sizeof(kad_node_t);
 8049b1a:	f103 0340 	add.w	r3, r3, #64	@ 0x40
 8049b1e:	6013      	str	r3, [r2, #0]
	p->n_d = n_d;
 8049b20:	7006      	strb	r6, [r0, #0]
	for (i = 0; i < n_d; ++i)
 8049b22:	dd04      	ble.n	8049b2e <kad_feed+0x36>
		p->d[i] = va_arg(ap, int32_t);
 8049b24:	4629      	mov	r1, r5
 8049b26:	00b2      	lsls	r2, r6, #2
 8049b28:	3010      	adds	r0, #16
 8049b2a:	f002 fa44 	bl	804bfb6 <memcpy>
	p->x = x, p->g = g, p->flag = flag;
 8049b2e:	2000      	movs	r0, #0
 8049b30:	2100      	movs	r1, #0
 8049b32:	2300      	movs	r3, #0
 8049b34:	e9c4 010a 	strd	r0, r1, [r4, #40]	@ 0x28
 8049b38:	7063      	strb	r3, [r4, #1]
}
 8049b3a:	4620      	mov	r0, r4
 8049b3c:	b002      	add	sp, #8
 8049b3e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 8049b42:	b004      	add	sp, #16
 8049b44:	4770      	bx	lr
	if (n_d > KAD_MAX_DIM) return 0;
 8049b46:	2400      	movs	r4, #0
	return p;
 8049b48:	e7f7      	b.n	8049b3a <kad_feed+0x42>
 8049b4a:	bf00      	nop
 8049b4c:	20018344 	.word	0x20018344

08049b50 <kad_var>:
{
 8049b50:	b40c      	push	{r2, r3}
 8049b52:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8049b56:	b082      	sub	sp, #8
 8049b58:	ad08      	add	r5, sp, #32
 8049b5a:	f855 6b04 	ldr.w	r6, [r5], #4
	if (n_d > KAD_MAX_DIM) return 0;
 8049b5e:	2e04      	cmp	r6, #4
	va_start(ap, n_d); p = kad_vleaf(KAD_VAR, x, g, n_d, ap); va_end(ap);
 8049b60:	9501      	str	r5, [sp, #4]
	if (n_d > KAD_MAX_DIM) return 0;
 8049b62:	dc1d      	bgt.n	8049ba0 <kad_var+0x50>
 8049b64:	4680      	mov	r8, r0
 8049b66:	460f      	mov	r7, r1
	p = (kad_node_t*)calloc(1, sizeof(kad_node_t));
 8049b68:	2001      	movs	r0, #1
 8049b6a:	2140      	movs	r1, #64	@ 0x40
 8049b6c:	f001 fe1c 	bl	804b7a8 <calloc>
	heapSize += 1 * sizeof(kad_node_t);
 8049b70:	4a0c      	ldr	r2, [pc, #48]	@ (8049ba4 <kad_var+0x54>)
	for (i = 0; i < n_d; ++i)
 8049b72:	2e00      	cmp	r6, #0
	heapSize += 1 * sizeof(kad_node_t);
 8049b74:	6813      	ldr	r3, [r2, #0]
	p = (kad_node_t*)calloc(1, sizeof(kad_node_t));
 8049b76:	4604      	mov	r4, r0
	heapSize += 1 * sizeof(kad_node_t);
 8049b78:	f103 0340 	add.w	r3, r3, #64	@ 0x40
 8049b7c:	6013      	str	r3, [r2, #0]
	p->n_d = n_d;
 8049b7e:	7006      	strb	r6, [r0, #0]
	for (i = 0; i < n_d; ++i)
 8049b80:	dd04      	ble.n	8049b8c <kad_var+0x3c>
		p->d[i] = va_arg(ap, int32_t);
 8049b82:	4629      	mov	r1, r5
 8049b84:	00b2      	lsls	r2, r6, #2
 8049b86:	3010      	adds	r0, #16
 8049b88:	f002 fa15 	bl	804bfb6 <memcpy>
	p->x = x, p->g = g, p->flag = flag;
 8049b8c:	2301      	movs	r3, #1
 8049b8e:	e9c4 870a 	strd	r8, r7, [r4, #40]	@ 0x28
 8049b92:	7063      	strb	r3, [r4, #1]
}
 8049b94:	4620      	mov	r0, r4
 8049b96:	b002      	add	sp, #8
 8049b98:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8049b9c:	b002      	add	sp, #8
 8049b9e:	4770      	bx	lr
	if (n_d > KAD_MAX_DIM) return 0;
 8049ba0:	2400      	movs	r4, #0
	return p;
 8049ba2:	e7f7      	b.n	8049b94 <kad_var+0x44>
 8049ba4:	20018344 	.word	0x20018344

08049ba8 <kad_add>:
KAD_FUNC_OP2(kad_add, 1)
 8049ba8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8049bac:	4680      	mov	r8, r0
 8049bae:	460f      	mov	r7, r1
	s = (kad_node_t*)calloc(1, sizeof(kad_node_t));
 8049bb0:	2001      	movs	r0, #1
 8049bb2:	2140      	movs	r1, #64	@ 0x40
 8049bb4:	f001 fdf8 	bl	804b7a8 <calloc>
	s->n_d = n_d, s->op = op, s->n_child = n_child;
 8049bb8:	2400      	movs	r4, #0
 8049bba:	2202      	movs	r2, #2
 8049bbc:	f04f 0c01 	mov.w	ip, #1
	heapSize += 1 * sizeof(kad_node_t);
 8049bc0:	4e20      	ldr	r6, [pc, #128]	@ (8049c44 <kad_add+0x9c>)
	s = (kad_node_t*)calloc(1, sizeof(kad_node_t));
 8049bc2:	4605      	mov	r5, r0
	heapSize += 1 * sizeof(kad_node_t);
 8049bc4:	6833      	ldr	r3, [r6, #0]
	s->n_d = n_d, s->op = op, s->n_child = n_child;
 8049bc6:	f8a0 c002 	strh.w	ip, [r0, #2]
	heapSize += 1 * sizeof(kad_node_t);
 8049bca:	3340      	adds	r3, #64	@ 0x40
	s->n_d = n_d, s->op = op, s->n_child = n_child;
 8049bcc:	6042      	str	r2, [r0, #4]
		s->child = (kad_node_t**)calloc(s->n_child, sizeof(kad_node_t*));
 8049bce:	2104      	movs	r1, #4
	s->n_d = n_d, s->op = op, s->n_child = n_child;
 8049bd0:	7004      	strb	r4, [r0, #0]
		s->child = (kad_node_t**)calloc(s->n_child, sizeof(kad_node_t*));
 8049bd2:	4610      	mov	r0, r2
	heapSize += 1 * sizeof(kad_node_t);
 8049bd4:	6033      	str	r3, [r6, #0]
		s->child = (kad_node_t**)calloc(s->n_child, sizeof(kad_node_t*));
 8049bd6:	f001 fde7 	bl	804b7a8 <calloc>
 8049bda:	4603      	mov	r3, r0
		heapSize += s->n_child * sizeof(kad_node_t*);
 8049bdc:	6832      	ldr	r2, [r6, #0]
	if (kad_op_list[s->op](s, KAD_SYNC_DIM) < 0) { /* check dimension */
 8049bde:	2104      	movs	r1, #4
		heapSize += s->n_child * sizeof(kad_node_t*);
 8049be0:	3208      	adds	r2, #8
 8049be2:	6032      	str	r2, [r6, #0]
	if (kad_op_list[s->op](s, KAD_SYNC_DIM) < 0) { /* check dimension */
 8049be4:	4a18      	ldr	r2, [pc, #96]	@ (8049c48 <kad_add+0xa0>)
 8049be6:	4628      	mov	r0, r5
	s->child[0] = x, s->child[1] = y;
 8049be8:	e9c3 8700 	strd	r8, r7, [r3]
	if (kad_op_list[s->op](s, KAD_SYNC_DIM) < 0) { /* check dimension */
 8049bec:	6852      	ldr	r2, [r2, #4]
		s->child = (kad_node_t**)calloc(s->n_child, sizeof(kad_node_t*));
 8049bee:	63ab      	str	r3, [r5, #56]	@ 0x38
	if (kad_op_list[s->op](s, KAD_SYNC_DIM) < 0) { /* check dimension */
 8049bf0:	4790      	blx	r2
 8049bf2:	42a0      	cmp	r0, r4
 8049bf4:	db17      	blt.n	8049c26 <kad_add+0x7e>
	for (i = 0; i < s->n_child; ++i)
 8049bf6:	6868      	ldr	r0, [r5, #4]
 8049bf8:	42a0      	cmp	r0, r4
 8049bfa:	dd11      	ble.n	8049c20 <kad_add+0x78>
 8049bfc:	6baa      	ldr	r2, [r5, #56]	@ 0x38
 8049bfe:	4623      	mov	r3, r4
 8049c00:	3a04      	subs	r2, #4
 8049c02:	e002      	b.n	8049c0a <kad_add+0x62>
 8049c04:	3301      	adds	r3, #1
 8049c06:	4298      	cmp	r0, r3
 8049c08:	d00a      	beq.n	8049c20 <kad_add+0x78>
		if (kad_is_back(s->child[i]))
 8049c0a:	f852 1f04 	ldr.w	r1, [r2, #4]!
 8049c0e:	7849      	ldrb	r1, [r1, #1]
 8049c10:	07c9      	lsls	r1, r1, #31
 8049c12:	d5f7      	bpl.n	8049c04 <kad_add+0x5c>
	if (i < s->n_child) s->flag |= KAD_VAR;
 8049c14:	4283      	cmp	r3, r0
 8049c16:	da03      	bge.n	8049c20 <kad_add+0x78>
 8049c18:	786b      	ldrb	r3, [r5, #1]
 8049c1a:	f043 0301 	orr.w	r3, r3, #1
 8049c1e:	706b      	strb	r3, [r5, #1]
KAD_FUNC_OP2(kad_add, 1)
 8049c20:	4628      	mov	r0, r5
 8049c22:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (s->ptr) free(s->ptr);
 8049c26:	6b28      	ldr	r0, [r5, #48]	@ 0x30
 8049c28:	b108      	cbz	r0, 8049c2e <kad_add+0x86>
 8049c2a:	f001 fde1 	bl	804b7f0 <free>
		free(s->child); free(s);
 8049c2e:	6ba8      	ldr	r0, [r5, #56]	@ 0x38
 8049c30:	f001 fdde 	bl	804b7f0 <free>
 8049c34:	4628      	mov	r0, r5
 8049c36:	2500      	movs	r5, #0
 8049c38:	f001 fdda 	bl	804b7f0 <free>
KAD_FUNC_OP2(kad_add, 1)
 8049c3c:	4628      	mov	r0, r5
 8049c3e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8049c42:	bf00      	nop
 8049c44:	20018344 	.word	0x20018344
 8049c48:	20018004 	.word	0x20018004

08049c4c <kad_mul>:
KAD_FUNC_OP2(kad_mul, 2)
 8049c4c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8049c50:	4680      	mov	r8, r0
 8049c52:	460f      	mov	r7, r1
	s = (kad_node_t*)calloc(1, sizeof(kad_node_t));
 8049c54:	2001      	movs	r0, #1
 8049c56:	2140      	movs	r1, #64	@ 0x40
 8049c58:	f001 fda6 	bl	804b7a8 <calloc>
	s->n_d = n_d, s->op = op, s->n_child = n_child;
 8049c5c:	2400      	movs	r4, #0
	s = (kad_node_t*)calloc(1, sizeof(kad_node_t));
 8049c5e:	4605      	mov	r5, r0
	s->n_d = n_d, s->op = op, s->n_child = n_child;
 8049c60:	2302      	movs	r3, #2
	heapSize += 1 * sizeof(kad_node_t);
 8049c62:	4e1f      	ldr	r6, [pc, #124]	@ (8049ce0 <kad_mul+0x94>)
		s->child = (kad_node_t**)calloc(s->n_child, sizeof(kad_node_t*));
 8049c64:	2104      	movs	r1, #4
	heapSize += 1 * sizeof(kad_node_t);
 8049c66:	6832      	ldr	r2, [r6, #0]
		s->child = (kad_node_t**)calloc(s->n_child, sizeof(kad_node_t*));
 8049c68:	4618      	mov	r0, r3
	heapSize += 1 * sizeof(kad_node_t);
 8049c6a:	3240      	adds	r2, #64	@ 0x40
	s->n_d = n_d, s->op = op, s->n_child = n_child;
 8049c6c:	806b      	strh	r3, [r5, #2]
 8049c6e:	606b      	str	r3, [r5, #4]
 8049c70:	702c      	strb	r4, [r5, #0]
	heapSize += 1 * sizeof(kad_node_t);
 8049c72:	6032      	str	r2, [r6, #0]
		s->child = (kad_node_t**)calloc(s->n_child, sizeof(kad_node_t*));
 8049c74:	f001 fd98 	bl	804b7a8 <calloc>
 8049c78:	4603      	mov	r3, r0
		heapSize += s->n_child * sizeof(kad_node_t*);
 8049c7a:	6832      	ldr	r2, [r6, #0]
	if (kad_op_list[s->op](s, KAD_SYNC_DIM) < 0) { /* check dimension */
 8049c7c:	2104      	movs	r1, #4
		heapSize += s->n_child * sizeof(kad_node_t*);
 8049c7e:	3208      	adds	r2, #8
 8049c80:	6032      	str	r2, [r6, #0]
	if (kad_op_list[s->op](s, KAD_SYNC_DIM) < 0) { /* check dimension */
 8049c82:	4a18      	ldr	r2, [pc, #96]	@ (8049ce4 <kad_mul+0x98>)
 8049c84:	4628      	mov	r0, r5
	s->child[0] = x, s->child[1] = y;
 8049c86:	e9c3 8700 	strd	r8, r7, [r3]
	if (kad_op_list[s->op](s, KAD_SYNC_DIM) < 0) { /* check dimension */
 8049c8a:	6892      	ldr	r2, [r2, #8]
		s->child = (kad_node_t**)calloc(s->n_child, sizeof(kad_node_t*));
 8049c8c:	63ab      	str	r3, [r5, #56]	@ 0x38
	if (kad_op_list[s->op](s, KAD_SYNC_DIM) < 0) { /* check dimension */
 8049c8e:	4790      	blx	r2
 8049c90:	42a0      	cmp	r0, r4
 8049c92:	db17      	blt.n	8049cc4 <kad_mul+0x78>
	for (i = 0; i < s->n_child; ++i)
 8049c94:	6868      	ldr	r0, [r5, #4]
 8049c96:	42a0      	cmp	r0, r4
 8049c98:	dd11      	ble.n	8049cbe <kad_mul+0x72>
 8049c9a:	6baa      	ldr	r2, [r5, #56]	@ 0x38
 8049c9c:	4623      	mov	r3, r4
 8049c9e:	3a04      	subs	r2, #4
 8049ca0:	e002      	b.n	8049ca8 <kad_mul+0x5c>
 8049ca2:	3301      	adds	r3, #1
 8049ca4:	4298      	cmp	r0, r3
 8049ca6:	d00a      	beq.n	8049cbe <kad_mul+0x72>
		if (kad_is_back(s->child[i]))
 8049ca8:	f852 1f04 	ldr.w	r1, [r2, #4]!
 8049cac:	7849      	ldrb	r1, [r1, #1]
 8049cae:	07c9      	lsls	r1, r1, #31
 8049cb0:	d5f7      	bpl.n	8049ca2 <kad_mul+0x56>
	if (i < s->n_child) s->flag |= KAD_VAR;
 8049cb2:	4283      	cmp	r3, r0
 8049cb4:	da03      	bge.n	8049cbe <kad_mul+0x72>
 8049cb6:	786b      	ldrb	r3, [r5, #1]
 8049cb8:	f043 0301 	orr.w	r3, r3, #1
 8049cbc:	706b      	strb	r3, [r5, #1]
KAD_FUNC_OP2(kad_mul, 2)
 8049cbe:	4628      	mov	r0, r5
 8049cc0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (s->ptr) free(s->ptr);
 8049cc4:	6b28      	ldr	r0, [r5, #48]	@ 0x30
 8049cc6:	b108      	cbz	r0, 8049ccc <kad_mul+0x80>
 8049cc8:	f001 fd92 	bl	804b7f0 <free>
		free(s->child); free(s);
 8049ccc:	6ba8      	ldr	r0, [r5, #56]	@ 0x38
 8049cce:	f001 fd8f 	bl	804b7f0 <free>
 8049cd2:	4628      	mov	r0, r5
 8049cd4:	2500      	movs	r5, #0
 8049cd6:	f001 fd8b 	bl	804b7f0 <free>
KAD_FUNC_OP2(kad_mul, 2)
 8049cda:	4628      	mov	r0, r5
 8049cdc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8049ce0:	20018344 	.word	0x20018344
 8049ce4:	20018004 	.word	0x20018004

08049ce8 <kad_cmul>:
KAD_FUNC_OP2(kad_cmul, 3)
 8049ce8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8049cec:	4680      	mov	r8, r0
 8049cee:	460f      	mov	r7, r1
	s = (kad_node_t*)calloc(1, sizeof(kad_node_t));
 8049cf0:	2001      	movs	r0, #1
 8049cf2:	2140      	movs	r1, #64	@ 0x40
 8049cf4:	f001 fd58 	bl	804b7a8 <calloc>
	s->n_d = n_d, s->op = op, s->n_child = n_child;
 8049cf8:	2400      	movs	r4, #0
 8049cfa:	2202      	movs	r2, #2
 8049cfc:	f04f 0c03 	mov.w	ip, #3
	heapSize += 1 * sizeof(kad_node_t);
 8049d00:	4e20      	ldr	r6, [pc, #128]	@ (8049d84 <kad_cmul+0x9c>)
	s = (kad_node_t*)calloc(1, sizeof(kad_node_t));
 8049d02:	4605      	mov	r5, r0
	heapSize += 1 * sizeof(kad_node_t);
 8049d04:	6833      	ldr	r3, [r6, #0]
	s->n_d = n_d, s->op = op, s->n_child = n_child;
 8049d06:	f8a0 c002 	strh.w	ip, [r0, #2]
	heapSize += 1 * sizeof(kad_node_t);
 8049d0a:	3340      	adds	r3, #64	@ 0x40
	s->n_d = n_d, s->op = op, s->n_child = n_child;
 8049d0c:	6042      	str	r2, [r0, #4]
		s->child = (kad_node_t**)calloc(s->n_child, sizeof(kad_node_t*));
 8049d0e:	2104      	movs	r1, #4
	s->n_d = n_d, s->op = op, s->n_child = n_child;
 8049d10:	7004      	strb	r4, [r0, #0]
		s->child = (kad_node_t**)calloc(s->n_child, sizeof(kad_node_t*));
 8049d12:	4610      	mov	r0, r2
	heapSize += 1 * sizeof(kad_node_t);
 8049d14:	6033      	str	r3, [r6, #0]
		s->child = (kad_node_t**)calloc(s->n_child, sizeof(kad_node_t*));
 8049d16:	f001 fd47 	bl	804b7a8 <calloc>
 8049d1a:	4603      	mov	r3, r0
		heapSize += s->n_child * sizeof(kad_node_t*);
 8049d1c:	6832      	ldr	r2, [r6, #0]
	if (kad_op_list[s->op](s, KAD_SYNC_DIM) < 0) { /* check dimension */
 8049d1e:	2104      	movs	r1, #4
		heapSize += s->n_child * sizeof(kad_node_t*);
 8049d20:	3208      	adds	r2, #8
 8049d22:	6032      	str	r2, [r6, #0]
	if (kad_op_list[s->op](s, KAD_SYNC_DIM) < 0) { /* check dimension */
 8049d24:	4a18      	ldr	r2, [pc, #96]	@ (8049d88 <kad_cmul+0xa0>)
 8049d26:	4628      	mov	r0, r5
	s->child[0] = x, s->child[1] = y;
 8049d28:	e9c3 8700 	strd	r8, r7, [r3]
	if (kad_op_list[s->op](s, KAD_SYNC_DIM) < 0) { /* check dimension */
 8049d2c:	68d2      	ldr	r2, [r2, #12]
		s->child = (kad_node_t**)calloc(s->n_child, sizeof(kad_node_t*));
 8049d2e:	63ab      	str	r3, [r5, #56]	@ 0x38
	if (kad_op_list[s->op](s, KAD_SYNC_DIM) < 0) { /* check dimension */
 8049d30:	4790      	blx	r2
 8049d32:	42a0      	cmp	r0, r4
 8049d34:	db17      	blt.n	8049d66 <kad_cmul+0x7e>
	for (i = 0; i < s->n_child; ++i)
 8049d36:	6868      	ldr	r0, [r5, #4]
 8049d38:	42a0      	cmp	r0, r4
 8049d3a:	dd11      	ble.n	8049d60 <kad_cmul+0x78>
 8049d3c:	6baa      	ldr	r2, [r5, #56]	@ 0x38
 8049d3e:	4623      	mov	r3, r4
 8049d40:	3a04      	subs	r2, #4
 8049d42:	e002      	b.n	8049d4a <kad_cmul+0x62>
 8049d44:	3301      	adds	r3, #1
 8049d46:	4298      	cmp	r0, r3
 8049d48:	d00a      	beq.n	8049d60 <kad_cmul+0x78>
		if (kad_is_back(s->child[i]))
 8049d4a:	f852 1f04 	ldr.w	r1, [r2, #4]!
 8049d4e:	7849      	ldrb	r1, [r1, #1]
 8049d50:	07c9      	lsls	r1, r1, #31
 8049d52:	d5f7      	bpl.n	8049d44 <kad_cmul+0x5c>
	if (i < s->n_child) s->flag |= KAD_VAR;
 8049d54:	4283      	cmp	r3, r0
 8049d56:	da03      	bge.n	8049d60 <kad_cmul+0x78>
 8049d58:	786b      	ldrb	r3, [r5, #1]
 8049d5a:	f043 0301 	orr.w	r3, r3, #1
 8049d5e:	706b      	strb	r3, [r5, #1]
KAD_FUNC_OP2(kad_cmul, 3)
 8049d60:	4628      	mov	r0, r5
 8049d62:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (s->ptr) free(s->ptr);
 8049d66:	6b28      	ldr	r0, [r5, #48]	@ 0x30
 8049d68:	b108      	cbz	r0, 8049d6e <kad_cmul+0x86>
 8049d6a:	f001 fd41 	bl	804b7f0 <free>
		free(s->child); free(s);
 8049d6e:	6ba8      	ldr	r0, [r5, #56]	@ 0x38
 8049d70:	f001 fd3e 	bl	804b7f0 <free>
 8049d74:	4628      	mov	r0, r5
 8049d76:	2500      	movs	r5, #0
 8049d78:	f001 fd3a 	bl	804b7f0 <free>
KAD_FUNC_OP2(kad_cmul, 3)
 8049d7c:	4628      	mov	r0, r5
 8049d7e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8049d82:	bf00      	nop
 8049d84:	20018344 	.word	0x20018344
 8049d88:	20018004 	.word	0x20018004

08049d8c <kad_ce_multi>:
KAD_FUNC_OP2(kad_ce_multi, 13)
 8049d8c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8049d90:	4680      	mov	r8, r0
 8049d92:	460f      	mov	r7, r1
	s = (kad_node_t*)calloc(1, sizeof(kad_node_t));
 8049d94:	2001      	movs	r0, #1
 8049d96:	2140      	movs	r1, #64	@ 0x40
 8049d98:	f001 fd06 	bl	804b7a8 <calloc>
	s->n_d = n_d, s->op = op, s->n_child = n_child;
 8049d9c:	2400      	movs	r4, #0
 8049d9e:	2202      	movs	r2, #2
 8049da0:	f04f 0c0d 	mov.w	ip, #13
	heapSize += 1 * sizeof(kad_node_t);
 8049da4:	4e20      	ldr	r6, [pc, #128]	@ (8049e28 <kad_ce_multi+0x9c>)
	s = (kad_node_t*)calloc(1, sizeof(kad_node_t));
 8049da6:	4605      	mov	r5, r0
	heapSize += 1 * sizeof(kad_node_t);
 8049da8:	6833      	ldr	r3, [r6, #0]
	s->n_d = n_d, s->op = op, s->n_child = n_child;
 8049daa:	f8a0 c002 	strh.w	ip, [r0, #2]
	heapSize += 1 * sizeof(kad_node_t);
 8049dae:	3340      	adds	r3, #64	@ 0x40
	s->n_d = n_d, s->op = op, s->n_child = n_child;
 8049db0:	6042      	str	r2, [r0, #4]
		s->child = (kad_node_t**)calloc(s->n_child, sizeof(kad_node_t*));
 8049db2:	2104      	movs	r1, #4
	s->n_d = n_d, s->op = op, s->n_child = n_child;
 8049db4:	7004      	strb	r4, [r0, #0]
		s->child = (kad_node_t**)calloc(s->n_child, sizeof(kad_node_t*));
 8049db6:	4610      	mov	r0, r2
	heapSize += 1 * sizeof(kad_node_t);
 8049db8:	6033      	str	r3, [r6, #0]
		s->child = (kad_node_t**)calloc(s->n_child, sizeof(kad_node_t*));
 8049dba:	f001 fcf5 	bl	804b7a8 <calloc>
 8049dbe:	4603      	mov	r3, r0
		heapSize += s->n_child * sizeof(kad_node_t*);
 8049dc0:	6832      	ldr	r2, [r6, #0]
	if (kad_op_list[s->op](s, KAD_SYNC_DIM) < 0) { /* check dimension */
 8049dc2:	2104      	movs	r1, #4
		heapSize += s->n_child * sizeof(kad_node_t*);
 8049dc4:	3208      	adds	r2, #8
 8049dc6:	6032      	str	r2, [r6, #0]
	if (kad_op_list[s->op](s, KAD_SYNC_DIM) < 0) { /* check dimension */
 8049dc8:	4a18      	ldr	r2, [pc, #96]	@ (8049e2c <kad_ce_multi+0xa0>)
 8049dca:	4628      	mov	r0, r5
	s->child[0] = x, s->child[1] = y;
 8049dcc:	e9c3 8700 	strd	r8, r7, [r3]
	if (kad_op_list[s->op](s, KAD_SYNC_DIM) < 0) { /* check dimension */
 8049dd0:	6b52      	ldr	r2, [r2, #52]	@ 0x34
		s->child = (kad_node_t**)calloc(s->n_child, sizeof(kad_node_t*));
 8049dd2:	63ab      	str	r3, [r5, #56]	@ 0x38
	if (kad_op_list[s->op](s, KAD_SYNC_DIM) < 0) { /* check dimension */
 8049dd4:	4790      	blx	r2
 8049dd6:	42a0      	cmp	r0, r4
 8049dd8:	db17      	blt.n	8049e0a <kad_ce_multi+0x7e>
	for (i = 0; i < s->n_child; ++i)
 8049dda:	6868      	ldr	r0, [r5, #4]
 8049ddc:	42a0      	cmp	r0, r4
 8049dde:	dd11      	ble.n	8049e04 <kad_ce_multi+0x78>
 8049de0:	6baa      	ldr	r2, [r5, #56]	@ 0x38
 8049de2:	4623      	mov	r3, r4
 8049de4:	3a04      	subs	r2, #4
 8049de6:	e002      	b.n	8049dee <kad_ce_multi+0x62>
 8049de8:	3301      	adds	r3, #1
 8049dea:	4298      	cmp	r0, r3
 8049dec:	d00a      	beq.n	8049e04 <kad_ce_multi+0x78>
		if (kad_is_back(s->child[i]))
 8049dee:	f852 1f04 	ldr.w	r1, [r2, #4]!
 8049df2:	7849      	ldrb	r1, [r1, #1]
 8049df4:	07c9      	lsls	r1, r1, #31
 8049df6:	d5f7      	bpl.n	8049de8 <kad_ce_multi+0x5c>
	if (i < s->n_child) s->flag |= KAD_VAR;
 8049df8:	4283      	cmp	r3, r0
 8049dfa:	da03      	bge.n	8049e04 <kad_ce_multi+0x78>
 8049dfc:	786b      	ldrb	r3, [r5, #1]
 8049dfe:	f043 0301 	orr.w	r3, r3, #1
 8049e02:	706b      	strb	r3, [r5, #1]
KAD_FUNC_OP2(kad_ce_multi, 13)
 8049e04:	4628      	mov	r0, r5
 8049e06:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (s->ptr) free(s->ptr);
 8049e0a:	6b28      	ldr	r0, [r5, #48]	@ 0x30
 8049e0c:	b108      	cbz	r0, 8049e12 <kad_ce_multi+0x86>
 8049e0e:	f001 fcef 	bl	804b7f0 <free>
		free(s->child); free(s);
 8049e12:	6ba8      	ldr	r0, [r5, #56]	@ 0x38
 8049e14:	f001 fcec 	bl	804b7f0 <free>
 8049e18:	4628      	mov	r0, r5
 8049e1a:	2500      	movs	r5, #0
 8049e1c:	f001 fce8 	bl	804b7f0 <free>
KAD_FUNC_OP2(kad_ce_multi, 13)
 8049e20:	4628      	mov	r0, r5
 8049e22:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8049e26:	bf00      	nop
 8049e28:	20018344 	.word	0x20018344
 8049e2c:	20018004 	.word	0x20018004

08049e30 <kad_sigm>:
KAD_FUNC_OP1(kad_sigm, 6)
 8049e30:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	s = (kad_node_t*)calloc(1, sizeof(kad_node_t));
 8049e32:	2140      	movs	r1, #64	@ 0x40
KAD_FUNC_OP1(kad_sigm, 6)
 8049e34:	4607      	mov	r7, r0
	s = (kad_node_t*)calloc(1, sizeof(kad_node_t));
 8049e36:	2001      	movs	r0, #1
 8049e38:	f001 fcb6 	bl	804b7a8 <calloc>
	heapSize += 1 * sizeof(kad_node_t);
 8049e3c:	4e1f      	ldr	r6, [pc, #124]	@ (8049ebc <kad_sigm+0x8c>)
	s = (kad_node_t*)calloc(1, sizeof(kad_node_t));
 8049e3e:	4605      	mov	r5, r0
	heapSize += 1 * sizeof(kad_node_t);
 8049e40:	6833      	ldr	r3, [r6, #0]
	s->n_d = n_d, s->op = op, s->n_child = n_child;
 8049e42:	2206      	movs	r2, #6
	heapSize += 1 * sizeof(kad_node_t);
 8049e44:	3340      	adds	r3, #64	@ 0x40
	s->n_d = n_d, s->op = op, s->n_child = n_child;
 8049e46:	2400      	movs	r4, #0
	heapSize += 1 * sizeof(kad_node_t);
 8049e48:	6033      	str	r3, [r6, #0]
	s->n_d = n_d, s->op = op, s->n_child = n_child;
 8049e4a:	2301      	movs	r3, #1
		s->child = (kad_node_t**)calloc(s->n_child, sizeof(kad_node_t*));
 8049e4c:	2104      	movs	r1, #4
 8049e4e:	4618      	mov	r0, r3
	s->n_d = n_d, s->op = op, s->n_child = n_child;
 8049e50:	606b      	str	r3, [r5, #4]
 8049e52:	806a      	strh	r2, [r5, #2]
 8049e54:	702c      	strb	r4, [r5, #0]
		s->child = (kad_node_t**)calloc(s->n_child, sizeof(kad_node_t*));
 8049e56:	f001 fca7 	bl	804b7a8 <calloc>
 8049e5a:	4603      	mov	r3, r0
		heapSize += s->n_child * sizeof(kad_node_t*);
 8049e5c:	6832      	ldr	r2, [r6, #0]
	if (kad_op_list[s->op](s, KAD_SYNC_DIM) < 0) { /* check dimension */
 8049e5e:	2104      	movs	r1, #4
		heapSize += s->n_child * sizeof(kad_node_t*);
 8049e60:	3204      	adds	r2, #4
 8049e62:	6032      	str	r2, [r6, #0]
	if (kad_op_list[s->op](s, KAD_SYNC_DIM) < 0) { /* check dimension */
 8049e64:	4a16      	ldr	r2, [pc, #88]	@ (8049ec0 <kad_sigm+0x90>)
 8049e66:	4628      	mov	r0, r5
 8049e68:	6992      	ldr	r2, [r2, #24]
		s->child = (kad_node_t**)calloc(s->n_child, sizeof(kad_node_t*));
 8049e6a:	63ab      	str	r3, [r5, #56]	@ 0x38
	s->child[0] = x;
 8049e6c:	601f      	str	r7, [r3, #0]
	if (kad_op_list[s->op](s, KAD_SYNC_DIM) < 0) { /* check dimension */
 8049e6e:	4790      	blx	r2
 8049e70:	42a0      	cmp	r0, r4
 8049e72:	db16      	blt.n	8049ea2 <kad_sigm+0x72>
	for (i = 0; i < s->n_child; ++i)
 8049e74:	6868      	ldr	r0, [r5, #4]
 8049e76:	42a0      	cmp	r0, r4
 8049e78:	dd11      	ble.n	8049e9e <kad_sigm+0x6e>
 8049e7a:	6baa      	ldr	r2, [r5, #56]	@ 0x38
 8049e7c:	4623      	mov	r3, r4
 8049e7e:	3a04      	subs	r2, #4
 8049e80:	e002      	b.n	8049e88 <kad_sigm+0x58>
 8049e82:	3301      	adds	r3, #1
 8049e84:	4298      	cmp	r0, r3
 8049e86:	d00a      	beq.n	8049e9e <kad_sigm+0x6e>
		if (kad_is_back(s->child[i]))
 8049e88:	f852 1f04 	ldr.w	r1, [r2, #4]!
 8049e8c:	7849      	ldrb	r1, [r1, #1]
 8049e8e:	07c9      	lsls	r1, r1, #31
 8049e90:	d5f7      	bpl.n	8049e82 <kad_sigm+0x52>
	if (i < s->n_child) s->flag |= KAD_VAR;
 8049e92:	4283      	cmp	r3, r0
 8049e94:	da03      	bge.n	8049e9e <kad_sigm+0x6e>
 8049e96:	786b      	ldrb	r3, [r5, #1]
 8049e98:	f043 0301 	orr.w	r3, r3, #1
 8049e9c:	706b      	strb	r3, [r5, #1]
KAD_FUNC_OP1(kad_sigm, 6)
 8049e9e:	4628      	mov	r0, r5
 8049ea0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (s->ptr) free(s->ptr);
 8049ea2:	6b28      	ldr	r0, [r5, #48]	@ 0x30
 8049ea4:	b108      	cbz	r0, 8049eaa <kad_sigm+0x7a>
 8049ea6:	f001 fca3 	bl	804b7f0 <free>
		free(s->child); free(s);
 8049eaa:	6ba8      	ldr	r0, [r5, #56]	@ 0x38
 8049eac:	f001 fca0 	bl	804b7f0 <free>
 8049eb0:	4628      	mov	r0, r5
 8049eb2:	2500      	movs	r5, #0
 8049eb4:	f001 fc9c 	bl	804b7f0 <free>
KAD_FUNC_OP1(kad_sigm, 6)
 8049eb8:	4628      	mov	r0, r5
 8049eba:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8049ebc:	20018344 	.word	0x20018344
 8049ec0:	20018004 	.word	0x20018004

08049ec4 <kad_tanh>:
KAD_FUNC_OP1(kad_tanh, 7)
 8049ec4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	s = (kad_node_t*)calloc(1, sizeof(kad_node_t));
 8049ec6:	2140      	movs	r1, #64	@ 0x40
KAD_FUNC_OP1(kad_tanh, 7)
 8049ec8:	4607      	mov	r7, r0
	s = (kad_node_t*)calloc(1, sizeof(kad_node_t));
 8049eca:	2001      	movs	r0, #1
 8049ecc:	f001 fc6c 	bl	804b7a8 <calloc>
	heapSize += 1 * sizeof(kad_node_t);
 8049ed0:	4e1f      	ldr	r6, [pc, #124]	@ (8049f50 <kad_tanh+0x8c>)
	s = (kad_node_t*)calloc(1, sizeof(kad_node_t));
 8049ed2:	4605      	mov	r5, r0
	heapSize += 1 * sizeof(kad_node_t);
 8049ed4:	6833      	ldr	r3, [r6, #0]
	s->n_d = n_d, s->op = op, s->n_child = n_child;
 8049ed6:	2207      	movs	r2, #7
	heapSize += 1 * sizeof(kad_node_t);
 8049ed8:	3340      	adds	r3, #64	@ 0x40
	s->n_d = n_d, s->op = op, s->n_child = n_child;
 8049eda:	2400      	movs	r4, #0
	heapSize += 1 * sizeof(kad_node_t);
 8049edc:	6033      	str	r3, [r6, #0]
	s->n_d = n_d, s->op = op, s->n_child = n_child;
 8049ede:	2301      	movs	r3, #1
		s->child = (kad_node_t**)calloc(s->n_child, sizeof(kad_node_t*));
 8049ee0:	2104      	movs	r1, #4
 8049ee2:	4618      	mov	r0, r3
	s->n_d = n_d, s->op = op, s->n_child = n_child;
 8049ee4:	606b      	str	r3, [r5, #4]
 8049ee6:	806a      	strh	r2, [r5, #2]
 8049ee8:	702c      	strb	r4, [r5, #0]
		s->child = (kad_node_t**)calloc(s->n_child, sizeof(kad_node_t*));
 8049eea:	f001 fc5d 	bl	804b7a8 <calloc>
 8049eee:	4603      	mov	r3, r0
		heapSize += s->n_child * sizeof(kad_node_t*);
 8049ef0:	6832      	ldr	r2, [r6, #0]
	if (kad_op_list[s->op](s, KAD_SYNC_DIM) < 0) { /* check dimension */
 8049ef2:	2104      	movs	r1, #4
		heapSize += s->n_child * sizeof(kad_node_t*);
 8049ef4:	3204      	adds	r2, #4
 8049ef6:	6032      	str	r2, [r6, #0]
	if (kad_op_list[s->op](s, KAD_SYNC_DIM) < 0) { /* check dimension */
 8049ef8:	4a16      	ldr	r2, [pc, #88]	@ (8049f54 <kad_tanh+0x90>)
 8049efa:	4628      	mov	r0, r5
 8049efc:	69d2      	ldr	r2, [r2, #28]
		s->child = (kad_node_t**)calloc(s->n_child, sizeof(kad_node_t*));
 8049efe:	63ab      	str	r3, [r5, #56]	@ 0x38
	s->child[0] = x;
 8049f00:	601f      	str	r7, [r3, #0]
	if (kad_op_list[s->op](s, KAD_SYNC_DIM) < 0) { /* check dimension */
 8049f02:	4790      	blx	r2
 8049f04:	42a0      	cmp	r0, r4
 8049f06:	db16      	blt.n	8049f36 <kad_tanh+0x72>
	for (i = 0; i < s->n_child; ++i)
 8049f08:	6868      	ldr	r0, [r5, #4]
 8049f0a:	42a0      	cmp	r0, r4
 8049f0c:	dd11      	ble.n	8049f32 <kad_tanh+0x6e>
 8049f0e:	6baa      	ldr	r2, [r5, #56]	@ 0x38
 8049f10:	4623      	mov	r3, r4
 8049f12:	3a04      	subs	r2, #4
 8049f14:	e002      	b.n	8049f1c <kad_tanh+0x58>
 8049f16:	3301      	adds	r3, #1
 8049f18:	4298      	cmp	r0, r3
 8049f1a:	d00a      	beq.n	8049f32 <kad_tanh+0x6e>
		if (kad_is_back(s->child[i]))
 8049f1c:	f852 1f04 	ldr.w	r1, [r2, #4]!
 8049f20:	7849      	ldrb	r1, [r1, #1]
 8049f22:	07c9      	lsls	r1, r1, #31
 8049f24:	d5f7      	bpl.n	8049f16 <kad_tanh+0x52>
	if (i < s->n_child) s->flag |= KAD_VAR;
 8049f26:	4283      	cmp	r3, r0
 8049f28:	da03      	bge.n	8049f32 <kad_tanh+0x6e>
 8049f2a:	786b      	ldrb	r3, [r5, #1]
 8049f2c:	f043 0301 	orr.w	r3, r3, #1
 8049f30:	706b      	strb	r3, [r5, #1]
KAD_FUNC_OP1(kad_tanh, 7)
 8049f32:	4628      	mov	r0, r5
 8049f34:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (s->ptr) free(s->ptr);
 8049f36:	6b28      	ldr	r0, [r5, #48]	@ 0x30
 8049f38:	b108      	cbz	r0, 8049f3e <kad_tanh+0x7a>
 8049f3a:	f001 fc59 	bl	804b7f0 <free>
		free(s->child); free(s);
 8049f3e:	6ba8      	ldr	r0, [r5, #56]	@ 0x38
 8049f40:	f001 fc56 	bl	804b7f0 <free>
 8049f44:	4628      	mov	r0, r5
 8049f46:	2500      	movs	r5, #0
 8049f48:	f001 fc52 	bl	804b7f0 <free>
KAD_FUNC_OP1(kad_tanh, 7)
 8049f4c:	4628      	mov	r0, r5
 8049f4e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8049f50:	20018344 	.word	0x20018344
 8049f54:	20018004 	.word	0x20018004

08049f58 <kad_softmax>:
KAD_FUNC_OP1(kad_softmax, 14)
 8049f58:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	s = (kad_node_t*)calloc(1, sizeof(kad_node_t));
 8049f5a:	2140      	movs	r1, #64	@ 0x40
KAD_FUNC_OP1(kad_softmax, 14)
 8049f5c:	4607      	mov	r7, r0
	s = (kad_node_t*)calloc(1, sizeof(kad_node_t));
 8049f5e:	2001      	movs	r0, #1
 8049f60:	f001 fc22 	bl	804b7a8 <calloc>
	heapSize += 1 * sizeof(kad_node_t);
 8049f64:	4e1f      	ldr	r6, [pc, #124]	@ (8049fe4 <kad_softmax+0x8c>)
	s = (kad_node_t*)calloc(1, sizeof(kad_node_t));
 8049f66:	4605      	mov	r5, r0
	heapSize += 1 * sizeof(kad_node_t);
 8049f68:	6833      	ldr	r3, [r6, #0]
	s->n_d = n_d, s->op = op, s->n_child = n_child;
 8049f6a:	220e      	movs	r2, #14
	heapSize += 1 * sizeof(kad_node_t);
 8049f6c:	3340      	adds	r3, #64	@ 0x40
	s->n_d = n_d, s->op = op, s->n_child = n_child;
 8049f6e:	2400      	movs	r4, #0
	heapSize += 1 * sizeof(kad_node_t);
 8049f70:	6033      	str	r3, [r6, #0]
	s->n_d = n_d, s->op = op, s->n_child = n_child;
 8049f72:	2301      	movs	r3, #1
		s->child = (kad_node_t**)calloc(s->n_child, sizeof(kad_node_t*));
 8049f74:	2104      	movs	r1, #4
 8049f76:	4618      	mov	r0, r3
	s->n_d = n_d, s->op = op, s->n_child = n_child;
 8049f78:	606b      	str	r3, [r5, #4]
 8049f7a:	806a      	strh	r2, [r5, #2]
 8049f7c:	702c      	strb	r4, [r5, #0]
		s->child = (kad_node_t**)calloc(s->n_child, sizeof(kad_node_t*));
 8049f7e:	f001 fc13 	bl	804b7a8 <calloc>
 8049f82:	4603      	mov	r3, r0
		heapSize += s->n_child * sizeof(kad_node_t*);
 8049f84:	6832      	ldr	r2, [r6, #0]
	if (kad_op_list[s->op](s, KAD_SYNC_DIM) < 0) { /* check dimension */
 8049f86:	2104      	movs	r1, #4
		heapSize += s->n_child * sizeof(kad_node_t*);
 8049f88:	3204      	adds	r2, #4
 8049f8a:	6032      	str	r2, [r6, #0]
	if (kad_op_list[s->op](s, KAD_SYNC_DIM) < 0) { /* check dimension */
 8049f8c:	4a16      	ldr	r2, [pc, #88]	@ (8049fe8 <kad_softmax+0x90>)
 8049f8e:	4628      	mov	r0, r5
 8049f90:	6b92      	ldr	r2, [r2, #56]	@ 0x38
		s->child = (kad_node_t**)calloc(s->n_child, sizeof(kad_node_t*));
 8049f92:	63ab      	str	r3, [r5, #56]	@ 0x38
	s->child[0] = x;
 8049f94:	601f      	str	r7, [r3, #0]
	if (kad_op_list[s->op](s, KAD_SYNC_DIM) < 0) { /* check dimension */
 8049f96:	4790      	blx	r2
 8049f98:	42a0      	cmp	r0, r4
 8049f9a:	db16      	blt.n	8049fca <kad_softmax+0x72>
	for (i = 0; i < s->n_child; ++i)
 8049f9c:	6868      	ldr	r0, [r5, #4]
 8049f9e:	42a0      	cmp	r0, r4
 8049fa0:	dd11      	ble.n	8049fc6 <kad_softmax+0x6e>
 8049fa2:	6baa      	ldr	r2, [r5, #56]	@ 0x38
 8049fa4:	4623      	mov	r3, r4
 8049fa6:	3a04      	subs	r2, #4
 8049fa8:	e002      	b.n	8049fb0 <kad_softmax+0x58>
 8049faa:	3301      	adds	r3, #1
 8049fac:	4298      	cmp	r0, r3
 8049fae:	d00a      	beq.n	8049fc6 <kad_softmax+0x6e>
		if (kad_is_back(s->child[i]))
 8049fb0:	f852 1f04 	ldr.w	r1, [r2, #4]!
 8049fb4:	7849      	ldrb	r1, [r1, #1]
 8049fb6:	07c9      	lsls	r1, r1, #31
 8049fb8:	d5f7      	bpl.n	8049faa <kad_softmax+0x52>
	if (i < s->n_child) s->flag |= KAD_VAR;
 8049fba:	4283      	cmp	r3, r0
 8049fbc:	da03      	bge.n	8049fc6 <kad_softmax+0x6e>
 8049fbe:	786b      	ldrb	r3, [r5, #1]
 8049fc0:	f043 0301 	orr.w	r3, r3, #1
 8049fc4:	706b      	strb	r3, [r5, #1]
KAD_FUNC_OP1(kad_softmax, 14)
 8049fc6:	4628      	mov	r0, r5
 8049fc8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (s->ptr) free(s->ptr);
 8049fca:	6b28      	ldr	r0, [r5, #48]	@ 0x30
 8049fcc:	b108      	cbz	r0, 8049fd2 <kad_softmax+0x7a>
 8049fce:	f001 fc0f 	bl	804b7f0 <free>
		free(s->child); free(s);
 8049fd2:	6ba8      	ldr	r0, [r5, #56]	@ 0x38
 8049fd4:	f001 fc0c 	bl	804b7f0 <free>
 8049fd8:	4628      	mov	r0, r5
 8049fda:	2500      	movs	r5, #0
 8049fdc:	f001 fc08 	bl	804b7f0 <free>
KAD_FUNC_OP1(kad_softmax, 14)
 8049fe0:	4628      	mov	r0, r5
 8049fe2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8049fe4:	20018344 	.word	0x20018344
 8049fe8:	20018004 	.word	0x20018004

08049fec <kad_stdnorm>:
KAD_FUNC_OP1(kad_stdnorm, 32)
 8049fec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	s = (kad_node_t*)calloc(1, sizeof(kad_node_t));
 8049fee:	2140      	movs	r1, #64	@ 0x40
KAD_FUNC_OP1(kad_stdnorm, 32)
 8049ff0:	4607      	mov	r7, r0
	s = (kad_node_t*)calloc(1, sizeof(kad_node_t));
 8049ff2:	2001      	movs	r0, #1
 8049ff4:	f001 fbd8 	bl	804b7a8 <calloc>
	heapSize += 1 * sizeof(kad_node_t);
 8049ff8:	4e20      	ldr	r6, [pc, #128]	@ (804a07c <kad_stdnorm+0x90>)
	s = (kad_node_t*)calloc(1, sizeof(kad_node_t));
 8049ffa:	4605      	mov	r5, r0
	heapSize += 1 * sizeof(kad_node_t);
 8049ffc:	6833      	ldr	r3, [r6, #0]
	s->n_d = n_d, s->op = op, s->n_child = n_child;
 8049ffe:	2220      	movs	r2, #32
	heapSize += 1 * sizeof(kad_node_t);
 804a000:	3340      	adds	r3, #64	@ 0x40
	s->n_d = n_d, s->op = op, s->n_child = n_child;
 804a002:	2400      	movs	r4, #0
	heapSize += 1 * sizeof(kad_node_t);
 804a004:	6033      	str	r3, [r6, #0]
	s->n_d = n_d, s->op = op, s->n_child = n_child;
 804a006:	2301      	movs	r3, #1
		s->child = (kad_node_t**)calloc(s->n_child, sizeof(kad_node_t*));
 804a008:	2104      	movs	r1, #4
 804a00a:	4618      	mov	r0, r3
	s->n_d = n_d, s->op = op, s->n_child = n_child;
 804a00c:	606b      	str	r3, [r5, #4]
 804a00e:	806a      	strh	r2, [r5, #2]
 804a010:	702c      	strb	r4, [r5, #0]
		s->child = (kad_node_t**)calloc(s->n_child, sizeof(kad_node_t*));
 804a012:	f001 fbc9 	bl	804b7a8 <calloc>
 804a016:	4603      	mov	r3, r0
		heapSize += s->n_child * sizeof(kad_node_t*);
 804a018:	6832      	ldr	r2, [r6, #0]
	if (kad_op_list[s->op](s, KAD_SYNC_DIM) < 0) { /* check dimension */
 804a01a:	2104      	movs	r1, #4
		heapSize += s->n_child * sizeof(kad_node_t*);
 804a01c:	3204      	adds	r2, #4
 804a01e:	6032      	str	r2, [r6, #0]
	if (kad_op_list[s->op](s, KAD_SYNC_DIM) < 0) { /* check dimension */
 804a020:	4a17      	ldr	r2, [pc, #92]	@ (804a080 <kad_stdnorm+0x94>)
 804a022:	4628      	mov	r0, r5
 804a024:	f8d2 2080 	ldr.w	r2, [r2, #128]	@ 0x80
		s->child = (kad_node_t**)calloc(s->n_child, sizeof(kad_node_t*));
 804a028:	63ab      	str	r3, [r5, #56]	@ 0x38
	s->child[0] = x;
 804a02a:	601f      	str	r7, [r3, #0]
	if (kad_op_list[s->op](s, KAD_SYNC_DIM) < 0) { /* check dimension */
 804a02c:	4790      	blx	r2
 804a02e:	42a0      	cmp	r0, r4
 804a030:	db16      	blt.n	804a060 <kad_stdnorm+0x74>
	for (i = 0; i < s->n_child; ++i)
 804a032:	6868      	ldr	r0, [r5, #4]
 804a034:	42a0      	cmp	r0, r4
 804a036:	dd11      	ble.n	804a05c <kad_stdnorm+0x70>
 804a038:	6baa      	ldr	r2, [r5, #56]	@ 0x38
 804a03a:	4623      	mov	r3, r4
 804a03c:	3a04      	subs	r2, #4
 804a03e:	e002      	b.n	804a046 <kad_stdnorm+0x5a>
 804a040:	3301      	adds	r3, #1
 804a042:	4298      	cmp	r0, r3
 804a044:	d00a      	beq.n	804a05c <kad_stdnorm+0x70>
		if (kad_is_back(s->child[i]))
 804a046:	f852 1f04 	ldr.w	r1, [r2, #4]!
 804a04a:	7849      	ldrb	r1, [r1, #1]
 804a04c:	07c9      	lsls	r1, r1, #31
 804a04e:	d5f7      	bpl.n	804a040 <kad_stdnorm+0x54>
	if (i < s->n_child) s->flag |= KAD_VAR;
 804a050:	4283      	cmp	r3, r0
 804a052:	da03      	bge.n	804a05c <kad_stdnorm+0x70>
 804a054:	786b      	ldrb	r3, [r5, #1]
 804a056:	f043 0301 	orr.w	r3, r3, #1
 804a05a:	706b      	strb	r3, [r5, #1]
KAD_FUNC_OP1(kad_stdnorm, 32)
 804a05c:	4628      	mov	r0, r5
 804a05e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (s->ptr) free(s->ptr);
 804a060:	6b28      	ldr	r0, [r5, #48]	@ 0x30
 804a062:	b108      	cbz	r0, 804a068 <kad_stdnorm+0x7c>
 804a064:	f001 fbc4 	bl	804b7f0 <free>
		free(s->child); free(s);
 804a068:	6ba8      	ldr	r0, [r5, #56]	@ 0x38
 804a06a:	f001 fbc1 	bl	804b7f0 <free>
 804a06e:	4628      	mov	r0, r5
 804a070:	2500      	movs	r5, #0
 804a072:	f001 fbbd 	bl	804b7f0 <free>
KAD_FUNC_OP1(kad_stdnorm, 32)
 804a076:	4628      	mov	r0, r5
 804a078:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 804a07a:	bf00      	nop
 804a07c:	20018344 	.word	0x20018344
 804a080:	20018004 	.word	0x20018004

0804a084 <kad_avg>:
kad_node_t *kad_avg(int n, kad_node_t **x)   { return kad_pooling_general(10, n, x); }
 804a084:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 804a086:	4605      	mov	r5, r0
 804a088:	460f      	mov	r7, r1
	s = (kad_node_t*)calloc(1, sizeof(kad_node_t));
 804a08a:	2001      	movs	r0, #1
 804a08c:	2140      	movs	r1, #64	@ 0x40
 804a08e:	f001 fb8b 	bl	804b7a8 <calloc>
	s->n_d = n_d, s->op = op, s->n_child = n_child;
 804a092:	2100      	movs	r1, #0
 804a094:	220a      	movs	r2, #10
	heapSize += 1 * sizeof(kad_node_t);
 804a096:	4e26      	ldr	r6, [pc, #152]	@ (804a130 <kad_avg+0xac>)
	s = (kad_node_t*)calloc(1, sizeof(kad_node_t));
 804a098:	4604      	mov	r4, r0
	heapSize += 1 * sizeof(kad_node_t);
 804a09a:	6833      	ldr	r3, [r6, #0]
	s->n_d = n_d, s->op = op, s->n_child = n_child;
 804a09c:	7001      	strb	r1, [r0, #0]
	heapSize += 1 * sizeof(kad_node_t);
 804a09e:	3340      	adds	r3, #64	@ 0x40
 804a0a0:	6033      	str	r3, [r6, #0]
	s->n_d = n_d, s->op = op, s->n_child = n_child;
 804a0a2:	8042      	strh	r2, [r0, #2]
 804a0a4:	6045      	str	r5, [r0, #4]
	if (s->n_child) {
 804a0a6:	bb0d      	cbnz	r5, 804a0ec <kad_avg+0x68>
	s->flag |= KAD_POOL;
 804a0a8:	7843      	ldrb	r3, [r0, #1]
 804a0aa:	f043 0304 	orr.w	r3, r3, #4
 804a0ae:	7043      	strb	r3, [r0, #1]
	if (kad_op_list[s->op](s, KAD_SYNC_DIM) < 0) { /* check dimension */
 804a0b0:	4b20      	ldr	r3, [pc, #128]	@ (804a134 <kad_avg+0xb0>)
 804a0b2:	2104      	movs	r1, #4
 804a0b4:	4620      	mov	r0, r4
 804a0b6:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 804a0b8:	4798      	blx	r3
 804a0ba:	2800      	cmp	r0, #0
 804a0bc:	db2b      	blt.n	804a116 <kad_avg+0x92>
	for (i = 0; i < s->n_child; ++i)
 804a0be:	6860      	ldr	r0, [r4, #4]
 804a0c0:	2800      	cmp	r0, #0
 804a0c2:	dd11      	ble.n	804a0e8 <kad_avg+0x64>
 804a0c4:	6ba2      	ldr	r2, [r4, #56]	@ 0x38
 804a0c6:	2300      	movs	r3, #0
 804a0c8:	3a04      	subs	r2, #4
 804a0ca:	e002      	b.n	804a0d2 <kad_avg+0x4e>
 804a0cc:	3301      	adds	r3, #1
 804a0ce:	4298      	cmp	r0, r3
 804a0d0:	d00a      	beq.n	804a0e8 <kad_avg+0x64>
		if (kad_is_back(s->child[i]))
 804a0d2:	f852 1f04 	ldr.w	r1, [r2, #4]!
 804a0d6:	7849      	ldrb	r1, [r1, #1]
 804a0d8:	07c9      	lsls	r1, r1, #31
 804a0da:	d5f7      	bpl.n	804a0cc <kad_avg+0x48>
	if (i < s->n_child) s->flag |= KAD_VAR;
 804a0dc:	4283      	cmp	r3, r0
 804a0de:	da03      	bge.n	804a0e8 <kad_avg+0x64>
 804a0e0:	7863      	ldrb	r3, [r4, #1]
 804a0e2:	f043 0301 	orr.w	r3, r3, #1
 804a0e6:	7063      	strb	r3, [r4, #1]
kad_node_t *kad_avg(int n, kad_node_t **x)   { return kad_pooling_general(10, n, x); }
 804a0e8:	4620      	mov	r0, r4
 804a0ea:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		s->child = (kad_node_t**)calloc(s->n_child, sizeof(kad_node_t*));
 804a0ec:	2104      	movs	r1, #4
 804a0ee:	4628      	mov	r0, r5
 804a0f0:	f001 fb5a 	bl	804b7a8 <calloc>
		heapSize += s->n_child * sizeof(kad_node_t*);
 804a0f4:	6833      	ldr	r3, [r6, #0]
	for (i = 0; i < n; ++i)
 804a0f6:	2d00      	cmp	r5, #0
		heapSize += s->n_child * sizeof(kad_node_t*);
 804a0f8:	eb03 0385 	add.w	r3, r3, r5, lsl #2
 804a0fc:	6033      	str	r3, [r6, #0]
	s->flag |= KAD_POOL;
 804a0fe:	7863      	ldrb	r3, [r4, #1]
		s->child = (kad_node_t**)calloc(s->n_child, sizeof(kad_node_t*));
 804a100:	63a0      	str	r0, [r4, #56]	@ 0x38
	s->flag |= KAD_POOL;
 804a102:	f043 0304 	orr.w	r3, r3, #4
 804a106:	7063      	strb	r3, [r4, #1]
		heapSize += s->n_child * sizeof(kad_node_t*);
 804a108:	ea4f 0285 	mov.w	r2, r5, lsl #2
	for (i = 0; i < n; ++i)
 804a10c:	ddd0      	ble.n	804a0b0 <kad_avg+0x2c>
		s->child[i] = x[i];
 804a10e:	4639      	mov	r1, r7
 804a110:	f001 ff51 	bl	804bfb6 <memcpy>
 804a114:	e7cc      	b.n	804a0b0 <kad_avg+0x2c>
		if (s->ptr) free(s->ptr);
 804a116:	6b20      	ldr	r0, [r4, #48]	@ 0x30
 804a118:	b108      	cbz	r0, 804a11e <kad_avg+0x9a>
 804a11a:	f001 fb69 	bl	804b7f0 <free>
		free(s->child); free(s);
 804a11e:	6ba0      	ldr	r0, [r4, #56]	@ 0x38
 804a120:	f001 fb66 	bl	804b7f0 <free>
 804a124:	4620      	mov	r0, r4
 804a126:	2400      	movs	r4, #0
 804a128:	f001 fb62 	bl	804b7f0 <free>
kad_node_t *kad_avg(int n, kad_node_t **x)   { return kad_pooling_general(10, n, x); }
 804a12c:	4620      	mov	r0, r4
 804a12e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 804a130:	20018344 	.word	0x20018344
 804a134:	20018004 	.word	0x20018004

0804a138 <kad_sync_dim>:
{
 804a138:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	for (i = 0; i < n; ++i) {
 804a13c:	1e06      	subs	r6, r0, #0
{
 804a13e:	4617      	mov	r7, r2
	for (i = 0; i < n; ++i) {
 804a140:	dd5a      	ble.n	804a1f8 <kad_sync_dim+0xc0>
 804a142:	2a00      	cmp	r2, #0
 804a144:	4689      	mov	r9, r1
 804a146:	f1a1 0404 	sub.w	r4, r1, #4
 804a14a:	dd3d      	ble.n	804a1c8 <kad_sync_dim+0x90>
	int i, req_alloc = 0, req_sync = 0, old_size = 0;
 804a14c:	f04f 0800 	mov.w	r8, #0
 804a150:	46a3      	mov	fp, r4
 804a152:	46c2      	mov	sl, r8
	for (i = 0; i < n; ++i) {
 804a154:	4645      	mov	r5, r8
		if (kad_is_feed(v[i])) {
 804a156:	f85b 0f04 	ldr.w	r0, [fp, #4]!
 804a15a:	6842      	ldr	r2, [r0, #4]
 804a15c:	2a00      	cmp	r2, #0
 804a15e:	d125      	bne.n	804a1ac <kad_sync_dim+0x74>
 804a160:	7842      	ldrb	r2, [r0, #1]
 804a162:	0793      	lsls	r3, r2, #30
 804a164:	d106      	bne.n	804a174 <kad_sync_dim+0x3c>
			old_size = v[i]->d[0]; /* TODO: check if all feeds have the same batch size */
 804a166:	f8d0 8010 	ldr.w	r8, [r0, #16]
			if (batch_size > 0 && v[i]->d[0] != batch_size)
 804a16a:	4547      	cmp	r7, r8
 804a16c:	d002      	beq.n	804a174 <kad_sync_dim+0x3c>
				v[i]->d[0] = batch_size, req_sync = 1;
 804a16e:	f04f 0a01 	mov.w	sl, #1
 804a172:	6107      	str	r7, [r0, #16]
	for (i = 0; i < n; ++i) {
 804a174:	3501      	adds	r5, #1
 804a176:	42ae      	cmp	r6, r5
 804a178:	d1ed      	bne.n	804a156 <kad_sync_dim+0x1e>
 804a17a:	00b1      	lsls	r1, r6, #2
	if (old_size < batch_size) req_alloc = 1;
 804a17c:	45b8      	cmp	r8, r7
 804a17e:	4623      	mov	r3, r4
 804a180:	bfac      	ite	ge
 804a182:	2200      	movge	r2, #0
 804a184:	2201      	movlt	r2, #1
	for (i = 0; i < n; ++i)
 804a186:	4421      	add	r1, r4
		if (v[i]->n_child > 0 && v[i]->x == 0) req_alloc = 1;
 804a188:	f853 4f04 	ldr.w	r4, [r3, #4]!
 804a18c:	6860      	ldr	r0, [r4, #4]
 804a18e:	2800      	cmp	r0, #0
 804a190:	dd03      	ble.n	804a19a <kad_sync_dim+0x62>
 804a192:	6aa0      	ldr	r0, [r4, #40]	@ 0x28
 804a194:	2800      	cmp	r0, #0
 804a196:	bf08      	it	eq
 804a198:	2201      	moveq	r2, #1
	for (i = 0; i < n; ++i)
 804a19a:	4299      	cmp	r1, r3
 804a19c:	d1f4      	bne.n	804a188 <kad_sync_dim+0x50>
	if (req_alloc) kad_allocate_internal(n, v);
 804a19e:	bb32      	cbnz	r2, 804a1ee <kad_sync_dim+0xb6>
	return batch_size > 0? batch_size : old_size;
 804a1a0:	2f00      	cmp	r7, #0
 804a1a2:	dd00      	ble.n	804a1a6 <kad_sync_dim+0x6e>
	int i, req_alloc = 0, req_sync = 0, old_size = 0;
 804a1a4:	46b8      	mov	r8, r7
}
 804a1a6:	4640      	mov	r0, r8
 804a1a8:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		} else if (v[i]->n_child > 0 && req_sync)
 804a1ac:	dde2      	ble.n	804a174 <kad_sync_dim+0x3c>
 804a1ae:	f1ba 0f00 	cmp.w	sl, #0
 804a1b2:	d0df      	beq.n	804a174 <kad_sync_dim+0x3c>
			kad_op_list[v[i]->op](v[i], KAD_SYNC_DIM);
 804a1b4:	8842      	ldrh	r2, [r0, #2]
 804a1b6:	4b14      	ldr	r3, [pc, #80]	@ (804a208 <kad_sync_dim+0xd0>)
 804a1b8:	2104      	movs	r1, #4
 804a1ba:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
	for (i = 0; i < n; ++i) {
 804a1be:	3501      	adds	r5, #1
			kad_op_list[v[i]->op](v[i], KAD_SYNC_DIM);
 804a1c0:	4790      	blx	r2
	for (i = 0; i < n; ++i) {
 804a1c2:	42ae      	cmp	r6, r5
 804a1c4:	d1c7      	bne.n	804a156 <kad_sync_dim+0x1e>
 804a1c6:	e7d8      	b.n	804a17a <kad_sync_dim+0x42>
 804a1c8:	4623      	mov	r3, r4
	int i, req_alloc = 0, req_sync = 0, old_size = 0;
 804a1ca:	f04f 0800 	mov.w	r8, #0
 804a1ce:	00b1      	lsls	r1, r6, #2
 804a1d0:	eb04 0586 	add.w	r5, r4, r6, lsl #2
		if (kad_is_feed(v[i])) {
 804a1d4:	f853 0f04 	ldr.w	r0, [r3, #4]!
 804a1d8:	6842      	ldr	r2, [r0, #4]
 804a1da:	b92a      	cbnz	r2, 804a1e8 <kad_sync_dim+0xb0>
 804a1dc:	7842      	ldrb	r2, [r0, #1]
 804a1de:	f012 0f03 	tst.w	r2, #3
			old_size = v[i]->d[0]; /* TODO: check if all feeds have the same batch size */
 804a1e2:	bf08      	it	eq
 804a1e4:	f8d0 8010 	ldreq.w	r8, [r0, #16]
	for (i = 0; i < n; ++i) {
 804a1e8:	42ab      	cmp	r3, r5
 804a1ea:	d1f3      	bne.n	804a1d4 <kad_sync_dim+0x9c>
 804a1ec:	e7c6      	b.n	804a17c <kad_sync_dim+0x44>
	if (req_alloc) kad_allocate_internal(n, v);
 804a1ee:	4649      	mov	r1, r9
 804a1f0:	4630      	mov	r0, r6
 804a1f2:	f7fc fb87 	bl	8046904 <kad_allocate_internal>
 804a1f6:	e7d3      	b.n	804a1a0 <kad_sync_dim+0x68>
 804a1f8:	2a00      	cmp	r2, #0
 804a1fa:	dc02      	bgt.n	804a202 <kad_sync_dim+0xca>
	int i, req_alloc = 0, req_sync = 0, old_size = 0;
 804a1fc:	f04f 0800 	mov.w	r8, #0
	return batch_size > 0? batch_size : old_size;
 804a200:	e7d1      	b.n	804a1a6 <kad_sync_dim+0x6e>
	if (req_alloc) kad_allocate_internal(n, v);
 804a202:	f7fc fb7f 	bl	8046904 <kad_allocate_internal>
	return batch_size > 0? batch_size : old_size;
 804a206:	e7cd      	b.n	804a1a4 <kad_sync_dim+0x6c>
 804a208:	20018004 	.word	0x20018004

0804a20c <kad_compile_array>:
{
 804a20c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	for (i = 0; i < n_roots; ++i) {
 804a210:	1e0b      	subs	r3, r1, #0
{
 804a212:	b085      	sub	sp, #20
 804a214:	9003      	str	r0, [sp, #12]
	for (i = 0; i < n_roots; ++i) {
 804a216:	9301      	str	r3, [sp, #4]
 804a218:	f340 80f0 	ble.w	804a3fc <kad_compile_array+0x1f0>
	kvec_t(kad_node_p) stack = {0,0,0}, a = {0,0,0};
 804a21c:	2700      	movs	r7, #0
 804a21e:	1f13      	subs	r3, r2, #4
 804a220:	461e      	mov	r6, r3
	for (i = 0; i < n_roots; ++i) {
 804a222:	4698      	mov	r8, r3
		roots[i]->tmp = 1; /* mark the root */
 804a224:	f04f 0a01 	mov.w	sl, #1
	for (i = 0; i < n_roots; ++i) {
 804a228:	463c      	mov	r4, r7
	kvec_t(kad_node_p) stack = {0,0,0}, a = {0,0,0};
 804a22a:	46b9      	mov	r9, r7
 804a22c:	9302      	str	r3, [sp, #8]
 804a22e:	e005      	b.n	804a23c <kad_compile_array+0x30>
	for (i = 0; i < n_roots; ++i) {
 804a230:	9b01      	ldr	r3, [sp, #4]
		kv_push(kad_node_p, stack, roots[i]);
 804a232:	f847 5024 	str.w	r5, [r7, r4, lsl #2]
	for (i = 0; i < n_roots; ++i) {
 804a236:	3401      	adds	r4, #1
 804a238:	42a3      	cmp	r3, r4
 804a23a:	d013      	beq.n	804a264 <kad_compile_array+0x58>
		roots[i]->tmp = 1; /* mark the root */
 804a23c:	f858 5f04 	ldr.w	r5, [r8, #4]!
		kv_push(kad_node_p, stack, roots[i]);
 804a240:	454c      	cmp	r4, r9
		roots[i]->tmp = 1; /* mark the root */
 804a242:	f8c5 a008 	str.w	sl, [r5, #8]
		kv_push(kad_node_p, stack, roots[i]);
 804a246:	d1f3      	bne.n	804a230 <kad_compile_array+0x24>
 804a248:	b394      	cbz	r4, 804a2b0 <kad_compile_array+0xa4>
 804a24a:	ea4f 0944 	mov.w	r9, r4, lsl #1
 804a24e:	00e1      	lsls	r1, r4, #3
 804a250:	4638      	mov	r0, r7
 804a252:	f001 fbb1 	bl	804b9b8 <realloc>
 804a256:	4607      	mov	r7, r0
	for (i = 0; i < n_roots; ++i) {
 804a258:	9b01      	ldr	r3, [sp, #4]
		kv_push(kad_node_p, stack, roots[i]);
 804a25a:	f847 5024 	str.w	r5, [r7, r4, lsl #2]
	for (i = 0; i < n_roots; ++i) {
 804a25e:	3401      	adds	r4, #1
 804a260:	42a3      	cmp	r3, r4
 804a262:	d1eb      	bne.n	804a23c <kad_compile_array+0x30>
 804a264:	f103 38ff 	add.w	r8, r3, #4294967295
		for (i = 0; i < p->n_child; ++i) {
 804a268:	686a      	ldr	r2, [r5, #4]
 804a26a:	2a00      	cmp	r2, #0
 804a26c:	dd24      	ble.n	804a2b8 <kad_compile_array+0xac>
			kad_node_t *q = p->child[i];
 804a26e:	6bab      	ldr	r3, [r5, #56]	@ 0x38
 804a270:	f1a3 0b04 	sub.w	fp, r3, #4
 804a274:	eb0b 0a82 	add.w	sl, fp, r2, lsl #2
 804a278:	e007      	b.n	804a28a <kad_compile_array+0x7e>
			if (q->tmp == 0) kv_push(kad_node_p, stack, q);
 804a27a:	f847 5028 	str.w	r5, [r7, r8, lsl #2]
 804a27e:	f108 0801 	add.w	r8, r8, #1
			q->tmp += 1<<1;
 804a282:	3402      	adds	r4, #2
		for (i = 0; i < p->n_child; ++i) {
 804a284:	45da      	cmp	sl, fp
			q->tmp += 1<<1;
 804a286:	60ac      	str	r4, [r5, #8]
		for (i = 0; i < p->n_child; ++i) {
 804a288:	d016      	beq.n	804a2b8 <kad_compile_array+0xac>
			kad_node_t *q = p->child[i];
 804a28a:	f85b 5f04 	ldr.w	r5, [fp, #4]!
			if (q->tmp == 0) kv_push(kad_node_p, stack, q);
 804a28e:	68ac      	ldr	r4, [r5, #8]
 804a290:	2c00      	cmp	r4, #0
 804a292:	d1f6      	bne.n	804a282 <kad_compile_array+0x76>
 804a294:	45c1      	cmp	r9, r8
 804a296:	d1f0      	bne.n	804a27a <kad_compile_array+0x6e>
 804a298:	f1b9 0f00 	cmp.w	r9, #0
 804a29c:	d014      	beq.n	804a2c8 <kad_compile_array+0xbc>
 804a29e:	ea4f 0949 	mov.w	r9, r9, lsl #1
 804a2a2:	ea4f 0189 	mov.w	r1, r9, lsl #2
 804a2a6:	4638      	mov	r0, r7
 804a2a8:	f001 fb86 	bl	804b9b8 <realloc>
 804a2ac:	4607      	mov	r7, r0
 804a2ae:	e7e4      	b.n	804a27a <kad_compile_array+0x6e>
 804a2b0:	2108      	movs	r1, #8
		kv_push(kad_node_p, stack, roots[i]);
 804a2b2:	f04f 0902 	mov.w	r9, #2
 804a2b6:	e7cb      	b.n	804a250 <kad_compile_array+0x44>
	while (stack.n) {
 804a2b8:	f1b8 0f00 	cmp.w	r8, #0
 804a2bc:	d008      	beq.n	804a2d0 <kad_compile_array+0xc4>
		kad_node_t *p = kv_pop(stack);
 804a2be:	f108 38ff 	add.w	r8, r8, #4294967295
 804a2c2:	f857 5028 	ldr.w	r5, [r7, r8, lsl #2]
 804a2c6:	e7cf      	b.n	804a268 <kad_compile_array+0x5c>
 804a2c8:	2108      	movs	r1, #8
			if (q->tmp == 0) kv_push(kad_node_p, stack, q);
 804a2ca:	f04f 0902 	mov.w	r9, #2
 804a2ce:	e7ea      	b.n	804a2a6 <kad_compile_array+0x9a>
 804a2d0:	e9dd 2301 	ldrd	r2, r3, [sp, #4]
	while (stack.n) {
 804a2d4:	4644      	mov	r4, r8
 804a2d6:	eb03 0a82 	add.w	sl, r3, r2, lsl #2
 804a2da:	e004      	b.n	804a2e6 <kad_compile_array+0xda>
			kv_push(kad_node_p, stack, roots[i]);
 804a2dc:	f847 5024 	str.w	r5, [r7, r4, lsl #2]
 804a2e0:	3401      	adds	r4, #1
	for (i = 0; i < n_roots; ++i)
 804a2e2:	45b2      	cmp	sl, r6
 804a2e4:	d010      	beq.n	804a308 <kad_compile_array+0xfc>
		if (roots[i]->tmp>>1 == 0) /* if roots[i]->tmp>>1 != 0, it is not a real root */
 804a2e6:	f856 5f04 	ldr.w	r5, [r6, #4]!
 804a2ea:	68ab      	ldr	r3, [r5, #8]
 804a2ec:	085b      	lsrs	r3, r3, #1
 804a2ee:	d1f8      	bne.n	804a2e2 <kad_compile_array+0xd6>
			kv_push(kad_node_p, stack, roots[i]);
 804a2f0:	454c      	cmp	r4, r9
 804a2f2:	d1f3      	bne.n	804a2dc <kad_compile_array+0xd0>
 804a2f4:	2c00      	cmp	r4, #0
 804a2f6:	d07d      	beq.n	804a3f4 <kad_compile_array+0x1e8>
 804a2f8:	ea4f 0944 	mov.w	r9, r4, lsl #1
 804a2fc:	00e1      	lsls	r1, r4, #3
 804a2fe:	4638      	mov	r0, r7
 804a300:	f001 fb5a 	bl	804b9b8 <realloc>
 804a304:	4607      	mov	r7, r0
 804a306:	e7e9      	b.n	804a2dc <kad_compile_array+0xd0>
	while (stack.n) {
 804a308:	2c00      	cmp	r4, #0
 804a30a:	d078      	beq.n	804a3fe <kad_compile_array+0x1f2>
	kvec_t(kad_node_p) stack = {0,0,0}, a = {0,0,0};
 804a30c:	f04f 0b00 	mov.w	fp, #0
 804a310:	f8cd b004 	str.w	fp, [sp, #4]
		kad_node_t *p = kv_pop(stack);
 804a314:	3c01      	subs	r4, #1
		kv_push(kad_node_p, a, p);
 804a316:	45c3      	cmp	fp, r8
		kad_node_t *p = kv_pop(stack);
 804a318:	f857 5024 	ldr.w	r5, [r7, r4, lsl #2]
		kv_push(kad_node_p, a, p);
 804a31c:	d05a      	beq.n	804a3d4 <kad_compile_array+0x1c8>
		for (i = 0; i < p->n_child; ++i) {
 804a31e:	686b      	ldr	r3, [r5, #4]
		kv_push(kad_node_p, a, p);
 804a320:	9a01      	ldr	r2, [sp, #4]
 804a322:	f10b 0b01 	add.w	fp, fp, #1
 804a326:	eb02 028b 	add.w	r2, r2, fp, lsl #2
		for (i = 0; i < p->n_child; ++i) {
 804a32a:	2b00      	cmp	r3, #0
		kv_push(kad_node_p, a, p);
 804a32c:	9202      	str	r2, [sp, #8]
 804a32e:	f842 5c04 	str.w	r5, [r2, #-4]
		for (i = 0; i < p->n_child; ++i) {
 804a332:	dd1c      	ble.n	804a36e <kad_compile_array+0x162>
			p->child[i]->tmp -= 1<<1;
 804a334:	6bae      	ldr	r6, [r5, #56]	@ 0x38
 804a336:	3e04      	subs	r6, #4
 804a338:	eb06 0a83 	add.w	sl, r6, r3, lsl #2
 804a33c:	e004      	b.n	804a348 <kad_compile_array+0x13c>
				kv_push(kad_node_p, stack, p->child[i]);
 804a33e:	f847 5024 	str.w	r5, [r7, r4, lsl #2]
 804a342:	3401      	adds	r4, #1
		for (i = 0; i < p->n_child; ++i) {
 804a344:	45b2      	cmp	sl, r6
 804a346:	d012      	beq.n	804a36e <kad_compile_array+0x162>
			p->child[i]->tmp -= 1<<1;
 804a348:	f856 5f04 	ldr.w	r5, [r6, #4]!
 804a34c:	68a9      	ldr	r1, [r5, #8]
 804a34e:	3902      	subs	r1, #2
 804a350:	60a9      	str	r1, [r5, #8]
			if (p->child[i]->tmp>>1 == 0)
 804a352:	0849      	lsrs	r1, r1, #1
 804a354:	d1f6      	bne.n	804a344 <kad_compile_array+0x138>
				kv_push(kad_node_p, stack, p->child[i]);
 804a356:	454c      	cmp	r4, r9
 804a358:	d1f1      	bne.n	804a33e <kad_compile_array+0x132>
 804a35a:	2c00      	cmp	r4, #0
 804a35c:	d036      	beq.n	804a3cc <kad_compile_array+0x1c0>
 804a35e:	ea4f 0944 	mov.w	r9, r4, lsl #1
 804a362:	00e1      	lsls	r1, r4, #3
 804a364:	4638      	mov	r0, r7
 804a366:	f001 fb27 	bl	804b9b8 <realloc>
 804a36a:	4607      	mov	r7, r0
 804a36c:	e7e7      	b.n	804a33e <kad_compile_array+0x132>
	while (stack.n) {
 804a36e:	2c00      	cmp	r4, #0
 804a370:	d1d0      	bne.n	804a314 <kad_compile_array+0x108>
	free(stack.a);
 804a372:	4638      	mov	r0, r7
 804a374:	f001 fa3c 	bl	804b7f0 <free>
	for (i = 0; i < (int)a.n; ++i) { /* check cycles; no cycles if constructed with kad_add() etc */
 804a378:	f1bb 0f00 	cmp.w	fp, #0
 804a37c:	dd4d      	ble.n	804a41a <kad_compile_array+0x20e>
 804a37e:	9b01      	ldr	r3, [sp, #4]
 804a380:	1f1d      	subs	r5, r3, #4
 804a382:	4628      	mov	r0, r5
		assert(a.a[i]->tmp>>1 == 0);
 804a384:	f850 1f04 	ldr.w	r1, [r0, #4]!
 804a388:	688b      	ldr	r3, [r1, #8]
 804a38a:	105b      	asrs	r3, r3, #1
 804a38c:	d13e      	bne.n	804a40c <kad_compile_array+0x200>
	for (i = 0; i < (int)a.n; ++i) { /* check cycles; no cycles if constructed with kad_add() etc */
 804a38e:	3401      	adds	r4, #1
 804a390:	45a3      	cmp	fp, r4
		a.a[i]->tmp = 0;
 804a392:	608b      	str	r3, [r1, #8]
	for (i = 0; i < (int)a.n; ++i) { /* check cycles; no cycles if constructed with kad_add() etc */
 804a394:	d1f6      	bne.n	804a384 <kad_compile_array+0x178>
	for (i = 0; i < (int)a.n>>1; ++i) { /* reverse a.a[] */
 804a396:	1061      	asrs	r1, r4, #1
 804a398:	d03f      	beq.n	804a41a <kad_compile_array+0x20e>
 804a39a:	e9dd 3a01 	ldrd	r3, sl, [sp, #4]
 804a39e:	eb03 0181 	add.w	r1, r3, r1, lsl #2
 804a3a2:	3904      	subs	r1, #4
		t = a.a[i], a.a[i] = a.a[a.n-1-i], a.a[a.n-1-i] = t;
 804a3a4:	f855 3f04 	ldr.w	r3, [r5, #4]!
 804a3a8:	f85a 2d04 	ldr.w	r2, [sl, #-4]!
	for (i = 0; i < (int)a.n>>1; ++i) { /* reverse a.a[] */
 804a3ac:	42a9      	cmp	r1, r5
		t = a.a[i], a.a[i] = a.a[a.n-1-i], a.a[a.n-1-i] = t;
 804a3ae:	602a      	str	r2, [r5, #0]
 804a3b0:	f8ca 3000 	str.w	r3, [sl]
	for (i = 0; i < (int)a.n>>1; ++i) { /* reverse a.a[] */
 804a3b4:	d1f6      	bne.n	804a3a4 <kad_compile_array+0x198>
	kad_allocate_internal(a.n, a.a);
 804a3b6:	9d01      	ldr	r5, [sp, #4]
 804a3b8:	4620      	mov	r0, r4
 804a3ba:	4629      	mov	r1, r5
 804a3bc:	f7fc faa2 	bl	8046904 <kad_allocate_internal>
}
 804a3c0:	4628      	mov	r0, r5
	*n_node = a.n;
 804a3c2:	9b03      	ldr	r3, [sp, #12]
 804a3c4:	601c      	str	r4, [r3, #0]
}
 804a3c6:	b005      	add	sp, #20
 804a3c8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 804a3cc:	2108      	movs	r1, #8
				kv_push(kad_node_p, stack, p->child[i]);
 804a3ce:	f04f 0902 	mov.w	r9, #2
 804a3d2:	e7c7      	b.n	804a364 <kad_compile_array+0x158>
		kv_push(kad_node_p, a, p);
 804a3d4:	f1bb 0f00 	cmp.w	fp, #0
 804a3d8:	d008      	beq.n	804a3ec <kad_compile_array+0x1e0>
 804a3da:	ea4f 084b 	mov.w	r8, fp, lsl #1
 804a3de:	ea4f 01cb 	mov.w	r1, fp, lsl #3
 804a3e2:	9801      	ldr	r0, [sp, #4]
 804a3e4:	f001 fae8 	bl	804b9b8 <realloc>
 804a3e8:	9001      	str	r0, [sp, #4]
 804a3ea:	e798      	b.n	804a31e <kad_compile_array+0x112>
 804a3ec:	2108      	movs	r1, #8
 804a3ee:	f04f 0802 	mov.w	r8, #2
 804a3f2:	e7f6      	b.n	804a3e2 <kad_compile_array+0x1d6>
 804a3f4:	2108      	movs	r1, #8
			kv_push(kad_node_p, stack, roots[i]);
 804a3f6:	f04f 0902 	mov.w	r9, #2
 804a3fa:	e780      	b.n	804a2fe <kad_compile_array+0xf2>
	for (i = 0; i < n_roots; ++i) {
 804a3fc:	2700      	movs	r7, #0
	free(stack.a);
 804a3fe:	2300      	movs	r3, #0
 804a400:	4638      	mov	r0, r7
 804a402:	461c      	mov	r4, r3
 804a404:	9301      	str	r3, [sp, #4]
 804a406:	f001 f9f3 	bl	804b7f0 <free>
	for (i = 0; i < (int)a.n>>1; ++i) { /* reverse a.a[] */
 804a40a:	e7d4      	b.n	804a3b6 <kad_compile_array+0x1aa>
		assert(a.a[i]->tmp>>1 == 0);
 804a40c:	f44f 71f1 	mov.w	r1, #482	@ 0x1e2
 804a410:	4b03      	ldr	r3, [pc, #12]	@ (804a420 <kad_compile_array+0x214>)
 804a412:	4a04      	ldr	r2, [pc, #16]	@ (804a424 <kad_compile_array+0x218>)
 804a414:	4804      	ldr	r0, [pc, #16]	@ (804a428 <kad_compile_array+0x21c>)
 804a416:	f001 f9a9 	bl	804b76c <__assert_func>
	for (i = 0; i < (int)a.n; ++i) { /* check cycles; no cycles if constructed with kad_add() etc */
 804a41a:	465c      	mov	r4, fp
 804a41c:	e7cb      	b.n	804a3b6 <kad_compile_array+0x1aa>
 804a41e:	bf00      	nop
 804a420:	0804e3e8 	.word	0x0804e3e8
 804a424:	0804e534 	.word	0x0804e534
 804a428:	0804e328 	.word	0x0804e328

0804a42c <kad_delete>:
{
 804a42c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	for (i = 0; i < n; ++i) {
 804a42e:	1e06      	subs	r6, r0, #0
{
 804a430:	460f      	mov	r7, r1
	for (i = 0; i < n; ++i) {
 804a432:	dd1d      	ble.n	804a470 <kad_delete+0x44>
 804a434:	1f0d      	subs	r5, r1, #4
 804a436:	eb05 0686 	add.w	r6, r5, r6, lsl #2
 804a43a:	e00d      	b.n	804a458 <kad_delete+0x2c>
		free(p->child); free(p->ptr); free(p->gtmp); free(p);
 804a43c:	6ba0      	ldr	r0, [r4, #56]	@ 0x38
 804a43e:	f001 f9d7 	bl	804b7f0 <free>
 804a442:	6b20      	ldr	r0, [r4, #48]	@ 0x30
 804a444:	f001 f9d4 	bl	804b7f0 <free>
 804a448:	6b60      	ldr	r0, [r4, #52]	@ 0x34
 804a44a:	f001 f9d1 	bl	804b7f0 <free>
 804a44e:	4620      	mov	r0, r4
 804a450:	f001 f9ce 	bl	804b7f0 <free>
	for (i = 0; i < n; ++i) {
 804a454:	42b5      	cmp	r5, r6
 804a456:	d00b      	beq.n	804a470 <kad_delete+0x44>
		kad_node_t *p = a[i];
 804a458:	f855 4f04 	ldr.w	r4, [r5, #4]!
		if (p->n_child) {
 804a45c:	6863      	ldr	r3, [r4, #4]
 804a45e:	2b00      	cmp	r3, #0
 804a460:	d0ec      	beq.n	804a43c <kad_delete+0x10>
			free(p->x); free(p->g);
 804a462:	6aa0      	ldr	r0, [r4, #40]	@ 0x28
 804a464:	f001 f9c4 	bl	804b7f0 <free>
 804a468:	6ae0      	ldr	r0, [r4, #44]	@ 0x2c
 804a46a:	f001 f9c1 	bl	804b7f0 <free>
		free(p->child); free(p->ptr); free(p->gtmp); free(p);
 804a46e:	e7e5      	b.n	804a43c <kad_delete+0x10>
	free(a);
 804a470:	4638      	mov	r0, r7
}
 804a472:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	free(a);
 804a476:	f001 b9bb 	b.w	804b7f0 <free>
 804a47a:	bf00      	nop

0804a47c <kad_size_var>:
	for (i = c = 0; i < n; ++i)
 804a47c:	f1b0 0c00 	subs.w	ip, r0, #0
 804a480:	f04f 0000 	mov.w	r0, #0
 804a484:	dd32      	ble.n	804a4ec <kad_size_var+0x70>
 804a486:	3904      	subs	r1, #4
 804a488:	eb01 0c8c 	add.w	ip, r1, ip, lsl #2
 804a48c:	e001      	b.n	804a492 <kad_size_var+0x16>
 804a48e:	4561      	cmp	r1, ip
 804a490:	d029      	beq.n	804a4e6 <kad_size_var+0x6a>
		if (kad_is_var(v[i]))
 804a492:	f851 3f04 	ldr.w	r3, [r1, #4]!
 804a496:	685a      	ldr	r2, [r3, #4]
 804a498:	2a00      	cmp	r2, #0
 804a49a:	d1f8      	bne.n	804a48e <kad_size_var+0x12>
 804a49c:	785a      	ldrb	r2, [r3, #1]
 804a49e:	07d2      	lsls	r2, r2, #31
 804a4a0:	d5f5      	bpl.n	804a48e <kad_size_var+0x12>
{
 804a4a2:	b430      	push	{r4, r5}
 804a4a4:	781c      	ldrb	r4, [r3, #0]
 804a4a6:	b1fc      	cbz	r4, 804a4e8 <kad_size_var+0x6c>
 804a4a8:	2c01      	cmp	r4, #1
 804a4aa:	691a      	ldr	r2, [r3, #16]
 804a4ac:	d00c      	beq.n	804a4c8 <kad_size_var+0x4c>
 804a4ae:	695d      	ldr	r5, [r3, #20]
 804a4b0:	2c02      	cmp	r4, #2
 804a4b2:	fb05 f202 	mul.w	r2, r5, r2
 804a4b6:	d007      	beq.n	804a4c8 <kad_size_var+0x4c>
 804a4b8:	699d      	ldr	r5, [r3, #24]
 804a4ba:	2c03      	cmp	r4, #3
 804a4bc:	fb05 f202 	mul.w	r2, r5, r2
 804a4c0:	d002      	beq.n	804a4c8 <kad_size_var+0x4c>
 804a4c2:	69db      	ldr	r3, [r3, #28]
 804a4c4:	fb03 f202 	mul.w	r2, r3, r2
			c += kad_len(v[i]);
 804a4c8:	4410      	add	r0, r2
	for (i = c = 0; i < n; ++i)
 804a4ca:	4561      	cmp	r1, ip
 804a4cc:	d009      	beq.n	804a4e2 <kad_size_var+0x66>
		if (kad_is_var(v[i]))
 804a4ce:	f851 3f04 	ldr.w	r3, [r1, #4]!
 804a4d2:	685a      	ldr	r2, [r3, #4]
 804a4d4:	2a00      	cmp	r2, #0
 804a4d6:	d1f8      	bne.n	804a4ca <kad_size_var+0x4e>
 804a4d8:	785a      	ldrb	r2, [r3, #1]
 804a4da:	07d4      	lsls	r4, r2, #31
 804a4dc:	d4e2      	bmi.n	804a4a4 <kad_size_var+0x28>
	for (i = c = 0; i < n; ++i)
 804a4de:	4561      	cmp	r1, ip
 804a4e0:	d1f5      	bne.n	804a4ce <kad_size_var+0x52>
}
 804a4e2:	bc30      	pop	{r4, r5}
 804a4e4:	4770      	bx	lr
 804a4e6:	4770      	bx	lr
	int n = 1, i;
 804a4e8:	2201      	movs	r2, #1
 804a4ea:	e7ed      	b.n	804a4c8 <kad_size_var+0x4c>
	return c;
 804a4ec:	4770      	bx	lr
 804a4ee:	bf00      	nop

0804a4f0 <kad_size_const>:
	for (i = c = 0; i < n; ++i)
 804a4f0:	f1b0 0c00 	subs.w	ip, r0, #0
 804a4f4:	f04f 0000 	mov.w	r0, #0
 804a4f8:	dd32      	ble.n	804a560 <kad_size_const+0x70>
 804a4fa:	3904      	subs	r1, #4
 804a4fc:	eb01 0c8c 	add.w	ip, r1, ip, lsl #2
 804a500:	e001      	b.n	804a506 <kad_size_const+0x16>
 804a502:	4561      	cmp	r1, ip
 804a504:	d029      	beq.n	804a55a <kad_size_const+0x6a>
		if (kad_is_const(v[i]))
 804a506:	f851 3f04 	ldr.w	r3, [r1, #4]!
 804a50a:	685a      	ldr	r2, [r3, #4]
 804a50c:	2a00      	cmp	r2, #0
 804a50e:	d1f8      	bne.n	804a502 <kad_size_const+0x12>
 804a510:	785a      	ldrb	r2, [r3, #1]
 804a512:	0792      	lsls	r2, r2, #30
 804a514:	d5f5      	bpl.n	804a502 <kad_size_const+0x12>
{
 804a516:	b430      	push	{r4, r5}
	for (i = 0; i < p->n_d; ++i) n *= p->d[i];
 804a518:	781c      	ldrb	r4, [r3, #0]
 804a51a:	b1fc      	cbz	r4, 804a55c <kad_size_const+0x6c>
 804a51c:	2c01      	cmp	r4, #1
 804a51e:	691a      	ldr	r2, [r3, #16]
 804a520:	d00c      	beq.n	804a53c <kad_size_const+0x4c>
 804a522:	695d      	ldr	r5, [r3, #20]
 804a524:	2c02      	cmp	r4, #2
 804a526:	fb05 f202 	mul.w	r2, r5, r2
 804a52a:	d007      	beq.n	804a53c <kad_size_const+0x4c>
 804a52c:	699d      	ldr	r5, [r3, #24]
 804a52e:	2c03      	cmp	r4, #3
 804a530:	fb05 f202 	mul.w	r2, r5, r2
 804a534:	d002      	beq.n	804a53c <kad_size_const+0x4c>
 804a536:	69db      	ldr	r3, [r3, #28]
 804a538:	fb03 f202 	mul.w	r2, r3, r2
			c += kad_len(v[i]);
 804a53c:	4410      	add	r0, r2
	for (i = c = 0; i < n; ++i)
 804a53e:	4561      	cmp	r1, ip
 804a540:	d009      	beq.n	804a556 <kad_size_const+0x66>
		if (kad_is_const(v[i]))
 804a542:	f851 3f04 	ldr.w	r3, [r1, #4]!
 804a546:	685a      	ldr	r2, [r3, #4]
 804a548:	2a00      	cmp	r2, #0
 804a54a:	d1f8      	bne.n	804a53e <kad_size_const+0x4e>
 804a54c:	785a      	ldrb	r2, [r3, #1]
 804a54e:	0794      	lsls	r4, r2, #30
 804a550:	d4e2      	bmi.n	804a518 <kad_size_const+0x28>
	for (i = c = 0; i < n; ++i)
 804a552:	4561      	cmp	r1, ip
 804a554:	d1f5      	bne.n	804a542 <kad_size_const+0x52>
}
 804a556:	bc30      	pop	{r4, r5}
 804a558:	4770      	bx	lr
 804a55a:	4770      	bx	lr
	int n = 1, i;
 804a55c:	2201      	movs	r2, #1
 804a55e:	e7ed      	b.n	804a53c <kad_size_const+0x4c>
	return c;
 804a560:	4770      	bx	lr
 804a562:	bf00      	nop

0804a564 <kad_eval_at>:
{
 804a564:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (from < 0 || from >= n) from = n - 1;
 804a568:	f1b2 0a00 	subs.w	sl, r2, #0
{
 804a56c:	4689      	mov	r9, r1
	if (from < 0 || from >= n) from = n - 1;
 804a56e:	db38      	blt.n	804a5e2 <kad_eval_at+0x7e>
 804a570:	4582      	cmp	sl, r0
 804a572:	da36      	bge.n	804a5e2 <kad_eval_at+0x7e>
 804a574:	f1a9 0804 	sub.w	r8, r9, #4
 804a578:	4645      	mov	r5, r8
{
 804a57a:	4643      	mov	r3, r8
	for (i = 0; i < n; ++i) a[i]->tmp = (i == from);
 804a57c:	2400      	movs	r4, #0
 804a57e:	eba4 060a 	sub.w	r6, r4, sl
 804a582:	fab6 f686 	clz	r6, r6
 804a586:	46a3      	mov	fp, r4
 804a588:	f853 1f04 	ldr.w	r1, [r3, #4]!
 804a58c:	3401      	adds	r4, #1
 804a58e:	0976      	lsrs	r6, r6, #5
 804a590:	42a0      	cmp	r0, r4
 804a592:	608e      	str	r6, [r1, #8]
 804a594:	d1f3      	bne.n	804a57e <kad_eval_at+0x1a>
	kad_propagate_marks(n, a);
 804a596:	4649      	mov	r1, r9
 804a598:	4620      	mov	r0, r4
 804a59a:	f7f8 fb0d 	bl	8042bb8 <kad_propagate_marks>
 804a59e:	4647      	mov	r7, r8
	for (i = 0; i < n; ++i)
 804a5a0:	2600      	movs	r6, #0
 804a5a2:	e000      	b.n	804a5a6 <kad_eval_at+0x42>
 804a5a4:	461e      	mov	r6, r3
		if (a[i]->n_child && a[i]->tmp > 0)
 804a5a6:	f857 0f04 	ldr.w	r0, [r7, #4]!
 804a5aa:	6843      	ldr	r3, [r0, #4]
 804a5ac:	b143      	cbz	r3, 804a5c0 <kad_eval_at+0x5c>
 804a5ae:	6883      	ldr	r3, [r0, #8]
 804a5b0:	2b00      	cmp	r3, #0
 804a5b2:	dd05      	ble.n	804a5c0 <kad_eval_at+0x5c>
			kad_op_list[a[i]->op](a[i], KAD_FORWARD);
 804a5b4:	8843      	ldrh	r3, [r0, #2]
 804a5b6:	4a11      	ldr	r2, [pc, #68]	@ (804a5fc <kad_eval_at+0x98>)
 804a5b8:	2102      	movs	r1, #2
 804a5ba:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 804a5be:	4798      	blx	r3
	for (i = 0; i < n; ++i)
 804a5c0:	455e      	cmp	r6, fp
 804a5c2:	f106 0301 	add.w	r3, r6, #1
 804a5c6:	d1ed      	bne.n	804a5a4 <kad_eval_at+0x40>
	for (i = 0; i < n; ++i) a[i]->tmp = 0;
 804a5c8:	2100      	movs	r1, #0
 804a5ca:	eb08 0884 	add.w	r8, r8, r4, lsl #2
 804a5ce:	f855 3f04 	ldr.w	r3, [r5, #4]!
 804a5d2:	45a8      	cmp	r8, r5
 804a5d4:	6099      	str	r1, [r3, #8]
 804a5d6:	d1fa      	bne.n	804a5ce <kad_eval_at+0x6a>
	return a[from]->x;
 804a5d8:	f859 302a 	ldr.w	r3, [r9, sl, lsl #2]
}
 804a5dc:	6a98      	ldr	r0, [r3, #40]	@ 0x28
 804a5de:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	for (i = 0; i < n; ++i) a[i]->tmp = (i == from);
 804a5e2:	2800      	cmp	r0, #0
	if (from < 0 || from >= n) from = n - 1;
 804a5e4:	f100 3aff 	add.w	sl, r0, #4294967295
	for (i = 0; i < n; ++i) a[i]->tmp = (i == from);
 804a5e8:	dcc4      	bgt.n	804a574 <kad_eval_at+0x10>
	kad_propagate_marks(n, a);
 804a5ea:	4649      	mov	r1, r9
 804a5ec:	f7f8 fae4 	bl	8042bb8 <kad_propagate_marks>
	return a[from]->x;
 804a5f0:	f859 302a 	ldr.w	r3, [r9, sl, lsl #2]
}
 804a5f4:	6a98      	ldr	r0, [r3, #40]	@ 0x28
 804a5f6:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 804a5fa:	bf00      	nop
 804a5fc:	20018004 	.word	0x20018004

0804a600 <kad_grad>:
{
 804a600:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	if (from < 0 || from >= n) from = n - 1;
 804a604:	1e15      	subs	r5, r2, #0
{
 804a606:	4688      	mov	r8, r1
	if (from < 0 || from >= n) from = n - 1;
 804a608:	db01      	blt.n	804a60e <kad_grad+0xe>
 804a60a:	4285      	cmp	r5, r0
 804a60c:	db63      	blt.n	804a6d6 <kad_grad+0xd6>
 804a60e:	1e45      	subs	r5, r0, #1
	assert(a[from]->n_d == 0);
 804a610:	f858 9025 	ldr.w	r9, [r8, r5, lsl #2]
 804a614:	ea4f 0a85 	mov.w	sl, r5, lsl #2
 804a618:	f899 3000 	ldrb.w	r3, [r9]
 804a61c:	eb08 0785 	add.w	r7, r8, r5, lsl #2
 804a620:	2b00      	cmp	r3, #0
 804a622:	d162      	bne.n	804a6ea <kad_grad+0xea>
	for (i = 0; i < n; ++i) a[i]->tmp = (i == from);
 804a624:	2800      	cmp	r0, #0
 804a626:	dd0c      	ble.n	804a642 <kad_grad+0x42>
 804a628:	2300      	movs	r3, #0
 804a62a:	f1a8 0204 	sub.w	r2, r8, #4
 804a62e:	1aee      	subs	r6, r5, r3
 804a630:	fab6 f686 	clz	r6, r6
 804a634:	f852 1f04 	ldr.w	r1, [r2, #4]!
 804a638:	3301      	adds	r3, #1
 804a63a:	0976      	lsrs	r6, r6, #5
 804a63c:	4298      	cmp	r0, r3
 804a63e:	608e      	str	r6, [r1, #8]
 804a640:	d1f5      	bne.n	804a62e <kad_grad+0x2e>
	kad_propagate_marks(n, a);
 804a642:	4641      	mov	r1, r8
 804a644:	f7f8 fab8 	bl	8042bb8 <kad_propagate_marks>
	for (i = 0; i <= from; ++i) /* set all grandients to zero */
 804a648:	2d00      	cmp	r5, #0
 804a64a:	db57      	blt.n	804a6fc <kad_grad+0xfc>
 804a64c:	f1a8 0504 	sub.w	r5, r8, #4
 804a650:	462e      	mov	r6, r5
 804a652:	e001      	b.n	804a658 <kad_grad+0x58>
 804a654:	42b7      	cmp	r7, r6
 804a656:	d01f      	beq.n	804a698 <kad_grad+0x98>
		if (a[i]->g && a[i]->tmp > 0)
 804a658:	f856 3f04 	ldr.w	r3, [r6, #4]!
 804a65c:	6ad8      	ldr	r0, [r3, #44]	@ 0x2c
 804a65e:	2800      	cmp	r0, #0
 804a660:	d0f8      	beq.n	804a654 <kad_grad+0x54>
 804a662:	689a      	ldr	r2, [r3, #8]
 804a664:	2a00      	cmp	r2, #0
 804a666:	ddf5      	ble.n	804a654 <kad_grad+0x54>
	for (i = 0; i < p->n_d; ++i) n *= p->d[i];
 804a668:	7819      	ldrb	r1, [r3, #0]
 804a66a:	2900      	cmp	r1, #0
 804a66c:	d044      	beq.n	804a6f8 <kad_grad+0xf8>
 804a66e:	2901      	cmp	r1, #1
 804a670:	691a      	ldr	r2, [r3, #16]
 804a672:	d00b      	beq.n	804a68c <kad_grad+0x8c>
 804a674:	695c      	ldr	r4, [r3, #20]
 804a676:	2902      	cmp	r1, #2
 804a678:	fb04 f202 	mul.w	r2, r4, r2
 804a67c:	d006      	beq.n	804a68c <kad_grad+0x8c>
 804a67e:	699c      	ldr	r4, [r3, #24]
 804a680:	2903      	cmp	r1, #3
 804a682:	fb04 f202 	mul.w	r2, r4, r2
 804a686:	bf1c      	itt	ne
 804a688:	69db      	ldrne	r3, [r3, #28]
 804a68a:	435a      	mulne	r2, r3
			memset(a[i]->g, 0, kad_len(a[i]) * sizeof(float));
 804a68c:	0092      	lsls	r2, r2, #2
 804a68e:	2100      	movs	r1, #0
 804a690:	f001 fb94 	bl	804bdbc <memset>
	for (i = 0; i <= from; ++i) /* set all grandients to zero */
 804a694:	42b7      	cmp	r7, r6
 804a696:	d1df      	bne.n	804a658 <kad_grad+0x58>
	for (i = from, a[i]->g[0] = 1.0f; i >= 0; --i) /* backprop */
 804a698:	f04f 527e 	mov.w	r2, #1065353216	@ 0x3f800000
 804a69c:	683b      	ldr	r3, [r7, #0]
 804a69e:	f10a 0404 	add.w	r4, sl, #4
 804a6a2:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
			kad_op_list[a[i]->op](a[i], KAD_BACKWARD);
 804a6a4:	4e19      	ldr	r6, [pc, #100]	@ (804a70c <kad_grad+0x10c>)
 804a6a6:	4444      	add	r4, r8
	for (i = from, a[i]->g[0] = 1.0f; i >= 0; --i) /* backprop */
 804a6a8:	601a      	str	r2, [r3, #0]
		if (a[i]->n_child && a[i]->tmp > 0)
 804a6aa:	f854 0d04 	ldr.w	r0, [r4, #-4]!
 804a6ae:	6843      	ldr	r3, [r0, #4]
 804a6b0:	b13b      	cbz	r3, 804a6c2 <kad_grad+0xc2>
 804a6b2:	6883      	ldr	r3, [r0, #8]
 804a6b4:	2b00      	cmp	r3, #0
 804a6b6:	dd04      	ble.n	804a6c2 <kad_grad+0xc2>
			kad_op_list[a[i]->op](a[i], KAD_BACKWARD);
 804a6b8:	8843      	ldrh	r3, [r0, #2]
 804a6ba:	2103      	movs	r1, #3
 804a6bc:	f856 3023 	ldr.w	r3, [r6, r3, lsl #2]
 804a6c0:	4798      	blx	r3
	for (i = from, a[i]->g[0] = 1.0f; i >= 0; --i) /* backprop */
 804a6c2:	4544      	cmp	r4, r8
 804a6c4:	d1f1      	bne.n	804a6aa <kad_grad+0xaa>
	for (i = 0; i <= from; ++i) a[i]->tmp = 0;
 804a6c6:	2200      	movs	r2, #0
 804a6c8:	f855 3f04 	ldr.w	r3, [r5, #4]!
 804a6cc:	42af      	cmp	r7, r5
 804a6ce:	609a      	str	r2, [r3, #8]
 804a6d0:	d1fa      	bne.n	804a6c8 <kad_grad+0xc8>
}
 804a6d2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	assert(a[from]->n_d == 0);
 804a6d6:	f851 9025 	ldr.w	r9, [r1, r5, lsl #2]
 804a6da:	ea4f 0a85 	mov.w	sl, r5, lsl #2
 804a6de:	f899 3000 	ldrb.w	r3, [r9]
 804a6e2:	eb01 0785 	add.w	r7, r1, r5, lsl #2
 804a6e6:	2b00      	cmp	r3, #0
 804a6e8:	d09e      	beq.n	804a628 <kad_grad+0x28>
 804a6ea:	f240 2151 	movw	r1, #593	@ 0x251
 804a6ee:	4b08      	ldr	r3, [pc, #32]	@ (804a710 <kad_grad+0x110>)
 804a6f0:	4a08      	ldr	r2, [pc, #32]	@ (804a714 <kad_grad+0x114>)
 804a6f2:	4809      	ldr	r0, [pc, #36]	@ (804a718 <kad_grad+0x118>)
 804a6f4:	f001 f83a 	bl	804b76c <__assert_func>
 804a6f8:	2204      	movs	r2, #4
 804a6fa:	e7c8      	b.n	804a68e <kad_grad+0x8e>
	for (i = from, a[i]->g[0] = 1.0f; i >= 0; --i) /* backprop */
 804a6fc:	f04f 527e 	mov.w	r2, #1065353216	@ 0x3f800000
 804a700:	f8d9 302c 	ldr.w	r3, [r9, #44]	@ 0x2c
 804a704:	601a      	str	r2, [r3, #0]
}
 804a706:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 804a70a:	bf00      	nop
 804a70c:	20018004 	.word	0x20018004
 804a710:	0804e3fc 	.word	0x0804e3fc
 804a714:	0804e528 	.word	0x0804e528
 804a718:	0804e328 	.word	0x0804e328

0804a71c <kad_n_pivots>:
	for (i = 0; i < n_v; ++i)
 804a71c:	f1b0 0c00 	subs.w	ip, r0, #0
	int i, n_pivots = 0;
 804a720:	f04f 0000 	mov.w	r0, #0
	for (i = 0; i < n_v; ++i)
 804a724:	dd0e      	ble.n	804a744 <kad_n_pivots+0x28>
 804a726:	3904      	subs	r1, #4
 804a728:	eb01 0c8c 	add.w	ip, r1, ip, lsl #2
		if (kad_is_pivot(v[i])) ++n_pivots;
 804a72c:	f851 3f04 	ldr.w	r3, [r1, #4]!
 804a730:	685a      	ldr	r2, [r3, #4]
 804a732:	2a01      	cmp	r2, #1
 804a734:	d103      	bne.n	804a73e <kad_n_pivots+0x22>
 804a736:	785b      	ldrb	r3, [r3, #1]
 804a738:	075b      	lsls	r3, r3, #29
 804a73a:	bf48      	it	mi
 804a73c:	3001      	addmi	r0, #1
	for (i = 0; i < n_v; ++i)
 804a73e:	458c      	cmp	ip, r1
 804a740:	d1f4      	bne.n	804a72c <kad_n_pivots+0x10>
 804a742:	4770      	bx	lr
}
 804a744:	4770      	bx	lr
 804a746:	bf00      	nop

0804a748 <kad_rng>:
{
 804a748:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	r = (kad_rng_t*)calloc(1, sizeof(kad_rng_t));
 804a74c:	2120      	movs	r1, #32
{
 804a74e:	b083      	sub	sp, #12
	r = (kad_rng_t*)calloc(1, sizeof(kad_rng_t));
 804a750:	2001      	movs	r0, #1
 804a752:	f001 f829 	bl	804b7a8 <calloc>
	heapSize += 1 * sizeof(kad_rng_t);
 804a756:	4a51      	ldr	r2, [pc, #324]	@ (804a89c <kad_rng+0x154>)
 804a758:	4951      	ldr	r1, [pc, #324]	@ (804a8a0 <kad_rng+0x158>)
 804a75a:	6813      	ldr	r3, [r2, #0]
	uint64_t s0 = 0, s1 = 0;
 804a75c:	2500      	movs	r5, #0
	heapSize += 1 * sizeof(kad_rng_t);
 804a75e:	3320      	adds	r3, #32
	r = (kad_rng_t*)calloc(1, sizeof(kad_rng_t));
 804a760:	4682      	mov	sl, r0
	heapSize += 1 * sizeof(kad_rng_t);
 804a762:	6013      	str	r3, [r2, #0]
 804a764:	460b      	mov	r3, r1
 804a766:	680c      	ldr	r4, [r1, #0]
	uint64_t s0 = 0, s1 = 0;
 804a768:	462e      	mov	r6, r5
 804a76a:	e9d1 e101 	ldrd	lr, r1, [r1, #4]
 804a76e:	46a8      	mov	r8, r5
 804a770:	462f      	mov	r7, r5
		for (b = 0; b < 64; b++) {
 804a772:	4628      	mov	r0, r5
 804a774:	f8d3 c00c 	ldr.w	ip, [r3, #12]
			if (JUMP[i] & 1ULL << b)
 804a778:	f8df 9130 	ldr.w	r9, [pc, #304]	@ 804a8ac <kad_rng+0x164>
 804a77c:	f8cd a004 	str.w	sl, [sp, #4]
 804a780:	e001      	b.n	804a786 <kad_rng+0x3e>
	r->s[0] = (s0 << 55 | s0 >> 9) ^ s1 ^ (s1 << 14);
 804a782:	461c      	mov	r4, r3
 804a784:	4696      	mov	lr, r2
			if (JUMP[i] & 1ULL << b)
 804a786:	4b47      	ldr	r3, [pc, #284]	@ (804a8a4 <kad_rng+0x15c>)
 804a788:	f1c0 0b20 	rsb	fp, r0, #32
 804a78c:	f1a0 0a20 	sub.w	sl, r0, #32
 804a790:	40c3      	lsrs	r3, r0
 804a792:	fa09 fb0b 	lsl.w	fp, r9, fp
 804a796:	ea43 030b 	orr.w	r3, r3, fp
 804a79a:	fa29 fa0a 	lsr.w	sl, r9, sl
 804a79e:	ea43 030a 	orr.w	r3, r3, sl
 804a7a2:	07db      	lsls	r3, r3, #31
	s1 ^= s0;
 804a7a4:	ea8e 020c 	eor.w	r2, lr, ip
 804a7a8:	ea84 0b01 	eor.w	fp, r4, r1
		for (b = 0; b < 64; b++) {
 804a7ac:	f100 0001 	add.w	r0, r0, #1
			if (JUMP[i] & 1ULL << b)
 804a7b0:	d506      	bpl.n	804a7c0 <kad_rng+0x78>
				s0 ^= r->s[0], s1 ^= r->s[1];
 804a7b2:	ea84 0808 	eor.w	r8, r4, r8
 804a7b6:	ea8e 0707 	eor.w	r7, lr, r7
 804a7ba:	404d      	eors	r5, r1
 804a7bc:	ea86 060c 	eor.w	r6, r6, ip
	r->s[0] = (s0 << 55 | s0 >> 9) ^ s1 ^ (s1 << 14);
 804a7c0:	0a63      	lsrs	r3, r4, #9
 804a7c2:	ea4f 215e 	mov.w	r1, lr, lsr #9
 804a7c6:	ea41 51c4 	orr.w	r1, r1, r4, lsl #23
 804a7ca:	ea4f 3a82 	mov.w	sl, r2, lsl #14
 804a7ce:	ea43 53ce 	orr.w	r3, r3, lr, lsl #23
 804a7d2:	404a      	eors	r2, r1
 804a7d4:	ea83 030b 	eor.w	r3, r3, fp
 804a7d8:	ea4a 4a9b 	orr.w	sl, sl, fp, lsr #18
	r->s[1] = s0 << 36 | s0 >> 28;
 804a7dc:	0f21      	lsrs	r1, r4, #28
 804a7de:	ea4f 7c1e 	mov.w	ip, lr, lsr #28
		for (b = 0; b < 64; b++) {
 804a7e2:	2840      	cmp	r0, #64	@ 0x40
	r->s[0] = (s0 << 55 | s0 >> 9) ^ s1 ^ (s1 << 14);
 804a7e4:	ea83 338b 	eor.w	r3, r3, fp, lsl #14
 804a7e8:	ea82 020a 	eor.w	r2, r2, sl
	r->s[1] = s0 << 36 | s0 >> 28;
 804a7ec:	ea41 110e 	orr.w	r1, r1, lr, lsl #4
 804a7f0:	ea4c 1c04 	orr.w	ip, ip, r4, lsl #4
		for (b = 0; b < 64; b++) {
 804a7f4:	d1c5      	bne.n	804a782 <kad_rng+0x3a>
 804a7f6:	f04f 0e00 	mov.w	lr, #0
 804a7fa:	460c      	mov	r4, r1
			if (JUMP[i] & 1ULL << b)
 804a7fc:	f8df 90b0 	ldr.w	r9, [pc, #176]	@ 804a8b0 <kad_rng+0x168>
 804a800:	e001      	b.n	804a806 <kad_rng+0xbe>
	r->s[0] = (s0 << 55 | s0 >> 9) ^ s1 ^ (s1 << 14);
 804a802:	4603      	mov	r3, r0
 804a804:	460a      	mov	r2, r1
			if (JUMP[i] & 1ULL << b)
 804a806:	4928      	ldr	r1, [pc, #160]	@ (804a8a8 <kad_rng+0x160>)
 804a808:	f1ce 0b20 	rsb	fp, lr, #32
 804a80c:	fa21 f00e 	lsr.w	r0, r1, lr
 804a810:	f1ae 0a20 	sub.w	sl, lr, #32
 804a814:	fa09 fb0b 	lsl.w	fp, r9, fp
 804a818:	ea40 000b 	orr.w	r0, r0, fp
 804a81c:	fa29 fa0a 	lsr.w	sl, r9, sl
 804a820:	ea40 000a 	orr.w	r0, r0, sl
 804a824:	07c0      	lsls	r0, r0, #31
	s1 ^= s0;
 804a826:	ea82 010c 	eor.w	r1, r2, ip
 804a82a:	ea83 0b04 	eor.w	fp, r3, r4
		for (b = 0; b < 64; b++) {
 804a82e:	f10e 0e01 	add.w	lr, lr, #1
			if (JUMP[i] & 1ULL << b)
 804a832:	d505      	bpl.n	804a840 <kad_rng+0xf8>
				s0 ^= r->s[0], s1 ^= r->s[1];
 804a834:	ea88 0803 	eor.w	r8, r8, r3
 804a838:	4057      	eors	r7, r2
 804a83a:	4065      	eors	r5, r4
 804a83c:	ea86 060c 	eor.w	r6, r6, ip
	r->s[0] = (s0 << 55 | s0 >> 9) ^ s1 ^ (s1 << 14);
 804a840:	0a58      	lsrs	r0, r3, #9
 804a842:	0a54      	lsrs	r4, r2, #9
 804a844:	ea44 54c3 	orr.w	r4, r4, r3, lsl #23
 804a848:	ea4f 3a81 	mov.w	sl, r1, lsl #14
 804a84c:	ea40 50c2 	orr.w	r0, r0, r2, lsl #23
 804a850:	4061      	eors	r1, r4
 804a852:	ea80 000b 	eor.w	r0, r0, fp
 804a856:	ea4a 4a9b 	orr.w	sl, sl, fp, lsr #18
	r->s[1] = s0 << 36 | s0 >> 28;
 804a85a:	0f1c      	lsrs	r4, r3, #28
 804a85c:	ea4f 7c12 	mov.w	ip, r2, lsr #28
		for (b = 0; b < 64; b++) {
 804a860:	f1be 0f40 	cmp.w	lr, #64	@ 0x40
	r->s[0] = (s0 << 55 | s0 >> 9) ^ s1 ^ (s1 << 14);
 804a864:	ea80 308b 	eor.w	r0, r0, fp, lsl #14
 804a868:	ea81 010a 	eor.w	r1, r1, sl
	r->s[1] = s0 << 36 | s0 >> 28;
 804a86c:	ea44 1402 	orr.w	r4, r4, r2, lsl #4
 804a870:	ea4c 1c03 	orr.w	ip, ip, r3, lsl #4
		for (b = 0; b < 64; b++) {
 804a874:	d1c5      	bne.n	804a802 <kad_rng+0xba>
	r->s[0] = s0, r->s[1] = s1;
 804a876:	f8dd a004 	ldr.w	sl, [sp, #4]
 804a87a:	4b09      	ldr	r3, [pc, #36]	@ (804a8a0 <kad_rng+0x158>)
}
 804a87c:	4650      	mov	r0, sl
	r->s[0] = s0, r->s[1] = s1;
 804a87e:	e9c3 7501 	strd	r7, r5, [r3, #4]
	r->s[0] = kad_rng_dat.s[0], r->s[1] = kad_rng_dat.s[1];
 804a882:	e9ca 7501 	strd	r7, r5, [sl, #4]
	r->s[0] = s0, r->s[1] = s1;
 804a886:	f8c3 8000 	str.w	r8, [r3]
	r->s[0] = kad_rng_dat.s[0], r->s[1] = kad_rng_dat.s[1];
 804a88a:	f8ca 8000 	str.w	r8, [sl]
	r->s[0] = s0, r->s[1] = s1;
 804a88e:	60de      	str	r6, [r3, #12]
	r->s[0] = kad_rng_dat.s[0], r->s[1] = kad_rng_dat.s[1];
 804a890:	f8ca 600c 	str.w	r6, [sl, #12]
}
 804a894:	b003      	add	sp, #12
 804a896:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 804a89a:	bf00      	nop
 804a89c:	20018344 	.word	0x20018344
 804a8a0:	20018108 	.word	0x20018108
 804a8a4:	eba5facb 	.word	0xeba5facb
 804a8a8:	86aa9922 	.word	0x86aa9922
 804a8ac:	beac0467 	.word	0xbeac0467
 804a8b0:	d86b048b 	.word	0xd86b048b
 804a8b4:	00000000 	.word	0x00000000

0804a8b8 <kad_unroll>:
{
 804a8b8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 804a8bc:	ed2d 8b02 	vpush	{d8}
 804a8c0:	4689      	mov	r9, r1
 804a8c2:	4604      	mov	r4, r0
 804a8c4:	b09b      	sub	sp, #108	@ 0x6c
	t = (kad_node_t**)calloc(n_v, sizeof(kad_node_t*));
 804a8c6:	2104      	movs	r1, #4
{
 804a8c8:	4692      	mov	sl, r2
 804a8ca:	461e      	mov	r6, r3
 804a8cc:	9010      	str	r0, [sp, #64]	@ 0x40
 804a8ce:	f8cd 9034 	str.w	r9, [sp, #52]	@ 0x34
	t = (kad_node_t**)calloc(n_v, sizeof(kad_node_t*));
 804a8d2:	f000 ff69 	bl	804b7a8 <calloc>
	for (i = 0; i < n_v; ++i)
 804a8d6:	2c00      	cmp	r4, #0
 804a8d8:	f340 8379 	ble.w	804afce <kad_unroll+0x716>
 804a8dc:	4622      	mov	r2, r4
 804a8de:	f1a9 0404 	sub.w	r4, r9, #4
 804a8e2:	4680      	mov	r8, r0
 804a8e4:	4623      	mov	r3, r4
	int i, n_pivots = 0;
 804a8e6:	2000      	movs	r0, #0
 804a8e8:	f8cd 9050 	str.w	r9, [sp, #80]	@ 0x50
 804a8ec:	eb04 0782 	add.w	r7, r4, r2, lsl #2
		if (kad_is_pivot(v[i])) ++n_pivots;
 804a8f0:	f853 2f04 	ldr.w	r2, [r3, #4]!
 804a8f4:	6851      	ldr	r1, [r2, #4]
 804a8f6:	2901      	cmp	r1, #1
 804a8f8:	d103      	bne.n	804a902 <kad_unroll+0x4a>
 804a8fa:	7852      	ldrb	r2, [r2, #1]
 804a8fc:	0751      	lsls	r1, r2, #29
 804a8fe:	bf48      	it	mi
 804a900:	3001      	addmi	r0, #1
	for (i = 0; i < n_v; ++i)
 804a902:	429f      	cmp	r7, r3
 804a904:	d1f4      	bne.n	804a8f0 <kad_unroll+0x38>
 804a906:	4622      	mov	r2, r4
	for (i = 0; i < n_v; ++i) v[i]->tmp = i;
 804a908:	2300      	movs	r3, #0
	for (i = 0; i < n_v; ++i)
 804a90a:	900e      	str	r0, [sp, #56]	@ 0x38
	for (i = 0; i < n_v; ++i) v[i]->tmp = i;
 804a90c:	9810      	ldr	r0, [sp, #64]	@ 0x40
 804a90e:	f852 1f04 	ldr.w	r1, [r2, #4]!
 804a912:	461d      	mov	r5, r3
 804a914:	608b      	str	r3, [r1, #8]
 804a916:	3301      	adds	r3, #1
 804a918:	4298      	cmp	r0, r3
 804a91a:	d1f8      	bne.n	804a90e <kad_unroll+0x56>
	if (n_pivots) {
 804a91c:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
 804a91e:	2b00      	cmp	r3, #0
 804a920:	f040 80d8 	bne.w	804aad4 <kad_unroll+0x21c>
	nodes_t w = {0,0,0};
 804a924:	e9cd 3304 	strd	r3, r3, [sp, #16]
	for (i = 0; i < n_v; ++i) { /* copy over the rest of nodes */
 804a928:	2600      	movs	r6, #0
 804a92a:	9500      	str	r5, [sp, #0]
	q->pre = 0, q->tmp = 0, q->gtmp = 0;
 804a92c:	46b3      	mov	fp, r6
	heapSize += sizeof(kad_node_t);
 804a92e:	f8df 93ac 	ldr.w	r9, [pc, #940]	@ 804acdc <kad_unroll+0x424>
 804a932:	9d14      	ldr	r5, [sp, #80]	@ 0x50
 804a934:	9702      	str	r7, [sp, #8]
 804a936:	9403      	str	r4, [sp, #12]
 804a938:	f8cd a018 	str.w	sl, [sp, #24]
 804a93c:	e006      	b.n	804a94c <kad_unroll+0x94>
	for (i = 0; i < n_v; ++i) { /* copy over the rest of nodes */
 804a93e:	9a00      	ldr	r2, [sp, #0]
 804a940:	1c73      	adds	r3, r6, #1
 804a942:	42b2      	cmp	r2, r6
 804a944:	f105 0504 	add.w	r5, r5, #4
 804a948:	d057      	beq.n	804a9fa <kad_unroll+0x142>
 804a94a:	461e      	mov	r6, r3
		if (t[i]) continue;
 804a94c:	f858 3026 	ldr.w	r3, [r8, r6, lsl #2]
 804a950:	2b00      	cmp	r3, #0
 804a952:	d1f4      	bne.n	804a93e <kad_unroll+0x86>
	q = (kad_node_t*)malloc(sizeof(kad_node_t));
 804a954:	2040      	movs	r0, #64	@ 0x40
		t[i] = kad_dup1(v[i]);
 804a956:	682f      	ldr	r7, [r5, #0]
	q = (kad_node_t*)malloc(sizeof(kad_node_t));
 804a958:	f000 ff42 	bl	804b7e0 <malloc>
	memcpy(q, p, sizeof(kad_node_t));
 804a95c:	463c      	mov	r4, r7
	q = (kad_node_t*)malloc(sizeof(kad_node_t));
 804a95e:	4682      	mov	sl, r0
	memcpy(q, p, sizeof(kad_node_t));
 804a960:	4684      	mov	ip, r0
	heapSize += sizeof(kad_node_t);
 804a962:	f8d9 3000 	ldr.w	r3, [r9]
	memcpy(q, p, sizeof(kad_node_t));
 804a966:	f107 0e40 	add.w	lr, r7, #64	@ 0x40
	heapSize += sizeof(kad_node_t);
 804a96a:	3340      	adds	r3, #64	@ 0x40
 804a96c:	f8c9 3000 	str.w	r3, [r9]
	memcpy(q, p, sizeof(kad_node_t));
 804a970:	9701      	str	r7, [sp, #4]
 804a972:	4667      	mov	r7, ip
 804a974:	6820      	ldr	r0, [r4, #0]
 804a976:	6861      	ldr	r1, [r4, #4]
 804a978:	68a2      	ldr	r2, [r4, #8]
 804a97a:	68e3      	ldr	r3, [r4, #12]
 804a97c:	3410      	adds	r4, #16
 804a97e:	4574      	cmp	r4, lr
 804a980:	c70f      	stmia	r7!, {r0, r1, r2, r3}
 804a982:	f10c 0c10 	add.w	ip, ip, #16
 804a986:	d1f4      	bne.n	804a972 <kad_unroll+0xba>
	q->pre = 0, q->tmp = 0, q->gtmp = 0;
 804a988:	9f01      	ldr	r7, [sp, #4]
 804a98a:	f8ca b03c 	str.w	fp, [sl, #60]	@ 0x3c
	if (p->ptr && p->ptr_size > 0) {
 804a98e:	6b39      	ldr	r1, [r7, #48]	@ 0x30
	q->pre = 0, q->tmp = 0, q->gtmp = 0;
 804a990:	f8ca b008 	str.w	fp, [sl, #8]
 804a994:	f8ca b034 	str.w	fp, [sl, #52]	@ 0x34
	if (p->ptr && p->ptr_size > 0) {
 804a998:	b1b1      	cbz	r1, 804a9c8 <kad_unroll+0x110>
 804a99a:	68fc      	ldr	r4, [r7, #12]
 804a99c:	2c00      	cmp	r4, #0
 804a99e:	dd13      	ble.n	804a9c8 <kad_unroll+0x110>
		if (kad_use_rng(p) && !(p->flag & KAD_SHARE_RNG) && p->ptr_size == sizeof(kad_rng_t)) {
 804a9a0:	887b      	ldrh	r3, [r7, #2]
 804a9a2:	2b0f      	cmp	r3, #15
 804a9a4:	d058      	beq.n	804aa58 <kad_unroll+0x1a0>
 804a9a6:	2b18      	cmp	r3, #24
 804a9a8:	d056      	beq.n	804aa58 <kad_unroll+0x1a0>
			q->ptr = malloc(p->ptr_size);
 804a9aa:	4620      	mov	r0, r4
 804a9ac:	9101      	str	r1, [sp, #4]
 804a9ae:	f000 ff17 	bl	804b7e0 <malloc>
			heapSize += p->ptr_size;
 804a9b2:	f8d9 3000 	ldr.w	r3, [r9]
			memcpy(q->ptr, p->ptr, p->ptr_size);
 804a9b6:	4622      	mov	r2, r4
			heapSize += p->ptr_size;
 804a9b8:	4423      	add	r3, r4
			memcpy(q->ptr, p->ptr, p->ptr_size);
 804a9ba:	9901      	ldr	r1, [sp, #4]
			q->ptr = malloc(p->ptr_size);
 804a9bc:	f8ca 0030 	str.w	r0, [sl, #48]	@ 0x30
			heapSize += p->ptr_size;
 804a9c0:	f8c9 3000 	str.w	r3, [r9]
			memcpy(q->ptr, p->ptr, p->ptr_size);
 804a9c4:	f001 faf7 	bl	804bfb6 <memcpy>
	if (q->n_child) {
 804a9c8:	f8da 4004 	ldr.w	r4, [sl, #4]
 804a9cc:	2c00      	cmp	r4, #0
 804a9ce:	d156      	bne.n	804aa7e <kad_unroll+0x1c6>
		if (v[i]->n_child)
 804a9d0:	687b      	ldr	r3, [r7, #4]
		t[i] = kad_dup1(v[i]);
 804a9d2:	f848 a026 	str.w	sl, [r8, r6, lsl #2]
		if (v[i]->n_child)
 804a9d6:	2b00      	cmp	r3, #0
 804a9d8:	dc66      	bgt.n	804aaa8 <kad_unroll+0x1f0>
	if (w->n == w->m) {
 804a9da:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
 804a9dc:	9a05      	ldr	r2, [sp, #20]
 804a9de:	4293      	cmp	r3, r2
 804a9e0:	d044      	beq.n	804aa6c <kad_unroll+0x1b4>
	w->v[w->n++] = p;
 804a9e2:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
 804a9e4:	9a04      	ldr	r2, [sp, #16]
	for (i = 0; i < n_v; ++i) { /* copy over the rest of nodes */
 804a9e6:	3504      	adds	r5, #4
	w->v[w->n++] = p;
 804a9e8:	f842 a023 	str.w	sl, [r2, r3, lsl #2]
	for (i = 0; i < n_v; ++i) { /* copy over the rest of nodes */
 804a9ec:	9a00      	ldr	r2, [sp, #0]
	w->v[w->n++] = p;
 804a9ee:	3301      	adds	r3, #1
	for (i = 0; i < n_v; ++i) { /* copy over the rest of nodes */
 804a9f0:	42b2      	cmp	r2, r6
	w->v[w->n++] = p;
 804a9f2:	930e      	str	r3, [sp, #56]	@ 0x38
	for (i = 0; i < n_v; ++i) { /* copy over the rest of nodes */
 804a9f4:	f106 0301 	add.w	r3, r6, #1
 804a9f8:	d1a7      	bne.n	804a94a <kad_unroll+0x92>
 804a9fa:	e9dd 7402 	ldrd	r7, r4, [sp, #8]
	free(t);
 804a9fe:	4640      	mov	r0, r8
 804aa00:	f8dd a018 	ldr.w	sl, [sp, #24]
 804aa04:	f000 fef4 	bl	804b7f0 <free>
	for (i = 0; i < n_v; ++i) v[i]->tmp = 0;
 804aa08:	2200      	movs	r2, #0
 804aa0a:	f854 3f04 	ldr.w	r3, [r4, #4]!
 804aa0e:	42a7      	cmp	r7, r4
 804aa10:	609a      	str	r2, [r3, #8]
 804aa12:	d1fa      	bne.n	804aa0a <kad_unroll+0x152>
	for (i = 0; i < w.n; ++i) /* stack may change the output dimension */
 804aa14:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
 804aa16:	2b00      	cmp	r3, #0
 804aa18:	dd11      	ble.n	804aa3e <kad_unroll+0x186>
 804aa1a:	2400      	movs	r4, #0
 804aa1c:	461f      	mov	r7, r3
 804aa1e:	9b04      	ldr	r3, [sp, #16]
			kad_op_list[w.v[i]->op](w.v[i], KAD_SYNC_DIM);
 804aa20:	4ead      	ldr	r6, [pc, #692]	@ (804acd8 <kad_unroll+0x420>)
 804aa22:	1f1d      	subs	r5, r3, #4
		if (w.v[i]->n_child > 0)
 804aa24:	f855 0f04 	ldr.w	r0, [r5, #4]!
 804aa28:	6843      	ldr	r3, [r0, #4]
 804aa2a:	2b00      	cmp	r3, #0
 804aa2c:	dd04      	ble.n	804aa38 <kad_unroll+0x180>
			kad_op_list[w.v[i]->op](w.v[i], KAD_SYNC_DIM);
 804aa2e:	8843      	ldrh	r3, [r0, #2]
 804aa30:	2104      	movs	r1, #4
 804aa32:	f856 3023 	ldr.w	r3, [r6, r3, lsl #2]
 804aa36:	4798      	blx	r3
	for (i = 0; i < w.n; ++i) /* stack may change the output dimension */
 804aa38:	3401      	adds	r4, #1
 804aa3a:	42a7      	cmp	r7, r4
 804aa3c:	d1f2      	bne.n	804aa24 <kad_unroll+0x16c>
	kad_allocate_internal(w.n, w.v);
 804aa3e:	9c0e      	ldr	r4, [sp, #56]	@ 0x38
 804aa40:	9904      	ldr	r1, [sp, #16]
 804aa42:	4620      	mov	r0, r4
 804aa44:	f7fb ff5e 	bl	8046904 <kad_allocate_internal>
}
 804aa48:	9804      	ldr	r0, [sp, #16]
	*new_n = w.n;
 804aa4a:	f8ca 4000 	str.w	r4, [sl]
}
 804aa4e:	b01b      	add	sp, #108	@ 0x6c
 804aa50:	ecbd 8b02 	vpop	{d8}
 804aa54:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (kad_use_rng(p) && !(p->flag & KAD_SHARE_RNG) && p->ptr_size == sizeof(kad_rng_t)) {
 804aa58:	787b      	ldrb	r3, [r7, #1]
 804aa5a:	06da      	lsls	r2, r3, #27
 804aa5c:	d4a5      	bmi.n	804a9aa <kad_unroll+0xf2>
 804aa5e:	2c20      	cmp	r4, #32
 804aa60:	d1a3      	bne.n	804a9aa <kad_unroll+0xf2>
			q->ptr = kad_rng(); /* each time step uses a different RNG */
 804aa62:	f7ff fe71 	bl	804a748 <kad_rng>
 804aa66:	f8ca 0030 	str.w	r0, [sl, #48]	@ 0x30
 804aa6a:	e7ad      	b.n	804a9c8 <kad_unroll+0x110>
		w->m = w->m? w->m<<1 : 16;
 804aa6c:	bb73      	cbnz	r3, 804aacc <kad_unroll+0x214>
 804aa6e:	2310      	movs	r3, #16
 804aa70:	2140      	movs	r1, #64	@ 0x40
 804aa72:	9305      	str	r3, [sp, #20]
		w->v = (kad_node_t**)realloc(w->v, w->m * sizeof(kad_node_t*));
 804aa74:	9804      	ldr	r0, [sp, #16]
 804aa76:	f000 ff9f 	bl	804b9b8 <realloc>
 804aa7a:	9004      	str	r0, [sp, #16]
 804aa7c:	e7b1      	b.n	804a9e2 <kad_unroll+0x12a>
		q->x = q->g = 0;
 804aa7e:	2300      	movs	r3, #0
 804aa80:	2200      	movs	r2, #0
		q->child = (kad_node_t**)calloc(q->n_child, sizeof(kad_node_t*));
 804aa82:	2104      	movs	r1, #4
		q->x = q->g = 0;
 804aa84:	e9ca 230a 	strd	r2, r3, [sl, #40]	@ 0x28
		q->child = (kad_node_t**)calloc(q->n_child, sizeof(kad_node_t*));
 804aa88:	4620      	mov	r0, r4
 804aa8a:	f000 fe8d 	bl	804b7a8 <calloc>
		heapSize += q->n_child * sizeof(kad_node_t*);
 804aa8e:	f8d9 3000 	ldr.w	r3, [r9]
		q->child = (kad_node_t**)calloc(q->n_child, sizeof(kad_node_t*));
 804aa92:	f8ca 0038 	str.w	r0, [sl, #56]	@ 0x38
		heapSize += q->n_child * sizeof(kad_node_t*);
 804aa96:	eb03 0384 	add.w	r3, r3, r4, lsl #2
 804aa9a:	f8c9 3000 	str.w	r3, [r9]
		if (v[i]->n_child)
 804aa9e:	687b      	ldr	r3, [r7, #4]
		t[i] = kad_dup1(v[i]);
 804aaa0:	f848 a026 	str.w	sl, [r8, r6, lsl #2]
		if (v[i]->n_child)
 804aaa4:	2b00      	cmp	r3, #0
 804aaa6:	dd98      	ble.n	804a9da <kad_unroll+0x122>
			for (j = 0; j < v[i]->n_child; ++j)
 804aaa8:	2300      	movs	r3, #0
 804aaaa:	f8da 2038 	ldr.w	r2, [sl, #56]	@ 0x38
 804aaae:	3a04      	subs	r2, #4
				t[i]->child[j] = t[v[i]->child[j]->tmp];
 804aab0:	6bb9      	ldr	r1, [r7, #56]	@ 0x38
 804aab2:	f851 1023 	ldr.w	r1, [r1, r3, lsl #2]
			for (j = 0; j < v[i]->n_child; ++j)
 804aab6:	3301      	adds	r3, #1
				t[i]->child[j] = t[v[i]->child[j]->tmp];
 804aab8:	6889      	ldr	r1, [r1, #8]
 804aaba:	f858 1021 	ldr.w	r1, [r8, r1, lsl #2]
 804aabe:	f842 1f04 	str.w	r1, [r2, #4]!
			for (j = 0; j < v[i]->n_child; ++j)
 804aac2:	682f      	ldr	r7, [r5, #0]
 804aac4:	6879      	ldr	r1, [r7, #4]
 804aac6:	4299      	cmp	r1, r3
 804aac8:	dcf2      	bgt.n	804aab0 <kad_unroll+0x1f8>
 804aaca:	e786      	b.n	804a9da <kad_unroll+0x122>
		w->m = w->m? w->m<<1 : 16;
 804aacc:	005a      	lsls	r2, r3, #1
 804aace:	9205      	str	r2, [sp, #20]
		w->v = (kad_node_t**)realloc(w->v, w->m * sizeof(kad_node_t*));
 804aad0:	00d9      	lsls	r1, r3, #3
 804aad2:	e7cf      	b.n	804aa74 <kad_unroll+0x1bc>
		i_pivots = (int*)calloc(n_pivots, sizeof(int));
 804aad4:	4618      	mov	r0, r3
 804aad6:	2104      	movs	r1, #4
 804aad8:	f000 fe66 	bl	804b7a8 <calloc>
		for (i = k = 0; i < n_v; ++i) /* collect pivots */
 804aadc:	f04f 0c00 	mov.w	ip, #0
		i_pivots = (int*)calloc(n_pivots, sizeof(int));
 804aae0:	4681      	mov	r9, r0
 804aae2:	4623      	mov	r3, r4
		for (i = k = 0; i < n_v; ++i) /* collect pivots */
 804aae4:	4660      	mov	r0, ip
			if (kad_is_pivot(v[i])) i_pivots[k++] = i;
 804aae6:	f853 2f04 	ldr.w	r2, [r3, #4]!
 804aaea:	6851      	ldr	r1, [r2, #4]
 804aaec:	2901      	cmp	r1, #1
 804aaee:	d106      	bne.n	804aafe <kad_unroll+0x246>
 804aaf0:	7852      	ldrb	r2, [r2, #1]
 804aaf2:	0752      	lsls	r2, r2, #29
 804aaf4:	bf44      	itt	mi
 804aaf6:	f849 002c 	strmi.w	r0, [r9, ip, lsl #2]
 804aafa:	f10c 0c01 	addmi.w	ip, ip, #1
		for (i = k = 0; i < n_v; ++i) /* collect pivots */
 804aafe:	429f      	cmp	r7, r3
 804ab00:	f100 0001 	add.w	r0, r0, #1
 804ab04:	d1ef      	bne.n	804aae6 <kad_unroll+0x22e>
		for (i = 0; i < n_pivots; ++i) /* unroll each pivot, from the lowest to the highest */
 804ab06:	1f33      	subs	r3, r6, #4
 804ab08:	9311      	str	r3, [sp, #68]	@ 0x44
	nodes_t w = {0,0,0};
 804ab0a:	2300      	movs	r3, #0
		q->x = q->g = 0;
 804ab0c:	ed9f 8b70 	vldr	d8, [pc, #448]	@ 804acd0 <kad_unroll+0x418>
		for (i = 0; i < n_pivots; ++i) /* unroll each pivot, from the lowest to the highest */
 804ab10:	469b      	mov	fp, r3
 804ab12:	e9cd 7915 	strd	r7, r9, [sp, #84]	@ 0x54
 804ab16:	e9cd 5417 	strd	r5, r4, [sp, #92]	@ 0x5c
 804ab1a:	f1a9 0204 	sub.w	r2, r9, #4
	nodes_t w = {0,0,0};
 804ab1e:	9304      	str	r3, [sp, #16]
 804ab20:	9212      	str	r2, [sp, #72]	@ 0x48
 804ab22:	9305      	str	r3, [sp, #20]
 804ab24:	9300      	str	r3, [sp, #0]
		for (i = 0; i < n_pivots; ++i) /* unroll each pivot, from the lowest to the highest */
 804ab26:	f8cd 803c 	str.w	r8, [sp, #60]	@ 0x3c
 804ab2a:	f8cd a064 	str.w	sl, [sp, #100]	@ 0x64
			kad_unroll_helper(n_v, v, i_pivots[i], t, len[i], &w);
 804ab2e:	9b12      	ldr	r3, [sp, #72]	@ 0x48
	assert(kad_is_pivot(v[i_pivot]) && t[i_pivot] == 0);
 804ab30:	990d      	ldr	r1, [sp, #52]	@ 0x34
			kad_unroll_helper(n_v, v, i_pivots[i], t, len[i], &w);
 804ab32:	f853 af04 	ldr.w	sl, [r3, #4]!
 804ab36:	9312      	str	r3, [sp, #72]	@ 0x48
 804ab38:	9b11      	ldr	r3, [sp, #68]	@ 0x44
	assert(kad_is_pivot(v[i_pivot]) && t[i_pivot] == 0);
 804ab3a:	f851 802a 	ldr.w	r8, [r1, sl, lsl #2]
			kad_unroll_helper(n_v, v, i_pivots[i], t, len[i], &w);
 804ab3e:	f853 2f04 	ldr.w	r2, [r3, #4]!
	assert(kad_is_pivot(v[i_pivot]) && t[i_pivot] == 0);
 804ab42:	eb01 018a 	add.w	r1, r1, sl, lsl #2
			kad_unroll_helper(n_v, v, i_pivots[i], t, len[i], &w);
 804ab46:	920c      	str	r2, [sp, #48]	@ 0x30
	assert(kad_is_pivot(v[i_pivot]) && t[i_pivot] == 0);
 804ab48:	f8d8 2004 	ldr.w	r2, [r8, #4]
			kad_unroll_helper(n_v, v, i_pivots[i], t, len[i], &w);
 804ab4c:	9311      	str	r3, [sp, #68]	@ 0x44
	assert(kad_is_pivot(v[i_pivot]) && t[i_pivot] == 0);
 804ab4e:	2a01      	cmp	r2, #1
 804ab50:	ea4f 038a 	mov.w	r3, sl, lsl #2
 804ab54:	9101      	str	r1, [sp, #4]
 804ab56:	f040 8241 	bne.w	804afdc <kad_unroll+0x724>
 804ab5a:	f898 2001 	ldrb.w	r2, [r8, #1]
 804ab5e:	0750      	lsls	r0, r2, #29
 804ab60:	f140 823c 	bpl.w	804afdc <kad_unroll+0x724>
 804ab64:	9a0f      	ldr	r2, [sp, #60]	@ 0x3c
 804ab66:	18d3      	adds	r3, r2, r3
 804ab68:	9308      	str	r3, [sp, #32]
 804ab6a:	f852 302a 	ldr.w	r3, [r2, sl, lsl #2]
 804ab6e:	2b00      	cmp	r3, #0
 804ab70:	f040 8234 	bne.w	804afdc <kad_unroll+0x724>
	q = (kad_node_t*)malloc(sizeof(kad_node_t));
 804ab74:	2040      	movs	r0, #64	@ 0x40
 804ab76:	f000 fe33 	bl	804b7e0 <malloc>
	memcpy(q, p, sizeof(kad_node_t));
 804ab7a:	4644      	mov	r4, r8
	q = (kad_node_t*)malloc(sizeof(kad_node_t));
 804ab7c:	4681      	mov	r9, r0
	memcpy(q, p, sizeof(kad_node_t));
 804ab7e:	4606      	mov	r6, r0
	heapSize += sizeof(kad_node_t);
 804ab80:	4a56      	ldr	r2, [pc, #344]	@ (804acdc <kad_unroll+0x424>)
	memcpy(q, p, sizeof(kad_node_t));
 804ab82:	f108 0740 	add.w	r7, r8, #64	@ 0x40
	heapSize += sizeof(kad_node_t);
 804ab86:	6813      	ldr	r3, [r2, #0]
 804ab88:	3340      	adds	r3, #64	@ 0x40
 804ab8a:	6013      	str	r3, [r2, #0]
	memcpy(q, p, sizeof(kad_node_t));
 804ab8c:	4635      	mov	r5, r6
 804ab8e:	6820      	ldr	r0, [r4, #0]
 804ab90:	6861      	ldr	r1, [r4, #4]
 804ab92:	68a2      	ldr	r2, [r4, #8]
 804ab94:	68e3      	ldr	r3, [r4, #12]
 804ab96:	3410      	adds	r4, #16
 804ab98:	42bc      	cmp	r4, r7
 804ab9a:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 804ab9c:	f106 0610 	add.w	r6, r6, #16
 804aba0:	d1f4      	bne.n	804ab8c <kad_unroll+0x2d4>
	q->pre = 0, q->tmp = 0, q->gtmp = 0;
 804aba2:	2300      	movs	r3, #0
	if (p->ptr && p->ptr_size > 0) {
 804aba4:	f8d8 5030 	ldr.w	r5, [r8, #48]	@ 0x30
	q->pre = 0, q->tmp = 0, q->gtmp = 0;
 804aba8:	f8c9 303c 	str.w	r3, [r9, #60]	@ 0x3c
 804abac:	f8c9 3008 	str.w	r3, [r9, #8]
 804abb0:	f8c9 3034 	str.w	r3, [r9, #52]	@ 0x34
	if (p->ptr && p->ptr_size > 0) {
 804abb4:	b1c5      	cbz	r5, 804abe8 <kad_unroll+0x330>
 804abb6:	f8d8 400c 	ldr.w	r4, [r8, #12]
 804abba:	429c      	cmp	r4, r3
 804abbc:	dd14      	ble.n	804abe8 <kad_unroll+0x330>
		if (kad_use_rng(p) && !(p->flag & KAD_SHARE_RNG) && p->ptr_size == sizeof(kad_rng_t)) {
 804abbe:	f8b8 3002 	ldrh.w	r3, [r8, #2]
 804abc2:	2b0f      	cmp	r3, #15
 804abc4:	f000 81f2 	beq.w	804afac <kad_unroll+0x6f4>
 804abc8:	2b18      	cmp	r3, #24
 804abca:	f000 81ef 	beq.w	804afac <kad_unroll+0x6f4>
			q->ptr = malloc(p->ptr_size);
 804abce:	4620      	mov	r0, r4
 804abd0:	f000 fe06 	bl	804b7e0 <malloc>
			heapSize += p->ptr_size;
 804abd4:	4a41      	ldr	r2, [pc, #260]	@ (804acdc <kad_unroll+0x424>)
			memcpy(q->ptr, p->ptr, p->ptr_size);
 804abd6:	4629      	mov	r1, r5
			heapSize += p->ptr_size;
 804abd8:	6813      	ldr	r3, [r2, #0]
			q->ptr = malloc(p->ptr_size);
 804abda:	f8c9 0030 	str.w	r0, [r9, #48]	@ 0x30
			heapSize += p->ptr_size;
 804abde:	4423      	add	r3, r4
 804abe0:	6013      	str	r3, [r2, #0]
			memcpy(q->ptr, p->ptr, p->ptr_size);
 804abe2:	4622      	mov	r2, r4
 804abe4:	f001 f9e7 	bl	804bfb6 <memcpy>
	if (q->n_child) {
 804abe8:	f8d9 4004 	ldr.w	r4, [r9, #4]
 804abec:	2c00      	cmp	r4, #0
 804abee:	f040 81cf 	bne.w	804af90 <kad_unroll+0x6d8>
	t[i_pivot]->child = (kad_node_t**)realloc(t[i_pivot]->child, len * sizeof(kad_node_t*));
 804abf2:	f8d9 0038 	ldr.w	r0, [r9, #56]	@ 0x38
	t[i_pivot]->n_child = len;
 804abf6:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
	t[i_pivot] = kad_dup1(v[i_pivot]);
 804abf8:	9a0f      	ldr	r2, [sp, #60]	@ 0x3c
	t[i_pivot]->child = (kad_node_t**)realloc(t[i_pivot]->child, len * sizeof(kad_node_t*));
 804abfa:	0099      	lsls	r1, r3, #2
	t[i_pivot]->n_child = len;
 804abfc:	f8c9 3004 	str.w	r3, [r9, #4]
	t[i_pivot] = kad_dup1(v[i_pivot]);
 804ac00:	f842 902a 	str.w	r9, [r2, sl, lsl #2]
	t[i_pivot]->child = (kad_node_t**)realloc(t[i_pivot]->child, len * sizeof(kad_node_t*));
 804ac04:	f000 fed8 	bl	804b9b8 <realloc>
	flag = (uint8_t*)calloc(n_v, 1);
 804ac08:	2101      	movs	r1, #1
	t[i_pivot]->child = (kad_node_t**)realloc(t[i_pivot]->child, len * sizeof(kad_node_t*));
 804ac0a:	f8c9 0038 	str.w	r0, [r9, #56]	@ 0x38
	flag = (uint8_t*)calloc(n_v, 1);
 804ac0e:	9810      	ldr	r0, [sp, #64]	@ 0x40
 804ac10:	f000 fdca 	bl	804b7a8 <calloc>
	for (i = i_pivot, flag[i] = 16; i >= 0; --i) {
 804ac14:	2510      	movs	r5, #16
 804ac16:	f1ba 0f00 	cmp.w	sl, #0
	flag = (uint8_t*)calloc(n_v, 1);
 804ac1a:	4604      	mov	r4, r0
	for (i = i_pivot, flag[i] = 16; i >= 0; --i) {
 804ac1c:	f800 500a 	strb.w	r5, [r0, sl]
 804ac20:	db7d      	blt.n	804ad1e <kad_unroll+0x466>
 804ac22:	f10a 0701 	add.w	r7, sl, #1
 804ac26:	4427      	add	r7, r4
		if (flag[i]&16) /* flag 16: nodes to unroll */
 804ac28:	f817 3d01 	ldrb.w	r3, [r7, #-1]!
			kad_unroll_helper(n_v, v, i_pivots[i], t, len[i], &w);
 804ac2c:	4650      	mov	r0, sl
		if (flag[i]&16) /* flag 16: nodes to unroll */
 804ac2e:	06da      	lsls	r2, r3, #27
 804ac30:	9e01      	ldr	r6, [sp, #4]
 804ac32:	d409      	bmi.n	804ac48 <kad_unroll+0x390>
	for (i = i_pivot, flag[i] = 16; i >= 0; --i) {
 804ac34:	1e41      	subs	r1, r0, #1
 804ac36:	458a      	cmp	sl, r1
 804ac38:	f1a6 0604 	sub.w	r6, r6, #4
 804ac3c:	dc17      	bgt.n	804ac6e <kad_unroll+0x3b6>
		if (flag[i]&16) /* flag 16: nodes to unroll */
 804ac3e:	f817 3d01 	ldrb.w	r3, [r7, #-1]!
	for (i = i_pivot, flag[i] = 16; i >= 0; --i) {
 804ac42:	4608      	mov	r0, r1
		if (flag[i]&16) /* flag 16: nodes to unroll */
 804ac44:	06da      	lsls	r2, r3, #27
 804ac46:	d5f5      	bpl.n	804ac34 <kad_unroll+0x37c>
			for (j = 0; j < v[i]->n_child; ++j)
 804ac48:	6833      	ldr	r3, [r6, #0]
 804ac4a:	6859      	ldr	r1, [r3, #4]
 804ac4c:	2900      	cmp	r1, #0
 804ac4e:	ddf1      	ble.n	804ac34 <kad_unroll+0x37c>
				flag[v[i]->child[j]->tmp] = 16;
 804ac50:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 804ac52:	3b04      	subs	r3, #4
 804ac54:	eb03 0181 	add.w	r1, r3, r1, lsl #2
 804ac58:	f853 2f04 	ldr.w	r2, [r3, #4]!
 804ac5c:	6892      	ldr	r2, [r2, #8]
			for (j = 0; j < v[i]->n_child; ++j)
 804ac5e:	4299      	cmp	r1, r3
				flag[v[i]->child[j]->tmp] = 16;
 804ac60:	54a5      	strb	r5, [r4, r2]
			for (j = 0; j < v[i]->n_child; ++j)
 804ac62:	d1f9      	bne.n	804ac58 <kad_unroll+0x3a0>
	for (i = i_pivot, flag[i] = 16; i >= 0; --i) {
 804ac64:	1e41      	subs	r1, r0, #1
 804ac66:	458a      	cmp	sl, r1
 804ac68:	f1a6 0604 	sub.w	r6, r6, #4
 804ac6c:	dde7      	ble.n	804ac3e <kad_unroll+0x386>
 804ac6e:	1c4d      	adds	r5, r1, #1
 804ac70:	d023      	beq.n	804acba <kad_unroll+0x402>
 804ac72:	9b0d      	ldr	r3, [sp, #52]	@ 0x34
				flag[v[i]->child[j]->tmp] = 16;
 804ac74:	2610      	movs	r6, #16
 804ac76:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 804ac7a:	4421      	add	r1, r4
 804ac7c:	e004      	b.n	804ac88 <kad_unroll+0x3d0>
	for (i = i_pivot, flag[i] = 16; i >= 0; --i) {
 804ac7e:	428c      	cmp	r4, r1
 804ac80:	f101 33ff 	add.w	r3, r1, #4294967295
 804ac84:	d019      	beq.n	804acba <kad_unroll+0x402>
 804ac86:	4619      	mov	r1, r3
		if (i < i_pivot && kad_is_pivot(v[i])) continue; /* don't trespass other pivots */
 804ac88:	f850 2d04 	ldr.w	r2, [r0, #-4]!
 804ac8c:	6855      	ldr	r5, [r2, #4]
 804ac8e:	2d01      	cmp	r5, #1
 804ac90:	f000 816c 	beq.w	804af6c <kad_unroll+0x6b4>
		if (flag[i]&16) /* flag 16: nodes to unroll */
 804ac94:	780b      	ldrb	r3, [r1, #0]
 804ac96:	06df      	lsls	r7, r3, #27
 804ac98:	d5f1      	bpl.n	804ac7e <kad_unroll+0x3c6>
			for (j = 0; j < v[i]->n_child; ++j)
 804ac9a:	2d00      	cmp	r5, #0
 804ac9c:	ddef      	ble.n	804ac7e <kad_unroll+0x3c6>
				flag[v[i]->child[j]->tmp] = 16;
 804ac9e:	6b93      	ldr	r3, [r2, #56]	@ 0x38
 804aca0:	3b04      	subs	r3, #4
 804aca2:	eb03 0585 	add.w	r5, r3, r5, lsl #2
 804aca6:	f853 2f04 	ldr.w	r2, [r3, #4]!
 804acaa:	6892      	ldr	r2, [r2, #8]
			for (j = 0; j < v[i]->n_child; ++j)
 804acac:	429d      	cmp	r5, r3
				flag[v[i]->child[j]->tmp] = 16;
 804acae:	54a6      	strb	r6, [r4, r2]
			for (j = 0; j < v[i]->n_child; ++j)
 804acb0:	d1f9      	bne.n	804aca6 <kad_unroll+0x3ee>
	for (i = i_pivot, flag[i] = 16; i >= 0; --i) {
 804acb2:	428c      	cmp	r4, r1
 804acb4:	f101 33ff 	add.w	r3, r1, #4294967295
 804acb8:	d1e5      	bne.n	804ac86 <kad_unroll+0x3ce>
	for (i = 0; i < i_pivot; ++i) {
 804acba:	f1ba 0f00 	cmp.w	sl, #0
 804acbe:	d02e      	beq.n	804ad1e <kad_unroll+0x466>
 804acc0:	f10a 36ff 	add.w	r6, sl, #4294967295
 804acc4:	9a0d      	ldr	r2, [sp, #52]	@ 0x34
 804acc6:	4426      	add	r6, r4
 804acc8:	1e63      	subs	r3, r4, #1
 804acca:	e01a      	b.n	804ad02 <kad_unroll+0x44a>
 804accc:	f3af 8000 	nop.w
	...
 804acd8:	20018004 	.word	0x20018004
 804acdc:	20018344 	.word	0x20018344
		if (kad_is_var(v[i]) || kad_is_const(v[i]) || kad_is_pivot(v[i])) flag[i] |= 1; /* external nodes that should not be duplicated */
 804ace0:	7845      	ldrb	r5, [r0, #1]
 804ace2:	07af      	lsls	r7, r5, #30
 804ace4:	d002      	beq.n	804acec <kad_unroll+0x434>
 804ace6:	f041 0101 	orr.w	r1, r1, #1
 804acea:	7019      	strb	r1, [r3, #0]
		if (v[i]->pre) flag[v[i]->pre->tmp] |= 2;
 804acec:	6bc1      	ldr	r1, [r0, #60]	@ 0x3c
 804acee:	b121      	cbz	r1, 804acfa <kad_unroll+0x442>
 804acf0:	6888      	ldr	r0, [r1, #8]
 804acf2:	5c21      	ldrb	r1, [r4, r0]
 804acf4:	f041 0102 	orr.w	r1, r1, #2
 804acf8:	5421      	strb	r1, [r4, r0]
	for (i = 0; i < i_pivot; ++i) {
 804acfa:	42b3      	cmp	r3, r6
 804acfc:	f102 0204 	add.w	r2, r2, #4
 804ad00:	d00d      	beq.n	804ad1e <kad_unroll+0x466>
		if (!(flag[i]&16)) continue;
 804ad02:	f813 1f01 	ldrb.w	r1, [r3, #1]!
 804ad06:	06c8      	lsls	r0, r1, #27
 804ad08:	d5f7      	bpl.n	804acfa <kad_unroll+0x442>
		if (kad_is_var(v[i]) || kad_is_const(v[i]) || kad_is_pivot(v[i])) flag[i] |= 1; /* external nodes that should not be duplicated */
 804ad0a:	6810      	ldr	r0, [r2, #0]
 804ad0c:	6845      	ldr	r5, [r0, #4]
 804ad0e:	2d00      	cmp	r5, #0
 804ad10:	d0e6      	beq.n	804ace0 <kad_unroll+0x428>
 804ad12:	2d01      	cmp	r5, #1
 804ad14:	d1ea      	bne.n	804acec <kad_unroll+0x434>
 804ad16:	7845      	ldrb	r5, [r0, #1]
 804ad18:	076d      	lsls	r5, r5, #29
 804ad1a:	d5e7      	bpl.n	804acec <kad_unroll+0x434>
 804ad1c:	e7e3      	b.n	804ace6 <kad_unroll+0x42e>
	aux = (kad_node_t**)calloc(n_v, sizeof(kad_node_t*));
 804ad1e:	2104      	movs	r1, #4
	flag[v[i_pivot]->child[0]->tmp] |= 4;
 804ad20:	9b0d      	ldr	r3, [sp, #52]	@ 0x34
	aux = (kad_node_t**)calloc(n_v, sizeof(kad_node_t*));
 804ad22:	9810      	ldr	r0, [sp, #64]	@ 0x40
	flag[v[i_pivot]->child[0]->tmp] |= 4;
 804ad24:	f853 302a 	ldr.w	r3, [r3, sl, lsl #2]
 804ad28:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 804ad2a:	681b      	ldr	r3, [r3, #0]
 804ad2c:	689a      	ldr	r2, [r3, #8]
 804ad2e:	5ca3      	ldrb	r3, [r4, r2]
 804ad30:	430b      	orrs	r3, r1
 804ad32:	54a3      	strb	r3, [r4, r2]
	aux = (kad_node_t**)calloc(n_v, sizeof(kad_node_t*));
 804ad34:	f000 fd38 	bl	804b7a8 <calloc>
	for (l = 0; l < len; ++l) {
 804ad38:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
	aux = (kad_node_t**)calloc(n_v, sizeof(kad_node_t*));
 804ad3a:	900b      	str	r0, [sp, #44]	@ 0x2c
	for (l = 0; l < len; ++l) {
 804ad3c:	2b00      	cmp	r3, #0
 804ad3e:	f340 80ae 	ble.w	804ae9e <kad_unroll+0x5e6>
 804ad42:	2200      	movs	r2, #0
				if (l == len - 1) t[i]->pre = aux[v[i]->pre->tmp]; /* this forms a cycle! */
 804ad44:	3b01      	subs	r3, #1
 804ad46:	9d0f      	ldr	r5, [sp, #60]	@ 0x3c
 804ad48:	9307      	str	r3, [sp, #28]
 804ad4a:	f8cd b04c 	str.w	fp, [sp, #76]	@ 0x4c
		for (i = 0; i < i_pivot; ++i) {
 804ad4e:	f1ba 0f00 	cmp.w	sl, #0
 804ad52:	f340 809a 	ble.w	804ae8a <kad_unroll+0x5d2>
 804ad56:	f10a 33ff 	add.w	r3, sl, #4294967295
 804ad5a:	18e3      	adds	r3, r4, r3
 804ad5c:	f104 3bff 	add.w	fp, r4, #4294967295
 804ad60:	9301      	str	r3, [sp, #4]
 804ad62:	0093      	lsls	r3, r2, #2
	q->pre = 0, q->tmp = 0, q->gtmp = 0;
 804ad64:	465e      	mov	r6, fp
		for (i = 0; i < i_pivot; ++i) {
 804ad66:	f04f 0900 	mov.w	r9, #0
	q->pre = 0, q->tmp = 0, q->gtmp = 0;
 804ad6a:	46ab      	mov	fp, r5
 804ad6c:	e9cd a409 	strd	sl, r4, [sp, #36]	@ 0x24
				if (l == len - 1) t[i]->pre = aux[v[i]->pre->tmp]; /* this forms a cycle! */
 804ad70:	f8dd 8034 	ldr.w	r8, [sp, #52]	@ 0x34
 804ad74:	9306      	str	r3, [sp, #24]
	q->pre = 0, q->tmp = 0, q->gtmp = 0;
 804ad76:	9202      	str	r2, [sp, #8]
 804ad78:	e009      	b.n	804ad8e <kad_unroll+0x4d6>
			if (!(flag[i]&16) || ((flag[i]&3) && t[i])) continue;
 804ad7a:	f85b 3029 	ldr.w	r3, [fp, r9, lsl #2]
 804ad7e:	b173      	cbz	r3, 804ad9e <kad_unroll+0x4e6>
		for (i = 0; i < i_pivot; ++i) {
 804ad80:	9b01      	ldr	r3, [sp, #4]
 804ad82:	f109 0901 	add.w	r9, r9, #1
 804ad86:	429e      	cmp	r6, r3
 804ad88:	f108 0804 	add.w	r8, r8, #4
 804ad8c:	d078      	beq.n	804ae80 <kad_unroll+0x5c8>
			if (!(flag[i]&16) || ((flag[i]&3) && t[i])) continue;
 804ad8e:	f816 af01 	ldrb.w	sl, [r6, #1]!
 804ad92:	f01a 0f10 	tst.w	sl, #16
 804ad96:	d0f3      	beq.n	804ad80 <kad_unroll+0x4c8>
 804ad98:	f01a 0f03 	tst.w	sl, #3
 804ad9c:	d1ed      	bne.n	804ad7a <kad_unroll+0x4c2>
	q = (kad_node_t*)malloc(sizeof(kad_node_t));
 804ad9e:	2040      	movs	r0, #64	@ 0x40
			t[i] = kad_dup1(v[i]);
 804ada0:	f8d8 7000 	ldr.w	r7, [r8]
	q = (kad_node_t*)malloc(sizeof(kad_node_t));
 804ada4:	f000 fd1c 	bl	804b7e0 <malloc>
	memcpy(q, p, sizeof(kad_node_t));
 804ada8:	463c      	mov	r4, r7
	q = (kad_node_t*)malloc(sizeof(kad_node_t));
 804adaa:	4605      	mov	r5, r0
	memcpy(q, p, sizeof(kad_node_t));
 804adac:	4684      	mov	ip, r0
	heapSize += sizeof(kad_node_t);
 804adae:	4a8f      	ldr	r2, [pc, #572]	@ (804afec <kad_unroll+0x734>)
	memcpy(q, p, sizeof(kad_node_t));
 804adb0:	f107 0e40 	add.w	lr, r7, #64	@ 0x40
	heapSize += sizeof(kad_node_t);
 804adb4:	6813      	ldr	r3, [r2, #0]
	memcpy(q, p, sizeof(kad_node_t));
 804adb6:	f8cd b00c 	str.w	fp, [sp, #12]
	heapSize += sizeof(kad_node_t);
 804adba:	3340      	adds	r3, #64	@ 0x40
 804adbc:	6013      	str	r3, [r2, #0]
	memcpy(q, p, sizeof(kad_node_t));
 804adbe:	46e3      	mov	fp, ip
 804adc0:	6820      	ldr	r0, [r4, #0]
 804adc2:	6861      	ldr	r1, [r4, #4]
 804adc4:	68a2      	ldr	r2, [r4, #8]
 804adc6:	68e3      	ldr	r3, [r4, #12]
 804adc8:	3410      	adds	r4, #16
 804adca:	4574      	cmp	r4, lr
 804adcc:	e8ab 000f 	stmia.w	fp!, {r0, r1, r2, r3}
 804add0:	f10c 0c10 	add.w	ip, ip, #16
 804add4:	d1f3      	bne.n	804adbe <kad_unroll+0x506>
	q->pre = 0, q->tmp = 0, q->gtmp = 0;
 804add6:	2300      	movs	r3, #0
	if (p->ptr && p->ptr_size > 0) {
 804add8:	6b39      	ldr	r1, [r7, #48]	@ 0x30
	q->pre = 0, q->tmp = 0, q->gtmp = 0;
 804adda:	f8dd b00c 	ldr.w	fp, [sp, #12]
 804adde:	63eb      	str	r3, [r5, #60]	@ 0x3c
 804ade0:	60ab      	str	r3, [r5, #8]
 804ade2:	636b      	str	r3, [r5, #52]	@ 0x34
	if (p->ptr && p->ptr_size > 0) {
 804ade4:	b1b1      	cbz	r1, 804ae14 <kad_unroll+0x55c>
 804ade6:	68fc      	ldr	r4, [r7, #12]
 804ade8:	429c      	cmp	r4, r3
 804adea:	dd13      	ble.n	804ae14 <kad_unroll+0x55c>
		if (kad_use_rng(p) && !(p->flag & KAD_SHARE_RNG) && p->ptr_size == sizeof(kad_rng_t)) {
 804adec:	887b      	ldrh	r3, [r7, #2]
 804adee:	2b0f      	cmp	r3, #15
 804adf0:	f000 80ad 	beq.w	804af4e <kad_unroll+0x696>
 804adf4:	2b18      	cmp	r3, #24
 804adf6:	f000 80aa 	beq.w	804af4e <kad_unroll+0x696>
			q->ptr = malloc(p->ptr_size);
 804adfa:	4620      	mov	r0, r4
 804adfc:	9103      	str	r1, [sp, #12]
 804adfe:	f000 fcef 	bl	804b7e0 <malloc>
			heapSize += p->ptr_size;
 804ae02:	4a7a      	ldr	r2, [pc, #488]	@ (804afec <kad_unroll+0x734>)
			memcpy(q->ptr, p->ptr, p->ptr_size);
 804ae04:	9903      	ldr	r1, [sp, #12]
			heapSize += p->ptr_size;
 804ae06:	6813      	ldr	r3, [r2, #0]
			q->ptr = malloc(p->ptr_size);
 804ae08:	6328      	str	r0, [r5, #48]	@ 0x30
			heapSize += p->ptr_size;
 804ae0a:	4423      	add	r3, r4
 804ae0c:	6013      	str	r3, [r2, #0]
			memcpy(q->ptr, p->ptr, p->ptr_size);
 804ae0e:	4622      	mov	r2, r4
 804ae10:	f001 f8d1 	bl	804bfb6 <memcpy>
	if (q->n_child) {
 804ae14:	686c      	ldr	r4, [r5, #4]
 804ae16:	2c00      	cmp	r4, #0
 804ae18:	d16f      	bne.n	804aefa <kad_unroll+0x642>
			if (v[i]->n_child)
 804ae1a:	687b      	ldr	r3, [r7, #4]
			t[i] = kad_dup1(v[i]);
 804ae1c:	f84b 5029 	str.w	r5, [fp, r9, lsl #2]
			if (v[i]->n_child)
 804ae20:	2b00      	cmp	r3, #0
 804ae22:	dc7b      	bgt.n	804af1c <kad_unroll+0x664>
			if (flag[i]&4) t[i_pivot]->child[l] = t[i];
 804ae24:	f01a 0f04 	tst.w	sl, #4
 804ae28:	d006      	beq.n	804ae38 <kad_unroll+0x580>
 804ae2a:	9b08      	ldr	r3, [sp, #32]
 804ae2c:	9a06      	ldr	r2, [sp, #24]
 804ae2e:	681b      	ldr	r3, [r3, #0]
 804ae30:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 804ae32:	509d      	str	r5, [r3, r2]
			if (v[i]->pre) {
 804ae34:	f8d8 7000 	ldr.w	r7, [r8]
			if (l == 0 && (flag[i]&2)) aux[i] = t[i];
 804ae38:	9b02      	ldr	r3, [sp, #8]
 804ae3a:	b92b      	cbnz	r3, 804ae48 <kad_unroll+0x590>
 804ae3c:	f01a 0f02 	tst.w	sl, #2
 804ae40:	bf1c      	itt	ne
 804ae42:	9b0b      	ldrne	r3, [sp, #44]	@ 0x2c
 804ae44:	f843 5029 	strne.w	r5, [r3, r9, lsl #2]
			if (v[i]->pre) {
 804ae48:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 804ae4a:	b143      	cbz	r3, 804ae5e <kad_unroll+0x5a6>
				if (l == len - 1) t[i]->pre = aux[v[i]->pre->tmp]; /* this forms a cycle! */
 804ae4c:	9a07      	ldr	r2, [sp, #28]
 804ae4e:	9902      	ldr	r1, [sp, #8]
				t[v[i]->pre->tmp] = t[i];
 804ae50:	689b      	ldr	r3, [r3, #8]
				if (l == len - 1) t[i]->pre = aux[v[i]->pre->tmp]; /* this forms a cycle! */
 804ae52:	428a      	cmp	r2, r1
				t[v[i]->pre->tmp] = t[i];
 804ae54:	f84b 5023 	str.w	r5, [fp, r3, lsl #2]
				if (l == len - 1) t[i]->pre = aux[v[i]->pre->tmp]; /* this forms a cycle! */
 804ae58:	d072      	beq.n	804af40 <kad_unroll+0x688>
 804ae5a:	f85b 5029 	ldr.w	r5, [fp, r9, lsl #2]
	if (w->n == w->m) {
 804ae5e:	9b05      	ldr	r3, [sp, #20]
 804ae60:	9a00      	ldr	r2, [sp, #0]
 804ae62:	4293      	cmp	r3, r2
 804ae64:	d03f      	beq.n	804aee6 <kad_unroll+0x62e>
	w->v[w->n++] = p;
 804ae66:	9b00      	ldr	r3, [sp, #0]
 804ae68:	9a04      	ldr	r2, [sp, #16]
		for (i = 0; i < i_pivot; ++i) {
 804ae6a:	f109 0901 	add.w	r9, r9, #1
	w->v[w->n++] = p;
 804ae6e:	f842 5023 	str.w	r5, [r2, r3, lsl #2]
 804ae72:	3301      	adds	r3, #1
 804ae74:	9300      	str	r3, [sp, #0]
		for (i = 0; i < i_pivot; ++i) {
 804ae76:	9b01      	ldr	r3, [sp, #4]
 804ae78:	f108 0804 	add.w	r8, r8, #4
 804ae7c:	429e      	cmp	r6, r3
 804ae7e:	d186      	bne.n	804ad8e <kad_unroll+0x4d6>
 804ae80:	465d      	mov	r5, fp
 804ae82:	f8dd a024 	ldr.w	sl, [sp, #36]	@ 0x24
 804ae86:	9c0a      	ldr	r4, [sp, #40]	@ 0x28
 804ae88:	9a02      	ldr	r2, [sp, #8]
	for (l = 0; l < len; ++l) {
 804ae8a:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
 804ae8c:	3201      	adds	r2, #1
 804ae8e:	4293      	cmp	r3, r2
 804ae90:	f47f af5d 	bne.w	804ad4e <kad_unroll+0x496>
	push_nodes(w, t[i_pivot]);
 804ae94:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
 804ae96:	f8dd b04c 	ldr.w	fp, [sp, #76]	@ 0x4c
 804ae9a:	f853 902a 	ldr.w	r9, [r3, sl, lsl #2]
 804ae9e:	9d00      	ldr	r5, [sp, #0]
	if (w->n == w->m) {
 804aea0:	9b05      	ldr	r3, [sp, #20]
 804aea2:	42ab      	cmp	r3, r5
 804aea4:	d06b      	beq.n	804af7e <kad_unroll+0x6c6>
	w->v[w->n++] = p;
 804aea6:	9b04      	ldr	r3, [sp, #16]
	free(aux); free(flag);
 804aea8:	980b      	ldr	r0, [sp, #44]	@ 0x2c
	w->v[w->n++] = p;
 804aeaa:	f843 9025 	str.w	r9, [r3, r5, lsl #2]
	free(aux); free(flag);
 804aeae:	f000 fc9f 	bl	804b7f0 <free>
 804aeb2:	4620      	mov	r0, r4
 804aeb4:	f000 fc9c 	bl	804b7f0 <free>
	w->v[w->n++] = p;
 804aeb8:	9b00      	ldr	r3, [sp, #0]
		for (i = 0; i < n_pivots; ++i) /* unroll each pivot, from the lowest to the highest */
 804aeba:	f10b 0b01 	add.w	fp, fp, #1
	w->v[w->n++] = p;
 804aebe:	3301      	adds	r3, #1
 804aec0:	9300      	str	r3, [sp, #0]
		for (i = 0; i < n_pivots; ++i) /* unroll each pivot, from the lowest to the highest */
 804aec2:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
 804aec4:	459b      	cmp	fp, r3
 804aec6:	f47f ae32 	bne.w	804ab2e <kad_unroll+0x276>
		free(i_pivots);
 804aeca:	e9dd 7915 	ldrd	r7, r9, [sp, #84]	@ 0x54
 804aece:	e9dd 5417 	ldrd	r5, r4, [sp, #92]	@ 0x5c
 804aed2:	4648      	mov	r0, r9
 804aed4:	f8dd 803c 	ldr.w	r8, [sp, #60]	@ 0x3c
 804aed8:	f8dd a064 	ldr.w	sl, [sp, #100]	@ 0x64
 804aedc:	f000 fc88 	bl	804b7f0 <free>
	w->v[w->n++] = p;
 804aee0:	9b00      	ldr	r3, [sp, #0]
 804aee2:	930e      	str	r3, [sp, #56]	@ 0x38
 804aee4:	e520      	b.n	804a928 <kad_unroll+0x70>
		w->m = w->m? w->m<<1 : 16;
 804aee6:	2b00      	cmp	r3, #0
 804aee8:	d03c      	beq.n	804af64 <kad_unroll+0x6ac>
 804aeea:	005b      	lsls	r3, r3, #1
 804aeec:	9305      	str	r3, [sp, #20]
		w->v = (kad_node_t**)realloc(w->v, w->m * sizeof(kad_node_t*));
 804aeee:	0099      	lsls	r1, r3, #2
 804aef0:	9804      	ldr	r0, [sp, #16]
 804aef2:	f000 fd61 	bl	804b9b8 <realloc>
 804aef6:	9004      	str	r0, [sp, #16]
 804aef8:	e7b5      	b.n	804ae66 <kad_unroll+0x5ae>
		q->x = q->g = 0;
 804aefa:	ed85 8b0a 	vstr	d8, [r5, #40]	@ 0x28
		q->child = (kad_node_t**)calloc(q->n_child, sizeof(kad_node_t*));
 804aefe:	2104      	movs	r1, #4
 804af00:	4620      	mov	r0, r4
 804af02:	f000 fc51 	bl	804b7a8 <calloc>
		heapSize += q->n_child * sizeof(kad_node_t*);
 804af06:	4a39      	ldr	r2, [pc, #228]	@ (804afec <kad_unroll+0x734>)
		q->child = (kad_node_t**)calloc(q->n_child, sizeof(kad_node_t*));
 804af08:	63a8      	str	r0, [r5, #56]	@ 0x38
		heapSize += q->n_child * sizeof(kad_node_t*);
 804af0a:	6813      	ldr	r3, [r2, #0]
			t[i] = kad_dup1(v[i]);
 804af0c:	f84b 5029 	str.w	r5, [fp, r9, lsl #2]
		heapSize += q->n_child * sizeof(kad_node_t*);
 804af10:	eb03 0384 	add.w	r3, r3, r4, lsl #2
 804af14:	6013      	str	r3, [r2, #0]
			if (v[i]->n_child)
 804af16:	687b      	ldr	r3, [r7, #4]
 804af18:	2b00      	cmp	r3, #0
 804af1a:	dd83      	ble.n	804ae24 <kad_unroll+0x56c>
				for (j = 0; j < v[i]->n_child; ++j)
 804af1c:	2300      	movs	r3, #0
 804af1e:	6baa      	ldr	r2, [r5, #56]	@ 0x38
 804af20:	3a04      	subs	r2, #4
					t[i]->child[j] = t[v[i]->child[j]->tmp];
 804af22:	6bb9      	ldr	r1, [r7, #56]	@ 0x38
 804af24:	f851 1023 	ldr.w	r1, [r1, r3, lsl #2]
				for (j = 0; j < v[i]->n_child; ++j)
 804af28:	3301      	adds	r3, #1
					t[i]->child[j] = t[v[i]->child[j]->tmp];
 804af2a:	6889      	ldr	r1, [r1, #8]
 804af2c:	f85b 1021 	ldr.w	r1, [fp, r1, lsl #2]
 804af30:	f842 1f04 	str.w	r1, [r2, #4]!
				for (j = 0; j < v[i]->n_child; ++j)
 804af34:	f8d8 7000 	ldr.w	r7, [r8]
 804af38:	6879      	ldr	r1, [r7, #4]
 804af3a:	428b      	cmp	r3, r1
 804af3c:	dbf1      	blt.n	804af22 <kad_unroll+0x66a>
 804af3e:	e771      	b.n	804ae24 <kad_unroll+0x56c>
				if (l == len - 1) t[i]->pre = aux[v[i]->pre->tmp]; /* this forms a cycle! */
 804af40:	9a0b      	ldr	r2, [sp, #44]	@ 0x2c
 804af42:	f85b 5029 	ldr.w	r5, [fp, r9, lsl #2]
 804af46:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 804af4a:	63eb      	str	r3, [r5, #60]	@ 0x3c
 804af4c:	e787      	b.n	804ae5e <kad_unroll+0x5a6>
		if (kad_use_rng(p) && !(p->flag & KAD_SHARE_RNG) && p->ptr_size == sizeof(kad_rng_t)) {
 804af4e:	787b      	ldrb	r3, [r7, #1]
 804af50:	06d8      	lsls	r0, r3, #27
 804af52:	f53f af52 	bmi.w	804adfa <kad_unroll+0x542>
 804af56:	2c20      	cmp	r4, #32
 804af58:	f47f af4f 	bne.w	804adfa <kad_unroll+0x542>
			q->ptr = kad_rng(); /* each time step uses a different RNG */
 804af5c:	f7ff fbf4 	bl	804a748 <kad_rng>
 804af60:	6328      	str	r0, [r5, #48]	@ 0x30
 804af62:	e757      	b.n	804ae14 <kad_unroll+0x55c>
		w->m = w->m? w->m<<1 : 16;
 804af64:	2310      	movs	r3, #16
 804af66:	2140      	movs	r1, #64	@ 0x40
 804af68:	9305      	str	r3, [sp, #20]
 804af6a:	e7c1      	b.n	804aef0 <kad_unroll+0x638>
		if (i < i_pivot && kad_is_pivot(v[i])) continue; /* don't trespass other pivots */
 804af6c:	7853      	ldrb	r3, [r2, #1]
 804af6e:	075b      	lsls	r3, r3, #29
 804af70:	f53f ae85 	bmi.w	804ac7e <kad_unroll+0x3c6>
		if (flag[i]&16) /* flag 16: nodes to unroll */
 804af74:	780b      	ldrb	r3, [r1, #0]
 804af76:	06db      	lsls	r3, r3, #27
 804af78:	f57f ae81 	bpl.w	804ac7e <kad_unroll+0x3c6>
 804af7c:	e68f      	b.n	804ac9e <kad_unroll+0x3e6>
		w->m = w->m? w->m<<1 : 16;
 804af7e:	b313      	cbz	r3, 804afc6 <kad_unroll+0x70e>
 804af80:	005b      	lsls	r3, r3, #1
 804af82:	9305      	str	r3, [sp, #20]
		w->v = (kad_node_t**)realloc(w->v, w->m * sizeof(kad_node_t*));
 804af84:	0099      	lsls	r1, r3, #2
 804af86:	9804      	ldr	r0, [sp, #16]
 804af88:	f000 fd16 	bl	804b9b8 <realloc>
 804af8c:	9004      	str	r0, [sp, #16]
 804af8e:	e78a      	b.n	804aea6 <kad_unroll+0x5ee>
		q->x = q->g = 0;
 804af90:	ed89 8b0a 	vstr	d8, [r9, #40]	@ 0x28
		q->child = (kad_node_t**)calloc(q->n_child, sizeof(kad_node_t*));
 804af94:	2104      	movs	r1, #4
 804af96:	4620      	mov	r0, r4
 804af98:	f000 fc06 	bl	804b7a8 <calloc>
		heapSize += q->n_child * sizeof(kad_node_t*);
 804af9c:	4a13      	ldr	r2, [pc, #76]	@ (804afec <kad_unroll+0x734>)
		q->child = (kad_node_t**)calloc(q->n_child, sizeof(kad_node_t*));
 804af9e:	f8c9 0038 	str.w	r0, [r9, #56]	@ 0x38
		heapSize += q->n_child * sizeof(kad_node_t*);
 804afa2:	6813      	ldr	r3, [r2, #0]
 804afa4:	eb03 0384 	add.w	r3, r3, r4, lsl #2
 804afa8:	6013      	str	r3, [r2, #0]
 804afaa:	e624      	b.n	804abf6 <kad_unroll+0x33e>
		if (kad_use_rng(p) && !(p->flag & KAD_SHARE_RNG) && p->ptr_size == sizeof(kad_rng_t)) {
 804afac:	f898 3001 	ldrb.w	r3, [r8, #1]
 804afb0:	06d9      	lsls	r1, r3, #27
 804afb2:	f53f ae0c 	bmi.w	804abce <kad_unroll+0x316>
 804afb6:	2c20      	cmp	r4, #32
 804afb8:	f47f ae09 	bne.w	804abce <kad_unroll+0x316>
			q->ptr = kad_rng(); /* each time step uses a different RNG */
 804afbc:	f7ff fbc4 	bl	804a748 <kad_rng>
 804afc0:	f8c9 0030 	str.w	r0, [r9, #48]	@ 0x30
 804afc4:	e610      	b.n	804abe8 <kad_unroll+0x330>
		w->m = w->m? w->m<<1 : 16;
 804afc6:	2310      	movs	r3, #16
 804afc8:	2140      	movs	r1, #64	@ 0x40
 804afca:	9305      	str	r3, [sp, #20]
 804afcc:	e7db      	b.n	804af86 <kad_unroll+0x6ce>
	free(t);
 804afce:	2300      	movs	r3, #0
 804afd0:	461c      	mov	r4, r3
 804afd2:	9304      	str	r3, [sp, #16]
 804afd4:	f000 fc0c 	bl	804b7f0 <free>
 804afd8:	940e      	str	r4, [sp, #56]	@ 0x38
 804afda:	e530      	b.n	804aa3e <kad_unroll+0x186>
	assert(kad_is_pivot(v[i_pivot]) && t[i_pivot] == 0);
 804afdc:	f240 21ff 	movw	r1, #767	@ 0x2ff
 804afe0:	4b03      	ldr	r3, [pc, #12]	@ (804aff0 <kad_unroll+0x738>)
 804afe2:	4a04      	ldr	r2, [pc, #16]	@ (804aff4 <kad_unroll+0x73c>)
 804afe4:	4804      	ldr	r0, [pc, #16]	@ (804aff8 <kad_unroll+0x740>)
 804afe6:	f000 fbc1 	bl	804b76c <__assert_func>
 804afea:	bf00      	nop
 804afec:	20018344 	.word	0x20018344
 804aff0:	0804e410 	.word	0x0804e410
 804aff4:	0804e514 	.word	0x0804e514
 804aff8:	0804e328 	.word	0x0804e328

0804affc <kad_drand>:
	u.i = 0x3FFULL << 52 | kad_xoroshiro128plus_next(d? (kad_rng_t*)d : &kad_rng_dat) >> 12;
 804affc:	4b1f      	ldr	r3, [pc, #124]	@ (804b07c <kad_drand+0x80>)
{
 804affe:	b570      	push	{r4, r5, r6, lr}
	u.i = 0x3FFULL << 52 | kad_xoroshiro128plus_next(d? (kad_rng_t*)d : &kad_rng_dat) >> 12;
 804b000:	2800      	cmp	r0, #0
 804b002:	bf14      	ite	ne
 804b004:	4602      	movne	r2, r0
 804b006:	461a      	moveq	r2, r3
	const uint64_t s0 = r->s[0];
 804b008:	6811      	ldr	r1, [r2, #0]
 804b00a:	e9d2 3001 	ldrd	r3, r0, [r2, #4]
	s1 ^= s0;
 804b00e:	ea81 0c00 	eor.w	ip, r1, r0
	const uint64_t result = s0 + s1;
 804b012:	180c      	adds	r4, r1, r0
	r->s[0] = (s0 << 55 | s0 >> 9) ^ s1 ^ (s1 << 14);
 804b014:	ea4f 2051 	mov.w	r0, r1, lsr #9
 804b018:	ea40 50c3 	orr.w	r0, r0, r3, lsl #23
 804b01c:	ea80 000c 	eor.w	r0, r0, ip
	uint64_t s1 = r->s[1];
 804b020:	68d6      	ldr	r6, [r2, #12]
	r->s[0] = (s0 << 55 | s0 >> 9) ^ s1 ^ (s1 << 14);
 804b022:	ea80 308c 	eor.w	r0, r0, ip, lsl #14
 804b026:	6010      	str	r0, [r2, #0]
 804b028:	ea4f 2053 	mov.w	r0, r3, lsr #9
	s1 ^= s0;
 804b02c:	ea83 0506 	eor.w	r5, r3, r6
	r->s[0] = (s0 << 55 | s0 >> 9) ^ s1 ^ (s1 << 14);
 804b030:	ea40 50c1 	orr.w	r0, r0, r1, lsl #23
 804b034:	ea80 0005 	eor.w	r0, r0, r5
 804b038:	ea4f 3585 	mov.w	r5, r5, lsl #14
 804b03c:	ea45 459c 	orr.w	r5, r5, ip, lsr #18
 804b040:	ea80 0005 	eor.w	r0, r0, r5
	const uint64_t result = s0 + s1;
 804b044:	eb43 0e06 	adc.w	lr, r3, r6
	r->s[0] = (s0 << 55 | s0 >> 9) ^ s1 ^ (s1 << 14);
 804b048:	6050      	str	r0, [r2, #4]
	r->s[1] = s0 << 36 | s0 >> 28;
 804b04a:	0f08      	lsrs	r0, r1, #28
	u.i = 0x3FFULL << 52 | kad_xoroshiro128plus_next(d? (kad_rng_t*)d : &kad_rng_dat) >> 12;
 804b04c:	ea4f 351e 	mov.w	r5, lr, lsr #12
	r->s[1] = s0 << 36 | s0 >> 28;
 804b050:	ea40 1003 	orr.w	r0, r0, r3, lsl #4
 804b054:	0f1b      	lsrs	r3, r3, #28
 804b056:	ea43 1301 	orr.w	r3, r3, r1, lsl #4
	u.i = 0x3FFULL << 52 | kad_xoroshiro128plus_next(d? (kad_rng_t*)d : &kad_rng_dat) >> 12;
 804b05a:	0b24      	lsrs	r4, r4, #12
 804b05c:	f045 517f 	orr.w	r1, r5, #1069547520	@ 0x3fc00000
	r->s[1] = s0 << 36 | s0 >> 28;
 804b060:	6090      	str	r0, [r2, #8]
 804b062:	60d3      	str	r3, [r2, #12]
	u.i = 0x3FFULL << 52 | kad_xoroshiro128plus_next(d? (kad_rng_t*)d : &kad_rng_dat) >> 12;
 804b064:	ea44 500e 	orr.w	r0, r4, lr, lsl #20
	return u.d - 1.0;
 804b068:	2200      	movs	r2, #0
 804b06a:	4b05      	ldr	r3, [pc, #20]	@ (804b080 <kad_drand+0x84>)
	u.i = 0x3FFULL << 52 | kad_xoroshiro128plus_next(d? (kad_rng_t*)d : &kad_rng_dat) >> 12;
 804b06c:	f441 1140 	orr.w	r1, r1, #3145728	@ 0x300000
	return u.d - 1.0;
 804b070:	f7f5 f8e6 	bl	8040240 <__aeabi_dsub>
}
 804b074:	ec41 0b10 	vmov	d0, r0, r1
 804b078:	bd70      	pop	{r4, r5, r6, pc}
 804b07a:	bf00      	nop
 804b07c:	20018108 	.word	0x20018108
 804b080:	3ff00000 	.word	0x3ff00000

0804b084 <kad_drand_normal>:
	kad_rng_t *r = d? (kad_rng_t*)d : &kad_rng_dat;
 804b084:	4602      	mov	r2, r0
 804b086:	4b6e      	ldr	r3, [pc, #440]	@ (804b240 <kad_drand_normal+0x1bc>)
{
 804b088:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	kad_rng_t *r = d? (kad_rng_t*)d : &kad_rng_dat;
 804b08c:	2800      	cmp	r0, #0
 804b08e:	bf08      	it	eq
 804b090:	461a      	moveq	r2, r3
	if (r->n_iset == 0) {
 804b092:	6993      	ldr	r3, [r2, #24]
{
 804b094:	b089      	sub	sp, #36	@ 0x24
	kad_rng_t *r = d? (kad_rng_t*)d : &kad_rng_dat;
 804b096:	9207      	str	r2, [sp, #28]
	if (r->n_iset == 0) {
 804b098:	2b00      	cmp	r3, #0
 804b09a:	f040 80c9 	bne.w	804b230 <kad_drand_normal+0x1ac>
 804b09e:	e9d2 6500 	ldrd	r6, r5, [r2]
 804b0a2:	e9d2 7402 	ldrd	r7, r4, [r2, #8]
	s1 ^= s0;
 804b0a6:	ea87 0206 	eor.w	r2, r7, r6
	const uint64_t result = s0 + s1;
 804b0aa:	19bf      	adds	r7, r7, r6
	s1 ^= s0;
 804b0ac:	ea84 0305 	eor.w	r3, r4, r5
	u.i = 0x3FFULL << 52 | kad_xoroshiro128plus_next(d? (kad_rng_t*)d : &kad_rng_dat) >> 12;
 804b0b0:	ea4f 3717 	mov.w	r7, r7, lsr #12
	const uint64_t result = s0 + s1;
 804b0b4:	eb45 0404 	adc.w	r4, r5, r4
	u.i = 0x3FFULL << 52 | kad_xoroshiro128plus_next(d? (kad_rng_t*)d : &kad_rng_dat) >> 12;
 804b0b8:	ea47 5a04 	orr.w	sl, r7, r4, lsl #20
 804b0bc:	0b24      	lsrs	r4, r4, #12
 804b0be:	f044 5b7f 	orr.w	fp, r4, #1069547520	@ 0x3fc00000
	r->s[0] = (s0 << 55 | s0 >> 9) ^ s1 ^ (s1 << 14);
 804b0c2:	0a6c      	lsrs	r4, r5, #9
 804b0c4:	ea4f 2856 	mov.w	r8, r6, lsr #9
 804b0c8:	ea44 54c6 	orr.w	r4, r4, r6, lsl #23
 804b0cc:	ea48 58c5 	orr.w	r8, r8, r5, lsl #23
 804b0d0:	405c      	eors	r4, r3
 804b0d2:	039b      	lsls	r3, r3, #14
 804b0d4:	ea43 4392 	orr.w	r3, r3, r2, lsr #18
 804b0d8:	ea88 0802 	eor.w	r8, r8, r2
	u.i = 0x3FFULL << 52 | kad_xoroshiro128plus_next(d? (kad_rng_t*)d : &kad_rng_dat) >> 12;
 804b0dc:	f44b 1b40 	orr.w	fp, fp, #3145728	@ 0x300000
	r->s[0] = (s0 << 55 | s0 >> 9) ^ s1 ^ (s1 << 14);
 804b0e0:	ea88 3882 	eor.w	r8, r8, r2, lsl #14
 804b0e4:	405c      	eors	r4, r3
	return u.d - 1.0;
 804b0e6:	2200      	movs	r2, #0
 804b0e8:	4b56      	ldr	r3, [pc, #344]	@ (804b244 <kad_drand_normal+0x1c0>)
 804b0ea:	4650      	mov	r0, sl
 804b0ec:	4659      	mov	r1, fp
 804b0ee:	f7f5 f8a7 	bl	8040240 <__aeabi_dsub>
 804b0f2:	4602      	mov	r2, r0
 804b0f4:	460b      	mov	r3, r1
			v1 = 2.0 * kad_drand(d) - 1.0;
 804b0f6:	f7f5 f8a5 	bl	8040244 <__adddf3>
 804b0fa:	2200      	movs	r2, #0
 804b0fc:	4b51      	ldr	r3, [pc, #324]	@ (804b244 <kad_drand_normal+0x1c0>)
 804b0fe:	f7f5 f89f 	bl	8040240 <__aeabi_dsub>
	r->s[1] = s0 << 36 | s0 >> 28;
 804b102:	0f37      	lsrs	r7, r6, #28
 804b104:	ea47 1705 	orr.w	r7, r7, r5, lsl #4
 804b108:	0f2d      	lsrs	r5, r5, #28
	const uint64_t result = s0 + s1;
 804b10a:	eb18 0207 	adds.w	r2, r8, r7
	r->s[1] = s0 << 36 | s0 >> 28;
 804b10e:	ea45 1506 	orr.w	r5, r5, r6, lsl #4
	const uint64_t result = s0 + s1;
 804b112:	eb44 0305 	adc.w	r3, r4, r5
	u.i = 0x3FFULL << 52 | kad_xoroshiro128plus_next(d? (kad_rng_t*)d : &kad_rng_dat) >> 12;
 804b116:	0b12      	lsrs	r2, r2, #12
 804b118:	ea42 5203 	orr.w	r2, r2, r3, lsl #20
 804b11c:	0b1b      	lsrs	r3, r3, #12
 804b11e:	f043 537f 	orr.w	r3, r3, #1069547520	@ 0x3fc00000
 804b122:	f443 1340 	orr.w	r3, r3, #3145728	@ 0x300000
 804b126:	9301      	str	r3, [sp, #4]
	r->s[0] = (s0 << 55 | s0 >> 9) ^ s1 ^ (s1 << 14);
 804b128:	0a63      	lsrs	r3, r4, #9
	s1 ^= s0;
 804b12a:	4065      	eors	r5, r4
	r->s[0] = (s0 << 55 | s0 >> 9) ^ s1 ^ (s1 << 14);
 804b12c:	ea43 53c8 	orr.w	r3, r3, r8, lsl #23
	s1 ^= s0;
 804b130:	ea88 0707 	eor.w	r7, r8, r7
	r->s[0] = (s0 << 55 | s0 >> 9) ^ s1 ^ (s1 << 14);
 804b134:	406b      	eors	r3, r5
 804b136:	03ad      	lsls	r5, r5, #14
	u.i = 0x3FFULL << 52 | kad_xoroshiro128plus_next(d? (kad_rng_t*)d : &kad_rng_dat) >> 12;
 804b138:	9200      	str	r2, [sp, #0]
	r->s[0] = (s0 << 55 | s0 >> 9) ^ s1 ^ (s1 << 14);
 804b13a:	ea45 4597 	orr.w	r5, r5, r7, lsr #18
	return u.d - 1.0;
 804b13e:	2200      	movs	r2, #0
			v1 = 2.0 * kad_drand(d) - 1.0;
 804b140:	e9cd 0102 	strd	r0, r1, [sp, #8]
	return u.d - 1.0;
 804b144:	e9dd 0100 	ldrd	r0, r1, [sp]
	r->s[0] = (s0 << 55 | s0 >> 9) ^ s1 ^ (s1 << 14);
 804b148:	405d      	eors	r5, r3
	return u.d - 1.0;
 804b14a:	4b3e      	ldr	r3, [pc, #248]	@ (804b244 <kad_drand_normal+0x1c0>)
 804b14c:	f7f5 f878 	bl	8040240 <__aeabi_dsub>
 804b150:	4602      	mov	r2, r0
 804b152:	460b      	mov	r3, r1
			v2 = 2.0 * kad_drand(d) - 1.0;
 804b154:	f7f5 f876 	bl	8040244 <__adddf3>
 804b158:	2200      	movs	r2, #0
 804b15a:	4b3a      	ldr	r3, [pc, #232]	@ (804b244 <kad_drand_normal+0x1c0>)
 804b15c:	f7f5 f870 	bl	8040240 <__aeabi_dsub>
	r->s[0] = (s0 << 55 | s0 >> 9) ^ s1 ^ (s1 << 14);
 804b160:	ea4f 2658 	mov.w	r6, r8, lsr #9
 804b164:	ea46 56c4 	orr.w	r6, r6, r4, lsl #23
 804b168:	407e      	eors	r6, r7
 804b16a:	ea86 3687 	eor.w	r6, r6, r7, lsl #14
	r->s[1] = s0 << 36 | s0 >> 28;
 804b16e:	ea4f 7718 	mov.w	r7, r8, lsr #28
 804b172:	ea47 1704 	orr.w	r7, r7, r4, lsl #4
 804b176:	0f24      	lsrs	r4, r4, #28
			v2 = 2.0 * kad_drand(d) - 1.0;
 804b178:	e9cd 0104 	strd	r0, r1, [sp, #16]
	r->s[1] = s0 << 36 | s0 >> 28;
 804b17c:	ea44 1408 	orr.w	r4, r4, r8, lsl #4
			rsq = v1 * v1 + v2 * v2;
 804b180:	e9dd 8902 	ldrd	r8, r9, [sp, #8]
 804b184:	4642      	mov	r2, r8
 804b186:	464b      	mov	r3, r9
 804b188:	4640      	mov	r0, r8
 804b18a:	4649      	mov	r1, r9
 804b18c:	f7f5 fa10 	bl	80405b0 <__aeabi_dmul>
 804b190:	4680      	mov	r8, r0
 804b192:	4689      	mov	r9, r1
 804b194:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 804b198:	4602      	mov	r2, r0
 804b19a:	460b      	mov	r3, r1
 804b19c:	f7f5 fa08 	bl	80405b0 <__aeabi_dmul>
 804b1a0:	4602      	mov	r2, r0
 804b1a2:	460b      	mov	r3, r1
 804b1a4:	4640      	mov	r0, r8
 804b1a6:	4649      	mov	r1, r9
 804b1a8:	f7f5 f84c 	bl	8040244 <__adddf3>
		} while (rsq >= 1.0 || rsq == 0.0);
 804b1ac:	2200      	movs	r2, #0
 804b1ae:	4b25      	ldr	r3, [pc, #148]	@ (804b244 <kad_drand_normal+0x1c0>)
			rsq = v1 * v1 + v2 * v2;
 804b1b0:	4680      	mov	r8, r0
 804b1b2:	4689      	mov	r9, r1
		} while (rsq >= 1.0 || rsq == 0.0);
 804b1b4:	f7f5 fc82 	bl	8040abc <__aeabi_dcmpge>
 804b1b8:	2800      	cmp	r0, #0
 804b1ba:	f47f af74 	bne.w	804b0a6 <kad_drand_normal+0x22>
 804b1be:	2200      	movs	r2, #0
 804b1c0:	2300      	movs	r3, #0
 804b1c2:	4640      	mov	r0, r8
 804b1c4:	4649      	mov	r1, r9
 804b1c6:	f7f5 fc5b 	bl	8040a80 <__aeabi_dcmpeq>
 804b1ca:	2800      	cmp	r0, #0
 804b1cc:	f47f af6b 	bne.w	804b0a6 <kad_drand_normal+0x22>
 804b1d0:	9b07      	ldr	r3, [sp, #28]
		fac = sqrt(-2.0 * log(rsq) / rsq);
 804b1d2:	ec49 8b10 	vmov	d0, r8, r9
 804b1d6:	e9c3 6500 	strd	r6, r5, [r3]
 804b1da:	e9c3 7402 	strd	r7, r4, [r3, #8]
 804b1de:	461e      	mov	r6, r3
 804b1e0:	f001 fcda 	bl	804cb98 <log>
 804b1e4:	2200      	movs	r2, #0
 804b1e6:	ec51 0b10 	vmov	r0, r1, d0
 804b1ea:	f04f 4340 	mov.w	r3, #3221225472	@ 0xc0000000
 804b1ee:	f7f5 f9df 	bl	80405b0 <__aeabi_dmul>
 804b1f2:	4642      	mov	r2, r8
 804b1f4:	464b      	mov	r3, r9
 804b1f6:	f7f5 fb05 	bl	8040804 <__aeabi_ddiv>
 804b1fa:	ec41 0b10 	vmov	d0, r0, r1
 804b1fe:	f001 fd09 	bl	804cc14 <sqrt>
		r->n_gset = v1 * fac;
 804b202:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
		fac = sqrt(-2.0 * log(rsq) / rsq);
 804b206:	ec55 4b10 	vmov	r4, r5, d0
		r->n_gset = v1 * fac;
 804b20a:	4622      	mov	r2, r4
 804b20c:	462b      	mov	r3, r5
 804b20e:	f7f5 f9cf 	bl	80405b0 <__aeabi_dmul>
		return v2 * fac;
 804b212:	4622      	mov	r2, r4
		r->n_iset = 1;
 804b214:	2401      	movs	r4, #1
		r->n_gset = v1 * fac;
 804b216:	e9c6 0104 	strd	r0, r1, [r6, #16]
		return v2 * fac;
 804b21a:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 804b21e:	462b      	mov	r3, r5
		r->n_iset = 1;
 804b220:	61b4      	str	r4, [r6, #24]
		return v2 * fac;
 804b222:	f7f5 f9c5 	bl	80405b0 <__aeabi_dmul>
 804b226:	ec41 0b10 	vmov	d0, r0, r1
}
 804b22a:	b009      	add	sp, #36	@ 0x24
 804b22c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		r->n_iset = 0;
 804b230:	2300      	movs	r3, #0
		return r->n_gset;
 804b232:	ed92 0b04 	vldr	d0, [r2, #16]
		r->n_iset = 0;
 804b236:	6193      	str	r3, [r2, #24]
}
 804b238:	b009      	add	sp, #36	@ 0x24
 804b23a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 804b23e:	bf00      	nop
 804b240:	20018108 	.word	0x20018108
 804b244:	3ff00000 	.word	0x3ff00000

0804b248 <kad_op_sample_normal>:
{
 804b248:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	kad_node_t *q = p->child[0];
 804b24c:	6b83      	ldr	r3, [r0, #56]	@ 0x38
{
 804b24e:	4604      	mov	r4, r0
	kad_node_t *q = p->child[0];
 804b250:	681d      	ldr	r5, [r3, #0]
 804b252:	782b      	ldrb	r3, [r5, #0]
 804b254:	b37b      	cbz	r3, 804b2b6 <kad_op_sample_normal+0x6e>
 804b256:	2b01      	cmp	r3, #1
 804b258:	692e      	ldr	r6, [r5, #16]
 804b25a:	d00c      	beq.n	804b276 <kad_op_sample_normal+0x2e>
 804b25c:	696a      	ldr	r2, [r5, #20]
 804b25e:	2b02      	cmp	r3, #2
 804b260:	fb02 f606 	mul.w	r6, r2, r6
 804b264:	d007      	beq.n	804b276 <kad_op_sample_normal+0x2e>
 804b266:	69aa      	ldr	r2, [r5, #24]
 804b268:	2b03      	cmp	r3, #3
 804b26a:	fb02 f606 	mul.w	r6, r2, r6
 804b26e:	d002      	beq.n	804b276 <kad_op_sample_normal+0x2e>
 804b270:	69ea      	ldr	r2, [r5, #28]
 804b272:	fb02 f606 	mul.w	r6, r2, r6
	if (action == KAD_SYNC_DIM) {
 804b276:	2904      	cmp	r1, #4
 804b278:	d012      	beq.n	804b2a0 <kad_op_sample_normal+0x58>
	} else if (action == KAD_ALLOC) {
 804b27a:	2901      	cmp	r1, #1
 804b27c:	d007      	beq.n	804b28e <kad_op_sample_normal+0x46>
	} else if (action == KAD_FORWARD) {
 804b27e:	2902      	cmp	r1, #2
 804b280:	d040      	beq.n	804b304 <kad_op_sample_normal+0xbc>
	} else if (action == KAD_BACKWARD && kad_is_back(p->child[0])) {
 804b282:	2903      	cmp	r1, #3
 804b284:	d025      	beq.n	804b2d2 <kad_op_sample_normal+0x8a>
}
 804b286:	2000      	movs	r0, #0
 804b288:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	int n = 1, i;
 804b28c:	460e      	mov	r6, r1
		if (kad_is_back(p->child[0]))
 804b28e:	786b      	ldrb	r3, [r5, #1]
 804b290:	07d9      	lsls	r1, r3, #31
 804b292:	d5f8      	bpl.n	804b286 <kad_op_sample_normal+0x3e>
			p->gtmp = realloc(p->gtmp, n * sizeof(float));
 804b294:	6b60      	ldr	r0, [r4, #52]	@ 0x34
 804b296:	00b1      	lsls	r1, r6, #2
 804b298:	f000 fb8e 	bl	804b9b8 <realloc>
 804b29c:	6360      	str	r0, [r4, #52]	@ 0x34
 804b29e:	e7f2      	b.n	804b286 <kad_op_sample_normal+0x3e>
	dst->n_d = src->n_d;
 804b2a0:	4620      	mov	r0, r4
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 804b2a2:	009a      	lsls	r2, r3, #2
 804b2a4:	f105 0110 	add.w	r1, r5, #16
	dst->n_d = src->n_d;
 804b2a8:	f800 3b10 	strb.w	r3, [r0], #16
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 804b2ac:	f000 fe83 	bl	804bfb6 <memcpy>
}
 804b2b0:	2000      	movs	r0, #0
 804b2b2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	if (action == KAD_SYNC_DIM) {
 804b2b6:	2904      	cmp	r1, #4
 804b2b8:	d022      	beq.n	804b300 <kad_op_sample_normal+0xb8>
	} else if (action == KAD_ALLOC) {
 804b2ba:	2901      	cmp	r1, #1
 804b2bc:	d0e6      	beq.n	804b28c <kad_op_sample_normal+0x44>
	} else if (action == KAD_FORWARD) {
 804b2be:	2902      	cmp	r1, #2
 804b2c0:	d05d      	beq.n	804b37e <kad_op_sample_normal+0x136>
	} else if (action == KAD_BACKWARD && kad_is_back(p->child[0])) {
 804b2c2:	2903      	cmp	r1, #3
 804b2c4:	d1df      	bne.n	804b286 <kad_op_sample_normal+0x3e>
 804b2c6:	786b      	ldrb	r3, [r5, #1]
 804b2c8:	07da      	lsls	r2, r3, #31
 804b2ca:	d5dc      	bpl.n	804b286 <kad_op_sample_normal+0x3e>
 804b2cc:	2601      	movs	r6, #1
		float *r = (float*)p->gtmp;
 804b2ce:	6b42      	ldr	r2, [r0, #52]	@ 0x34
		for (i = 0; i < n; ++i)
 804b2d0:	e005      	b.n	804b2de <kad_op_sample_normal+0x96>
	} else if (action == KAD_BACKWARD && kad_is_back(p->child[0])) {
 804b2d2:	786b      	ldrb	r3, [r5, #1]
 804b2d4:	07db      	lsls	r3, r3, #31
 804b2d6:	d5d6      	bpl.n	804b286 <kad_op_sample_normal+0x3e>
		for (i = 0; i < n; ++i)
 804b2d8:	2e00      	cmp	r6, #0
		float *r = (float*)p->gtmp;
 804b2da:	6b62      	ldr	r2, [r4, #52]	@ 0x34
		for (i = 0; i < n; ++i)
 804b2dc:	ddd3      	ble.n	804b286 <kad_op_sample_normal+0x3e>
 804b2de:	6aeb      	ldr	r3, [r5, #44]	@ 0x2c
 804b2e0:	6ae1      	ldr	r1, [r4, #44]	@ 0x2c
 804b2e2:	eb03 0686 	add.w	r6, r3, r6, lsl #2
			q->g[i] += p->g[i] * r[i];
 804b2e6:	edd3 7a00 	vldr	s15, [r3]
 804b2ea:	ecf1 6a01 	vldmia	r1!, {s13}
 804b2ee:	ecb2 7a01 	vldmia	r2!, {s14}
 804b2f2:	eee6 7a87 	vfma.f32	s15, s13, s14
 804b2f6:	ece3 7a01 	vstmia	r3!, {s15}
		for (i = 0; i < n; ++i)
 804b2fa:	42b3      	cmp	r3, r6
 804b2fc:	d1f3      	bne.n	804b2e6 <kad_op_sample_normal+0x9e>
 804b2fe:	e7c2      	b.n	804b286 <kad_op_sample_normal+0x3e>
	dst->n_d = src->n_d;
 804b300:	7003      	strb	r3, [r0, #0]
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 804b302:	e7c0      	b.n	804b286 <kad_op_sample_normal+0x3e>
		for (i = 0; i < n; ++i) {
 804b304:	2e00      	cmp	r6, #0
		float *r = (float*)p->gtmp;
 804b306:	6b63      	ldr	r3, [r4, #52]	@ 0x34
		for (i = 0; i < n; ++i) {
 804b308:	ddbd      	ble.n	804b286 <kad_op_sample_normal+0x3e>
 804b30a:	4698      	mov	r8, r3
			z = (float)kad_drand_normal(p->ptr);
 804b30c:	f8d4 9030 	ldr.w	r9, [r4, #48]	@ 0x30
 804b310:	b1db      	cbz	r3, 804b34a <kad_op_sample_normal+0x102>
		for (i = 0; i < n; ++i) {
 804b312:	2700      	movs	r7, #0
			z = (float)kad_drand_normal(p->ptr);
 804b314:	4648      	mov	r0, r9
 804b316:	f7ff feb5 	bl	804b084 <kad_drand_normal>
 804b31a:	ec51 0b10 	vmov	r0, r1, d0
 804b31e:	f7f5 fc1f 	bl	8040b60 <__aeabi_d2f>
			p->x[i] = q->x[i] * z;
 804b322:	6aab      	ldr	r3, [r5, #40]	@ 0x28
			z = (float)kad_drand_normal(p->ptr);
 804b324:	ee07 0a90 	vmov	s15, r0
			p->x[i] = q->x[i] * z;
 804b328:	eb03 0387 	add.w	r3, r3, r7, lsl #2
 804b32c:	ed93 7a00 	vldr	s14, [r3]
 804b330:	ee27 7a27 	vmul.f32	s14, s14, s15
 804b334:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
 804b336:	eb03 0387 	add.w	r3, r3, r7, lsl #2
		for (i = 0; i < n; ++i) {
 804b33a:	3701      	adds	r7, #1
 804b33c:	42b7      	cmp	r7, r6
			p->x[i] = q->x[i] * z;
 804b33e:	ed83 7a00 	vstr	s14, [r3]
			if (r) r[i] = z;
 804b342:	f848 0b04 	str.w	r0, [r8], #4
		for (i = 0; i < n; ++i) {
 804b346:	d1e5      	bne.n	804b314 <kad_op_sample_normal+0xcc>
 804b348:	e79d      	b.n	804b286 <kad_op_sample_normal+0x3e>
			z = (float)kad_drand_normal(p->ptr);
 804b34a:	4648      	mov	r0, r9
 804b34c:	f7ff fe9a 	bl	804b084 <kad_drand_normal>
			p->x[i] = q->x[i] * z;
 804b350:	6aab      	ldr	r3, [r5, #40]	@ 0x28
			z = (float)kad_drand_normal(p->ptr);
 804b352:	ec51 0b10 	vmov	r0, r1, d0
			p->x[i] = q->x[i] * z;
 804b356:	eb03 0a88 	add.w	sl, r3, r8, lsl #2
 804b35a:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
 804b35c:	eb03 0788 	add.w	r7, r3, r8, lsl #2
			z = (float)kad_drand_normal(p->ptr);
 804b360:	f7f5 fbfe 	bl	8040b60 <__aeabi_d2f>
			p->x[i] = q->x[i] * z;
 804b364:	edda 7a00 	vldr	s15, [sl]
			z = (float)kad_drand_normal(p->ptr);
 804b368:	ee07 0a10 	vmov	s14, r0
			p->x[i] = q->x[i] * z;
 804b36c:	ee67 7a87 	vmul.f32	s15, s15, s14
		for (i = 0; i < n; ++i) {
 804b370:	f108 0801 	add.w	r8, r8, #1
 804b374:	45b0      	cmp	r8, r6
			p->x[i] = q->x[i] * z;
 804b376:	edc7 7a00 	vstr	s15, [r7]
		for (i = 0; i < n; ++i) {
 804b37a:	d1e6      	bne.n	804b34a <kad_op_sample_normal+0x102>
 804b37c:	e783      	b.n	804b286 <kad_op_sample_normal+0x3e>
 804b37e:	2601      	movs	r6, #1
		float *r = (float*)p->gtmp;
 804b380:	6b43      	ldr	r3, [r0, #52]	@ 0x34
		for (i = 0; i < n; ++i) {
 804b382:	e7c2      	b.n	804b30a <kad_op_sample_normal+0xc2>

0804b384 <Reset_Handler>:

    .section	.text.Reset_Handler
	.weak	Reset_Handler
	.type	Reset_Handler, %function
Reset_Handler:
  ldr   sp, =_estack    /* set stack pointer */
 804b384:	f8df d034 	ldr.w	sp, [pc, #52]	@ 804b3bc <LoopForever+0x2>

/* Call the clock system initialization function.*/
  bl  SystemInit
 804b388:	f7f5 ffb2 	bl	80412f0 <SystemInit>

/* Copy the data segment initializers from flash to SRAM */
  movs	r1, #0
 804b38c:	2100      	movs	r1, #0
  b	LoopCopyDataInit
 804b38e:	e003      	b.n	804b398 <LoopCopyDataInit>

0804b390 <CopyDataInit>:

CopyDataInit:
	ldr	r3, =_sidata
 804b390:	4b0b      	ldr	r3, [pc, #44]	@ (804b3c0 <LoopForever+0x6>)
	ldr	r3, [r3, r1]
 804b392:	585b      	ldr	r3, [r3, r1]
	str	r3, [r0, r1]
 804b394:	5043      	str	r3, [r0, r1]
	adds	r1, r1, #4
 804b396:	3104      	adds	r1, #4

0804b398 <LoopCopyDataInit>:

LoopCopyDataInit:
	ldr	r0, =_sdata
 804b398:	480a      	ldr	r0, [pc, #40]	@ (804b3c4 <LoopForever+0xa>)
	ldr	r3, =_edata
 804b39a:	4b0b      	ldr	r3, [pc, #44]	@ (804b3c8 <LoopForever+0xe>)
	adds	r2, r0, r1
 804b39c:	1842      	adds	r2, r0, r1
	cmp	r2, r3
 804b39e:	429a      	cmp	r2, r3
	bcc	CopyDataInit
 804b3a0:	d3f6      	bcc.n	804b390 <CopyDataInit>
	ldr	r2, =_sbss
 804b3a2:	4a0a      	ldr	r2, [pc, #40]	@ (804b3cc <LoopForever+0x12>)
	b	LoopFillZerobss
 804b3a4:	e002      	b.n	804b3ac <LoopFillZerobss>

0804b3a6 <FillZerobss>:
/* Zero fill the bss segment. */
FillZerobss:
	movs	r3, #0
 804b3a6:	2300      	movs	r3, #0
	str	r3, [r2], #4
 804b3a8:	f842 3b04 	str.w	r3, [r2], #4

0804b3ac <LoopFillZerobss>:

LoopFillZerobss:
	ldr	r3, = _ebss
 804b3ac:	4b08      	ldr	r3, [pc, #32]	@ (804b3d0 <LoopForever+0x16>)
	cmp	r2, r3
 804b3ae:	429a      	cmp	r2, r3
	bcc	FillZerobss
 804b3b0:	d3f9      	bcc.n	804b3a6 <FillZerobss>

/* Call static constructors */
  bl __libc_init_array
 804b3b2:	f000 fdd9 	bl	804bf68 <__libc_init_array>
/* Call the application's entry point.*/
	bl	main
 804b3b6:	f7f5 feff 	bl	80411b8 <main>

0804b3ba <LoopForever>:

LoopForever:
    b LoopForever
 804b3ba:	e7fe      	b.n	804b3ba <LoopForever>
  ldr   sp, =_estack    /* set stack pointer */
 804b3bc:	20040000 	.word	0x20040000
	ldr	r3, =_sidata
 804b3c0:	0804ea14 	.word	0x0804ea14
	ldr	r0, =_sdata
 804b3c4:	20018000 	.word	0x20018000
	ldr	r3, =_edata
 804b3c8:	200181a0 	.word	0x200181a0
	ldr	r2, =_sbss
 804b3cc:	200181a0 	.word	0x200181a0
	ldr	r3, = _ebss
 804b3d0:	2001849c 	.word	0x2001849c

0804b3d4 <ADC1_2_IRQHandler>:
 * @retval : None
*/
    .section	.text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
	b	Infinite_Loop
 804b3d4:	e7fe      	b.n	804b3d4 <ADC1_2_IRQHandler>
	...

0804b3d8 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority  Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 804b3d8:	b538      	push	{r3, r4, r5, lr}
  HAL_StatusTypeDef  status = HAL_OK;

  /* Check uwTickFreq for MisraC 2012 (even if uwTickFreq is a enum type that doesn't take the value zero)*/
  if ((uint32_t)uwTickFreq != 0U)
 804b3da:	4b0f      	ldr	r3, [pc, #60]	@ (804b418 <HAL_InitTick+0x40>)
 804b3dc:	781b      	ldrb	r3, [r3, #0]
 804b3de:	b90b      	cbnz	r3, 804b3e4 <HAL_InitTick+0xc>
        status = HAL_ERROR;
      }
    }
    else
    {
      status = HAL_ERROR;
 804b3e0:	2001      	movs	r0, #1
    status = HAL_ERROR;
  }

  /* Return function status */
  return status;
}
 804b3e2:	bd38      	pop	{r3, r4, r5, pc}
    if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / (uint32_t)uwTickFreq)) == 0U)
 804b3e4:	f44f 727a 	mov.w	r2, #1000	@ 0x3e8
 804b3e8:	fbb2 f3f3 	udiv	r3, r2, r3
 804b3ec:	490b      	ldr	r1, [pc, #44]	@ (804b41c <HAL_InitTick+0x44>)
 804b3ee:	4605      	mov	r5, r0
 804b3f0:	6808      	ldr	r0, [r1, #0]
 804b3f2:	fbb0 f0f3 	udiv	r0, r0, r3
 804b3f6:	f000 f881 	bl	804b4fc <HAL_SYSTICK_Config>
 804b3fa:	4604      	mov	r4, r0
 804b3fc:	2800      	cmp	r0, #0
 804b3fe:	d1ef      	bne.n	804b3e0 <HAL_InitTick+0x8>
      if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 804b400:	2d07      	cmp	r5, #7
 804b402:	d8ed      	bhi.n	804b3e0 <HAL_InitTick+0x8>
        HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 804b404:	4602      	mov	r2, r0
 804b406:	4629      	mov	r1, r5
 804b408:	f04f 30ff 	mov.w	r0, #4294967295
 804b40c:	f000 f83a 	bl	804b484 <HAL_NVIC_SetPriority>
        uwTickPrio = TickPriority;
 804b410:	4b03      	ldr	r3, [pc, #12]	@ (804b420 <HAL_InitTick+0x48>)
 804b412:	4620      	mov	r0, r4
 804b414:	601d      	str	r5, [r3, #0]
}
 804b416:	bd38      	pop	{r3, r4, r5, pc}
 804b418:	20018128 	.word	0x20018128
 804b41c:	20018000 	.word	0x20018000
 804b420:	2001812c 	.word	0x2001812c

0804b424 <HAL_Init>:
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_3);
 804b424:	2004      	movs	r0, #4
{
 804b426:	b510      	push	{r4, lr}
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_3);
 804b428:	f000 f81a 	bl	804b460 <HAL_NVIC_SetPriorityGrouping>
  SystemCoreClockUpdate();
 804b42c:	f7f5 ff62 	bl	80412f4 <SystemCoreClockUpdate>
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
 804b430:	2007      	movs	r0, #7
 804b432:	f7ff ffd1 	bl	804b3d8 <HAL_InitTick>
 804b436:	b110      	cbz	r0, 804b43e <HAL_Init+0x1a>
    status = HAL_ERROR;
 804b438:	2401      	movs	r4, #1
}
 804b43a:	4620      	mov	r0, r4
 804b43c:	bd10      	pop	{r4, pc}
 804b43e:	4604      	mov	r4, r0
    HAL_MspInit();
 804b440:	f7f5 fed4 	bl	80411ec <HAL_MspInit>
}
 804b444:	4620      	mov	r0, r4
 804b446:	bd10      	pop	{r4, pc}

0804b448 <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick += (uint32_t)uwTickFreq;
 804b448:	4a03      	ldr	r2, [pc, #12]	@ (804b458 <HAL_IncTick+0x10>)
 804b44a:	4b04      	ldr	r3, [pc, #16]	@ (804b45c <HAL_IncTick+0x14>)
 804b44c:	6811      	ldr	r1, [r2, #0]
 804b44e:	781b      	ldrb	r3, [r3, #0]
 804b450:	440b      	add	r3, r1
 804b452:	6013      	str	r3, [r2, #0]
}
 804b454:	4770      	bx	lr
 804b456:	bf00      	nop
 804b458:	2001834c 	.word	0x2001834c
 804b45c:	20018128 	.word	0x20018128

0804b460 <HAL_NVIC_SetPriorityGrouping>:
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 804b460:	f64f 0cff 	movw	ip, #63743	@ 0xf8ff
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 804b464:	4906      	ldr	r1, [pc, #24]	@ (804b480 <HAL_NVIC_SetPriorityGrouping+0x20>)
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 804b466:	0203      	lsls	r3, r0, #8
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 804b468:	68ca      	ldr	r2, [r1, #12]
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 804b46a:	f403 63e0 	and.w	r3, r3, #1792	@ 0x700
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 804b46e:	ea02 020c 	and.w	r2, r2, ip
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 804b472:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
 804b474:	f043 63bf 	orr.w	r3, r3, #100139008	@ 0x5f80000
 804b478:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
  SCB->AIRCR =  reg_value;
 804b47c:	60cb      	str	r3, [r1, #12]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
}
 804b47e:	4770      	bx	lr
 804b480:	e000ed00 	.word	0xe000ed00

0804b484 <HAL_NVIC_SetPriority>:
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 804b484:	4b1b      	ldr	r3, [pc, #108]	@ (804b4f4 <HAL_NVIC_SetPriority+0x70>)
  *         This parameter can be a value between 0 and 7
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
 804b486:	b500      	push	{lr}
 804b488:	68db      	ldr	r3, [r3, #12]
 804b48a:	f3c3 2302 	ubfx	r3, r3, #8, #3
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 804b48e:	f1c3 0e07 	rsb	lr, r3, #7
 804b492:	f1be 0f03 	cmp.w	lr, #3
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 804b496:	f103 0c03 	add.w	ip, r3, #3
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 804b49a:	bf28      	it	cs
 804b49c:	f04f 0e03 	movcs.w	lr, #3
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 804b4a0:	f1bc 0f06 	cmp.w	ip, #6
 804b4a4:	d91c      	bls.n	804b4e0 <HAL_NVIC_SetPriority+0x5c>
 804b4a6:	f1a3 0c04 	sub.w	ip, r3, #4

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 804b4aa:	f04f 33ff 	mov.w	r3, #4294967295
 804b4ae:	fa03 f30c 	lsl.w	r3, r3, ip
 804b4b2:	ea22 0203 	bic.w	r2, r2, r3
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 804b4b6:	f04f 33ff 	mov.w	r3, #4294967295
 804b4ba:	fa03 f30e 	lsl.w	r3, r3, lr
 804b4be:	ea21 0303 	bic.w	r3, r1, r3
 804b4c2:	fa03 f30c 	lsl.w	r3, r3, ip
 804b4c6:	4313      	orrs	r3, r2
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 804b4c8:	015b      	lsls	r3, r3, #5
  if ((int32_t)(IRQn) >= 0)
 804b4ca:	2800      	cmp	r0, #0
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 804b4cc:	b2db      	uxtb	r3, r3
  if ((int32_t)(IRQn) >= 0)
 804b4ce:	db0a      	blt.n	804b4e6 <HAL_NVIC_SetPriority+0x62>
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 804b4d0:	f100 4060 	add.w	r0, r0, #3758096384	@ 0xe0000000
 804b4d4:	f500 4061 	add.w	r0, r0, #57600	@ 0xe100
 804b4d8:	f880 3300 	strb.w	r3, [r0, #768]	@ 0x300
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));

  prioritygroup = NVIC_GetPriorityGrouping();

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
}
 804b4dc:	f85d fb04 	ldr.w	pc, [sp], #4
 804b4e0:	2200      	movs	r2, #0
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 804b4e2:	4694      	mov	ip, r2
 804b4e4:	e7e7      	b.n	804b4b6 <HAL_NVIC_SetPriority+0x32>
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 804b4e6:	4a04      	ldr	r2, [pc, #16]	@ (804b4f8 <HAL_NVIC_SetPriority+0x74>)
 804b4e8:	f000 000f 	and.w	r0, r0, #15
 804b4ec:	4402      	add	r2, r0
 804b4ee:	7613      	strb	r3, [r2, #24]
 804b4f0:	f85d fb04 	ldr.w	pc, [sp], #4
 804b4f4:	e000ed00 	.word	0xe000ed00
 804b4f8:	e000ecfc 	.word	0xe000ecfc

0804b4fc <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 804b4fc:	3801      	subs	r0, #1
 804b4fe:	f1b0 7f80 	cmp.w	r0, #16777216	@ 0x1000000
 804b502:	d301      	bcc.n	804b508 <HAL_SYSTICK_Config+0xc>
  {
    return (1UL);                                                   /* Reload value impossible */
 804b504:	2001      	movs	r0, #1
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
  return SysTick_Config(TicksNumb);
}
 804b506:	4770      	bx	lr
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 804b508:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 804b50c:	f04f 0ce0 	mov.w	ip, #224	@ 0xe0
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 804b510:	2200      	movs	r2, #0
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 804b512:	2107      	movs	r1, #7
{
 804b514:	b410      	push	{r4}
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 804b516:	4c05      	ldr	r4, [pc, #20]	@ (804b52c <HAL_SYSTICK_Config+0x30>)
  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 804b518:	6158      	str	r0, [r3, #20]
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 804b51a:	f884 c023 	strb.w	ip, [r4, #35]	@ 0x23
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 804b51e:	4610      	mov	r0, r2
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 804b520:	619a      	str	r2, [r3, #24]
}
 804b522:	f85d 4b04 	ldr.w	r4, [sp], #4
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 804b526:	6119      	str	r1, [r3, #16]
 804b528:	4770      	bx	lr
 804b52a:	bf00      	nop
 804b52c:	e000ed00 	.word	0xe000ed00

0804b530 <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 804b530:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0U)
 804b534:	680c      	ldr	r4, [r1, #0]
 804b536:	2c00      	cmp	r4, #0
 804b538:	f000 808d 	beq.w	804b656 <HAL_GPIO_Init+0x126>
  uint32_t position = 0U;
 804b53c:	2200      	movs	r2, #0
  {
    /* Get current io position */
    iocurrent = (GPIO_Init->Pin) & (1UL << position);
 804b53e:	f04f 0901 	mov.w	r9, #1
 804b542:	fa09 f502 	lsl.w	r5, r9, r2

    if(iocurrent != 0U)
 804b546:	ea15 0a04 	ands.w	sl, r5, r4
 804b54a:	d07f      	beq.n	804b64c <HAL_GPIO_Init+0x11c>
        GPIOx->OTYPER = temp;
      }

      /* Activate the Pull-up or Pull down resistor for the current IO */
      temp = GPIOx->PUPDR;
      temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 804b54c:	2603      	movs	r6, #3
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 804b54e:	684b      	ldr	r3, [r1, #4]
      temp |= ((GPIO_Init->Pull) << (position * 2U));
 804b550:	688f      	ldr	r7, [r1, #8]
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 804b552:	f023 0e10 	bic.w	lr, r3, #16
 804b556:	ea4f 0c42 	mov.w	ip, r2, lsl #1
 804b55a:	f10e 3bff 	add.w	fp, lr, #4294967295
      temp |= ((GPIO_Init->Pull) << (position * 2U));
 804b55e:	fa07 f80c 	lsl.w	r8, r7, ip
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 804b562:	f1bb 0f01 	cmp.w	fp, #1
      temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 804b566:	fa06 f70c 	lsl.w	r7, r6, ip
 804b56a:	ea6f 0707 	mvn.w	r7, r7
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 804b56e:	d974      	bls.n	804b65a <HAL_GPIO_Init+0x12a>
      temp = GPIOx->PUPDR;
 804b570:	68c5      	ldr	r5, [r0, #12]
      temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 804b572:	403d      	ands	r5, r7
      temp |= ((GPIO_Init->Pull) << (position * 2U));
 804b574:	ea45 0508 	orr.w	r5, r5, r8
      GPIOx->PUPDR = temp;
 804b578:	60c5      	str	r5, [r0, #12]
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
        GPIOx->AFR[position >> 3U] = temp;
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
 804b57a:	6805      	ldr	r5, [r0, #0]
      temp &= ~(GPIO_MODER_MODE0 << (position * 2U));
 804b57c:	402f      	ands	r7, r5
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 804b57e:	ea03 0506 	and.w	r5, r3, r6
 804b582:	fa05 f50c 	lsl.w	r5, r5, ip
 804b586:	433d      	orrs	r5, r7
      GPIOx->MODER = temp;

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 804b588:	00df      	lsls	r7, r3, #3
      GPIOx->MODER = temp;
 804b58a:	6005      	str	r5, [r0, #0]
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 804b58c:	d55e      	bpl.n	804b64c <HAL_GPIO_Init+0x11c>
      {
        temp = EXTI->EXTICR[position >> 2U];
        temp &= ~((0x0FU) << (8U * (position & 0x03U)));
 804b58e:	260f      	movs	r6, #15
 804b590:	f022 0503 	bic.w	r5, r2, #3
 804b594:	f002 0c03 	and.w	ip, r2, #3
 804b598:	f105 4580 	add.w	r5, r5, #1073741824	@ 0x40000000
 804b59c:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
 804b5a0:	fa06 fe0c 	lsl.w	lr, r6, ip
 804b5a4:	f505 353d 	add.w	r5, r5, #193536	@ 0x2f400
        temp |= (GPIO_GET_INDEX(GPIOx) << (8U * (position & 0x03U)));
 804b5a8:	4e62      	ldr	r6, [pc, #392]	@ (804b734 <HAL_GPIO_Init+0x204>)
        temp = EXTI->EXTICR[position >> 2U];
 804b5aa:	6e2f      	ldr	r7, [r5, #96]	@ 0x60
        temp |= (GPIO_GET_INDEX(GPIOx) << (8U * (position & 0x03U)));
 804b5ac:	42b0      	cmp	r0, r6
        temp &= ~((0x0FU) << (8U * (position & 0x03U)));
 804b5ae:	ea27 070e 	bic.w	r7, r7, lr
        temp |= (GPIO_GET_INDEX(GPIOx) << (8U * (position & 0x03U)));
 804b5b2:	d023      	beq.n	804b5fc <HAL_GPIO_Init+0xcc>
 804b5b4:	f506 6680 	add.w	r6, r6, #1024	@ 0x400
 804b5b8:	42b0      	cmp	r0, r6
 804b5ba:	f000 80a0 	beq.w	804b6fe <HAL_GPIO_Init+0x1ce>
 804b5be:	4e5e      	ldr	r6, [pc, #376]	@ (804b738 <HAL_GPIO_Init+0x208>)
 804b5c0:	42b0      	cmp	r0, r6
 804b5c2:	f000 80a1 	beq.w	804b708 <HAL_GPIO_Init+0x1d8>
 804b5c6:	f8df e178 	ldr.w	lr, [pc, #376]	@ 804b740 <HAL_GPIO_Init+0x210>
 804b5ca:	4570      	cmp	r0, lr
 804b5cc:	f000 8091 	beq.w	804b6f2 <HAL_GPIO_Init+0x1c2>
 804b5d0:	f8df e170 	ldr.w	lr, [pc, #368]	@ 804b744 <HAL_GPIO_Init+0x214>
 804b5d4:	4570      	cmp	r0, lr
 804b5d6:	f000 809e 	beq.w	804b716 <HAL_GPIO_Init+0x1e6>
 804b5da:	f8df e16c 	ldr.w	lr, [pc, #364]	@ 804b748 <HAL_GPIO_Init+0x218>
 804b5de:	4570      	cmp	r0, lr
 804b5e0:	f000 80a0 	beq.w	804b724 <HAL_GPIO_Init+0x1f4>
 804b5e4:	f8df e164 	ldr.w	lr, [pc, #356]	@ 804b74c <HAL_GPIO_Init+0x21c>
 804b5e8:	4570      	cmp	r0, lr
 804b5ea:	bf0c      	ite	eq
 804b5ec:	f04f 0e06 	moveq.w	lr, #6
 804b5f0:	f04f 0e07 	movne.w	lr, #7
 804b5f4:	fa0e fc0c 	lsl.w	ip, lr, ip
 804b5f8:	ea47 070c 	orr.w	r7, r7, ip
        EXTI->EXTICR[position >> 2U] = temp;
 804b5fc:	662f      	str	r7, [r5, #96]	@ 0x60

        /* Clear EXTI line configuration */
        temp = EXTI->IMR1;
        temp &= ~(iocurrent);
 804b5fe:	ea6f 070a 	mvn.w	r7, sl
        temp = EXTI->IMR1;
 804b602:	4d4e      	ldr	r5, [pc, #312]	@ (804b73c <HAL_GPIO_Init+0x20c>)
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 804b604:	03de      	lsls	r6, r3, #15
        temp = EXTI->IMR1;
 804b606:	f8d5 5080 	ldr.w	r5, [r5, #128]	@ 0x80
        {
          temp |= iocurrent;
        }
        EXTI->IMR1 = temp;
 804b60a:	4e4c      	ldr	r6, [pc, #304]	@ (804b73c <HAL_GPIO_Init+0x20c>)
        temp &= ~(iocurrent);
 804b60c:	bf54      	ite	pl
 804b60e:	403d      	andpl	r5, r7
          temp |= iocurrent;
 804b610:	ea4a 0505 	orrmi.w	r5, sl, r5
        EXTI->IMR1 = temp;
 804b614:	f8c6 5080 	str.w	r5, [r6, #128]	@ 0x80

        temp = EXTI->EMR1;
 804b618:	f8d6 5084 	ldr.w	r5, [r6, #132]	@ 0x84
        temp &= ~(iocurrent);
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 804b61c:	039e      	lsls	r6, r3, #14
        {
          temp |= iocurrent;
        }
        EXTI->EMR1 = temp;
 804b61e:	4e47      	ldr	r6, [pc, #284]	@ (804b73c <HAL_GPIO_Init+0x20c>)
        temp &= ~(iocurrent);
 804b620:	bf54      	ite	pl
 804b622:	403d      	andpl	r5, r7
          temp |= iocurrent;
 804b624:	ea4a 0505 	orrmi.w	r5, sl, r5
        EXTI->EMR1 = temp;
 804b628:	f8c6 5084 	str.w	r5, [r6, #132]	@ 0x84

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
 804b62c:	6835      	ldr	r5, [r6, #0]
        temp &= ~(iocurrent);
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 804b62e:	02de      	lsls	r6, r3, #11
        {
          temp |= iocurrent;
        }
        EXTI->RTSR1 = temp;
 804b630:	4e42      	ldr	r6, [pc, #264]	@ (804b73c <HAL_GPIO_Init+0x20c>)
        temp &= ~(iocurrent);
 804b632:	bf54      	ite	pl
 804b634:	403d      	andpl	r5, r7
          temp |= iocurrent;
 804b636:	ea4a 0505 	orrmi.w	r5, sl, r5
        EXTI->RTSR1 = temp;
 804b63a:	6035      	str	r5, [r6, #0]

        temp = EXTI->FTSR1;
 804b63c:	6875      	ldr	r5, [r6, #4]
        temp &= ~(iocurrent);
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 804b63e:	029b      	lsls	r3, r3, #10
        {
          temp |= iocurrent;
        }
        EXTI->FTSR1 = temp;
 804b640:	4b3e      	ldr	r3, [pc, #248]	@ (804b73c <HAL_GPIO_Init+0x20c>)
        temp &= ~(iocurrent);
 804b642:	bf54      	ite	pl
 804b644:	403d      	andpl	r5, r7
          temp |= iocurrent;
 804b646:	ea4a 0505 	orrmi.w	r5, sl, r5
        EXTI->FTSR1 = temp;
 804b64a:	605d      	str	r5, [r3, #4]
      }
    }

    position++;
 804b64c:	3201      	adds	r2, #1
  while (((GPIO_Init->Pin) >> position) != 0U)
 804b64e:	fa34 f302 	lsrs.w	r3, r4, r2
 804b652:	f47f af76 	bne.w	804b542 <HAL_GPIO_Init+0x12>
  }
}
 804b656:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        temp = GPIOx->OSPEEDR;
 804b65a:	f8d0 b008 	ldr.w	fp, [r0, #8]
        temp |= (GPIO_Init->Speed << (position * 2U));
 804b65e:	68ce      	ldr	r6, [r1, #12]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 804b660:	ea0b 0b07 	and.w	fp, fp, r7
        temp |= (GPIO_Init->Speed << (position * 2U));
 804b664:	fa06 fa0c 	lsl.w	sl, r6, ip
 804b668:	ea4a 0a0b 	orr.w	sl, sl, fp
        GPIOx->OSPEEDR = temp;
 804b66c:	f8c0 a008 	str.w	sl, [r0, #8]
        temp = GPIOx->OTYPER;
 804b670:	f8d0 a004 	ldr.w	sl, [r0, #4]
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 804b674:	f1be 0f02 	cmp.w	lr, #2
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
 804b678:	ea2a 0a05 	bic.w	sl, sl, r5
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4) << position);
 804b67c:	ea4f 1513 	mov.w	r5, r3, lsr #4
 804b680:	fa05 f502 	lsl.w	r5, r5, r2
 804b684:	ea45 050a 	orr.w	r5, r5, sl
        GPIOx->OTYPER = temp;
 804b688:	6045      	str	r5, [r0, #4]
      temp = GPIOx->PUPDR;
 804b68a:	68c5      	ldr	r5, [r0, #12]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 804b68c:	f003 0303 	and.w	r3, r3, #3
      temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 804b690:	ea05 0507 	and.w	r5, r5, r7
      temp |= ((GPIO_Init->Pull) << (position * 2U));
 804b694:	ea45 0508 	orr.w	r5, r5, r8
      GPIOx->PUPDR = temp;
 804b698:	60c5      	str	r5, [r0, #12]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 804b69a:	fa03 f30c 	lsl.w	r3, r3, ip
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 804b69e:	d009      	beq.n	804b6b4 <HAL_GPIO_Init+0x184>
      temp = GPIOx->MODER;
 804b6a0:	6805      	ldr	r5, [r0, #0]
    position++;
 804b6a2:	3201      	adds	r2, #1
      temp &= ~(GPIO_MODER_MODE0 << (position * 2U));
 804b6a4:	403d      	ands	r5, r7
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 804b6a6:	432b      	orrs	r3, r5
      GPIOx->MODER = temp;
 804b6a8:	6003      	str	r3, [r0, #0]
  while (((GPIO_Init->Pin) >> position) != 0U)
 804b6aa:	fa34 f302 	lsrs.w	r3, r4, r2
 804b6ae:	f47f af48 	bne.w	804b542 <HAL_GPIO_Init+0x12>
 804b6b2:	e7d0      	b.n	804b656 <HAL_GPIO_Init+0x126>
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
 804b6b4:	690e      	ldr	r6, [r1, #16]
        temp &= ~(0x0FUL << ((position & 0x07U) * 4U)) ;
 804b6b6:	f002 0507 	and.w	r5, r2, #7
 804b6ba:	00ad      	lsls	r5, r5, #2
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
 804b6bc:	fa06 fe05 	lsl.w	lr, r6, r5
        temp &= ~(0x0FUL << ((position & 0x07U) * 4U)) ;
 804b6c0:	260f      	movs	r6, #15
        temp = GPIOx->AFR[position >> 3U];
 804b6c2:	ea4f 0cd2 	mov.w	ip, r2, lsr #3
 804b6c6:	eb00 0c8c 	add.w	ip, r0, ip, lsl #2
 804b6ca:	f8dc 8020 	ldr.w	r8, [ip, #32]
        temp &= ~(0x0FUL << ((position & 0x07U) * 4U)) ;
 804b6ce:	fa06 f505 	lsl.w	r5, r6, r5
 804b6d2:	ea28 0505 	bic.w	r5, r8, r5
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
 804b6d6:	ea4e 0505 	orr.w	r5, lr, r5
        GPIOx->AFR[position >> 3U] = temp;
 804b6da:	f8cc 5020 	str.w	r5, [ip, #32]
      temp = GPIOx->MODER;
 804b6de:	6805      	ldr	r5, [r0, #0]
    position++;
 804b6e0:	3201      	adds	r2, #1
      temp &= ~(GPIO_MODER_MODE0 << (position * 2U));
 804b6e2:	403d      	ands	r5, r7
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 804b6e4:	432b      	orrs	r3, r5
      GPIOx->MODER = temp;
 804b6e6:	6003      	str	r3, [r0, #0]
  while (((GPIO_Init->Pin) >> position) != 0U)
 804b6e8:	fa34 f302 	lsrs.w	r3, r4, r2
 804b6ec:	f47f af29 	bne.w	804b542 <HAL_GPIO_Init+0x12>
 804b6f0:	e7b1      	b.n	804b656 <HAL_GPIO_Init+0x126>
        temp |= (GPIO_GET_INDEX(GPIOx) << (8U * (position & 0x03U)));
 804b6f2:	2603      	movs	r6, #3
 804b6f4:	fa06 fc0c 	lsl.w	ip, r6, ip
 804b6f8:	ea47 070c 	orr.w	r7, r7, ip
 804b6fc:	e77e      	b.n	804b5fc <HAL_GPIO_Init+0xcc>
 804b6fe:	fa09 fc0c 	lsl.w	ip, r9, ip
 804b702:	ea47 070c 	orr.w	r7, r7, ip
 804b706:	e779      	b.n	804b5fc <HAL_GPIO_Init+0xcc>
 804b708:	f04f 0e02 	mov.w	lr, #2
 804b70c:	fa0e fc0c 	lsl.w	ip, lr, ip
 804b710:	ea47 070c 	orr.w	r7, r7, ip
 804b714:	e772      	b.n	804b5fc <HAL_GPIO_Init+0xcc>
 804b716:	f04f 0e04 	mov.w	lr, #4
 804b71a:	fa0e fc0c 	lsl.w	ip, lr, ip
 804b71e:	ea47 070c 	orr.w	r7, r7, ip
 804b722:	e76b      	b.n	804b5fc <HAL_GPIO_Init+0xcc>
 804b724:	f04f 0e05 	mov.w	lr, #5
 804b728:	fa0e fc0c 	lsl.w	ip, lr, ip
 804b72c:	ea47 070c 	orr.w	r7, r7, ip
 804b730:	e764      	b.n	804b5fc <HAL_GPIO_Init+0xcc>
 804b732:	bf00      	nop
 804b734:	42020000 	.word	0x42020000
 804b738:	42020800 	.word	0x42020800
 804b73c:	4002f400 	.word	0x4002f400
 804b740:	42020c00 	.word	0x42020c00
 804b744:	42021000 	.word	0x42021000
 804b748:	42021400 	.word	0x42021400
 804b74c:	42021800 	.word	0x42021800

0804b750 <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if (PinState != GPIO_PIN_RESET)
 804b750:	b10a      	cbz	r2, 804b756 <HAL_GPIO_WritePin+0x6>
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
 804b752:	6181      	str	r1, [r0, #24]
 804b754:	4770      	bx	lr
  }
  else
  {
    GPIOx->BRR = (uint32_t)GPIO_Pin;
 804b756:	6281      	str	r1, [r0, #40]	@ 0x28
  }
}
 804b758:	4770      	bx	lr
 804b75a:	bf00      	nop

0804b75c <abort>:
 804b75c:	2006      	movs	r0, #6
 804b75e:	b508      	push	{r3, lr}
 804b760:	f000 fb5c 	bl	804be1c <raise>
 804b764:	2001      	movs	r0, #1
 804b766:	f7f5 fd6f 	bl	8041248 <_exit>
	...

0804b76c <__assert_func>:
 804b76c:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 804b76e:	4614      	mov	r4, r2
 804b770:	461a      	mov	r2, r3
 804b772:	4b09      	ldr	r3, [pc, #36]	@ (804b798 <__assert_func+0x2c>)
 804b774:	4605      	mov	r5, r0
 804b776:	681b      	ldr	r3, [r3, #0]
 804b778:	68d8      	ldr	r0, [r3, #12]
 804b77a:	b954      	cbnz	r4, 804b792 <__assert_func+0x26>
 804b77c:	4b07      	ldr	r3, [pc, #28]	@ (804b79c <__assert_func+0x30>)
 804b77e:	461c      	mov	r4, r3
 804b780:	9100      	str	r1, [sp, #0]
 804b782:	4907      	ldr	r1, [pc, #28]	@ (804b7a0 <__assert_func+0x34>)
 804b784:	e9cd 3401 	strd	r3, r4, [sp, #4]
 804b788:	462b      	mov	r3, r5
 804b78a:	f000 f9ef 	bl	804bb6c <fiprintf>
 804b78e:	f7ff ffe5 	bl	804b75c <abort>
 804b792:	4b04      	ldr	r3, [pc, #16]	@ (804b7a4 <__assert_func+0x38>)
 804b794:	e7f4      	b.n	804b780 <__assert_func+0x14>
 804b796:	bf00      	nop
 804b798:	2001813c 	.word	0x2001813c
 804b79c:	0804e581 	.word	0x0804e581
 804b7a0:	0804e553 	.word	0x0804e553
 804b7a4:	0804e546 	.word	0x0804e546

0804b7a8 <calloc>:
 804b7a8:	4b02      	ldr	r3, [pc, #8]	@ (804b7b4 <calloc+0xc>)
 804b7aa:	460a      	mov	r2, r1
 804b7ac:	4601      	mov	r1, r0
 804b7ae:	6818      	ldr	r0, [r3, #0]
 804b7b0:	f000 b802 	b.w	804b7b8 <_calloc_r>
 804b7b4:	2001813c 	.word	0x2001813c

0804b7b8 <_calloc_r>:
 804b7b8:	b570      	push	{r4, r5, r6, lr}
 804b7ba:	fba1 5402 	umull	r5, r4, r1, r2
 804b7be:	b93c      	cbnz	r4, 804b7d0 <_calloc_r+0x18>
 804b7c0:	4629      	mov	r1, r5
 804b7c2:	f000 f83f 	bl	804b844 <_malloc_r>
 804b7c6:	4606      	mov	r6, r0
 804b7c8:	b928      	cbnz	r0, 804b7d6 <_calloc_r+0x1e>
 804b7ca:	2600      	movs	r6, #0
 804b7cc:	4630      	mov	r0, r6
 804b7ce:	bd70      	pop	{r4, r5, r6, pc}
 804b7d0:	220c      	movs	r2, #12
 804b7d2:	6002      	str	r2, [r0, #0]
 804b7d4:	e7f9      	b.n	804b7ca <_calloc_r+0x12>
 804b7d6:	462a      	mov	r2, r5
 804b7d8:	4621      	mov	r1, r4
 804b7da:	f000 faef 	bl	804bdbc <memset>
 804b7de:	e7f5      	b.n	804b7cc <_calloc_r+0x14>

0804b7e0 <malloc>:
 804b7e0:	4b02      	ldr	r3, [pc, #8]	@ (804b7ec <malloc+0xc>)
 804b7e2:	4601      	mov	r1, r0
 804b7e4:	6818      	ldr	r0, [r3, #0]
 804b7e6:	f000 b82d 	b.w	804b844 <_malloc_r>
 804b7ea:	bf00      	nop
 804b7ec:	2001813c 	.word	0x2001813c

0804b7f0 <free>:
 804b7f0:	4b02      	ldr	r3, [pc, #8]	@ (804b7fc <free+0xc>)
 804b7f2:	4601      	mov	r1, r0
 804b7f4:	6818      	ldr	r0, [r3, #0]
 804b7f6:	f000 bbf9 	b.w	804bfec <_free_r>
 804b7fa:	bf00      	nop
 804b7fc:	2001813c 	.word	0x2001813c

0804b800 <sbrk_aligned>:
 804b800:	b570      	push	{r4, r5, r6, lr}
 804b802:	4e0f      	ldr	r6, [pc, #60]	@ (804b840 <sbrk_aligned+0x40>)
 804b804:	460c      	mov	r4, r1
 804b806:	4605      	mov	r5, r0
 804b808:	6831      	ldr	r1, [r6, #0]
 804b80a:	b911      	cbnz	r1, 804b812 <sbrk_aligned+0x12>
 804b80c:	f000 fb84 	bl	804bf18 <_sbrk_r>
 804b810:	6030      	str	r0, [r6, #0]
 804b812:	4621      	mov	r1, r4
 804b814:	4628      	mov	r0, r5
 804b816:	f000 fb7f 	bl	804bf18 <_sbrk_r>
 804b81a:	1c43      	adds	r3, r0, #1
 804b81c:	d103      	bne.n	804b826 <sbrk_aligned+0x26>
 804b81e:	f04f 34ff 	mov.w	r4, #4294967295
 804b822:	4620      	mov	r0, r4
 804b824:	bd70      	pop	{r4, r5, r6, pc}
 804b826:	1cc4      	adds	r4, r0, #3
 804b828:	f024 0403 	bic.w	r4, r4, #3
 804b82c:	42a0      	cmp	r0, r4
 804b82e:	d0f8      	beq.n	804b822 <sbrk_aligned+0x22>
 804b830:	1a21      	subs	r1, r4, r0
 804b832:	4628      	mov	r0, r5
 804b834:	f000 fb70 	bl	804bf18 <_sbrk_r>
 804b838:	3001      	adds	r0, #1
 804b83a:	d1f2      	bne.n	804b822 <sbrk_aligned+0x22>
 804b83c:	e7ef      	b.n	804b81e <sbrk_aligned+0x1e>
 804b83e:	bf00      	nop
 804b840:	20018350 	.word	0x20018350

0804b844 <_malloc_r>:
 804b844:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 804b848:	1ccd      	adds	r5, r1, #3
 804b84a:	4606      	mov	r6, r0
 804b84c:	f025 0503 	bic.w	r5, r5, #3
 804b850:	3508      	adds	r5, #8
 804b852:	2d0c      	cmp	r5, #12
 804b854:	bf38      	it	cc
 804b856:	250c      	movcc	r5, #12
 804b858:	2d00      	cmp	r5, #0
 804b85a:	db01      	blt.n	804b860 <_malloc_r+0x1c>
 804b85c:	42a9      	cmp	r1, r5
 804b85e:	d904      	bls.n	804b86a <_malloc_r+0x26>
 804b860:	230c      	movs	r3, #12
 804b862:	6033      	str	r3, [r6, #0]
 804b864:	2000      	movs	r0, #0
 804b866:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 804b86a:	f8df 80d4 	ldr.w	r8, [pc, #212]	@ 804b940 <_malloc_r+0xfc>
 804b86e:	f000 f869 	bl	804b944 <__malloc_lock>
 804b872:	f8d8 3000 	ldr.w	r3, [r8]
 804b876:	461c      	mov	r4, r3
 804b878:	bb44      	cbnz	r4, 804b8cc <_malloc_r+0x88>
 804b87a:	4629      	mov	r1, r5
 804b87c:	4630      	mov	r0, r6
 804b87e:	f7ff ffbf 	bl	804b800 <sbrk_aligned>
 804b882:	1c43      	adds	r3, r0, #1
 804b884:	4604      	mov	r4, r0
 804b886:	d158      	bne.n	804b93a <_malloc_r+0xf6>
 804b888:	f8d8 4000 	ldr.w	r4, [r8]
 804b88c:	4627      	mov	r7, r4
 804b88e:	2f00      	cmp	r7, #0
 804b890:	d143      	bne.n	804b91a <_malloc_r+0xd6>
 804b892:	2c00      	cmp	r4, #0
 804b894:	d04b      	beq.n	804b92e <_malloc_r+0xea>
 804b896:	6823      	ldr	r3, [r4, #0]
 804b898:	4639      	mov	r1, r7
 804b89a:	4630      	mov	r0, r6
 804b89c:	eb04 0903 	add.w	r9, r4, r3
 804b8a0:	f000 fb3a 	bl	804bf18 <_sbrk_r>
 804b8a4:	4581      	cmp	r9, r0
 804b8a6:	d142      	bne.n	804b92e <_malloc_r+0xea>
 804b8a8:	6821      	ldr	r1, [r4, #0]
 804b8aa:	4630      	mov	r0, r6
 804b8ac:	1a6d      	subs	r5, r5, r1
 804b8ae:	4629      	mov	r1, r5
 804b8b0:	f7ff ffa6 	bl	804b800 <sbrk_aligned>
 804b8b4:	3001      	adds	r0, #1
 804b8b6:	d03a      	beq.n	804b92e <_malloc_r+0xea>
 804b8b8:	6823      	ldr	r3, [r4, #0]
 804b8ba:	442b      	add	r3, r5
 804b8bc:	6023      	str	r3, [r4, #0]
 804b8be:	f8d8 3000 	ldr.w	r3, [r8]
 804b8c2:	685a      	ldr	r2, [r3, #4]
 804b8c4:	bb62      	cbnz	r2, 804b920 <_malloc_r+0xdc>
 804b8c6:	f8c8 7000 	str.w	r7, [r8]
 804b8ca:	e00f      	b.n	804b8ec <_malloc_r+0xa8>
 804b8cc:	6822      	ldr	r2, [r4, #0]
 804b8ce:	1b52      	subs	r2, r2, r5
 804b8d0:	d420      	bmi.n	804b914 <_malloc_r+0xd0>
 804b8d2:	2a0b      	cmp	r2, #11
 804b8d4:	d917      	bls.n	804b906 <_malloc_r+0xc2>
 804b8d6:	1961      	adds	r1, r4, r5
 804b8d8:	42a3      	cmp	r3, r4
 804b8da:	6025      	str	r5, [r4, #0]
 804b8dc:	bf18      	it	ne
 804b8de:	6059      	strne	r1, [r3, #4]
 804b8e0:	6863      	ldr	r3, [r4, #4]
 804b8e2:	bf08      	it	eq
 804b8e4:	f8c8 1000 	streq.w	r1, [r8]
 804b8e8:	5162      	str	r2, [r4, r5]
 804b8ea:	604b      	str	r3, [r1, #4]
 804b8ec:	4630      	mov	r0, r6
 804b8ee:	f000 f82f 	bl	804b950 <__malloc_unlock>
 804b8f2:	f104 000b 	add.w	r0, r4, #11
 804b8f6:	1d23      	adds	r3, r4, #4
 804b8f8:	f020 0007 	bic.w	r0, r0, #7
 804b8fc:	1ac2      	subs	r2, r0, r3
 804b8fe:	bf1c      	itt	ne
 804b900:	1a1b      	subne	r3, r3, r0
 804b902:	50a3      	strne	r3, [r4, r2]
 804b904:	e7af      	b.n	804b866 <_malloc_r+0x22>
 804b906:	6862      	ldr	r2, [r4, #4]
 804b908:	42a3      	cmp	r3, r4
 804b90a:	bf0c      	ite	eq
 804b90c:	f8c8 2000 	streq.w	r2, [r8]
 804b910:	605a      	strne	r2, [r3, #4]
 804b912:	e7eb      	b.n	804b8ec <_malloc_r+0xa8>
 804b914:	4623      	mov	r3, r4
 804b916:	6864      	ldr	r4, [r4, #4]
 804b918:	e7ae      	b.n	804b878 <_malloc_r+0x34>
 804b91a:	463c      	mov	r4, r7
 804b91c:	687f      	ldr	r7, [r7, #4]
 804b91e:	e7b6      	b.n	804b88e <_malloc_r+0x4a>
 804b920:	461a      	mov	r2, r3
 804b922:	685b      	ldr	r3, [r3, #4]
 804b924:	42a3      	cmp	r3, r4
 804b926:	d1fb      	bne.n	804b920 <_malloc_r+0xdc>
 804b928:	2300      	movs	r3, #0
 804b92a:	6053      	str	r3, [r2, #4]
 804b92c:	e7de      	b.n	804b8ec <_malloc_r+0xa8>
 804b92e:	230c      	movs	r3, #12
 804b930:	4630      	mov	r0, r6
 804b932:	6033      	str	r3, [r6, #0]
 804b934:	f000 f80c 	bl	804b950 <__malloc_unlock>
 804b938:	e794      	b.n	804b864 <_malloc_r+0x20>
 804b93a:	6005      	str	r5, [r0, #0]
 804b93c:	e7d6      	b.n	804b8ec <_malloc_r+0xa8>
 804b93e:	bf00      	nop
 804b940:	20018354 	.word	0x20018354

0804b944 <__malloc_lock>:
 804b944:	4801      	ldr	r0, [pc, #4]	@ (804b94c <__malloc_lock+0x8>)
 804b946:	f000 bb34 	b.w	804bfb2 <__retarget_lock_acquire_recursive>
 804b94a:	bf00      	nop
 804b94c:	20018498 	.word	0x20018498

0804b950 <__malloc_unlock>:
 804b950:	4801      	ldr	r0, [pc, #4]	@ (804b958 <__malloc_unlock+0x8>)
 804b952:	f000 bb2f 	b.w	804bfb4 <__retarget_lock_release_recursive>
 804b956:	bf00      	nop
 804b958:	20018498 	.word	0x20018498

0804b95c <srand>:
 804b95c:	b538      	push	{r3, r4, r5, lr}
 804b95e:	4b10      	ldr	r3, [pc, #64]	@ (804b9a0 <srand+0x44>)
 804b960:	4604      	mov	r4, r0
 804b962:	681d      	ldr	r5, [r3, #0]
 804b964:	6b2b      	ldr	r3, [r5, #48]	@ 0x30
 804b966:	b9b3      	cbnz	r3, 804b996 <srand+0x3a>
 804b968:	2018      	movs	r0, #24
 804b96a:	f7ff ff39 	bl	804b7e0 <malloc>
 804b96e:	4602      	mov	r2, r0
 804b970:	6328      	str	r0, [r5, #48]	@ 0x30
 804b972:	b920      	cbnz	r0, 804b97e <srand+0x22>
 804b974:	4b0b      	ldr	r3, [pc, #44]	@ (804b9a4 <srand+0x48>)
 804b976:	2146      	movs	r1, #70	@ 0x46
 804b978:	480b      	ldr	r0, [pc, #44]	@ (804b9a8 <srand+0x4c>)
 804b97a:	f7ff fef7 	bl	804b76c <__assert_func>
 804b97e:	490b      	ldr	r1, [pc, #44]	@ (804b9ac <srand+0x50>)
 804b980:	4b0b      	ldr	r3, [pc, #44]	@ (804b9b0 <srand+0x54>)
 804b982:	e9c0 1300 	strd	r1, r3, [r0]
 804b986:	4b0b      	ldr	r3, [pc, #44]	@ (804b9b4 <srand+0x58>)
 804b988:	2100      	movs	r1, #0
 804b98a:	6083      	str	r3, [r0, #8]
 804b98c:	230b      	movs	r3, #11
 804b98e:	8183      	strh	r3, [r0, #12]
 804b990:	2001      	movs	r0, #1
 804b992:	e9c2 0104 	strd	r0, r1, [r2, #16]
 804b996:	6b2b      	ldr	r3, [r5, #48]	@ 0x30
 804b998:	2200      	movs	r2, #0
 804b99a:	611c      	str	r4, [r3, #16]
 804b99c:	615a      	str	r2, [r3, #20]
 804b99e:	bd38      	pop	{r3, r4, r5, pc}
 804b9a0:	2001813c 	.word	0x2001813c
 804b9a4:	0804e582 	.word	0x0804e582
 804b9a8:	0804e599 	.word	0x0804e599
 804b9ac:	abcd330e 	.word	0xabcd330e
 804b9b0:	e66d1234 	.word	0xe66d1234
 804b9b4:	0005deec 	.word	0x0005deec

0804b9b8 <realloc>:
 804b9b8:	4b02      	ldr	r3, [pc, #8]	@ (804b9c4 <realloc+0xc>)
 804b9ba:	460a      	mov	r2, r1
 804b9bc:	4601      	mov	r1, r0
 804b9be:	6818      	ldr	r0, [r3, #0]
 804b9c0:	f000 b802 	b.w	804b9c8 <_realloc_r>
 804b9c4:	2001813c 	.word	0x2001813c

0804b9c8 <_realloc_r>:
 804b9c8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 804b9cc:	4680      	mov	r8, r0
 804b9ce:	4615      	mov	r5, r2
 804b9d0:	460c      	mov	r4, r1
 804b9d2:	b921      	cbnz	r1, 804b9de <_realloc_r+0x16>
 804b9d4:	4611      	mov	r1, r2
 804b9d6:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 804b9da:	f7ff bf33 	b.w	804b844 <_malloc_r>
 804b9de:	b92a      	cbnz	r2, 804b9ec <_realloc_r+0x24>
 804b9e0:	f000 fb04 	bl	804bfec <_free_r>
 804b9e4:	2400      	movs	r4, #0
 804b9e6:	4620      	mov	r0, r4
 804b9e8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 804b9ec:	f000 fb48 	bl	804c080 <_malloc_usable_size_r>
 804b9f0:	4285      	cmp	r5, r0
 804b9f2:	4606      	mov	r6, r0
 804b9f4:	d802      	bhi.n	804b9fc <_realloc_r+0x34>
 804b9f6:	ebb5 0f50 	cmp.w	r5, r0, lsr #1
 804b9fa:	d8f4      	bhi.n	804b9e6 <_realloc_r+0x1e>
 804b9fc:	4629      	mov	r1, r5
 804b9fe:	4640      	mov	r0, r8
 804ba00:	f7ff ff20 	bl	804b844 <_malloc_r>
 804ba04:	4607      	mov	r7, r0
 804ba06:	2800      	cmp	r0, #0
 804ba08:	d0ec      	beq.n	804b9e4 <_realloc_r+0x1c>
 804ba0a:	42b5      	cmp	r5, r6
 804ba0c:	462a      	mov	r2, r5
 804ba0e:	4621      	mov	r1, r4
 804ba10:	bf28      	it	cs
 804ba12:	4632      	movcs	r2, r6
 804ba14:	f000 facf 	bl	804bfb6 <memcpy>
 804ba18:	4621      	mov	r1, r4
 804ba1a:	4640      	mov	r0, r8
 804ba1c:	463c      	mov	r4, r7
 804ba1e:	f000 fae5 	bl	804bfec <_free_r>
 804ba22:	e7e0      	b.n	804b9e6 <_realloc_r+0x1e>

0804ba24 <std>:
 804ba24:	2300      	movs	r3, #0
 804ba26:	b510      	push	{r4, lr}
 804ba28:	4604      	mov	r4, r0
 804ba2a:	6083      	str	r3, [r0, #8]
 804ba2c:	8181      	strh	r1, [r0, #12]
 804ba2e:	4619      	mov	r1, r3
 804ba30:	6643      	str	r3, [r0, #100]	@ 0x64
 804ba32:	81c2      	strh	r2, [r0, #14]
 804ba34:	2208      	movs	r2, #8
 804ba36:	6183      	str	r3, [r0, #24]
 804ba38:	e9c0 3300 	strd	r3, r3, [r0]
 804ba3c:	e9c0 3304 	strd	r3, r3, [r0, #16]
 804ba40:	305c      	adds	r0, #92	@ 0x5c
 804ba42:	f000 f9bb 	bl	804bdbc <memset>
 804ba46:	4b0d      	ldr	r3, [pc, #52]	@ (804ba7c <std+0x58>)
 804ba48:	6224      	str	r4, [r4, #32]
 804ba4a:	6263      	str	r3, [r4, #36]	@ 0x24
 804ba4c:	4b0c      	ldr	r3, [pc, #48]	@ (804ba80 <std+0x5c>)
 804ba4e:	62a3      	str	r3, [r4, #40]	@ 0x28
 804ba50:	4b0c      	ldr	r3, [pc, #48]	@ (804ba84 <std+0x60>)
 804ba52:	62e3      	str	r3, [r4, #44]	@ 0x2c
 804ba54:	4b0c      	ldr	r3, [pc, #48]	@ (804ba88 <std+0x64>)
 804ba56:	6323      	str	r3, [r4, #48]	@ 0x30
 804ba58:	4b0c      	ldr	r3, [pc, #48]	@ (804ba8c <std+0x68>)
 804ba5a:	429c      	cmp	r4, r3
 804ba5c:	d006      	beq.n	804ba6c <std+0x48>
 804ba5e:	f103 0268 	add.w	r2, r3, #104	@ 0x68
 804ba62:	4294      	cmp	r4, r2
 804ba64:	d002      	beq.n	804ba6c <std+0x48>
 804ba66:	33d0      	adds	r3, #208	@ 0xd0
 804ba68:	429c      	cmp	r4, r3
 804ba6a:	d105      	bne.n	804ba78 <std+0x54>
 804ba6c:	f104 0058 	add.w	r0, r4, #88	@ 0x58
 804ba70:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 804ba74:	f000 ba9c 	b.w	804bfb0 <__retarget_lock_init_recursive>
 804ba78:	bd10      	pop	{r4, pc}
 804ba7a:	bf00      	nop
 804ba7c:	0804bc0d 	.word	0x0804bc0d
 804ba80:	0804bc2f 	.word	0x0804bc2f
 804ba84:	0804bc67 	.word	0x0804bc67
 804ba88:	0804bc8b 	.word	0x0804bc8b
 804ba8c:	20018358 	.word	0x20018358

0804ba90 <stdio_exit_handler>:
 804ba90:	4a02      	ldr	r2, [pc, #8]	@ (804ba9c <stdio_exit_handler+0xc>)
 804ba92:	4903      	ldr	r1, [pc, #12]	@ (804baa0 <stdio_exit_handler+0x10>)
 804ba94:	4803      	ldr	r0, [pc, #12]	@ (804baa4 <stdio_exit_handler+0x14>)
 804ba96:	f000 b87b 	b.w	804bb90 <_fwalk_sglue>
 804ba9a:	bf00      	nop
 804ba9c:	20018130 	.word	0x20018130
 804baa0:	0804c9f1 	.word	0x0804c9f1
 804baa4:	20018140 	.word	0x20018140

0804baa8 <cleanup_stdio>:
 804baa8:	6841      	ldr	r1, [r0, #4]
 804baaa:	4b0c      	ldr	r3, [pc, #48]	@ (804badc <cleanup_stdio+0x34>)
 804baac:	4299      	cmp	r1, r3
 804baae:	b510      	push	{r4, lr}
 804bab0:	4604      	mov	r4, r0
 804bab2:	d001      	beq.n	804bab8 <cleanup_stdio+0x10>
 804bab4:	f000 ff9c 	bl	804c9f0 <_fflush_r>
 804bab8:	68a1      	ldr	r1, [r4, #8]
 804baba:	4b09      	ldr	r3, [pc, #36]	@ (804bae0 <cleanup_stdio+0x38>)
 804babc:	4299      	cmp	r1, r3
 804babe:	d002      	beq.n	804bac6 <cleanup_stdio+0x1e>
 804bac0:	4620      	mov	r0, r4
 804bac2:	f000 ff95 	bl	804c9f0 <_fflush_r>
 804bac6:	68e1      	ldr	r1, [r4, #12]
 804bac8:	4b06      	ldr	r3, [pc, #24]	@ (804bae4 <cleanup_stdio+0x3c>)
 804baca:	4299      	cmp	r1, r3
 804bacc:	d004      	beq.n	804bad8 <cleanup_stdio+0x30>
 804bace:	4620      	mov	r0, r4
 804bad0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 804bad4:	f000 bf8c 	b.w	804c9f0 <_fflush_r>
 804bad8:	bd10      	pop	{r4, pc}
 804bada:	bf00      	nop
 804badc:	20018358 	.word	0x20018358
 804bae0:	200183c0 	.word	0x200183c0
 804bae4:	20018428 	.word	0x20018428

0804bae8 <global_stdio_init.part.0>:
 804bae8:	b510      	push	{r4, lr}
 804baea:	4b0b      	ldr	r3, [pc, #44]	@ (804bb18 <global_stdio_init.part.0+0x30>)
 804baec:	2104      	movs	r1, #4
 804baee:	4c0b      	ldr	r4, [pc, #44]	@ (804bb1c <global_stdio_init.part.0+0x34>)
 804baf0:	4a0b      	ldr	r2, [pc, #44]	@ (804bb20 <global_stdio_init.part.0+0x38>)
 804baf2:	4620      	mov	r0, r4
 804baf4:	601a      	str	r2, [r3, #0]
 804baf6:	2200      	movs	r2, #0
 804baf8:	f7ff ff94 	bl	804ba24 <std>
 804bafc:	f104 0068 	add.w	r0, r4, #104	@ 0x68
 804bb00:	2201      	movs	r2, #1
 804bb02:	2109      	movs	r1, #9
 804bb04:	f7ff ff8e 	bl	804ba24 <std>
 804bb08:	f104 00d0 	add.w	r0, r4, #208	@ 0xd0
 804bb0c:	2202      	movs	r2, #2
 804bb0e:	2112      	movs	r1, #18
 804bb10:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 804bb14:	f7ff bf86 	b.w	804ba24 <std>
 804bb18:	20018490 	.word	0x20018490
 804bb1c:	20018358 	.word	0x20018358
 804bb20:	0804ba91 	.word	0x0804ba91

0804bb24 <__sfp_lock_acquire>:
 804bb24:	4801      	ldr	r0, [pc, #4]	@ (804bb2c <__sfp_lock_acquire+0x8>)
 804bb26:	f000 ba44 	b.w	804bfb2 <__retarget_lock_acquire_recursive>
 804bb2a:	bf00      	nop
 804bb2c:	20018499 	.word	0x20018499

0804bb30 <__sfp_lock_release>:
 804bb30:	4801      	ldr	r0, [pc, #4]	@ (804bb38 <__sfp_lock_release+0x8>)
 804bb32:	f000 ba3f 	b.w	804bfb4 <__retarget_lock_release_recursive>
 804bb36:	bf00      	nop
 804bb38:	20018499 	.word	0x20018499

0804bb3c <__sinit>:
 804bb3c:	b510      	push	{r4, lr}
 804bb3e:	4604      	mov	r4, r0
 804bb40:	f7ff fff0 	bl	804bb24 <__sfp_lock_acquire>
 804bb44:	6a23      	ldr	r3, [r4, #32]
 804bb46:	b11b      	cbz	r3, 804bb50 <__sinit+0x14>
 804bb48:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 804bb4c:	f7ff bff0 	b.w	804bb30 <__sfp_lock_release>
 804bb50:	4b04      	ldr	r3, [pc, #16]	@ (804bb64 <__sinit+0x28>)
 804bb52:	6223      	str	r3, [r4, #32]
 804bb54:	4b04      	ldr	r3, [pc, #16]	@ (804bb68 <__sinit+0x2c>)
 804bb56:	681b      	ldr	r3, [r3, #0]
 804bb58:	2b00      	cmp	r3, #0
 804bb5a:	d1f5      	bne.n	804bb48 <__sinit+0xc>
 804bb5c:	f7ff ffc4 	bl	804bae8 <global_stdio_init.part.0>
 804bb60:	e7f2      	b.n	804bb48 <__sinit+0xc>
 804bb62:	bf00      	nop
 804bb64:	0804baa9 	.word	0x0804baa9
 804bb68:	20018490 	.word	0x20018490

0804bb6c <fiprintf>:
 804bb6c:	b40e      	push	{r1, r2, r3}
 804bb6e:	b503      	push	{r0, r1, lr}
 804bb70:	ab03      	add	r3, sp, #12
 804bb72:	4601      	mov	r1, r0
 804bb74:	4805      	ldr	r0, [pc, #20]	@ (804bb8c <fiprintf+0x20>)
 804bb76:	f853 2b04 	ldr.w	r2, [r3], #4
 804bb7a:	6800      	ldr	r0, [r0, #0]
 804bb7c:	9301      	str	r3, [sp, #4]
 804bb7e:	f000 fc09 	bl	804c394 <_vfiprintf_r>
 804bb82:	b002      	add	sp, #8
 804bb84:	f85d eb04 	ldr.w	lr, [sp], #4
 804bb88:	b003      	add	sp, #12
 804bb8a:	4770      	bx	lr
 804bb8c:	2001813c 	.word	0x2001813c

0804bb90 <_fwalk_sglue>:
 804bb90:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 804bb94:	4607      	mov	r7, r0
 804bb96:	4688      	mov	r8, r1
 804bb98:	4614      	mov	r4, r2
 804bb9a:	2600      	movs	r6, #0
 804bb9c:	e9d4 9501 	ldrd	r9, r5, [r4, #4]
 804bba0:	f1b9 0901 	subs.w	r9, r9, #1
 804bba4:	d505      	bpl.n	804bbb2 <_fwalk_sglue+0x22>
 804bba6:	6824      	ldr	r4, [r4, #0]
 804bba8:	2c00      	cmp	r4, #0
 804bbaa:	d1f7      	bne.n	804bb9c <_fwalk_sglue+0xc>
 804bbac:	4630      	mov	r0, r6
 804bbae:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 804bbb2:	89ab      	ldrh	r3, [r5, #12]
 804bbb4:	2b01      	cmp	r3, #1
 804bbb6:	d907      	bls.n	804bbc8 <_fwalk_sglue+0x38>
 804bbb8:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
 804bbbc:	3301      	adds	r3, #1
 804bbbe:	d003      	beq.n	804bbc8 <_fwalk_sglue+0x38>
 804bbc0:	4629      	mov	r1, r5
 804bbc2:	4638      	mov	r0, r7
 804bbc4:	47c0      	blx	r8
 804bbc6:	4306      	orrs	r6, r0
 804bbc8:	3568      	adds	r5, #104	@ 0x68
 804bbca:	e7e9      	b.n	804bba0 <_fwalk_sglue+0x10>

0804bbcc <siprintf>:
 804bbcc:	b40e      	push	{r1, r2, r3}
 804bbce:	b500      	push	{lr}
 804bbd0:	b09c      	sub	sp, #112	@ 0x70
 804bbd2:	f06f 4100 	mvn.w	r1, #2147483648	@ 0x80000000
 804bbd6:	ab1d      	add	r3, sp, #116	@ 0x74
 804bbd8:	9002      	str	r0, [sp, #8]
 804bbda:	9006      	str	r0, [sp, #24]
 804bbdc:	9107      	str	r1, [sp, #28]
 804bbde:	9104      	str	r1, [sp, #16]
 804bbe0:	4808      	ldr	r0, [pc, #32]	@ (804bc04 <siprintf+0x38>)
 804bbe2:	4909      	ldr	r1, [pc, #36]	@ (804bc08 <siprintf+0x3c>)
 804bbe4:	f853 2b04 	ldr.w	r2, [r3], #4
 804bbe8:	9105      	str	r1, [sp, #20]
 804bbea:	a902      	add	r1, sp, #8
 804bbec:	6800      	ldr	r0, [r0, #0]
 804bbee:	9301      	str	r3, [sp, #4]
 804bbf0:	f000 faaa 	bl	804c148 <_svfiprintf_r>
 804bbf4:	9b02      	ldr	r3, [sp, #8]
 804bbf6:	2200      	movs	r2, #0
 804bbf8:	701a      	strb	r2, [r3, #0]
 804bbfa:	b01c      	add	sp, #112	@ 0x70
 804bbfc:	f85d eb04 	ldr.w	lr, [sp], #4
 804bc00:	b003      	add	sp, #12
 804bc02:	4770      	bx	lr
 804bc04:	2001813c 	.word	0x2001813c
 804bc08:	ffff0208 	.word	0xffff0208

0804bc0c <__sread>:
 804bc0c:	b510      	push	{r4, lr}
 804bc0e:	460c      	mov	r4, r1
 804bc10:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 804bc14:	f000 f95a 	bl	804becc <_read_r>
 804bc18:	2800      	cmp	r0, #0
 804bc1a:	bfab      	itete	ge
 804bc1c:	6d63      	ldrge	r3, [r4, #84]	@ 0x54
 804bc1e:	89a3      	ldrhlt	r3, [r4, #12]
 804bc20:	181b      	addge	r3, r3, r0
 804bc22:	f423 5380 	biclt.w	r3, r3, #4096	@ 0x1000
 804bc26:	bfac      	ite	ge
 804bc28:	6563      	strge	r3, [r4, #84]	@ 0x54
 804bc2a:	81a3      	strhlt	r3, [r4, #12]
 804bc2c:	bd10      	pop	{r4, pc}

0804bc2e <__swrite>:
 804bc2e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 804bc32:	461f      	mov	r7, r3
 804bc34:	898b      	ldrh	r3, [r1, #12]
 804bc36:	4605      	mov	r5, r0
 804bc38:	460c      	mov	r4, r1
 804bc3a:	05db      	lsls	r3, r3, #23
 804bc3c:	4616      	mov	r6, r2
 804bc3e:	d505      	bpl.n	804bc4c <__swrite+0x1e>
 804bc40:	2302      	movs	r3, #2
 804bc42:	2200      	movs	r2, #0
 804bc44:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 804bc48:	f000 f92e 	bl	804bea8 <_lseek_r>
 804bc4c:	89a3      	ldrh	r3, [r4, #12]
 804bc4e:	4632      	mov	r2, r6
 804bc50:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 804bc54:	4628      	mov	r0, r5
 804bc56:	f423 5380 	bic.w	r3, r3, #4096	@ 0x1000
 804bc5a:	81a3      	strh	r3, [r4, #12]
 804bc5c:	463b      	mov	r3, r7
 804bc5e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 804bc62:	f000 b969 	b.w	804bf38 <_write_r>

0804bc66 <__sseek>:
 804bc66:	b510      	push	{r4, lr}
 804bc68:	460c      	mov	r4, r1
 804bc6a:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 804bc6e:	f000 f91b 	bl	804bea8 <_lseek_r>
 804bc72:	1c43      	adds	r3, r0, #1
 804bc74:	89a3      	ldrh	r3, [r4, #12]
 804bc76:	bf15      	itete	ne
 804bc78:	6560      	strne	r0, [r4, #84]	@ 0x54
 804bc7a:	f423 5380 	biceq.w	r3, r3, #4096	@ 0x1000
 804bc7e:	f443 5380 	orrne.w	r3, r3, #4096	@ 0x1000
 804bc82:	81a3      	strheq	r3, [r4, #12]
 804bc84:	bf18      	it	ne
 804bc86:	81a3      	strhne	r3, [r4, #12]
 804bc88:	bd10      	pop	{r4, pc}

0804bc8a <__sclose>:
 804bc8a:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 804bc8e:	f000 b8e9 	b.w	804be64 <_close_r>

0804bc92 <__swbuf_r>:
 804bc92:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 804bc94:	460e      	mov	r6, r1
 804bc96:	4614      	mov	r4, r2
 804bc98:	4605      	mov	r5, r0
 804bc9a:	b118      	cbz	r0, 804bca4 <__swbuf_r+0x12>
 804bc9c:	6a03      	ldr	r3, [r0, #32]
 804bc9e:	b90b      	cbnz	r3, 804bca4 <__swbuf_r+0x12>
 804bca0:	f7ff ff4c 	bl	804bb3c <__sinit>
 804bca4:	69a3      	ldr	r3, [r4, #24]
 804bca6:	60a3      	str	r3, [r4, #8]
 804bca8:	89a3      	ldrh	r3, [r4, #12]
 804bcaa:	071a      	lsls	r2, r3, #28
 804bcac:	d501      	bpl.n	804bcb2 <__swbuf_r+0x20>
 804bcae:	6923      	ldr	r3, [r4, #16]
 804bcb0:	b943      	cbnz	r3, 804bcc4 <__swbuf_r+0x32>
 804bcb2:	4621      	mov	r1, r4
 804bcb4:	4628      	mov	r0, r5
 804bcb6:	f000 f82b 	bl	804bd10 <__swsetup_r>
 804bcba:	b118      	cbz	r0, 804bcc4 <__swbuf_r+0x32>
 804bcbc:	f04f 37ff 	mov.w	r7, #4294967295
 804bcc0:	4638      	mov	r0, r7
 804bcc2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 804bcc4:	6823      	ldr	r3, [r4, #0]
 804bcc6:	b2f6      	uxtb	r6, r6
 804bcc8:	6922      	ldr	r2, [r4, #16]
 804bcca:	4637      	mov	r7, r6
 804bccc:	1a98      	subs	r0, r3, r2
 804bcce:	6963      	ldr	r3, [r4, #20]
 804bcd0:	4283      	cmp	r3, r0
 804bcd2:	dc05      	bgt.n	804bce0 <__swbuf_r+0x4e>
 804bcd4:	4621      	mov	r1, r4
 804bcd6:	4628      	mov	r0, r5
 804bcd8:	f000 fe8a 	bl	804c9f0 <_fflush_r>
 804bcdc:	2800      	cmp	r0, #0
 804bcde:	d1ed      	bne.n	804bcbc <__swbuf_r+0x2a>
 804bce0:	68a3      	ldr	r3, [r4, #8]
 804bce2:	3b01      	subs	r3, #1
 804bce4:	60a3      	str	r3, [r4, #8]
 804bce6:	6823      	ldr	r3, [r4, #0]
 804bce8:	1c5a      	adds	r2, r3, #1
 804bcea:	6022      	str	r2, [r4, #0]
 804bcec:	701e      	strb	r6, [r3, #0]
 804bcee:	1c43      	adds	r3, r0, #1
 804bcf0:	6962      	ldr	r2, [r4, #20]
 804bcf2:	429a      	cmp	r2, r3
 804bcf4:	d004      	beq.n	804bd00 <__swbuf_r+0x6e>
 804bcf6:	89a3      	ldrh	r3, [r4, #12]
 804bcf8:	07db      	lsls	r3, r3, #31
 804bcfa:	d5e1      	bpl.n	804bcc0 <__swbuf_r+0x2e>
 804bcfc:	2e0a      	cmp	r6, #10
 804bcfe:	d1df      	bne.n	804bcc0 <__swbuf_r+0x2e>
 804bd00:	4621      	mov	r1, r4
 804bd02:	4628      	mov	r0, r5
 804bd04:	f000 fe74 	bl	804c9f0 <_fflush_r>
 804bd08:	2800      	cmp	r0, #0
 804bd0a:	d0d9      	beq.n	804bcc0 <__swbuf_r+0x2e>
 804bd0c:	e7d6      	b.n	804bcbc <__swbuf_r+0x2a>
	...

0804bd10 <__swsetup_r>:
 804bd10:	b538      	push	{r3, r4, r5, lr}
 804bd12:	4b29      	ldr	r3, [pc, #164]	@ (804bdb8 <__swsetup_r+0xa8>)
 804bd14:	4605      	mov	r5, r0
 804bd16:	460c      	mov	r4, r1
 804bd18:	6818      	ldr	r0, [r3, #0]
 804bd1a:	b118      	cbz	r0, 804bd24 <__swsetup_r+0x14>
 804bd1c:	6a03      	ldr	r3, [r0, #32]
 804bd1e:	b90b      	cbnz	r3, 804bd24 <__swsetup_r+0x14>
 804bd20:	f7ff ff0c 	bl	804bb3c <__sinit>
 804bd24:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 804bd28:	0719      	lsls	r1, r3, #28
 804bd2a:	d422      	bmi.n	804bd72 <__swsetup_r+0x62>
 804bd2c:	06da      	lsls	r2, r3, #27
 804bd2e:	d407      	bmi.n	804bd40 <__swsetup_r+0x30>
 804bd30:	2209      	movs	r2, #9
 804bd32:	602a      	str	r2, [r5, #0]
 804bd34:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 804bd38:	f04f 30ff 	mov.w	r0, #4294967295
 804bd3c:	81a3      	strh	r3, [r4, #12]
 804bd3e:	e033      	b.n	804bda8 <__swsetup_r+0x98>
 804bd40:	0758      	lsls	r0, r3, #29
 804bd42:	d512      	bpl.n	804bd6a <__swsetup_r+0x5a>
 804bd44:	6b61      	ldr	r1, [r4, #52]	@ 0x34
 804bd46:	b141      	cbz	r1, 804bd5a <__swsetup_r+0x4a>
 804bd48:	f104 0344 	add.w	r3, r4, #68	@ 0x44
 804bd4c:	4299      	cmp	r1, r3
 804bd4e:	d002      	beq.n	804bd56 <__swsetup_r+0x46>
 804bd50:	4628      	mov	r0, r5
 804bd52:	f000 f94b 	bl	804bfec <_free_r>
 804bd56:	2300      	movs	r3, #0
 804bd58:	6363      	str	r3, [r4, #52]	@ 0x34
 804bd5a:	89a3      	ldrh	r3, [r4, #12]
 804bd5c:	f023 0324 	bic.w	r3, r3, #36	@ 0x24
 804bd60:	81a3      	strh	r3, [r4, #12]
 804bd62:	2300      	movs	r3, #0
 804bd64:	6063      	str	r3, [r4, #4]
 804bd66:	6923      	ldr	r3, [r4, #16]
 804bd68:	6023      	str	r3, [r4, #0]
 804bd6a:	89a3      	ldrh	r3, [r4, #12]
 804bd6c:	f043 0308 	orr.w	r3, r3, #8
 804bd70:	81a3      	strh	r3, [r4, #12]
 804bd72:	6923      	ldr	r3, [r4, #16]
 804bd74:	b94b      	cbnz	r3, 804bd8a <__swsetup_r+0x7a>
 804bd76:	89a3      	ldrh	r3, [r4, #12]
 804bd78:	f403 7320 	and.w	r3, r3, #640	@ 0x280
 804bd7c:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 804bd80:	d003      	beq.n	804bd8a <__swsetup_r+0x7a>
 804bd82:	4621      	mov	r1, r4
 804bd84:	4628      	mov	r0, r5
 804bd86:	f000 fe80 	bl	804ca8a <__smakebuf_r>
 804bd8a:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 804bd8e:	f013 0201 	ands.w	r2, r3, #1
 804bd92:	d00a      	beq.n	804bdaa <__swsetup_r+0x9a>
 804bd94:	2200      	movs	r2, #0
 804bd96:	60a2      	str	r2, [r4, #8]
 804bd98:	6962      	ldr	r2, [r4, #20]
 804bd9a:	4252      	negs	r2, r2
 804bd9c:	61a2      	str	r2, [r4, #24]
 804bd9e:	6922      	ldr	r2, [r4, #16]
 804bda0:	b942      	cbnz	r2, 804bdb4 <__swsetup_r+0xa4>
 804bda2:	f013 0080 	ands.w	r0, r3, #128	@ 0x80
 804bda6:	d1c5      	bne.n	804bd34 <__swsetup_r+0x24>
 804bda8:	bd38      	pop	{r3, r4, r5, pc}
 804bdaa:	0799      	lsls	r1, r3, #30
 804bdac:	bf58      	it	pl
 804bdae:	6962      	ldrpl	r2, [r4, #20]
 804bdb0:	60a2      	str	r2, [r4, #8]
 804bdb2:	e7f4      	b.n	804bd9e <__swsetup_r+0x8e>
 804bdb4:	2000      	movs	r0, #0
 804bdb6:	e7f7      	b.n	804bda8 <__swsetup_r+0x98>
 804bdb8:	2001813c 	.word	0x2001813c

0804bdbc <memset>:
 804bdbc:	4402      	add	r2, r0
 804bdbe:	4603      	mov	r3, r0
 804bdc0:	4293      	cmp	r3, r2
 804bdc2:	d100      	bne.n	804bdc6 <memset+0xa>
 804bdc4:	4770      	bx	lr
 804bdc6:	f803 1b01 	strb.w	r1, [r3], #1
 804bdca:	e7f9      	b.n	804bdc0 <memset+0x4>

0804bdcc <_raise_r>:
 804bdcc:	291f      	cmp	r1, #31
 804bdce:	b538      	push	{r3, r4, r5, lr}
 804bdd0:	4605      	mov	r5, r0
 804bdd2:	460c      	mov	r4, r1
 804bdd4:	d904      	bls.n	804bde0 <_raise_r+0x14>
 804bdd6:	2316      	movs	r3, #22
 804bdd8:	6003      	str	r3, [r0, #0]
 804bdda:	f04f 30ff 	mov.w	r0, #4294967295
 804bdde:	bd38      	pop	{r3, r4, r5, pc}
 804bde0:	6bc2      	ldr	r2, [r0, #60]	@ 0x3c
 804bde2:	b112      	cbz	r2, 804bdea <_raise_r+0x1e>
 804bde4:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
 804bde8:	b94b      	cbnz	r3, 804bdfe <_raise_r+0x32>
 804bdea:	4628      	mov	r0, r5
 804bdec:	f000 f892 	bl	804bf14 <_getpid_r>
 804bdf0:	4622      	mov	r2, r4
 804bdf2:	4601      	mov	r1, r0
 804bdf4:	4628      	mov	r0, r5
 804bdf6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 804bdfa:	f000 b879 	b.w	804bef0 <_kill_r>
 804bdfe:	2b01      	cmp	r3, #1
 804be00:	d00a      	beq.n	804be18 <_raise_r+0x4c>
 804be02:	1c59      	adds	r1, r3, #1
 804be04:	d103      	bne.n	804be0e <_raise_r+0x42>
 804be06:	2316      	movs	r3, #22
 804be08:	6003      	str	r3, [r0, #0]
 804be0a:	2001      	movs	r0, #1
 804be0c:	e7e7      	b.n	804bdde <_raise_r+0x12>
 804be0e:	2100      	movs	r1, #0
 804be10:	4620      	mov	r0, r4
 804be12:	f842 1024 	str.w	r1, [r2, r4, lsl #2]
 804be16:	4798      	blx	r3
 804be18:	2000      	movs	r0, #0
 804be1a:	e7e0      	b.n	804bdde <_raise_r+0x12>

0804be1c <raise>:
 804be1c:	4b02      	ldr	r3, [pc, #8]	@ (804be28 <raise+0xc>)
 804be1e:	4601      	mov	r1, r0
 804be20:	6818      	ldr	r0, [r3, #0]
 804be22:	f7ff bfd3 	b.w	804bdcc <_raise_r>
 804be26:	bf00      	nop
 804be28:	2001813c 	.word	0x2001813c

0804be2c <time>:
 804be2c:	b5df      	push	{r0, r1, r2, r3, r4, r6, r7, lr}
 804be2e:	4b0c      	ldr	r3, [pc, #48]	@ (804be60 <time+0x34>)
 804be30:	f04f 36ff 	mov.w	r6, #4294967295
 804be34:	f04f 37ff 	mov.w	r7, #4294967295
 804be38:	4669      	mov	r1, sp
 804be3a:	4604      	mov	r4, r0
 804be3c:	2200      	movs	r2, #0
 804be3e:	6818      	ldr	r0, [r3, #0]
 804be40:	e9cd 6700 	strd	r6, r7, [sp]
 804be44:	f000 f81e 	bl	804be84 <_gettimeofday_r>
 804be48:	2800      	cmp	r0, #0
 804be4a:	bfb8      	it	lt
 804be4c:	e9cd 6700 	strdlt	r6, r7, [sp]
 804be50:	e9dd 0100 	ldrd	r0, r1, [sp]
 804be54:	b10c      	cbz	r4, 804be5a <time+0x2e>
 804be56:	e9c4 0100 	strd	r0, r1, [r4]
 804be5a:	b004      	add	sp, #16
 804be5c:	bdd0      	pop	{r4, r6, r7, pc}
 804be5e:	bf00      	nop
 804be60:	2001813c 	.word	0x2001813c

0804be64 <_close_r>:
 804be64:	b538      	push	{r3, r4, r5, lr}
 804be66:	2300      	movs	r3, #0
 804be68:	4d05      	ldr	r5, [pc, #20]	@ (804be80 <_close_r+0x1c>)
 804be6a:	4604      	mov	r4, r0
 804be6c:	4608      	mov	r0, r1
 804be6e:	602b      	str	r3, [r5, #0]
 804be70:	f7f5 fa0c 	bl	804128c <_close>
 804be74:	1c43      	adds	r3, r0, #1
 804be76:	d102      	bne.n	804be7e <_close_r+0x1a>
 804be78:	682b      	ldr	r3, [r5, #0]
 804be7a:	b103      	cbz	r3, 804be7e <_close_r+0x1a>
 804be7c:	6023      	str	r3, [r4, #0]
 804be7e:	bd38      	pop	{r3, r4, r5, pc}
 804be80:	20018494 	.word	0x20018494

0804be84 <_gettimeofday_r>:
 804be84:	b538      	push	{r3, r4, r5, lr}
 804be86:	2300      	movs	r3, #0
 804be88:	4d06      	ldr	r5, [pc, #24]	@ (804bea4 <_gettimeofday_r+0x20>)
 804be8a:	4604      	mov	r4, r0
 804be8c:	4608      	mov	r0, r1
 804be8e:	4611      	mov	r1, r2
 804be90:	602b      	str	r3, [r5, #0]
 804be92:	f002 f92b 	bl	804e0ec <_gettimeofday>
 804be96:	1c43      	adds	r3, r0, #1
 804be98:	d102      	bne.n	804bea0 <_gettimeofday_r+0x1c>
 804be9a:	682b      	ldr	r3, [r5, #0]
 804be9c:	b103      	cbz	r3, 804bea0 <_gettimeofday_r+0x1c>
 804be9e:	6023      	str	r3, [r4, #0]
 804bea0:	bd38      	pop	{r3, r4, r5, pc}
 804bea2:	bf00      	nop
 804bea4:	20018494 	.word	0x20018494

0804bea8 <_lseek_r>:
 804bea8:	b538      	push	{r3, r4, r5, lr}
 804beaa:	4604      	mov	r4, r0
 804beac:	4d06      	ldr	r5, [pc, #24]	@ (804bec8 <_lseek_r+0x20>)
 804beae:	4608      	mov	r0, r1
 804beb0:	4611      	mov	r1, r2
 804beb2:	2200      	movs	r2, #0
 804beb4:	602a      	str	r2, [r5, #0]
 804beb6:	461a      	mov	r2, r3
 804beb8:	f7f5 f9f4 	bl	80412a4 <_lseek>
 804bebc:	1c43      	adds	r3, r0, #1
 804bebe:	d102      	bne.n	804bec6 <_lseek_r+0x1e>
 804bec0:	682b      	ldr	r3, [r5, #0]
 804bec2:	b103      	cbz	r3, 804bec6 <_lseek_r+0x1e>
 804bec4:	6023      	str	r3, [r4, #0]
 804bec6:	bd38      	pop	{r3, r4, r5, pc}
 804bec8:	20018494 	.word	0x20018494

0804becc <_read_r>:
 804becc:	b538      	push	{r3, r4, r5, lr}
 804bece:	4604      	mov	r4, r0
 804bed0:	4d06      	ldr	r5, [pc, #24]	@ (804beec <_read_r+0x20>)
 804bed2:	4608      	mov	r0, r1
 804bed4:	4611      	mov	r1, r2
 804bed6:	2200      	movs	r2, #0
 804bed8:	602a      	str	r2, [r5, #0]
 804beda:	461a      	mov	r2, r3
 804bedc:	f7f5 f9ba 	bl	8041254 <_read>
 804bee0:	1c43      	adds	r3, r0, #1
 804bee2:	d102      	bne.n	804beea <_read_r+0x1e>
 804bee4:	682b      	ldr	r3, [r5, #0]
 804bee6:	b103      	cbz	r3, 804beea <_read_r+0x1e>
 804bee8:	6023      	str	r3, [r4, #0]
 804beea:	bd38      	pop	{r3, r4, r5, pc}
 804beec:	20018494 	.word	0x20018494

0804bef0 <_kill_r>:
 804bef0:	b538      	push	{r3, r4, r5, lr}
 804bef2:	2300      	movs	r3, #0
 804bef4:	4d06      	ldr	r5, [pc, #24]	@ (804bf10 <_kill_r+0x20>)
 804bef6:	4604      	mov	r4, r0
 804bef8:	4608      	mov	r0, r1
 804befa:	4611      	mov	r1, r2
 804befc:	602b      	str	r3, [r5, #0]
 804befe:	f7f5 f999 	bl	8041234 <_kill>
 804bf02:	1c43      	adds	r3, r0, #1
 804bf04:	d102      	bne.n	804bf0c <_kill_r+0x1c>
 804bf06:	682b      	ldr	r3, [r5, #0]
 804bf08:	b103      	cbz	r3, 804bf0c <_kill_r+0x1c>
 804bf0a:	6023      	str	r3, [r4, #0]
 804bf0c:	bd38      	pop	{r3, r4, r5, pc}
 804bf0e:	bf00      	nop
 804bf10:	20018494 	.word	0x20018494

0804bf14 <_getpid_r>:
 804bf14:	f7f5 b98c 	b.w	8041230 <_getpid>

0804bf18 <_sbrk_r>:
 804bf18:	b538      	push	{r3, r4, r5, lr}
 804bf1a:	2300      	movs	r3, #0
 804bf1c:	4d05      	ldr	r5, [pc, #20]	@ (804bf34 <_sbrk_r+0x1c>)
 804bf1e:	4604      	mov	r4, r0
 804bf20:	4608      	mov	r0, r1
 804bf22:	602b      	str	r3, [r5, #0]
 804bf24:	f7f5 f9c0 	bl	80412a8 <_sbrk>
 804bf28:	1c43      	adds	r3, r0, #1
 804bf2a:	d102      	bne.n	804bf32 <_sbrk_r+0x1a>
 804bf2c:	682b      	ldr	r3, [r5, #0]
 804bf2e:	b103      	cbz	r3, 804bf32 <_sbrk_r+0x1a>
 804bf30:	6023      	str	r3, [r4, #0]
 804bf32:	bd38      	pop	{r3, r4, r5, pc}
 804bf34:	20018494 	.word	0x20018494

0804bf38 <_write_r>:
 804bf38:	b538      	push	{r3, r4, r5, lr}
 804bf3a:	4604      	mov	r4, r0
 804bf3c:	4d06      	ldr	r5, [pc, #24]	@ (804bf58 <_write_r+0x20>)
 804bf3e:	4608      	mov	r0, r1
 804bf40:	4611      	mov	r1, r2
 804bf42:	2200      	movs	r2, #0
 804bf44:	602a      	str	r2, [r5, #0]
 804bf46:	461a      	mov	r2, r3
 804bf48:	f7f5 f992 	bl	8041270 <_write>
 804bf4c:	1c43      	adds	r3, r0, #1
 804bf4e:	d102      	bne.n	804bf56 <_write_r+0x1e>
 804bf50:	682b      	ldr	r3, [r5, #0]
 804bf52:	b103      	cbz	r3, 804bf56 <_write_r+0x1e>
 804bf54:	6023      	str	r3, [r4, #0]
 804bf56:	bd38      	pop	{r3, r4, r5, pc}
 804bf58:	20018494 	.word	0x20018494

0804bf5c <__errno>:
 804bf5c:	4b01      	ldr	r3, [pc, #4]	@ (804bf64 <__errno+0x8>)
 804bf5e:	6818      	ldr	r0, [r3, #0]
 804bf60:	4770      	bx	lr
 804bf62:	bf00      	nop
 804bf64:	2001813c 	.word	0x2001813c

0804bf68 <__libc_init_array>:
 804bf68:	b570      	push	{r4, r5, r6, lr}
 804bf6a:	4d0d      	ldr	r5, [pc, #52]	@ (804bfa0 <__libc_init_array+0x38>)
 804bf6c:	2600      	movs	r6, #0
 804bf6e:	4c0d      	ldr	r4, [pc, #52]	@ (804bfa4 <__libc_init_array+0x3c>)
 804bf70:	1b64      	subs	r4, r4, r5
 804bf72:	10a4      	asrs	r4, r4, #2
 804bf74:	42a6      	cmp	r6, r4
 804bf76:	d109      	bne.n	804bf8c <__libc_init_array+0x24>
 804bf78:	4d0b      	ldr	r5, [pc, #44]	@ (804bfa8 <__libc_init_array+0x40>)
 804bf7a:	2600      	movs	r6, #0
 804bf7c:	4c0b      	ldr	r4, [pc, #44]	@ (804bfac <__libc_init_array+0x44>)
 804bf7e:	f002 f8bd 	bl	804e0fc <_init>
 804bf82:	1b64      	subs	r4, r4, r5
 804bf84:	10a4      	asrs	r4, r4, #2
 804bf86:	42a6      	cmp	r6, r4
 804bf88:	d105      	bne.n	804bf96 <__libc_init_array+0x2e>
 804bf8a:	bd70      	pop	{r4, r5, r6, pc}
 804bf8c:	f855 3b04 	ldr.w	r3, [r5], #4
 804bf90:	3601      	adds	r6, #1
 804bf92:	4798      	blx	r3
 804bf94:	e7ee      	b.n	804bf74 <__libc_init_array+0xc>
 804bf96:	f855 3b04 	ldr.w	r3, [r5], #4
 804bf9a:	3601      	adds	r6, #1
 804bf9c:	4798      	blx	r3
 804bf9e:	e7f2      	b.n	804bf86 <__libc_init_array+0x1e>
 804bfa0:	0804ea0c 	.word	0x0804ea0c
 804bfa4:	0804ea0c 	.word	0x0804ea0c
 804bfa8:	0804ea0c 	.word	0x0804ea0c
 804bfac:	0804ea10 	.word	0x0804ea10

0804bfb0 <__retarget_lock_init_recursive>:
 804bfb0:	4770      	bx	lr

0804bfb2 <__retarget_lock_acquire_recursive>:
 804bfb2:	4770      	bx	lr

0804bfb4 <__retarget_lock_release_recursive>:
 804bfb4:	4770      	bx	lr

0804bfb6 <memcpy>:
 804bfb6:	440a      	add	r2, r1
 804bfb8:	1e43      	subs	r3, r0, #1
 804bfba:	4291      	cmp	r1, r2
 804bfbc:	d100      	bne.n	804bfc0 <memcpy+0xa>
 804bfbe:	4770      	bx	lr
 804bfc0:	b510      	push	{r4, lr}
 804bfc2:	f811 4b01 	ldrb.w	r4, [r1], #1
 804bfc6:	4291      	cmp	r1, r2
 804bfc8:	f803 4f01 	strb.w	r4, [r3, #1]!
 804bfcc:	d1f9      	bne.n	804bfc2 <memcpy+0xc>
 804bfce:	bd10      	pop	{r4, pc}

0804bfd0 <nan>:
 804bfd0:	ed9f 0b01 	vldr	d0, [pc, #4]	@ 804bfd8 <nan+0x8>
 804bfd4:	4770      	bx	lr
 804bfd6:	bf00      	nop
 804bfd8:	00000000 	.word	0x00000000
 804bfdc:	7ff80000 	.word	0x7ff80000

0804bfe0 <nanf>:
 804bfe0:	ed9f 0a01 	vldr	s0, [pc, #4]	@ 804bfe8 <nanf+0x8>
 804bfe4:	4770      	bx	lr
 804bfe6:	bf00      	nop
 804bfe8:	7fc00000 	.word	0x7fc00000

0804bfec <_free_r>:
 804bfec:	b538      	push	{r3, r4, r5, lr}
 804bfee:	4605      	mov	r5, r0
 804bff0:	2900      	cmp	r1, #0
 804bff2:	d041      	beq.n	804c078 <_free_r+0x8c>
 804bff4:	f851 3c04 	ldr.w	r3, [r1, #-4]
 804bff8:	1f0c      	subs	r4, r1, #4
 804bffa:	2b00      	cmp	r3, #0
 804bffc:	bfb8      	it	lt
 804bffe:	18e4      	addlt	r4, r4, r3
 804c000:	f7ff fca0 	bl	804b944 <__malloc_lock>
 804c004:	4a1d      	ldr	r2, [pc, #116]	@ (804c07c <_free_r+0x90>)
 804c006:	6813      	ldr	r3, [r2, #0]
 804c008:	b933      	cbnz	r3, 804c018 <_free_r+0x2c>
 804c00a:	6063      	str	r3, [r4, #4]
 804c00c:	6014      	str	r4, [r2, #0]
 804c00e:	4628      	mov	r0, r5
 804c010:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 804c014:	f7ff bc9c 	b.w	804b950 <__malloc_unlock>
 804c018:	42a3      	cmp	r3, r4
 804c01a:	d908      	bls.n	804c02e <_free_r+0x42>
 804c01c:	6820      	ldr	r0, [r4, #0]
 804c01e:	1821      	adds	r1, r4, r0
 804c020:	428b      	cmp	r3, r1
 804c022:	bf01      	itttt	eq
 804c024:	6819      	ldreq	r1, [r3, #0]
 804c026:	685b      	ldreq	r3, [r3, #4]
 804c028:	1809      	addeq	r1, r1, r0
 804c02a:	6021      	streq	r1, [r4, #0]
 804c02c:	e7ed      	b.n	804c00a <_free_r+0x1e>
 804c02e:	461a      	mov	r2, r3
 804c030:	685b      	ldr	r3, [r3, #4]
 804c032:	b10b      	cbz	r3, 804c038 <_free_r+0x4c>
 804c034:	42a3      	cmp	r3, r4
 804c036:	d9fa      	bls.n	804c02e <_free_r+0x42>
 804c038:	6811      	ldr	r1, [r2, #0]
 804c03a:	1850      	adds	r0, r2, r1
 804c03c:	42a0      	cmp	r0, r4
 804c03e:	d10b      	bne.n	804c058 <_free_r+0x6c>
 804c040:	6820      	ldr	r0, [r4, #0]
 804c042:	4401      	add	r1, r0
 804c044:	1850      	adds	r0, r2, r1
 804c046:	6011      	str	r1, [r2, #0]
 804c048:	4283      	cmp	r3, r0
 804c04a:	d1e0      	bne.n	804c00e <_free_r+0x22>
 804c04c:	6818      	ldr	r0, [r3, #0]
 804c04e:	685b      	ldr	r3, [r3, #4]
 804c050:	4408      	add	r0, r1
 804c052:	6053      	str	r3, [r2, #4]
 804c054:	6010      	str	r0, [r2, #0]
 804c056:	e7da      	b.n	804c00e <_free_r+0x22>
 804c058:	d902      	bls.n	804c060 <_free_r+0x74>
 804c05a:	230c      	movs	r3, #12
 804c05c:	602b      	str	r3, [r5, #0]
 804c05e:	e7d6      	b.n	804c00e <_free_r+0x22>
 804c060:	6820      	ldr	r0, [r4, #0]
 804c062:	1821      	adds	r1, r4, r0
 804c064:	428b      	cmp	r3, r1
 804c066:	bf02      	ittt	eq
 804c068:	6819      	ldreq	r1, [r3, #0]
 804c06a:	685b      	ldreq	r3, [r3, #4]
 804c06c:	1809      	addeq	r1, r1, r0
 804c06e:	6063      	str	r3, [r4, #4]
 804c070:	bf08      	it	eq
 804c072:	6021      	streq	r1, [r4, #0]
 804c074:	6054      	str	r4, [r2, #4]
 804c076:	e7ca      	b.n	804c00e <_free_r+0x22>
 804c078:	bd38      	pop	{r3, r4, r5, pc}
 804c07a:	bf00      	nop
 804c07c:	20018354 	.word	0x20018354

0804c080 <_malloc_usable_size_r>:
 804c080:	f851 3c04 	ldr.w	r3, [r1, #-4]
 804c084:	1f18      	subs	r0, r3, #4
 804c086:	2b00      	cmp	r3, #0
 804c088:	bfbc      	itt	lt
 804c08a:	580b      	ldrlt	r3, [r1, r0]
 804c08c:	18c0      	addlt	r0, r0, r3
 804c08e:	4770      	bx	lr

0804c090 <__ssputs_r>:
 804c090:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 804c094:	461f      	mov	r7, r3
 804c096:	688e      	ldr	r6, [r1, #8]
 804c098:	4682      	mov	sl, r0
 804c09a:	460c      	mov	r4, r1
 804c09c:	42be      	cmp	r6, r7
 804c09e:	4690      	mov	r8, r2
 804c0a0:	680b      	ldr	r3, [r1, #0]
 804c0a2:	d82d      	bhi.n	804c100 <__ssputs_r+0x70>
 804c0a4:	f9b1 200c 	ldrsh.w	r2, [r1, #12]
 804c0a8:	f412 6f90 	tst.w	r2, #1152	@ 0x480
 804c0ac:	d026      	beq.n	804c0fc <__ssputs_r+0x6c>
 804c0ae:	6965      	ldr	r5, [r4, #20]
 804c0b0:	6909      	ldr	r1, [r1, #16]
 804c0b2:	eb05 0545 	add.w	r5, r5, r5, lsl #1
 804c0b6:	eba3 0901 	sub.w	r9, r3, r1
 804c0ba:	1c7b      	adds	r3, r7, #1
 804c0bc:	eb05 75d5 	add.w	r5, r5, r5, lsr #31
 804c0c0:	444b      	add	r3, r9
 804c0c2:	106d      	asrs	r5, r5, #1
 804c0c4:	429d      	cmp	r5, r3
 804c0c6:	bf38      	it	cc
 804c0c8:	461d      	movcc	r5, r3
 804c0ca:	0553      	lsls	r3, r2, #21
 804c0cc:	d527      	bpl.n	804c11e <__ssputs_r+0x8e>
 804c0ce:	4629      	mov	r1, r5
 804c0d0:	f7ff fbb8 	bl	804b844 <_malloc_r>
 804c0d4:	4606      	mov	r6, r0
 804c0d6:	b360      	cbz	r0, 804c132 <__ssputs_r+0xa2>
 804c0d8:	464a      	mov	r2, r9
 804c0da:	6921      	ldr	r1, [r4, #16]
 804c0dc:	f7ff ff6b 	bl	804bfb6 <memcpy>
 804c0e0:	89a3      	ldrh	r3, [r4, #12]
 804c0e2:	f423 6390 	bic.w	r3, r3, #1152	@ 0x480
 804c0e6:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 804c0ea:	81a3      	strh	r3, [r4, #12]
 804c0ec:	6126      	str	r6, [r4, #16]
 804c0ee:	444e      	add	r6, r9
 804c0f0:	6165      	str	r5, [r4, #20]
 804c0f2:	eba5 0509 	sub.w	r5, r5, r9
 804c0f6:	6026      	str	r6, [r4, #0]
 804c0f8:	463e      	mov	r6, r7
 804c0fa:	60a5      	str	r5, [r4, #8]
 804c0fc:	42be      	cmp	r6, r7
 804c0fe:	d900      	bls.n	804c102 <__ssputs_r+0x72>
 804c100:	463e      	mov	r6, r7
 804c102:	4632      	mov	r2, r6
 804c104:	4641      	mov	r1, r8
 804c106:	6820      	ldr	r0, [r4, #0]
 804c108:	f000 fcfb 	bl	804cb02 <memmove>
 804c10c:	68a3      	ldr	r3, [r4, #8]
 804c10e:	2000      	movs	r0, #0
 804c110:	1b9b      	subs	r3, r3, r6
 804c112:	60a3      	str	r3, [r4, #8]
 804c114:	6823      	ldr	r3, [r4, #0]
 804c116:	4433      	add	r3, r6
 804c118:	6023      	str	r3, [r4, #0]
 804c11a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 804c11e:	462a      	mov	r2, r5
 804c120:	f7ff fc52 	bl	804b9c8 <_realloc_r>
 804c124:	4606      	mov	r6, r0
 804c126:	2800      	cmp	r0, #0
 804c128:	d1e0      	bne.n	804c0ec <__ssputs_r+0x5c>
 804c12a:	6921      	ldr	r1, [r4, #16]
 804c12c:	4650      	mov	r0, sl
 804c12e:	f7ff ff5d 	bl	804bfec <_free_r>
 804c132:	230c      	movs	r3, #12
 804c134:	f04f 30ff 	mov.w	r0, #4294967295
 804c138:	f8ca 3000 	str.w	r3, [sl]
 804c13c:	89a3      	ldrh	r3, [r4, #12]
 804c13e:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 804c142:	81a3      	strh	r3, [r4, #12]
 804c144:	e7e9      	b.n	804c11a <__ssputs_r+0x8a>
	...

0804c148 <_svfiprintf_r>:
 804c148:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 804c14c:	4698      	mov	r8, r3
 804c14e:	898b      	ldrh	r3, [r1, #12]
 804c150:	b09d      	sub	sp, #116	@ 0x74
 804c152:	4607      	mov	r7, r0
 804c154:	061b      	lsls	r3, r3, #24
 804c156:	460d      	mov	r5, r1
 804c158:	4614      	mov	r4, r2
 804c15a:	d510      	bpl.n	804c17e <_svfiprintf_r+0x36>
 804c15c:	690b      	ldr	r3, [r1, #16]
 804c15e:	b973      	cbnz	r3, 804c17e <_svfiprintf_r+0x36>
 804c160:	2140      	movs	r1, #64	@ 0x40
 804c162:	f7ff fb6f 	bl	804b844 <_malloc_r>
 804c166:	6028      	str	r0, [r5, #0]
 804c168:	6128      	str	r0, [r5, #16]
 804c16a:	b930      	cbnz	r0, 804c17a <_svfiprintf_r+0x32>
 804c16c:	230c      	movs	r3, #12
 804c16e:	603b      	str	r3, [r7, #0]
 804c170:	f04f 30ff 	mov.w	r0, #4294967295
 804c174:	b01d      	add	sp, #116	@ 0x74
 804c176:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 804c17a:	2340      	movs	r3, #64	@ 0x40
 804c17c:	616b      	str	r3, [r5, #20]
 804c17e:	2300      	movs	r3, #0
 804c180:	f8cd 800c 	str.w	r8, [sp, #12]
 804c184:	f04f 0901 	mov.w	r9, #1
 804c188:	f8df 81a0 	ldr.w	r8, [pc, #416]	@ 804c32c <_svfiprintf_r+0x1e4>
 804c18c:	9309      	str	r3, [sp, #36]	@ 0x24
 804c18e:	2320      	movs	r3, #32
 804c190:	f88d 3029 	strb.w	r3, [sp, #41]	@ 0x29
 804c194:	2330      	movs	r3, #48	@ 0x30
 804c196:	f88d 302a 	strb.w	r3, [sp, #42]	@ 0x2a
 804c19a:	4623      	mov	r3, r4
 804c19c:	469a      	mov	sl, r3
 804c19e:	f813 2b01 	ldrb.w	r2, [r3], #1
 804c1a2:	b10a      	cbz	r2, 804c1a8 <_svfiprintf_r+0x60>
 804c1a4:	2a25      	cmp	r2, #37	@ 0x25
 804c1a6:	d1f9      	bne.n	804c19c <_svfiprintf_r+0x54>
 804c1a8:	ebba 0b04 	subs.w	fp, sl, r4
 804c1ac:	d00b      	beq.n	804c1c6 <_svfiprintf_r+0x7e>
 804c1ae:	465b      	mov	r3, fp
 804c1b0:	4622      	mov	r2, r4
 804c1b2:	4629      	mov	r1, r5
 804c1b4:	4638      	mov	r0, r7
 804c1b6:	f7ff ff6b 	bl	804c090 <__ssputs_r>
 804c1ba:	3001      	adds	r0, #1
 804c1bc:	f000 80a7 	beq.w	804c30e <_svfiprintf_r+0x1c6>
 804c1c0:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 804c1c2:	445a      	add	r2, fp
 804c1c4:	9209      	str	r2, [sp, #36]	@ 0x24
 804c1c6:	f89a 3000 	ldrb.w	r3, [sl]
 804c1ca:	2b00      	cmp	r3, #0
 804c1cc:	f000 809f 	beq.w	804c30e <_svfiprintf_r+0x1c6>
 804c1d0:	2300      	movs	r3, #0
 804c1d2:	f04f 32ff 	mov.w	r2, #4294967295
 804c1d6:	f10a 0a01 	add.w	sl, sl, #1
 804c1da:	9304      	str	r3, [sp, #16]
 804c1dc:	9307      	str	r3, [sp, #28]
 804c1de:	f88d 3053 	strb.w	r3, [sp, #83]	@ 0x53
 804c1e2:	931a      	str	r3, [sp, #104]	@ 0x68
 804c1e4:	e9cd 2305 	strd	r2, r3, [sp, #20]
 804c1e8:	4654      	mov	r4, sl
 804c1ea:	2205      	movs	r2, #5
 804c1ec:	484f      	ldr	r0, [pc, #316]	@ (804c32c <_svfiprintf_r+0x1e4>)
 804c1ee:	f814 1b01 	ldrb.w	r1, [r4], #1
 804c1f2:	f000 fcc3 	bl	804cb7c <memchr>
 804c1f6:	9a04      	ldr	r2, [sp, #16]
 804c1f8:	b9d8      	cbnz	r0, 804c232 <_svfiprintf_r+0xea>
 804c1fa:	06d0      	lsls	r0, r2, #27
 804c1fc:	bf44      	itt	mi
 804c1fe:	2320      	movmi	r3, #32
 804c200:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
 804c204:	0711      	lsls	r1, r2, #28
 804c206:	bf44      	itt	mi
 804c208:	232b      	movmi	r3, #43	@ 0x2b
 804c20a:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
 804c20e:	f89a 3000 	ldrb.w	r3, [sl]
 804c212:	2b2a      	cmp	r3, #42	@ 0x2a
 804c214:	d015      	beq.n	804c242 <_svfiprintf_r+0xfa>
 804c216:	9a07      	ldr	r2, [sp, #28]
 804c218:	4654      	mov	r4, sl
 804c21a:	2000      	movs	r0, #0
 804c21c:	f04f 0c0a 	mov.w	ip, #10
 804c220:	4621      	mov	r1, r4
 804c222:	f811 3b01 	ldrb.w	r3, [r1], #1
 804c226:	3b30      	subs	r3, #48	@ 0x30
 804c228:	2b09      	cmp	r3, #9
 804c22a:	d94b      	bls.n	804c2c4 <_svfiprintf_r+0x17c>
 804c22c:	b1b0      	cbz	r0, 804c25c <_svfiprintf_r+0x114>
 804c22e:	9207      	str	r2, [sp, #28]
 804c230:	e014      	b.n	804c25c <_svfiprintf_r+0x114>
 804c232:	eba0 0308 	sub.w	r3, r0, r8
 804c236:	46a2      	mov	sl, r4
 804c238:	fa09 f303 	lsl.w	r3, r9, r3
 804c23c:	4313      	orrs	r3, r2
 804c23e:	9304      	str	r3, [sp, #16]
 804c240:	e7d2      	b.n	804c1e8 <_svfiprintf_r+0xa0>
 804c242:	9b03      	ldr	r3, [sp, #12]
 804c244:	1d19      	adds	r1, r3, #4
 804c246:	681b      	ldr	r3, [r3, #0]
 804c248:	2b00      	cmp	r3, #0
 804c24a:	9103      	str	r1, [sp, #12]
 804c24c:	bfbb      	ittet	lt
 804c24e:	425b      	neglt	r3, r3
 804c250:	f042 0202 	orrlt.w	r2, r2, #2
 804c254:	9307      	strge	r3, [sp, #28]
 804c256:	9307      	strlt	r3, [sp, #28]
 804c258:	bfb8      	it	lt
 804c25a:	9204      	strlt	r2, [sp, #16]
 804c25c:	7823      	ldrb	r3, [r4, #0]
 804c25e:	2b2e      	cmp	r3, #46	@ 0x2e
 804c260:	d10a      	bne.n	804c278 <_svfiprintf_r+0x130>
 804c262:	7863      	ldrb	r3, [r4, #1]
 804c264:	2b2a      	cmp	r3, #42	@ 0x2a
 804c266:	d132      	bne.n	804c2ce <_svfiprintf_r+0x186>
 804c268:	9b03      	ldr	r3, [sp, #12]
 804c26a:	3402      	adds	r4, #2
 804c26c:	1d1a      	adds	r2, r3, #4
 804c26e:	681b      	ldr	r3, [r3, #0]
 804c270:	ea43 73e3 	orr.w	r3, r3, r3, asr #31
 804c274:	9203      	str	r2, [sp, #12]
 804c276:	9305      	str	r3, [sp, #20]
 804c278:	f8df a0c0 	ldr.w	sl, [pc, #192]	@ 804c33c <_svfiprintf_r+0x1f4>
 804c27c:	2203      	movs	r2, #3
 804c27e:	7821      	ldrb	r1, [r4, #0]
 804c280:	4650      	mov	r0, sl
 804c282:	f000 fc7b 	bl	804cb7c <memchr>
 804c286:	b138      	cbz	r0, 804c298 <_svfiprintf_r+0x150>
 804c288:	eba0 000a 	sub.w	r0, r0, sl
 804c28c:	2240      	movs	r2, #64	@ 0x40
 804c28e:	9b04      	ldr	r3, [sp, #16]
 804c290:	3401      	adds	r4, #1
 804c292:	4082      	lsls	r2, r0
 804c294:	4313      	orrs	r3, r2
 804c296:	9304      	str	r3, [sp, #16]
 804c298:	f814 1b01 	ldrb.w	r1, [r4], #1
 804c29c:	2206      	movs	r2, #6
 804c29e:	4824      	ldr	r0, [pc, #144]	@ (804c330 <_svfiprintf_r+0x1e8>)
 804c2a0:	f88d 1028 	strb.w	r1, [sp, #40]	@ 0x28
 804c2a4:	f000 fc6a 	bl	804cb7c <memchr>
 804c2a8:	2800      	cmp	r0, #0
 804c2aa:	d036      	beq.n	804c31a <_svfiprintf_r+0x1d2>
 804c2ac:	4b21      	ldr	r3, [pc, #132]	@ (804c334 <_svfiprintf_r+0x1ec>)
 804c2ae:	bb1b      	cbnz	r3, 804c2f8 <_svfiprintf_r+0x1b0>
 804c2b0:	9b03      	ldr	r3, [sp, #12]
 804c2b2:	3307      	adds	r3, #7
 804c2b4:	f023 0307 	bic.w	r3, r3, #7
 804c2b8:	3308      	adds	r3, #8
 804c2ba:	9303      	str	r3, [sp, #12]
 804c2bc:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 804c2be:	4433      	add	r3, r6
 804c2c0:	9309      	str	r3, [sp, #36]	@ 0x24
 804c2c2:	e76a      	b.n	804c19a <_svfiprintf_r+0x52>
 804c2c4:	fb0c 3202 	mla	r2, ip, r2, r3
 804c2c8:	460c      	mov	r4, r1
 804c2ca:	2001      	movs	r0, #1
 804c2cc:	e7a8      	b.n	804c220 <_svfiprintf_r+0xd8>
 804c2ce:	2300      	movs	r3, #0
 804c2d0:	3401      	adds	r4, #1
 804c2d2:	f04f 0c0a 	mov.w	ip, #10
 804c2d6:	4619      	mov	r1, r3
 804c2d8:	9305      	str	r3, [sp, #20]
 804c2da:	4620      	mov	r0, r4
 804c2dc:	f810 2b01 	ldrb.w	r2, [r0], #1
 804c2e0:	3a30      	subs	r2, #48	@ 0x30
 804c2e2:	2a09      	cmp	r2, #9
 804c2e4:	d903      	bls.n	804c2ee <_svfiprintf_r+0x1a6>
 804c2e6:	2b00      	cmp	r3, #0
 804c2e8:	d0c6      	beq.n	804c278 <_svfiprintf_r+0x130>
 804c2ea:	9105      	str	r1, [sp, #20]
 804c2ec:	e7c4      	b.n	804c278 <_svfiprintf_r+0x130>
 804c2ee:	fb0c 2101 	mla	r1, ip, r1, r2
 804c2f2:	4604      	mov	r4, r0
 804c2f4:	2301      	movs	r3, #1
 804c2f6:	e7f0      	b.n	804c2da <_svfiprintf_r+0x192>
 804c2f8:	ab03      	add	r3, sp, #12
 804c2fa:	462a      	mov	r2, r5
 804c2fc:	a904      	add	r1, sp, #16
 804c2fe:	4638      	mov	r0, r7
 804c300:	9300      	str	r3, [sp, #0]
 804c302:	4b0d      	ldr	r3, [pc, #52]	@ (804c338 <_svfiprintf_r+0x1f0>)
 804c304:	f3af 8000 	nop.w
 804c308:	1c42      	adds	r2, r0, #1
 804c30a:	4606      	mov	r6, r0
 804c30c:	d1d6      	bne.n	804c2bc <_svfiprintf_r+0x174>
 804c30e:	89ab      	ldrh	r3, [r5, #12]
 804c310:	065b      	lsls	r3, r3, #25
 804c312:	f53f af2d 	bmi.w	804c170 <_svfiprintf_r+0x28>
 804c316:	9809      	ldr	r0, [sp, #36]	@ 0x24
 804c318:	e72c      	b.n	804c174 <_svfiprintf_r+0x2c>
 804c31a:	ab03      	add	r3, sp, #12
 804c31c:	462a      	mov	r2, r5
 804c31e:	a904      	add	r1, sp, #16
 804c320:	4638      	mov	r0, r7
 804c322:	9300      	str	r3, [sp, #0]
 804c324:	4b04      	ldr	r3, [pc, #16]	@ (804c338 <_svfiprintf_r+0x1f0>)
 804c326:	f000 f9bf 	bl	804c6a8 <_printf_i>
 804c32a:	e7ed      	b.n	804c308 <_svfiprintf_r+0x1c0>
 804c32c:	0804e5f1 	.word	0x0804e5f1
 804c330:	0804e5fb 	.word	0x0804e5fb
 804c334:	00000000 	.word	0x00000000
 804c338:	0804c091 	.word	0x0804c091
 804c33c:	0804e5f7 	.word	0x0804e5f7

0804c340 <__sfputc_r>:
 804c340:	6893      	ldr	r3, [r2, #8]
 804c342:	3b01      	subs	r3, #1
 804c344:	2b00      	cmp	r3, #0
 804c346:	6093      	str	r3, [r2, #8]
 804c348:	b410      	push	{r4}
 804c34a:	da08      	bge.n	804c35e <__sfputc_r+0x1e>
 804c34c:	6994      	ldr	r4, [r2, #24]
 804c34e:	42a3      	cmp	r3, r4
 804c350:	db01      	blt.n	804c356 <__sfputc_r+0x16>
 804c352:	290a      	cmp	r1, #10
 804c354:	d103      	bne.n	804c35e <__sfputc_r+0x1e>
 804c356:	f85d 4b04 	ldr.w	r4, [sp], #4
 804c35a:	f7ff bc9a 	b.w	804bc92 <__swbuf_r>
 804c35e:	6813      	ldr	r3, [r2, #0]
 804c360:	1c58      	adds	r0, r3, #1
 804c362:	6010      	str	r0, [r2, #0]
 804c364:	4608      	mov	r0, r1
 804c366:	7019      	strb	r1, [r3, #0]
 804c368:	f85d 4b04 	ldr.w	r4, [sp], #4
 804c36c:	4770      	bx	lr

0804c36e <__sfputs_r>:
 804c36e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 804c370:	4606      	mov	r6, r0
 804c372:	460f      	mov	r7, r1
 804c374:	4614      	mov	r4, r2
 804c376:	18d5      	adds	r5, r2, r3
 804c378:	42ac      	cmp	r4, r5
 804c37a:	d101      	bne.n	804c380 <__sfputs_r+0x12>
 804c37c:	2000      	movs	r0, #0
 804c37e:	e007      	b.n	804c390 <__sfputs_r+0x22>
 804c380:	463a      	mov	r2, r7
 804c382:	f814 1b01 	ldrb.w	r1, [r4], #1
 804c386:	4630      	mov	r0, r6
 804c388:	f7ff ffda 	bl	804c340 <__sfputc_r>
 804c38c:	1c43      	adds	r3, r0, #1
 804c38e:	d1f3      	bne.n	804c378 <__sfputs_r+0xa>
 804c390:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

0804c394 <_vfiprintf_r>:
 804c394:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 804c398:	460d      	mov	r5, r1
 804c39a:	b09d      	sub	sp, #116	@ 0x74
 804c39c:	4614      	mov	r4, r2
 804c39e:	4698      	mov	r8, r3
 804c3a0:	4606      	mov	r6, r0
 804c3a2:	b118      	cbz	r0, 804c3ac <_vfiprintf_r+0x18>
 804c3a4:	6a03      	ldr	r3, [r0, #32]
 804c3a6:	b90b      	cbnz	r3, 804c3ac <_vfiprintf_r+0x18>
 804c3a8:	f7ff fbc8 	bl	804bb3c <__sinit>
 804c3ac:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
 804c3ae:	07d9      	lsls	r1, r3, #31
 804c3b0:	d405      	bmi.n	804c3be <_vfiprintf_r+0x2a>
 804c3b2:	89ab      	ldrh	r3, [r5, #12]
 804c3b4:	059a      	lsls	r2, r3, #22
 804c3b6:	d402      	bmi.n	804c3be <_vfiprintf_r+0x2a>
 804c3b8:	6da8      	ldr	r0, [r5, #88]	@ 0x58
 804c3ba:	f7ff fdfa 	bl	804bfb2 <__retarget_lock_acquire_recursive>
 804c3be:	89ab      	ldrh	r3, [r5, #12]
 804c3c0:	071b      	lsls	r3, r3, #28
 804c3c2:	d501      	bpl.n	804c3c8 <_vfiprintf_r+0x34>
 804c3c4:	692b      	ldr	r3, [r5, #16]
 804c3c6:	b99b      	cbnz	r3, 804c3f0 <_vfiprintf_r+0x5c>
 804c3c8:	4629      	mov	r1, r5
 804c3ca:	4630      	mov	r0, r6
 804c3cc:	f7ff fca0 	bl	804bd10 <__swsetup_r>
 804c3d0:	b170      	cbz	r0, 804c3f0 <_vfiprintf_r+0x5c>
 804c3d2:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
 804c3d4:	07dc      	lsls	r4, r3, #31
 804c3d6:	d504      	bpl.n	804c3e2 <_vfiprintf_r+0x4e>
 804c3d8:	f04f 30ff 	mov.w	r0, #4294967295
 804c3dc:	b01d      	add	sp, #116	@ 0x74
 804c3de:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 804c3e2:	89ab      	ldrh	r3, [r5, #12]
 804c3e4:	0598      	lsls	r0, r3, #22
 804c3e6:	d4f7      	bmi.n	804c3d8 <_vfiprintf_r+0x44>
 804c3e8:	6da8      	ldr	r0, [r5, #88]	@ 0x58
 804c3ea:	f7ff fde3 	bl	804bfb4 <__retarget_lock_release_recursive>
 804c3ee:	e7f3      	b.n	804c3d8 <_vfiprintf_r+0x44>
 804c3f0:	2300      	movs	r3, #0
 804c3f2:	f8cd 800c 	str.w	r8, [sp, #12]
 804c3f6:	f04f 0901 	mov.w	r9, #1
 804c3fa:	f8df 81b4 	ldr.w	r8, [pc, #436]	@ 804c5b0 <_vfiprintf_r+0x21c>
 804c3fe:	9309      	str	r3, [sp, #36]	@ 0x24
 804c400:	2320      	movs	r3, #32
 804c402:	f88d 3029 	strb.w	r3, [sp, #41]	@ 0x29
 804c406:	2330      	movs	r3, #48	@ 0x30
 804c408:	f88d 302a 	strb.w	r3, [sp, #42]	@ 0x2a
 804c40c:	4623      	mov	r3, r4
 804c40e:	469a      	mov	sl, r3
 804c410:	f813 2b01 	ldrb.w	r2, [r3], #1
 804c414:	b10a      	cbz	r2, 804c41a <_vfiprintf_r+0x86>
 804c416:	2a25      	cmp	r2, #37	@ 0x25
 804c418:	d1f9      	bne.n	804c40e <_vfiprintf_r+0x7a>
 804c41a:	ebba 0b04 	subs.w	fp, sl, r4
 804c41e:	d00b      	beq.n	804c438 <_vfiprintf_r+0xa4>
 804c420:	465b      	mov	r3, fp
 804c422:	4622      	mov	r2, r4
 804c424:	4629      	mov	r1, r5
 804c426:	4630      	mov	r0, r6
 804c428:	f7ff ffa1 	bl	804c36e <__sfputs_r>
 804c42c:	3001      	adds	r0, #1
 804c42e:	f000 80a7 	beq.w	804c580 <_vfiprintf_r+0x1ec>
 804c432:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 804c434:	445a      	add	r2, fp
 804c436:	9209      	str	r2, [sp, #36]	@ 0x24
 804c438:	f89a 3000 	ldrb.w	r3, [sl]
 804c43c:	2b00      	cmp	r3, #0
 804c43e:	f000 809f 	beq.w	804c580 <_vfiprintf_r+0x1ec>
 804c442:	2300      	movs	r3, #0
 804c444:	f04f 32ff 	mov.w	r2, #4294967295
 804c448:	f10a 0a01 	add.w	sl, sl, #1
 804c44c:	9304      	str	r3, [sp, #16]
 804c44e:	9307      	str	r3, [sp, #28]
 804c450:	f88d 3053 	strb.w	r3, [sp, #83]	@ 0x53
 804c454:	931a      	str	r3, [sp, #104]	@ 0x68
 804c456:	e9cd 2305 	strd	r2, r3, [sp, #20]
 804c45a:	4654      	mov	r4, sl
 804c45c:	2205      	movs	r2, #5
 804c45e:	4854      	ldr	r0, [pc, #336]	@ (804c5b0 <_vfiprintf_r+0x21c>)
 804c460:	f814 1b01 	ldrb.w	r1, [r4], #1
 804c464:	f000 fb8a 	bl	804cb7c <memchr>
 804c468:	9a04      	ldr	r2, [sp, #16]
 804c46a:	b9d8      	cbnz	r0, 804c4a4 <_vfiprintf_r+0x110>
 804c46c:	06d1      	lsls	r1, r2, #27
 804c46e:	bf44      	itt	mi
 804c470:	2320      	movmi	r3, #32
 804c472:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
 804c476:	0713      	lsls	r3, r2, #28
 804c478:	bf44      	itt	mi
 804c47a:	232b      	movmi	r3, #43	@ 0x2b
 804c47c:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
 804c480:	f89a 3000 	ldrb.w	r3, [sl]
 804c484:	2b2a      	cmp	r3, #42	@ 0x2a
 804c486:	d015      	beq.n	804c4b4 <_vfiprintf_r+0x120>
 804c488:	9a07      	ldr	r2, [sp, #28]
 804c48a:	4654      	mov	r4, sl
 804c48c:	2000      	movs	r0, #0
 804c48e:	f04f 0c0a 	mov.w	ip, #10
 804c492:	4621      	mov	r1, r4
 804c494:	f811 3b01 	ldrb.w	r3, [r1], #1
 804c498:	3b30      	subs	r3, #48	@ 0x30
 804c49a:	2b09      	cmp	r3, #9
 804c49c:	d94b      	bls.n	804c536 <_vfiprintf_r+0x1a2>
 804c49e:	b1b0      	cbz	r0, 804c4ce <_vfiprintf_r+0x13a>
 804c4a0:	9207      	str	r2, [sp, #28]
 804c4a2:	e014      	b.n	804c4ce <_vfiprintf_r+0x13a>
 804c4a4:	eba0 0308 	sub.w	r3, r0, r8
 804c4a8:	46a2      	mov	sl, r4
 804c4aa:	fa09 f303 	lsl.w	r3, r9, r3
 804c4ae:	4313      	orrs	r3, r2
 804c4b0:	9304      	str	r3, [sp, #16]
 804c4b2:	e7d2      	b.n	804c45a <_vfiprintf_r+0xc6>
 804c4b4:	9b03      	ldr	r3, [sp, #12]
 804c4b6:	1d19      	adds	r1, r3, #4
 804c4b8:	681b      	ldr	r3, [r3, #0]
 804c4ba:	2b00      	cmp	r3, #0
 804c4bc:	9103      	str	r1, [sp, #12]
 804c4be:	bfbb      	ittet	lt
 804c4c0:	425b      	neglt	r3, r3
 804c4c2:	f042 0202 	orrlt.w	r2, r2, #2
 804c4c6:	9307      	strge	r3, [sp, #28]
 804c4c8:	9307      	strlt	r3, [sp, #28]
 804c4ca:	bfb8      	it	lt
 804c4cc:	9204      	strlt	r2, [sp, #16]
 804c4ce:	7823      	ldrb	r3, [r4, #0]
 804c4d0:	2b2e      	cmp	r3, #46	@ 0x2e
 804c4d2:	d10a      	bne.n	804c4ea <_vfiprintf_r+0x156>
 804c4d4:	7863      	ldrb	r3, [r4, #1]
 804c4d6:	2b2a      	cmp	r3, #42	@ 0x2a
 804c4d8:	d132      	bne.n	804c540 <_vfiprintf_r+0x1ac>
 804c4da:	9b03      	ldr	r3, [sp, #12]
 804c4dc:	3402      	adds	r4, #2
 804c4de:	1d1a      	adds	r2, r3, #4
 804c4e0:	681b      	ldr	r3, [r3, #0]
 804c4e2:	ea43 73e3 	orr.w	r3, r3, r3, asr #31
 804c4e6:	9203      	str	r2, [sp, #12]
 804c4e8:	9305      	str	r3, [sp, #20]
 804c4ea:	f8df a0d4 	ldr.w	sl, [pc, #212]	@ 804c5c0 <_vfiprintf_r+0x22c>
 804c4ee:	2203      	movs	r2, #3
 804c4f0:	7821      	ldrb	r1, [r4, #0]
 804c4f2:	4650      	mov	r0, sl
 804c4f4:	f000 fb42 	bl	804cb7c <memchr>
 804c4f8:	b138      	cbz	r0, 804c50a <_vfiprintf_r+0x176>
 804c4fa:	eba0 000a 	sub.w	r0, r0, sl
 804c4fe:	2240      	movs	r2, #64	@ 0x40
 804c500:	9b04      	ldr	r3, [sp, #16]
 804c502:	3401      	adds	r4, #1
 804c504:	4082      	lsls	r2, r0
 804c506:	4313      	orrs	r3, r2
 804c508:	9304      	str	r3, [sp, #16]
 804c50a:	f814 1b01 	ldrb.w	r1, [r4], #1
 804c50e:	2206      	movs	r2, #6
 804c510:	4828      	ldr	r0, [pc, #160]	@ (804c5b4 <_vfiprintf_r+0x220>)
 804c512:	f88d 1028 	strb.w	r1, [sp, #40]	@ 0x28
 804c516:	f000 fb31 	bl	804cb7c <memchr>
 804c51a:	2800      	cmp	r0, #0
 804c51c:	d03f      	beq.n	804c59e <_vfiprintf_r+0x20a>
 804c51e:	4b26      	ldr	r3, [pc, #152]	@ (804c5b8 <_vfiprintf_r+0x224>)
 804c520:	bb1b      	cbnz	r3, 804c56a <_vfiprintf_r+0x1d6>
 804c522:	9b03      	ldr	r3, [sp, #12]
 804c524:	3307      	adds	r3, #7
 804c526:	f023 0307 	bic.w	r3, r3, #7
 804c52a:	3308      	adds	r3, #8
 804c52c:	9303      	str	r3, [sp, #12]
 804c52e:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 804c530:	443b      	add	r3, r7
 804c532:	9309      	str	r3, [sp, #36]	@ 0x24
 804c534:	e76a      	b.n	804c40c <_vfiprintf_r+0x78>
 804c536:	fb0c 3202 	mla	r2, ip, r2, r3
 804c53a:	460c      	mov	r4, r1
 804c53c:	2001      	movs	r0, #1
 804c53e:	e7a8      	b.n	804c492 <_vfiprintf_r+0xfe>
 804c540:	2300      	movs	r3, #0
 804c542:	3401      	adds	r4, #1
 804c544:	f04f 0c0a 	mov.w	ip, #10
 804c548:	4619      	mov	r1, r3
 804c54a:	9305      	str	r3, [sp, #20]
 804c54c:	4620      	mov	r0, r4
 804c54e:	f810 2b01 	ldrb.w	r2, [r0], #1
 804c552:	3a30      	subs	r2, #48	@ 0x30
 804c554:	2a09      	cmp	r2, #9
 804c556:	d903      	bls.n	804c560 <_vfiprintf_r+0x1cc>
 804c558:	2b00      	cmp	r3, #0
 804c55a:	d0c6      	beq.n	804c4ea <_vfiprintf_r+0x156>
 804c55c:	9105      	str	r1, [sp, #20]
 804c55e:	e7c4      	b.n	804c4ea <_vfiprintf_r+0x156>
 804c560:	fb0c 2101 	mla	r1, ip, r1, r2
 804c564:	4604      	mov	r4, r0
 804c566:	2301      	movs	r3, #1
 804c568:	e7f0      	b.n	804c54c <_vfiprintf_r+0x1b8>
 804c56a:	ab03      	add	r3, sp, #12
 804c56c:	462a      	mov	r2, r5
 804c56e:	a904      	add	r1, sp, #16
 804c570:	4630      	mov	r0, r6
 804c572:	9300      	str	r3, [sp, #0]
 804c574:	4b11      	ldr	r3, [pc, #68]	@ (804c5bc <_vfiprintf_r+0x228>)
 804c576:	f3af 8000 	nop.w
 804c57a:	4607      	mov	r7, r0
 804c57c:	1c78      	adds	r0, r7, #1
 804c57e:	d1d6      	bne.n	804c52e <_vfiprintf_r+0x19a>
 804c580:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
 804c582:	07d9      	lsls	r1, r3, #31
 804c584:	d405      	bmi.n	804c592 <_vfiprintf_r+0x1fe>
 804c586:	89ab      	ldrh	r3, [r5, #12]
 804c588:	059a      	lsls	r2, r3, #22
 804c58a:	d402      	bmi.n	804c592 <_vfiprintf_r+0x1fe>
 804c58c:	6da8      	ldr	r0, [r5, #88]	@ 0x58
 804c58e:	f7ff fd11 	bl	804bfb4 <__retarget_lock_release_recursive>
 804c592:	89ab      	ldrh	r3, [r5, #12]
 804c594:	065b      	lsls	r3, r3, #25
 804c596:	f53f af1f 	bmi.w	804c3d8 <_vfiprintf_r+0x44>
 804c59a:	9809      	ldr	r0, [sp, #36]	@ 0x24
 804c59c:	e71e      	b.n	804c3dc <_vfiprintf_r+0x48>
 804c59e:	ab03      	add	r3, sp, #12
 804c5a0:	462a      	mov	r2, r5
 804c5a2:	a904      	add	r1, sp, #16
 804c5a4:	4630      	mov	r0, r6
 804c5a6:	9300      	str	r3, [sp, #0]
 804c5a8:	4b04      	ldr	r3, [pc, #16]	@ (804c5bc <_vfiprintf_r+0x228>)
 804c5aa:	f000 f87d 	bl	804c6a8 <_printf_i>
 804c5ae:	e7e4      	b.n	804c57a <_vfiprintf_r+0x1e6>
 804c5b0:	0804e5f1 	.word	0x0804e5f1
 804c5b4:	0804e5fb 	.word	0x0804e5fb
 804c5b8:	00000000 	.word	0x00000000
 804c5bc:	0804c36f 	.word	0x0804c36f
 804c5c0:	0804e5f7 	.word	0x0804e5f7

0804c5c4 <_printf_common>:
 804c5c4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 804c5c8:	4616      	mov	r6, r2
 804c5ca:	4698      	mov	r8, r3
 804c5cc:	688a      	ldr	r2, [r1, #8]
 804c5ce:	4607      	mov	r7, r0
 804c5d0:	690b      	ldr	r3, [r1, #16]
 804c5d2:	460c      	mov	r4, r1
 804c5d4:	f8dd 9020 	ldr.w	r9, [sp, #32]
 804c5d8:	4293      	cmp	r3, r2
 804c5da:	bfb8      	it	lt
 804c5dc:	4613      	movlt	r3, r2
 804c5de:	6033      	str	r3, [r6, #0]
 804c5e0:	f891 2043 	ldrb.w	r2, [r1, #67]	@ 0x43
 804c5e4:	b10a      	cbz	r2, 804c5ea <_printf_common+0x26>
 804c5e6:	3301      	adds	r3, #1
 804c5e8:	6033      	str	r3, [r6, #0]
 804c5ea:	6823      	ldr	r3, [r4, #0]
 804c5ec:	0699      	lsls	r1, r3, #26
 804c5ee:	bf42      	ittt	mi
 804c5f0:	6833      	ldrmi	r3, [r6, #0]
 804c5f2:	3302      	addmi	r3, #2
 804c5f4:	6033      	strmi	r3, [r6, #0]
 804c5f6:	6825      	ldr	r5, [r4, #0]
 804c5f8:	f015 0506 	ands.w	r5, r5, #6
 804c5fc:	d106      	bne.n	804c60c <_printf_common+0x48>
 804c5fe:	f104 0a19 	add.w	sl, r4, #25
 804c602:	68e3      	ldr	r3, [r4, #12]
 804c604:	6832      	ldr	r2, [r6, #0]
 804c606:	1a9b      	subs	r3, r3, r2
 804c608:	42ab      	cmp	r3, r5
 804c60a:	dc2b      	bgt.n	804c664 <_printf_common+0xa0>
 804c60c:	f894 3043 	ldrb.w	r3, [r4, #67]	@ 0x43
 804c610:	6822      	ldr	r2, [r4, #0]
 804c612:	3b00      	subs	r3, #0
 804c614:	bf18      	it	ne
 804c616:	2301      	movne	r3, #1
 804c618:	0692      	lsls	r2, r2, #26
 804c61a:	d430      	bmi.n	804c67e <_printf_common+0xba>
 804c61c:	f104 0243 	add.w	r2, r4, #67	@ 0x43
 804c620:	4641      	mov	r1, r8
 804c622:	4638      	mov	r0, r7
 804c624:	47c8      	blx	r9
 804c626:	3001      	adds	r0, #1
 804c628:	d023      	beq.n	804c672 <_printf_common+0xae>
 804c62a:	6823      	ldr	r3, [r4, #0]
 804c62c:	341a      	adds	r4, #26
 804c62e:	f854 2c0a 	ldr.w	r2, [r4, #-10]
 804c632:	f003 0306 	and.w	r3, r3, #6
 804c636:	2b04      	cmp	r3, #4
 804c638:	bf0a      	itet	eq
 804c63a:	f854 5c0e 	ldreq.w	r5, [r4, #-14]
 804c63e:	2500      	movne	r5, #0
 804c640:	6833      	ldreq	r3, [r6, #0]
 804c642:	f04f 0600 	mov.w	r6, #0
 804c646:	bf08      	it	eq
 804c648:	1aed      	subeq	r5, r5, r3
 804c64a:	f854 3c12 	ldr.w	r3, [r4, #-18]
 804c64e:	bf08      	it	eq
 804c650:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
 804c654:	4293      	cmp	r3, r2
 804c656:	bfc4      	itt	gt
 804c658:	1a9b      	subgt	r3, r3, r2
 804c65a:	18ed      	addgt	r5, r5, r3
 804c65c:	42b5      	cmp	r5, r6
 804c65e:	d11a      	bne.n	804c696 <_printf_common+0xd2>
 804c660:	2000      	movs	r0, #0
 804c662:	e008      	b.n	804c676 <_printf_common+0xb2>
 804c664:	2301      	movs	r3, #1
 804c666:	4652      	mov	r2, sl
 804c668:	4641      	mov	r1, r8
 804c66a:	4638      	mov	r0, r7
 804c66c:	47c8      	blx	r9
 804c66e:	3001      	adds	r0, #1
 804c670:	d103      	bne.n	804c67a <_printf_common+0xb6>
 804c672:	f04f 30ff 	mov.w	r0, #4294967295
 804c676:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 804c67a:	3501      	adds	r5, #1
 804c67c:	e7c1      	b.n	804c602 <_printf_common+0x3e>
 804c67e:	18e1      	adds	r1, r4, r3
 804c680:	1c5a      	adds	r2, r3, #1
 804c682:	2030      	movs	r0, #48	@ 0x30
 804c684:	3302      	adds	r3, #2
 804c686:	4422      	add	r2, r4
 804c688:	f881 0043 	strb.w	r0, [r1, #67]	@ 0x43
 804c68c:	f894 1045 	ldrb.w	r1, [r4, #69]	@ 0x45
 804c690:	f882 1043 	strb.w	r1, [r2, #67]	@ 0x43
 804c694:	e7c2      	b.n	804c61c <_printf_common+0x58>
 804c696:	2301      	movs	r3, #1
 804c698:	4622      	mov	r2, r4
 804c69a:	4641      	mov	r1, r8
 804c69c:	4638      	mov	r0, r7
 804c69e:	47c8      	blx	r9
 804c6a0:	3001      	adds	r0, #1
 804c6a2:	d0e6      	beq.n	804c672 <_printf_common+0xae>
 804c6a4:	3601      	adds	r6, #1
 804c6a6:	e7d9      	b.n	804c65c <_printf_common+0x98>

0804c6a8 <_printf_i>:
 804c6a8:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 804c6ac:	7e0f      	ldrb	r7, [r1, #24]
 804c6ae:	4691      	mov	r9, r2
 804c6b0:	4680      	mov	r8, r0
 804c6b2:	460c      	mov	r4, r1
 804c6b4:	2f78      	cmp	r7, #120	@ 0x78
 804c6b6:	469a      	mov	sl, r3
 804c6b8:	9e0c      	ldr	r6, [sp, #48]	@ 0x30
 804c6ba:	f101 0243 	add.w	r2, r1, #67	@ 0x43
 804c6be:	d807      	bhi.n	804c6d0 <_printf_i+0x28>
 804c6c0:	2f62      	cmp	r7, #98	@ 0x62
 804c6c2:	d80a      	bhi.n	804c6da <_printf_i+0x32>
 804c6c4:	2f00      	cmp	r7, #0
 804c6c6:	f000 80d2 	beq.w	804c86e <_printf_i+0x1c6>
 804c6ca:	2f58      	cmp	r7, #88	@ 0x58
 804c6cc:	f000 80b9 	beq.w	804c842 <_printf_i+0x19a>
 804c6d0:	f104 0642 	add.w	r6, r4, #66	@ 0x42
 804c6d4:	f884 7042 	strb.w	r7, [r4, #66]	@ 0x42
 804c6d8:	e03a      	b.n	804c750 <_printf_i+0xa8>
 804c6da:	f1a7 0363 	sub.w	r3, r7, #99	@ 0x63
 804c6de:	2b15      	cmp	r3, #21
 804c6e0:	d8f6      	bhi.n	804c6d0 <_printf_i+0x28>
 804c6e2:	a101      	add	r1, pc, #4	@ (adr r1, 804c6e8 <_printf_i+0x40>)
 804c6e4:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
 804c6e8:	0804c741 	.word	0x0804c741
 804c6ec:	0804c755 	.word	0x0804c755
 804c6f0:	0804c6d1 	.word	0x0804c6d1
 804c6f4:	0804c6d1 	.word	0x0804c6d1
 804c6f8:	0804c6d1 	.word	0x0804c6d1
 804c6fc:	0804c6d1 	.word	0x0804c6d1
 804c700:	0804c755 	.word	0x0804c755
 804c704:	0804c6d1 	.word	0x0804c6d1
 804c708:	0804c6d1 	.word	0x0804c6d1
 804c70c:	0804c6d1 	.word	0x0804c6d1
 804c710:	0804c6d1 	.word	0x0804c6d1
 804c714:	0804c855 	.word	0x0804c855
 804c718:	0804c77f 	.word	0x0804c77f
 804c71c:	0804c80f 	.word	0x0804c80f
 804c720:	0804c6d1 	.word	0x0804c6d1
 804c724:	0804c6d1 	.word	0x0804c6d1
 804c728:	0804c877 	.word	0x0804c877
 804c72c:	0804c6d1 	.word	0x0804c6d1
 804c730:	0804c77f 	.word	0x0804c77f
 804c734:	0804c6d1 	.word	0x0804c6d1
 804c738:	0804c6d1 	.word	0x0804c6d1
 804c73c:	0804c817 	.word	0x0804c817
 804c740:	6833      	ldr	r3, [r6, #0]
 804c742:	1d1a      	adds	r2, r3, #4
 804c744:	681b      	ldr	r3, [r3, #0]
 804c746:	6032      	str	r2, [r6, #0]
 804c748:	f104 0642 	add.w	r6, r4, #66	@ 0x42
 804c74c:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
 804c750:	2301      	movs	r3, #1
 804c752:	e09d      	b.n	804c890 <_printf_i+0x1e8>
 804c754:	6833      	ldr	r3, [r6, #0]
 804c756:	6820      	ldr	r0, [r4, #0]
 804c758:	1d19      	adds	r1, r3, #4
 804c75a:	6031      	str	r1, [r6, #0]
 804c75c:	0606      	lsls	r6, r0, #24
 804c75e:	d501      	bpl.n	804c764 <_printf_i+0xbc>
 804c760:	681d      	ldr	r5, [r3, #0]
 804c762:	e003      	b.n	804c76c <_printf_i+0xc4>
 804c764:	0645      	lsls	r5, r0, #25
 804c766:	d5fb      	bpl.n	804c760 <_printf_i+0xb8>
 804c768:	f9b3 5000 	ldrsh.w	r5, [r3]
 804c76c:	2d00      	cmp	r5, #0
 804c76e:	da03      	bge.n	804c778 <_printf_i+0xd0>
 804c770:	232d      	movs	r3, #45	@ 0x2d
 804c772:	426d      	negs	r5, r5
 804c774:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
 804c778:	4859      	ldr	r0, [pc, #356]	@ (804c8e0 <_printf_i+0x238>)
 804c77a:	230a      	movs	r3, #10
 804c77c:	e011      	b.n	804c7a2 <_printf_i+0xfa>
 804c77e:	6821      	ldr	r1, [r4, #0]
 804c780:	6833      	ldr	r3, [r6, #0]
 804c782:	0608      	lsls	r0, r1, #24
 804c784:	f853 5b04 	ldr.w	r5, [r3], #4
 804c788:	d402      	bmi.n	804c790 <_printf_i+0xe8>
 804c78a:	0649      	lsls	r1, r1, #25
 804c78c:	bf48      	it	mi
 804c78e:	b2ad      	uxthmi	r5, r5
 804c790:	2f6f      	cmp	r7, #111	@ 0x6f
 804c792:	6033      	str	r3, [r6, #0]
 804c794:	4852      	ldr	r0, [pc, #328]	@ (804c8e0 <_printf_i+0x238>)
 804c796:	bf14      	ite	ne
 804c798:	230a      	movne	r3, #10
 804c79a:	2308      	moveq	r3, #8
 804c79c:	2100      	movs	r1, #0
 804c79e:	f884 1043 	strb.w	r1, [r4, #67]	@ 0x43
 804c7a2:	6866      	ldr	r6, [r4, #4]
 804c7a4:	2e00      	cmp	r6, #0
 804c7a6:	60a6      	str	r6, [r4, #8]
 804c7a8:	bfa2      	ittt	ge
 804c7aa:	6821      	ldrge	r1, [r4, #0]
 804c7ac:	f021 0104 	bicge.w	r1, r1, #4
 804c7b0:	6021      	strge	r1, [r4, #0]
 804c7b2:	b90d      	cbnz	r5, 804c7b8 <_printf_i+0x110>
 804c7b4:	2e00      	cmp	r6, #0
 804c7b6:	d04b      	beq.n	804c850 <_printf_i+0x1a8>
 804c7b8:	4616      	mov	r6, r2
 804c7ba:	fbb5 f1f3 	udiv	r1, r5, r3
 804c7be:	fb03 5711 	mls	r7, r3, r1, r5
 804c7c2:	5dc7      	ldrb	r7, [r0, r7]
 804c7c4:	f806 7d01 	strb.w	r7, [r6, #-1]!
 804c7c8:	462f      	mov	r7, r5
 804c7ca:	460d      	mov	r5, r1
 804c7cc:	42bb      	cmp	r3, r7
 804c7ce:	d9f4      	bls.n	804c7ba <_printf_i+0x112>
 804c7d0:	2b08      	cmp	r3, #8
 804c7d2:	d10b      	bne.n	804c7ec <_printf_i+0x144>
 804c7d4:	6823      	ldr	r3, [r4, #0]
 804c7d6:	07df      	lsls	r7, r3, #31
 804c7d8:	d508      	bpl.n	804c7ec <_printf_i+0x144>
 804c7da:	6923      	ldr	r3, [r4, #16]
 804c7dc:	6861      	ldr	r1, [r4, #4]
 804c7de:	4299      	cmp	r1, r3
 804c7e0:	bfde      	ittt	le
 804c7e2:	2330      	movle	r3, #48	@ 0x30
 804c7e4:	f806 3c01 	strble.w	r3, [r6, #-1]
 804c7e8:	f106 36ff 	addle.w	r6, r6, #4294967295
 804c7ec:	1b92      	subs	r2, r2, r6
 804c7ee:	6122      	str	r2, [r4, #16]
 804c7f0:	464b      	mov	r3, r9
 804c7f2:	aa03      	add	r2, sp, #12
 804c7f4:	4621      	mov	r1, r4
 804c7f6:	4640      	mov	r0, r8
 804c7f8:	f8cd a000 	str.w	sl, [sp]
 804c7fc:	f7ff fee2 	bl	804c5c4 <_printf_common>
 804c800:	3001      	adds	r0, #1
 804c802:	d14a      	bne.n	804c89a <_printf_i+0x1f2>
 804c804:	f04f 30ff 	mov.w	r0, #4294967295
 804c808:	b004      	add	sp, #16
 804c80a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 804c80e:	6823      	ldr	r3, [r4, #0]
 804c810:	f043 0320 	orr.w	r3, r3, #32
 804c814:	6023      	str	r3, [r4, #0]
 804c816:	2778      	movs	r7, #120	@ 0x78
 804c818:	4832      	ldr	r0, [pc, #200]	@ (804c8e4 <_printf_i+0x23c>)
 804c81a:	6823      	ldr	r3, [r4, #0]
 804c81c:	f884 7045 	strb.w	r7, [r4, #69]	@ 0x45
 804c820:	061f      	lsls	r7, r3, #24
 804c822:	6831      	ldr	r1, [r6, #0]
 804c824:	f851 5b04 	ldr.w	r5, [r1], #4
 804c828:	d402      	bmi.n	804c830 <_printf_i+0x188>
 804c82a:	065f      	lsls	r7, r3, #25
 804c82c:	bf48      	it	mi
 804c82e:	b2ad      	uxthmi	r5, r5
 804c830:	6031      	str	r1, [r6, #0]
 804c832:	07d9      	lsls	r1, r3, #31
 804c834:	bf44      	itt	mi
 804c836:	f043 0320 	orrmi.w	r3, r3, #32
 804c83a:	6023      	strmi	r3, [r4, #0]
 804c83c:	b11d      	cbz	r5, 804c846 <_printf_i+0x19e>
 804c83e:	2310      	movs	r3, #16
 804c840:	e7ac      	b.n	804c79c <_printf_i+0xf4>
 804c842:	4827      	ldr	r0, [pc, #156]	@ (804c8e0 <_printf_i+0x238>)
 804c844:	e7e9      	b.n	804c81a <_printf_i+0x172>
 804c846:	6823      	ldr	r3, [r4, #0]
 804c848:	f023 0320 	bic.w	r3, r3, #32
 804c84c:	6023      	str	r3, [r4, #0]
 804c84e:	e7f6      	b.n	804c83e <_printf_i+0x196>
 804c850:	4616      	mov	r6, r2
 804c852:	e7bd      	b.n	804c7d0 <_printf_i+0x128>
 804c854:	6833      	ldr	r3, [r6, #0]
 804c856:	6825      	ldr	r5, [r4, #0]
 804c858:	1d18      	adds	r0, r3, #4
 804c85a:	6961      	ldr	r1, [r4, #20]
 804c85c:	6030      	str	r0, [r6, #0]
 804c85e:	062e      	lsls	r6, r5, #24
 804c860:	681b      	ldr	r3, [r3, #0]
 804c862:	d501      	bpl.n	804c868 <_printf_i+0x1c0>
 804c864:	6019      	str	r1, [r3, #0]
 804c866:	e002      	b.n	804c86e <_printf_i+0x1c6>
 804c868:	0668      	lsls	r0, r5, #25
 804c86a:	d5fb      	bpl.n	804c864 <_printf_i+0x1bc>
 804c86c:	8019      	strh	r1, [r3, #0]
 804c86e:	2300      	movs	r3, #0
 804c870:	4616      	mov	r6, r2
 804c872:	6123      	str	r3, [r4, #16]
 804c874:	e7bc      	b.n	804c7f0 <_printf_i+0x148>
 804c876:	6833      	ldr	r3, [r6, #0]
 804c878:	2100      	movs	r1, #0
 804c87a:	1d1a      	adds	r2, r3, #4
 804c87c:	6032      	str	r2, [r6, #0]
 804c87e:	681e      	ldr	r6, [r3, #0]
 804c880:	6862      	ldr	r2, [r4, #4]
 804c882:	4630      	mov	r0, r6
 804c884:	f000 f97a 	bl	804cb7c <memchr>
 804c888:	b108      	cbz	r0, 804c88e <_printf_i+0x1e6>
 804c88a:	1b80      	subs	r0, r0, r6
 804c88c:	6060      	str	r0, [r4, #4]
 804c88e:	6863      	ldr	r3, [r4, #4]
 804c890:	6123      	str	r3, [r4, #16]
 804c892:	2300      	movs	r3, #0
 804c894:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
 804c898:	e7aa      	b.n	804c7f0 <_printf_i+0x148>
 804c89a:	6923      	ldr	r3, [r4, #16]
 804c89c:	4632      	mov	r2, r6
 804c89e:	4649      	mov	r1, r9
 804c8a0:	4640      	mov	r0, r8
 804c8a2:	47d0      	blx	sl
 804c8a4:	3001      	adds	r0, #1
 804c8a6:	d0ad      	beq.n	804c804 <_printf_i+0x15c>
 804c8a8:	6823      	ldr	r3, [r4, #0]
 804c8aa:	079b      	lsls	r3, r3, #30
 804c8ac:	d413      	bmi.n	804c8d6 <_printf_i+0x22e>
 804c8ae:	68e0      	ldr	r0, [r4, #12]
 804c8b0:	9b03      	ldr	r3, [sp, #12]
 804c8b2:	4298      	cmp	r0, r3
 804c8b4:	bfb8      	it	lt
 804c8b6:	4618      	movlt	r0, r3
 804c8b8:	e7a6      	b.n	804c808 <_printf_i+0x160>
 804c8ba:	2301      	movs	r3, #1
 804c8bc:	4632      	mov	r2, r6
 804c8be:	4649      	mov	r1, r9
 804c8c0:	4640      	mov	r0, r8
 804c8c2:	47d0      	blx	sl
 804c8c4:	3001      	adds	r0, #1
 804c8c6:	d09d      	beq.n	804c804 <_printf_i+0x15c>
 804c8c8:	3501      	adds	r5, #1
 804c8ca:	68e3      	ldr	r3, [r4, #12]
 804c8cc:	9903      	ldr	r1, [sp, #12]
 804c8ce:	1a5b      	subs	r3, r3, r1
 804c8d0:	42ab      	cmp	r3, r5
 804c8d2:	dcf2      	bgt.n	804c8ba <_printf_i+0x212>
 804c8d4:	e7eb      	b.n	804c8ae <_printf_i+0x206>
 804c8d6:	2500      	movs	r5, #0
 804c8d8:	f104 0619 	add.w	r6, r4, #25
 804c8dc:	e7f5      	b.n	804c8ca <_printf_i+0x222>
 804c8de:	bf00      	nop
 804c8e0:	0804e602 	.word	0x0804e602
 804c8e4:	0804e613 	.word	0x0804e613

0804c8e8 <__sflush_r>:
 804c8e8:	f9b1 200c 	ldrsh.w	r2, [r1, #12]
 804c8ec:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 804c8f0:	0716      	lsls	r6, r2, #28
 804c8f2:	4605      	mov	r5, r0
 804c8f4:	460c      	mov	r4, r1
 804c8f6:	d454      	bmi.n	804c9a2 <__sflush_r+0xba>
 804c8f8:	684b      	ldr	r3, [r1, #4]
 804c8fa:	2b00      	cmp	r3, #0
 804c8fc:	dc02      	bgt.n	804c904 <__sflush_r+0x1c>
 804c8fe:	6c0b      	ldr	r3, [r1, #64]	@ 0x40
 804c900:	2b00      	cmp	r3, #0
 804c902:	dd48      	ble.n	804c996 <__sflush_r+0xae>
 804c904:	6ae6      	ldr	r6, [r4, #44]	@ 0x2c
 804c906:	2e00      	cmp	r6, #0
 804c908:	d045      	beq.n	804c996 <__sflush_r+0xae>
 804c90a:	2300      	movs	r3, #0
 804c90c:	f412 5280 	ands.w	r2, r2, #4096	@ 0x1000
 804c910:	682f      	ldr	r7, [r5, #0]
 804c912:	6a21      	ldr	r1, [r4, #32]
 804c914:	602b      	str	r3, [r5, #0]
 804c916:	d030      	beq.n	804c97a <__sflush_r+0x92>
 804c918:	6d62      	ldr	r2, [r4, #84]	@ 0x54
 804c91a:	89a3      	ldrh	r3, [r4, #12]
 804c91c:	0759      	lsls	r1, r3, #29
 804c91e:	d505      	bpl.n	804c92c <__sflush_r+0x44>
 804c920:	6863      	ldr	r3, [r4, #4]
 804c922:	1ad2      	subs	r2, r2, r3
 804c924:	6b63      	ldr	r3, [r4, #52]	@ 0x34
 804c926:	b10b      	cbz	r3, 804c92c <__sflush_r+0x44>
 804c928:	6c23      	ldr	r3, [r4, #64]	@ 0x40
 804c92a:	1ad2      	subs	r2, r2, r3
 804c92c:	2300      	movs	r3, #0
 804c92e:	6ae6      	ldr	r6, [r4, #44]	@ 0x2c
 804c930:	6a21      	ldr	r1, [r4, #32]
 804c932:	4628      	mov	r0, r5
 804c934:	47b0      	blx	r6
 804c936:	1c43      	adds	r3, r0, #1
 804c938:	89a3      	ldrh	r3, [r4, #12]
 804c93a:	d106      	bne.n	804c94a <__sflush_r+0x62>
 804c93c:	6829      	ldr	r1, [r5, #0]
 804c93e:	291d      	cmp	r1, #29
 804c940:	d82b      	bhi.n	804c99a <__sflush_r+0xb2>
 804c942:	4a2a      	ldr	r2, [pc, #168]	@ (804c9ec <__sflush_r+0x104>)
 804c944:	410a      	asrs	r2, r1
 804c946:	07d6      	lsls	r6, r2, #31
 804c948:	d427      	bmi.n	804c99a <__sflush_r+0xb2>
 804c94a:	2200      	movs	r2, #0
 804c94c:	04d9      	lsls	r1, r3, #19
 804c94e:	6062      	str	r2, [r4, #4]
 804c950:	6922      	ldr	r2, [r4, #16]
 804c952:	6022      	str	r2, [r4, #0]
 804c954:	d504      	bpl.n	804c960 <__sflush_r+0x78>
 804c956:	1c42      	adds	r2, r0, #1
 804c958:	d101      	bne.n	804c95e <__sflush_r+0x76>
 804c95a:	682b      	ldr	r3, [r5, #0]
 804c95c:	b903      	cbnz	r3, 804c960 <__sflush_r+0x78>
 804c95e:	6560      	str	r0, [r4, #84]	@ 0x54
 804c960:	6b61      	ldr	r1, [r4, #52]	@ 0x34
 804c962:	602f      	str	r7, [r5, #0]
 804c964:	b1b9      	cbz	r1, 804c996 <__sflush_r+0xae>
 804c966:	f104 0344 	add.w	r3, r4, #68	@ 0x44
 804c96a:	4299      	cmp	r1, r3
 804c96c:	d002      	beq.n	804c974 <__sflush_r+0x8c>
 804c96e:	4628      	mov	r0, r5
 804c970:	f7ff fb3c 	bl	804bfec <_free_r>
 804c974:	2300      	movs	r3, #0
 804c976:	6363      	str	r3, [r4, #52]	@ 0x34
 804c978:	e00d      	b.n	804c996 <__sflush_r+0xae>
 804c97a:	2301      	movs	r3, #1
 804c97c:	4628      	mov	r0, r5
 804c97e:	47b0      	blx	r6
 804c980:	4602      	mov	r2, r0
 804c982:	1c50      	adds	r0, r2, #1
 804c984:	d1c9      	bne.n	804c91a <__sflush_r+0x32>
 804c986:	682b      	ldr	r3, [r5, #0]
 804c988:	2b00      	cmp	r3, #0
 804c98a:	d0c6      	beq.n	804c91a <__sflush_r+0x32>
 804c98c:	2b1d      	cmp	r3, #29
 804c98e:	d001      	beq.n	804c994 <__sflush_r+0xac>
 804c990:	2b16      	cmp	r3, #22
 804c992:	d11d      	bne.n	804c9d0 <__sflush_r+0xe8>
 804c994:	602f      	str	r7, [r5, #0]
 804c996:	2000      	movs	r0, #0
 804c998:	e021      	b.n	804c9de <__sflush_r+0xf6>
 804c99a:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 804c99e:	b21b      	sxth	r3, r3
 804c9a0:	e01a      	b.n	804c9d8 <__sflush_r+0xf0>
 804c9a2:	690f      	ldr	r7, [r1, #16]
 804c9a4:	2f00      	cmp	r7, #0
 804c9a6:	d0f6      	beq.n	804c996 <__sflush_r+0xae>
 804c9a8:	0793      	lsls	r3, r2, #30
 804c9aa:	680e      	ldr	r6, [r1, #0]
 804c9ac:	600f      	str	r7, [r1, #0]
 804c9ae:	bf0c      	ite	eq
 804c9b0:	694b      	ldreq	r3, [r1, #20]
 804c9b2:	2300      	movne	r3, #0
 804c9b4:	eba6 0807 	sub.w	r8, r6, r7
 804c9b8:	608b      	str	r3, [r1, #8]
 804c9ba:	f1b8 0f00 	cmp.w	r8, #0
 804c9be:	ddea      	ble.n	804c996 <__sflush_r+0xae>
 804c9c0:	4643      	mov	r3, r8
 804c9c2:	463a      	mov	r2, r7
 804c9c4:	6a21      	ldr	r1, [r4, #32]
 804c9c6:	4628      	mov	r0, r5
 804c9c8:	6aa6      	ldr	r6, [r4, #40]	@ 0x28
 804c9ca:	47b0      	blx	r6
 804c9cc:	2800      	cmp	r0, #0
 804c9ce:	dc08      	bgt.n	804c9e2 <__sflush_r+0xfa>
 804c9d0:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 804c9d4:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 804c9d8:	f04f 30ff 	mov.w	r0, #4294967295
 804c9dc:	81a3      	strh	r3, [r4, #12]
 804c9de:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 804c9e2:	4407      	add	r7, r0
 804c9e4:	eba8 0800 	sub.w	r8, r8, r0
 804c9e8:	e7e7      	b.n	804c9ba <__sflush_r+0xd2>
 804c9ea:	bf00      	nop
 804c9ec:	dfbffffe 	.word	0xdfbffffe

0804c9f0 <_fflush_r>:
 804c9f0:	b538      	push	{r3, r4, r5, lr}
 804c9f2:	690b      	ldr	r3, [r1, #16]
 804c9f4:	4605      	mov	r5, r0
 804c9f6:	460c      	mov	r4, r1
 804c9f8:	b913      	cbnz	r3, 804ca00 <_fflush_r+0x10>
 804c9fa:	2500      	movs	r5, #0
 804c9fc:	4628      	mov	r0, r5
 804c9fe:	bd38      	pop	{r3, r4, r5, pc}
 804ca00:	b118      	cbz	r0, 804ca0a <_fflush_r+0x1a>
 804ca02:	6a03      	ldr	r3, [r0, #32]
 804ca04:	b90b      	cbnz	r3, 804ca0a <_fflush_r+0x1a>
 804ca06:	f7ff f899 	bl	804bb3c <__sinit>
 804ca0a:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 804ca0e:	2b00      	cmp	r3, #0
 804ca10:	d0f3      	beq.n	804c9fa <_fflush_r+0xa>
 804ca12:	6e62      	ldr	r2, [r4, #100]	@ 0x64
 804ca14:	07d0      	lsls	r0, r2, #31
 804ca16:	d404      	bmi.n	804ca22 <_fflush_r+0x32>
 804ca18:	0599      	lsls	r1, r3, #22
 804ca1a:	d402      	bmi.n	804ca22 <_fflush_r+0x32>
 804ca1c:	6da0      	ldr	r0, [r4, #88]	@ 0x58
 804ca1e:	f7ff fac8 	bl	804bfb2 <__retarget_lock_acquire_recursive>
 804ca22:	4628      	mov	r0, r5
 804ca24:	4621      	mov	r1, r4
 804ca26:	f7ff ff5f 	bl	804c8e8 <__sflush_r>
 804ca2a:	6e63      	ldr	r3, [r4, #100]	@ 0x64
 804ca2c:	4605      	mov	r5, r0
 804ca2e:	07da      	lsls	r2, r3, #31
 804ca30:	d4e4      	bmi.n	804c9fc <_fflush_r+0xc>
 804ca32:	89a3      	ldrh	r3, [r4, #12]
 804ca34:	059b      	lsls	r3, r3, #22
 804ca36:	d4e1      	bmi.n	804c9fc <_fflush_r+0xc>
 804ca38:	6da0      	ldr	r0, [r4, #88]	@ 0x58
 804ca3a:	f7ff fabb 	bl	804bfb4 <__retarget_lock_release_recursive>
 804ca3e:	e7dd      	b.n	804c9fc <_fflush_r+0xc>

0804ca40 <__swhatbuf_r>:
 804ca40:	b570      	push	{r4, r5, r6, lr}
 804ca42:	460c      	mov	r4, r1
 804ca44:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 804ca48:	b096      	sub	sp, #88	@ 0x58
 804ca4a:	4615      	mov	r5, r2
 804ca4c:	2900      	cmp	r1, #0
 804ca4e:	461e      	mov	r6, r3
 804ca50:	da0c      	bge.n	804ca6c <__swhatbuf_r+0x2c>
 804ca52:	89a3      	ldrh	r3, [r4, #12]
 804ca54:	2100      	movs	r1, #0
 804ca56:	f013 0f80 	tst.w	r3, #128	@ 0x80
 804ca5a:	bf14      	ite	ne
 804ca5c:	2340      	movne	r3, #64	@ 0x40
 804ca5e:	f44f 6380 	moveq.w	r3, #1024	@ 0x400
 804ca62:	2000      	movs	r0, #0
 804ca64:	6031      	str	r1, [r6, #0]
 804ca66:	602b      	str	r3, [r5, #0]
 804ca68:	b016      	add	sp, #88	@ 0x58
 804ca6a:	bd70      	pop	{r4, r5, r6, pc}
 804ca6c:	466a      	mov	r2, sp
 804ca6e:	f000 f863 	bl	804cb38 <_fstat_r>
 804ca72:	2800      	cmp	r0, #0
 804ca74:	dbed      	blt.n	804ca52 <__swhatbuf_r+0x12>
 804ca76:	9901      	ldr	r1, [sp, #4]
 804ca78:	f401 4170 	and.w	r1, r1, #61440	@ 0xf000
 804ca7c:	f5a1 5300 	sub.w	r3, r1, #8192	@ 0x2000
 804ca80:	4259      	negs	r1, r3
 804ca82:	4159      	adcs	r1, r3
 804ca84:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 804ca88:	e7eb      	b.n	804ca62 <__swhatbuf_r+0x22>

0804ca8a <__smakebuf_r>:
 804ca8a:	898b      	ldrh	r3, [r1, #12]
 804ca8c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 804ca8e:	079d      	lsls	r5, r3, #30
 804ca90:	4606      	mov	r6, r0
 804ca92:	460c      	mov	r4, r1
 804ca94:	d507      	bpl.n	804caa6 <__smakebuf_r+0x1c>
 804ca96:	f104 0347 	add.w	r3, r4, #71	@ 0x47
 804ca9a:	6023      	str	r3, [r4, #0]
 804ca9c:	6123      	str	r3, [r4, #16]
 804ca9e:	2301      	movs	r3, #1
 804caa0:	6163      	str	r3, [r4, #20]
 804caa2:	b003      	add	sp, #12
 804caa4:	bdf0      	pop	{r4, r5, r6, r7, pc}
 804caa6:	ab01      	add	r3, sp, #4
 804caa8:	466a      	mov	r2, sp
 804caaa:	f7ff ffc9 	bl	804ca40 <__swhatbuf_r>
 804caae:	9f00      	ldr	r7, [sp, #0]
 804cab0:	4605      	mov	r5, r0
 804cab2:	4630      	mov	r0, r6
 804cab4:	4639      	mov	r1, r7
 804cab6:	f7fe fec5 	bl	804b844 <_malloc_r>
 804caba:	b948      	cbnz	r0, 804cad0 <__smakebuf_r+0x46>
 804cabc:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 804cac0:	059a      	lsls	r2, r3, #22
 804cac2:	d4ee      	bmi.n	804caa2 <__smakebuf_r+0x18>
 804cac4:	f023 0303 	bic.w	r3, r3, #3
 804cac8:	f043 0302 	orr.w	r3, r3, #2
 804cacc:	81a3      	strh	r3, [r4, #12]
 804cace:	e7e2      	b.n	804ca96 <__smakebuf_r+0xc>
 804cad0:	89a3      	ldrh	r3, [r4, #12]
 804cad2:	6020      	str	r0, [r4, #0]
 804cad4:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 804cad8:	81a3      	strh	r3, [r4, #12]
 804cada:	9b01      	ldr	r3, [sp, #4]
 804cadc:	e9c4 0704 	strd	r0, r7, [r4, #16]
 804cae0:	b15b      	cbz	r3, 804cafa <__smakebuf_r+0x70>
 804cae2:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 804cae6:	4630      	mov	r0, r6
 804cae8:	f000 f838 	bl	804cb5c <_isatty_r>
 804caec:	b128      	cbz	r0, 804cafa <__smakebuf_r+0x70>
 804caee:	89a3      	ldrh	r3, [r4, #12]
 804caf0:	f023 0303 	bic.w	r3, r3, #3
 804caf4:	f043 0301 	orr.w	r3, r3, #1
 804caf8:	81a3      	strh	r3, [r4, #12]
 804cafa:	89a3      	ldrh	r3, [r4, #12]
 804cafc:	431d      	orrs	r5, r3
 804cafe:	81a5      	strh	r5, [r4, #12]
 804cb00:	e7cf      	b.n	804caa2 <__smakebuf_r+0x18>

0804cb02 <memmove>:
 804cb02:	4288      	cmp	r0, r1
 804cb04:	b510      	push	{r4, lr}
 804cb06:	eb01 0402 	add.w	r4, r1, r2
 804cb0a:	d902      	bls.n	804cb12 <memmove+0x10>
 804cb0c:	4284      	cmp	r4, r0
 804cb0e:	4623      	mov	r3, r4
 804cb10:	d807      	bhi.n	804cb22 <memmove+0x20>
 804cb12:	1e43      	subs	r3, r0, #1
 804cb14:	42a1      	cmp	r1, r4
 804cb16:	d008      	beq.n	804cb2a <memmove+0x28>
 804cb18:	f811 2b01 	ldrb.w	r2, [r1], #1
 804cb1c:	f803 2f01 	strb.w	r2, [r3, #1]!
 804cb20:	e7f8      	b.n	804cb14 <memmove+0x12>
 804cb22:	4402      	add	r2, r0
 804cb24:	4601      	mov	r1, r0
 804cb26:	428a      	cmp	r2, r1
 804cb28:	d100      	bne.n	804cb2c <memmove+0x2a>
 804cb2a:	bd10      	pop	{r4, pc}
 804cb2c:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
 804cb30:	f802 4d01 	strb.w	r4, [r2, #-1]!
 804cb34:	e7f7      	b.n	804cb26 <memmove+0x24>
	...

0804cb38 <_fstat_r>:
 804cb38:	b538      	push	{r3, r4, r5, lr}
 804cb3a:	2300      	movs	r3, #0
 804cb3c:	4d06      	ldr	r5, [pc, #24]	@ (804cb58 <_fstat_r+0x20>)
 804cb3e:	4604      	mov	r4, r0
 804cb40:	4608      	mov	r0, r1
 804cb42:	4611      	mov	r1, r2
 804cb44:	602b      	str	r3, [r5, #0]
 804cb46:	f7f4 fba5 	bl	8041294 <_fstat>
 804cb4a:	1c43      	adds	r3, r0, #1
 804cb4c:	d102      	bne.n	804cb54 <_fstat_r+0x1c>
 804cb4e:	682b      	ldr	r3, [r5, #0]
 804cb50:	b103      	cbz	r3, 804cb54 <_fstat_r+0x1c>
 804cb52:	6023      	str	r3, [r4, #0]
 804cb54:	bd38      	pop	{r3, r4, r5, pc}
 804cb56:	bf00      	nop
 804cb58:	20018494 	.word	0x20018494

0804cb5c <_isatty_r>:
 804cb5c:	b538      	push	{r3, r4, r5, lr}
 804cb5e:	2300      	movs	r3, #0
 804cb60:	4d05      	ldr	r5, [pc, #20]	@ (804cb78 <_isatty_r+0x1c>)
 804cb62:	4604      	mov	r4, r0
 804cb64:	4608      	mov	r0, r1
 804cb66:	602b      	str	r3, [r5, #0]
 804cb68:	f7f4 fb9a 	bl	80412a0 <_isatty>
 804cb6c:	1c43      	adds	r3, r0, #1
 804cb6e:	d102      	bne.n	804cb76 <_isatty_r+0x1a>
 804cb70:	682b      	ldr	r3, [r5, #0]
 804cb72:	b103      	cbz	r3, 804cb76 <_isatty_r+0x1a>
 804cb74:	6023      	str	r3, [r4, #0]
 804cb76:	bd38      	pop	{r3, r4, r5, pc}
 804cb78:	20018494 	.word	0x20018494

0804cb7c <memchr>:
 804cb7c:	b2c9      	uxtb	r1, r1
 804cb7e:	4603      	mov	r3, r0
 804cb80:	4402      	add	r2, r0
 804cb82:	b510      	push	{r4, lr}
 804cb84:	4293      	cmp	r3, r2
 804cb86:	4618      	mov	r0, r3
 804cb88:	d101      	bne.n	804cb8e <memchr+0x12>
 804cb8a:	2000      	movs	r0, #0
 804cb8c:	e003      	b.n	804cb96 <memchr+0x1a>
 804cb8e:	7804      	ldrb	r4, [r0, #0]
 804cb90:	3301      	adds	r3, #1
 804cb92:	428c      	cmp	r4, r1
 804cb94:	d1f6      	bne.n	804cb84 <memchr+0x8>
 804cb96:	bd10      	pop	{r4, pc}

0804cb98 <log>:
 804cb98:	b538      	push	{r3, r4, r5, lr}
 804cb9a:	ec55 4b10 	vmov	r4, r5, d0
 804cb9e:	ed2d 8b02 	vpush	{d8}
 804cba2:	f000 fa5d 	bl	804d060 <__ieee754_log>
 804cba6:	4622      	mov	r2, r4
 804cba8:	462b      	mov	r3, r5
 804cbaa:	4620      	mov	r0, r4
 804cbac:	4629      	mov	r1, r5
 804cbae:	eeb0 8a40 	vmov.f32	s16, s0
 804cbb2:	eef0 8a60 	vmov.f32	s17, s1
 804cbb6:	f7f3 ff95 	bl	8040ae4 <__aeabi_dcmpun>
 804cbba:	b998      	cbnz	r0, 804cbe4 <log+0x4c>
 804cbbc:	2200      	movs	r2, #0
 804cbbe:	2300      	movs	r3, #0
 804cbc0:	4620      	mov	r0, r4
 804cbc2:	4629      	mov	r1, r5
 804cbc4:	f7f3 ff84 	bl	8040ad0 <__aeabi_dcmpgt>
 804cbc8:	b960      	cbnz	r0, 804cbe4 <log+0x4c>
 804cbca:	2200      	movs	r2, #0
 804cbcc:	2300      	movs	r3, #0
 804cbce:	4620      	mov	r0, r4
 804cbd0:	4629      	mov	r1, r5
 804cbd2:	f7f3 ff55 	bl	8040a80 <__aeabi_dcmpeq>
 804cbd6:	b160      	cbz	r0, 804cbf2 <log+0x5a>
 804cbd8:	f7ff f9c0 	bl	804bf5c <__errno>
 804cbdc:	2322      	movs	r3, #34	@ 0x22
 804cbde:	ed9f 8b0a 	vldr	d8, [pc, #40]	@ 804cc08 <log+0x70>
 804cbe2:	6003      	str	r3, [r0, #0]
 804cbe4:	eeb0 0a48 	vmov.f32	s0, s16
 804cbe8:	eef0 0a68 	vmov.f32	s1, s17
 804cbec:	ecbd 8b02 	vpop	{d8}
 804cbf0:	bd38      	pop	{r3, r4, r5, pc}
 804cbf2:	f7ff f9b3 	bl	804bf5c <__errno>
 804cbf6:	2321      	movs	r3, #33	@ 0x21
 804cbf8:	ecbd 8b02 	vpop	{d8}
 804cbfc:	6003      	str	r3, [r0, #0]
 804cbfe:	4804      	ldr	r0, [pc, #16]	@ (804cc10 <log+0x78>)
 804cc00:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 804cc04:	f7ff b9e4 	b.w	804bfd0 <nan>
 804cc08:	00000000 	.word	0x00000000
 804cc0c:	fff00000 	.word	0xfff00000
 804cc10:	0804e581 	.word	0x0804e581

0804cc14 <sqrt>:
 804cc14:	b538      	push	{r3, r4, r5, lr}
 804cc16:	ec55 4b10 	vmov	r4, r5, d0
 804cc1a:	ed2d 8b02 	vpush	{d8}
 804cc1e:	f000 f93b 	bl	804ce98 <__ieee754_sqrt>
 804cc22:	4622      	mov	r2, r4
 804cc24:	462b      	mov	r3, r5
 804cc26:	4620      	mov	r0, r4
 804cc28:	4629      	mov	r1, r5
 804cc2a:	eeb0 8a40 	vmov.f32	s16, s0
 804cc2e:	eef0 8a60 	vmov.f32	s17, s1
 804cc32:	f7f3 ff57 	bl	8040ae4 <__aeabi_dcmpun>
 804cc36:	b990      	cbnz	r0, 804cc5e <sqrt+0x4a>
 804cc38:	2200      	movs	r2, #0
 804cc3a:	2300      	movs	r3, #0
 804cc3c:	4620      	mov	r0, r4
 804cc3e:	4629      	mov	r1, r5
 804cc40:	f7f3 ff28 	bl	8040a94 <__aeabi_dcmplt>
 804cc44:	b158      	cbz	r0, 804cc5e <sqrt+0x4a>
 804cc46:	f7ff f989 	bl	804bf5c <__errno>
 804cc4a:	2321      	movs	r3, #33	@ 0x21
 804cc4c:	2200      	movs	r2, #0
 804cc4e:	6003      	str	r3, [r0, #0]
 804cc50:	2300      	movs	r3, #0
 804cc52:	4610      	mov	r0, r2
 804cc54:	4619      	mov	r1, r3
 804cc56:	f7f3 fdd5 	bl	8040804 <__aeabi_ddiv>
 804cc5a:	ec41 0b18 	vmov	d8, r0, r1
 804cc5e:	eeb0 0a48 	vmov.f32	s0, s16
 804cc62:	eef0 0a68 	vmov.f32	s1, s17
 804cc66:	ecbd 8b02 	vpop	{d8}
 804cc6a:	bd38      	pop	{r3, r4, r5, pc}

0804cc6c <expf>:
 804cc6c:	b508      	push	{r3, lr}
 804cc6e:	ed2d 8b02 	vpush	{d8}
 804cc72:	eef0 8a40 	vmov.f32	s17, s0
 804cc76:	f000 fc45 	bl	804d504 <__ieee754_expf>
 804cc7a:	eeb0 8a40 	vmov.f32	s16, s0
 804cc7e:	eeb0 0a68 	vmov.f32	s0, s17
 804cc82:	f000 f8ff 	bl	804ce84 <finitef>
 804cc86:	b160      	cbz	r0, 804cca2 <expf+0x36>
 804cc88:	eddf 7a0f 	vldr	s15, [pc, #60]	@ 804ccc8 <expf+0x5c>
 804cc8c:	eef4 8ae7 	vcmpe.f32	s17, s15
 804cc90:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 804cc94:	dd0a      	ble.n	804ccac <expf+0x40>
 804cc96:	f7ff f961 	bl	804bf5c <__errno>
 804cc9a:	ed9f 8a0c 	vldr	s16, [pc, #48]	@ 804cccc <expf+0x60>
 804cc9e:	2322      	movs	r3, #34	@ 0x22
 804cca0:	6003      	str	r3, [r0, #0]
 804cca2:	eeb0 0a48 	vmov.f32	s0, s16
 804cca6:	ecbd 8b02 	vpop	{d8}
 804ccaa:	bd08      	pop	{r3, pc}
 804ccac:	eddf 7a08 	vldr	s15, [pc, #32]	@ 804ccd0 <expf+0x64>
 804ccb0:	eef4 8ae7 	vcmpe.f32	s17, s15
 804ccb4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 804ccb8:	d5f3      	bpl.n	804cca2 <expf+0x36>
 804ccba:	f7ff f94f 	bl	804bf5c <__errno>
 804ccbe:	2322      	movs	r3, #34	@ 0x22
 804ccc0:	ed9f 8a04 	vldr	s16, [pc, #16]	@ 804ccd4 <expf+0x68>
 804ccc4:	6003      	str	r3, [r0, #0]
 804ccc6:	e7ec      	b.n	804cca2 <expf+0x36>
 804ccc8:	42b17217 	.word	0x42b17217
 804cccc:	7f800000 	.word	0x7f800000
 804ccd0:	c2cff1b5 	.word	0xc2cff1b5
 804ccd4:	00000000 	.word	0x00000000

0804ccd8 <logf>:
 804ccd8:	b508      	push	{r3, lr}
 804ccda:	ed2d 8b02 	vpush	{d8}
 804ccde:	eeb0 8a40 	vmov.f32	s16, s0
 804cce2:	f000 fcdd 	bl	804d6a0 <__ieee754_logf>
 804cce6:	eeb4 8a48 	vcmp.f32	s16, s16
 804ccea:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 804ccee:	d60f      	bvs.n	804cd10 <logf+0x38>
 804ccf0:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
 804ccf4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 804ccf8:	dc0a      	bgt.n	804cd10 <logf+0x38>
 804ccfa:	eeb5 8a40 	vcmp.f32	s16, #0.0
 804ccfe:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 804cd02:	d108      	bne.n	804cd16 <logf+0x3e>
 804cd04:	f7ff f92a 	bl	804bf5c <__errno>
 804cd08:	2322      	movs	r3, #34	@ 0x22
 804cd0a:	ed9f 0a08 	vldr	s0, [pc, #32]	@ 804cd2c <logf+0x54>
 804cd0e:	6003      	str	r3, [r0, #0]
 804cd10:	ecbd 8b02 	vpop	{d8}
 804cd14:	bd08      	pop	{r3, pc}
 804cd16:	f7ff f921 	bl	804bf5c <__errno>
 804cd1a:	2321      	movs	r3, #33	@ 0x21
 804cd1c:	ecbd 8b02 	vpop	{d8}
 804cd20:	6003      	str	r3, [r0, #0]
 804cd22:	4803      	ldr	r0, [pc, #12]	@ (804cd30 <logf+0x58>)
 804cd24:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 804cd28:	f7ff b95a 	b.w	804bfe0 <nanf>
 804cd2c:	ff800000 	.word	0xff800000
 804cd30:	0804e581 	.word	0x0804e581

0804cd34 <sqrtf>:
 804cd34:	b508      	push	{r3, lr}
 804cd36:	ed2d 8b02 	vpush	{d8}
 804cd3a:	eeb0 8a40 	vmov.f32	s16, s0
 804cd3e:	f000 f989 	bl	804d054 <__ieee754_sqrtf>
 804cd42:	eeb4 8a48 	vcmp.f32	s16, s16
 804cd46:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 804cd4a:	d60c      	bvs.n	804cd66 <sqrtf+0x32>
 804cd4c:	eddf 8a07 	vldr	s17, [pc, #28]	@ 804cd6c <sqrtf+0x38>
 804cd50:	eeb4 8ae8 	vcmpe.f32	s16, s17
 804cd54:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 804cd58:	d505      	bpl.n	804cd66 <sqrtf+0x32>
 804cd5a:	f7ff f8ff 	bl	804bf5c <__errno>
 804cd5e:	ee88 0aa8 	vdiv.f32	s0, s17, s17
 804cd62:	2321      	movs	r3, #33	@ 0x21
 804cd64:	6003      	str	r3, [r0, #0]
 804cd66:	ecbd 8b02 	vpop	{d8}
 804cd6a:	bd08      	pop	{r3, pc}
 804cd6c:	00000000 	.word	0x00000000

0804cd70 <cosf>:
 804cd70:	ee10 3a10 	vmov	r3, s0
 804cd74:	b507      	push	{r0, r1, r2, lr}
 804cd76:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
 804cd7a:	4a1d      	ldr	r2, [pc, #116]	@ (804cdf0 <cosf+0x80>)
 804cd7c:	4293      	cmp	r3, r2
 804cd7e:	d806      	bhi.n	804cd8e <cosf+0x1e>
 804cd80:	eddf 0a1c 	vldr	s1, [pc, #112]	@ 804cdf4 <cosf+0x84>
 804cd84:	b003      	add	sp, #12
 804cd86:	f85d eb04 	ldr.w	lr, [sp], #4
 804cd8a:	f000 bb1b 	b.w	804d3c4 <__kernel_cosf>
 804cd8e:	f1b3 4fff 	cmp.w	r3, #2139095040	@ 0x7f800000
 804cd92:	d304      	bcc.n	804cd9e <cosf+0x2e>
 804cd94:	ee30 0a40 	vsub.f32	s0, s0, s0
 804cd98:	b003      	add	sp, #12
 804cd9a:	f85d fb04 	ldr.w	pc, [sp], #4
 804cd9e:	4668      	mov	r0, sp
 804cda0:	f000 fd6e 	bl	804d880 <__ieee754_rem_pio2f>
 804cda4:	f000 0003 	and.w	r0, r0, #3
 804cda8:	2801      	cmp	r0, #1
 804cdaa:	d009      	beq.n	804cdc0 <cosf+0x50>
 804cdac:	2802      	cmp	r0, #2
 804cdae:	d010      	beq.n	804cdd2 <cosf+0x62>
 804cdb0:	b9b0      	cbnz	r0, 804cde0 <cosf+0x70>
 804cdb2:	eddd 0a01 	vldr	s1, [sp, #4]
 804cdb6:	ed9d 0a00 	vldr	s0, [sp]
 804cdba:	f000 fb03 	bl	804d3c4 <__kernel_cosf>
 804cdbe:	e7eb      	b.n	804cd98 <cosf+0x28>
 804cdc0:	eddd 0a01 	vldr	s1, [sp, #4]
 804cdc4:	ed9d 0a00 	vldr	s0, [sp]
 804cdc8:	f000 fb54 	bl	804d474 <__kernel_sinf>
 804cdcc:	eeb1 0a40 	vneg.f32	s0, s0
 804cdd0:	e7e2      	b.n	804cd98 <cosf+0x28>
 804cdd2:	eddd 0a01 	vldr	s1, [sp, #4]
 804cdd6:	ed9d 0a00 	vldr	s0, [sp]
 804cdda:	f000 faf3 	bl	804d3c4 <__kernel_cosf>
 804cdde:	e7f5      	b.n	804cdcc <cosf+0x5c>
 804cde0:	2001      	movs	r0, #1
 804cde2:	eddd 0a01 	vldr	s1, [sp, #4]
 804cde6:	ed9d 0a00 	vldr	s0, [sp]
 804cdea:	f000 fb43 	bl	804d474 <__kernel_sinf>
 804cdee:	e7d3      	b.n	804cd98 <cosf+0x28>
 804cdf0:	3f490fd8 	.word	0x3f490fd8
 804cdf4:	00000000 	.word	0x00000000

0804cdf8 <sinf>:
 804cdf8:	ee10 3a10 	vmov	r3, s0
 804cdfc:	b507      	push	{r0, r1, r2, lr}
 804cdfe:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
 804ce02:	4a1e      	ldr	r2, [pc, #120]	@ (804ce7c <sinf+0x84>)
 804ce04:	4293      	cmp	r3, r2
 804ce06:	d807      	bhi.n	804ce18 <sinf+0x20>
 804ce08:	2000      	movs	r0, #0
 804ce0a:	eddf 0a1d 	vldr	s1, [pc, #116]	@ 804ce80 <sinf+0x88>
 804ce0e:	b003      	add	sp, #12
 804ce10:	f85d eb04 	ldr.w	lr, [sp], #4
 804ce14:	f000 bb2e 	b.w	804d474 <__kernel_sinf>
 804ce18:	f1b3 4fff 	cmp.w	r3, #2139095040	@ 0x7f800000
 804ce1c:	d304      	bcc.n	804ce28 <sinf+0x30>
 804ce1e:	ee30 0a40 	vsub.f32	s0, s0, s0
 804ce22:	b003      	add	sp, #12
 804ce24:	f85d fb04 	ldr.w	pc, [sp], #4
 804ce28:	4668      	mov	r0, sp
 804ce2a:	f000 fd29 	bl	804d880 <__ieee754_rem_pio2f>
 804ce2e:	f000 0003 	and.w	r0, r0, #3
 804ce32:	2801      	cmp	r0, #1
 804ce34:	d00a      	beq.n	804ce4c <sinf+0x54>
 804ce36:	2802      	cmp	r0, #2
 804ce38:	d00f      	beq.n	804ce5a <sinf+0x62>
 804ce3a:	b9c0      	cbnz	r0, 804ce6e <sinf+0x76>
 804ce3c:	2001      	movs	r0, #1
 804ce3e:	eddd 0a01 	vldr	s1, [sp, #4]
 804ce42:	ed9d 0a00 	vldr	s0, [sp]
 804ce46:	f000 fb15 	bl	804d474 <__kernel_sinf>
 804ce4a:	e7ea      	b.n	804ce22 <sinf+0x2a>
 804ce4c:	eddd 0a01 	vldr	s1, [sp, #4]
 804ce50:	ed9d 0a00 	vldr	s0, [sp]
 804ce54:	f000 fab6 	bl	804d3c4 <__kernel_cosf>
 804ce58:	e7e3      	b.n	804ce22 <sinf+0x2a>
 804ce5a:	2001      	movs	r0, #1
 804ce5c:	eddd 0a01 	vldr	s1, [sp, #4]
 804ce60:	ed9d 0a00 	vldr	s0, [sp]
 804ce64:	f000 fb06 	bl	804d474 <__kernel_sinf>
 804ce68:	eeb1 0a40 	vneg.f32	s0, s0
 804ce6c:	e7d9      	b.n	804ce22 <sinf+0x2a>
 804ce6e:	eddd 0a01 	vldr	s1, [sp, #4]
 804ce72:	ed9d 0a00 	vldr	s0, [sp]
 804ce76:	f000 faa5 	bl	804d3c4 <__kernel_cosf>
 804ce7a:	e7f5      	b.n	804ce68 <sinf+0x70>
 804ce7c:	3f490fd8 	.word	0x3f490fd8
 804ce80:	00000000 	.word	0x00000000

0804ce84 <finitef>:
 804ce84:	ee10 3a10 	vmov	r3, s0
 804ce88:	f023 4000 	bic.w	r0, r3, #2147483648	@ 0x80000000
 804ce8c:	f1b0 4fff 	cmp.w	r0, #2139095040	@ 0x7f800000
 804ce90:	bfac      	ite	ge
 804ce92:	2000      	movge	r0, #0
 804ce94:	2001      	movlt	r0, #1
 804ce96:	4770      	bx	lr

0804ce98 <__ieee754_sqrt>:
 804ce98:	4a6b      	ldr	r2, [pc, #428]	@ (804d048 <__ieee754_sqrt+0x1b0>)
 804ce9a:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 804ce9e:	ec55 4b10 	vmov	r4, r5, d0
 804cea2:	43aa      	bics	r2, r5
 804cea4:	462b      	mov	r3, r5
 804cea6:	4621      	mov	r1, r4
 804cea8:	d110      	bne.n	804cecc <__ieee754_sqrt+0x34>
 804ceaa:	4622      	mov	r2, r4
 804ceac:	4620      	mov	r0, r4
 804ceae:	4629      	mov	r1, r5
 804ceb0:	f7f3 fb7e 	bl	80405b0 <__aeabi_dmul>
 804ceb4:	4602      	mov	r2, r0
 804ceb6:	460b      	mov	r3, r1
 804ceb8:	4620      	mov	r0, r4
 804ceba:	4629      	mov	r1, r5
 804cebc:	f7f3 f9c2 	bl	8040244 <__adddf3>
 804cec0:	4604      	mov	r4, r0
 804cec2:	460d      	mov	r5, r1
 804cec4:	ec45 4b10 	vmov	d0, r4, r5
 804cec8:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 804cecc:	2d00      	cmp	r5, #0
 804cece:	dc0e      	bgt.n	804ceee <__ieee754_sqrt+0x56>
 804ced0:	f025 4200 	bic.w	r2, r5, #2147483648	@ 0x80000000
 804ced4:	4322      	orrs	r2, r4
 804ced6:	d0f5      	beq.n	804cec4 <__ieee754_sqrt+0x2c>
 804ced8:	b19d      	cbz	r5, 804cf02 <__ieee754_sqrt+0x6a>
 804ceda:	4622      	mov	r2, r4
 804cedc:	4620      	mov	r0, r4
 804cede:	4629      	mov	r1, r5
 804cee0:	f7f3 f9ae 	bl	8040240 <__aeabi_dsub>
 804cee4:	4602      	mov	r2, r0
 804cee6:	460b      	mov	r3, r1
 804cee8:	f7f3 fc8c 	bl	8040804 <__aeabi_ddiv>
 804ceec:	e7e8      	b.n	804cec0 <__ieee754_sqrt+0x28>
 804ceee:	152a      	asrs	r2, r5, #20
 804cef0:	d115      	bne.n	804cf1e <__ieee754_sqrt+0x86>
 804cef2:	2000      	movs	r0, #0
 804cef4:	e009      	b.n	804cf0a <__ieee754_sqrt+0x72>
 804cef6:	0acb      	lsrs	r3, r1, #11
 804cef8:	3a15      	subs	r2, #21
 804cefa:	0549      	lsls	r1, r1, #21
 804cefc:	2b00      	cmp	r3, #0
 804cefe:	d0fa      	beq.n	804cef6 <__ieee754_sqrt+0x5e>
 804cf00:	e7f7      	b.n	804cef2 <__ieee754_sqrt+0x5a>
 804cf02:	462a      	mov	r2, r5
 804cf04:	e7fa      	b.n	804cefc <__ieee754_sqrt+0x64>
 804cf06:	005b      	lsls	r3, r3, #1
 804cf08:	3001      	adds	r0, #1
 804cf0a:	02dc      	lsls	r4, r3, #11
 804cf0c:	d5fb      	bpl.n	804cf06 <__ieee754_sqrt+0x6e>
 804cf0e:	1e44      	subs	r4, r0, #1
 804cf10:	1b12      	subs	r2, r2, r4
 804cf12:	f1c0 0420 	rsb	r4, r0, #32
 804cf16:	fa21 f404 	lsr.w	r4, r1, r4
 804cf1a:	4081      	lsls	r1, r0
 804cf1c:	4323      	orrs	r3, r4
 804cf1e:	f3c3 0313 	ubfx	r3, r3, #0, #20
 804cf22:	f2a2 35ff 	subw	r5, r2, #1023	@ 0x3ff
 804cf26:	07d2      	lsls	r2, r2, #31
 804cf28:	f04f 0600 	mov.w	r6, #0
 804cf2c:	f443 1380 	orr.w	r3, r3, #1048576	@ 0x100000
 804cf30:	ea4f 0565 	mov.w	r5, r5, asr #1
 804cf34:	f04f 0016 	mov.w	r0, #22
 804cf38:	4632      	mov	r2, r6
 804cf3a:	bf58      	it	pl
 804cf3c:	005b      	lslpl	r3, r3, #1
 804cf3e:	f44f 1400 	mov.w	r4, #2097152	@ 0x200000
 804cf42:	bf5c      	itt	pl
 804cf44:	eb03 73d1 	addpl.w	r3, r3, r1, lsr #31
 804cf48:	0049      	lslpl	r1, r1, #1
 804cf4a:	005b      	lsls	r3, r3, #1
 804cf4c:	eb03 73d1 	add.w	r3, r3, r1, lsr #31
 804cf50:	0049      	lsls	r1, r1, #1
 804cf52:	1917      	adds	r7, r2, r4
 804cf54:	429f      	cmp	r7, r3
 804cf56:	bfde      	ittt	le
 804cf58:	193a      	addle	r2, r7, r4
 804cf5a:	1bdb      	suble	r3, r3, r7
 804cf5c:	1936      	addle	r6, r6, r4
 804cf5e:	0fcf      	lsrs	r7, r1, #31
 804cf60:	3801      	subs	r0, #1
 804cf62:	ea4f 0141 	mov.w	r1, r1, lsl #1
 804cf66:	eb07 0343 	add.w	r3, r7, r3, lsl #1
 804cf6a:	ea4f 0454 	mov.w	r4, r4, lsr #1
 804cf6e:	d1f0      	bne.n	804cf52 <__ieee754_sqrt+0xba>
 804cf70:	4604      	mov	r4, r0
 804cf72:	2720      	movs	r7, #32
 804cf74:	f04f 4c00 	mov.w	ip, #2147483648	@ 0x80000000
 804cf78:	429a      	cmp	r2, r3
 804cf7a:	eb00 0e0c 	add.w	lr, r0, ip
 804cf7e:	db02      	blt.n	804cf86 <__ieee754_sqrt+0xee>
 804cf80:	d113      	bne.n	804cfaa <__ieee754_sqrt+0x112>
 804cf82:	458e      	cmp	lr, r1
 804cf84:	d811      	bhi.n	804cfaa <__ieee754_sqrt+0x112>
 804cf86:	f1be 0f00 	cmp.w	lr, #0
 804cf8a:	eb0e 000c 	add.w	r0, lr, ip
 804cf8e:	da43      	bge.n	804d018 <__ieee754_sqrt+0x180>
 804cf90:	2800      	cmp	r0, #0
 804cf92:	db41      	blt.n	804d018 <__ieee754_sqrt+0x180>
 804cf94:	f102 0801 	add.w	r8, r2, #1
 804cf98:	1a9b      	subs	r3, r3, r2
 804cf9a:	458e      	cmp	lr, r1
 804cf9c:	4464      	add	r4, ip
 804cf9e:	eba1 010e 	sub.w	r1, r1, lr
 804cfa2:	bf88      	it	hi
 804cfa4:	f103 33ff 	addhi.w	r3, r3, #4294967295
 804cfa8:	4642      	mov	r2, r8
 804cfaa:	ea4f 7ed1 	mov.w	lr, r1, lsr #31
 804cfae:	3f01      	subs	r7, #1
 804cfb0:	ea4f 0141 	mov.w	r1, r1, lsl #1
 804cfb4:	eb0e 0343 	add.w	r3, lr, r3, lsl #1
 804cfb8:	ea4f 0c5c 	mov.w	ip, ip, lsr #1
 804cfbc:	d1dc      	bne.n	804cf78 <__ieee754_sqrt+0xe0>
 804cfbe:	4319      	orrs	r1, r3
 804cfc0:	d01b      	beq.n	804cffa <__ieee754_sqrt+0x162>
 804cfc2:	f8df a088 	ldr.w	sl, [pc, #136]	@ 804d04c <__ieee754_sqrt+0x1b4>
 804cfc6:	f8df b088 	ldr.w	fp, [pc, #136]	@ 804d050 <__ieee754_sqrt+0x1b8>
 804cfca:	e9da 0100 	ldrd	r0, r1, [sl]
 804cfce:	e9db 2300 	ldrd	r2, r3, [fp]
 804cfd2:	e9da 8900 	ldrd	r8, r9, [sl]
 804cfd6:	f7f3 f933 	bl	8040240 <__aeabi_dsub>
 804cfda:	4602      	mov	r2, r0
 804cfdc:	460b      	mov	r3, r1
 804cfde:	4640      	mov	r0, r8
 804cfe0:	4649      	mov	r1, r9
 804cfe2:	f7f3 fd61 	bl	8040aa8 <__aeabi_dcmple>
 804cfe6:	b140      	cbz	r0, 804cffa <__ieee754_sqrt+0x162>
 804cfe8:	f1b4 3fff 	cmp.w	r4, #4294967295
 804cfec:	e9da 0100 	ldrd	r0, r1, [sl]
 804cff0:	e9db 2300 	ldrd	r2, r3, [fp]
 804cff4:	d112      	bne.n	804d01c <__ieee754_sqrt+0x184>
 804cff6:	3601      	adds	r6, #1
 804cff8:	463c      	mov	r4, r7
 804cffa:	1072      	asrs	r2, r6, #1
 804cffc:	07f1      	lsls	r1, r6, #31
 804cffe:	ea4f 0354 	mov.w	r3, r4, lsr #1
 804d002:	f102 527f 	add.w	r2, r2, #1069547520	@ 0x3fc00000
 804d006:	bf48      	it	mi
 804d008:	f043 4300 	orrmi.w	r3, r3, #2147483648	@ 0x80000000
 804d00c:	f502 1200 	add.w	r2, r2, #2097152	@ 0x200000
 804d010:	4618      	mov	r0, r3
 804d012:	eb02 5105 	add.w	r1, r2, r5, lsl #20
 804d016:	e753      	b.n	804cec0 <__ieee754_sqrt+0x28>
 804d018:	4690      	mov	r8, r2
 804d01a:	e7bd      	b.n	804cf98 <__ieee754_sqrt+0x100>
 804d01c:	e9da 8900 	ldrd	r8, r9, [sl]
 804d020:	f7f3 f910 	bl	8040244 <__adddf3>
 804d024:	4602      	mov	r2, r0
 804d026:	460b      	mov	r3, r1
 804d028:	4640      	mov	r0, r8
 804d02a:	4649      	mov	r1, r9
 804d02c:	f7f3 fd32 	bl	8040a94 <__aeabi_dcmplt>
 804d030:	b128      	cbz	r0, 804d03e <__ieee754_sqrt+0x1a6>
 804d032:	1ca0      	adds	r0, r4, #2
 804d034:	f104 0402 	add.w	r4, r4, #2
 804d038:	bf08      	it	eq
 804d03a:	3601      	addeq	r6, #1
 804d03c:	e7dd      	b.n	804cffa <__ieee754_sqrt+0x162>
 804d03e:	1c63      	adds	r3, r4, #1
 804d040:	f023 0401 	bic.w	r4, r3, #1
 804d044:	e7d9      	b.n	804cffa <__ieee754_sqrt+0x162>
 804d046:	bf00      	nop
 804d048:	7ff00000 	.word	0x7ff00000
 804d04c:	20018198 	.word	0x20018198
 804d050:	20018190 	.word	0x20018190

0804d054 <__ieee754_sqrtf>:
 804d054:	eeb1 0ac0 	vsqrt.f32	s0, s0
 804d058:	4770      	bx	lr
 804d05a:	0000      	movs	r0, r0
 804d05c:	0000      	movs	r0, r0
	...

0804d060 <__ieee754_log>:
 804d060:	ec51 0b10 	vmov	r0, r1, d0
 804d064:	f5b1 1f80 	cmp.w	r1, #1048576	@ 0x100000
 804d068:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 804d06c:	460d      	mov	r5, r1
 804d06e:	b087      	sub	sp, #28
 804d070:	da26      	bge.n	804d0c0 <__ieee754_log+0x60>
 804d072:	f021 4300 	bic.w	r3, r1, #2147483648	@ 0x80000000
 804d076:	4602      	mov	r2, r0
 804d078:	4303      	orrs	r3, r0
 804d07a:	d10a      	bne.n	804d092 <__ieee754_log+0x32>
 804d07c:	2200      	movs	r2, #0
 804d07e:	2300      	movs	r3, #0
 804d080:	2000      	movs	r0, #0
 804d082:	49cb      	ldr	r1, [pc, #812]	@ (804d3b0 <__ieee754_log+0x350>)
 804d084:	f7f3 fbbe 	bl	8040804 <__aeabi_ddiv>
 804d088:	ec41 0b10 	vmov	d0, r0, r1
 804d08c:	b007      	add	sp, #28
 804d08e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 804d092:	2900      	cmp	r1, #0
 804d094:	da05      	bge.n	804d0a2 <__ieee754_log+0x42>
 804d096:	460b      	mov	r3, r1
 804d098:	f7f3 f8d2 	bl	8040240 <__aeabi_dsub>
 804d09c:	2200      	movs	r2, #0
 804d09e:	2300      	movs	r3, #0
 804d0a0:	e7f0      	b.n	804d084 <__ieee754_log+0x24>
 804d0a2:	4bc4      	ldr	r3, [pc, #784]	@ (804d3b4 <__ieee754_log+0x354>)
 804d0a4:	2200      	movs	r2, #0
 804d0a6:	f7f3 fa83 	bl	80405b0 <__aeabi_dmul>
 804d0aa:	f06f 0335 	mvn.w	r3, #53	@ 0x35
 804d0ae:	460d      	mov	r5, r1
 804d0b0:	4ac1      	ldr	r2, [pc, #772]	@ (804d3b8 <__ieee754_log+0x358>)
 804d0b2:	4295      	cmp	r5, r2
 804d0b4:	dd06      	ble.n	804d0c4 <__ieee754_log+0x64>
 804d0b6:	4602      	mov	r2, r0
 804d0b8:	460b      	mov	r3, r1
 804d0ba:	f7f3 f8c3 	bl	8040244 <__adddf3>
 804d0be:	e7e3      	b.n	804d088 <__ieee754_log+0x28>
 804d0c0:	2300      	movs	r3, #0
 804d0c2:	e7f5      	b.n	804d0b0 <__ieee754_log+0x50>
 804d0c4:	152c      	asrs	r4, r5, #20
 804d0c6:	f3c5 0513 	ubfx	r5, r5, #0, #20
 804d0ca:	f2a4 34ff 	subw	r4, r4, #1023	@ 0x3ff
 804d0ce:	441c      	add	r4, r3
 804d0d0:	f505 2315 	add.w	r3, r5, #610304	@ 0x95000
 804d0d4:	f603 7364 	addw	r3, r3, #3940	@ 0xf64
 804d0d8:	f403 1380 	and.w	r3, r3, #1048576	@ 0x100000
 804d0dc:	f083 527f 	eor.w	r2, r3, #1069547520	@ 0x3fc00000
 804d0e0:	eb04 5413 	add.w	r4, r4, r3, lsr #20
 804d0e4:	4bb5      	ldr	r3, [pc, #724]	@ (804d3bc <__ieee754_log+0x35c>)
 804d0e6:	f482 1240 	eor.w	r2, r2, #3145728	@ 0x300000
 804d0ea:	ea42 0105 	orr.w	r1, r2, r5
 804d0ee:	2200      	movs	r2, #0
 804d0f0:	f7f3 f8a6 	bl	8040240 <__aeabi_dsub>
 804d0f4:	1cab      	adds	r3, r5, #2
 804d0f6:	4682      	mov	sl, r0
 804d0f8:	468b      	mov	fp, r1
 804d0fa:	f3c3 0313 	ubfx	r3, r3, #0, #20
 804d0fe:	2200      	movs	r2, #0
 804d100:	2b02      	cmp	r3, #2
 804d102:	dc53      	bgt.n	804d1ac <__ieee754_log+0x14c>
 804d104:	2300      	movs	r3, #0
 804d106:	f7f3 fcbb 	bl	8040a80 <__aeabi_dcmpeq>
 804d10a:	b1d0      	cbz	r0, 804d142 <__ieee754_log+0xe2>
 804d10c:	2c00      	cmp	r4, #0
 804d10e:	f000 8120 	beq.w	804d352 <__ieee754_log+0x2f2>
 804d112:	4620      	mov	r0, r4
 804d114:	f7f3 f9e2 	bl	80404dc <__aeabi_i2d>
 804d118:	4606      	mov	r6, r0
 804d11a:	460f      	mov	r7, r1
 804d11c:	a38e      	add	r3, pc, #568	@ (adr r3, 804d358 <__ieee754_log+0x2f8>)
 804d11e:	e9d3 2300 	ldrd	r2, r3, [r3]
 804d122:	f7f3 fa45 	bl	80405b0 <__aeabi_dmul>
 804d126:	4604      	mov	r4, r0
 804d128:	460d      	mov	r5, r1
 804d12a:	4630      	mov	r0, r6
 804d12c:	4639      	mov	r1, r7
 804d12e:	a38c      	add	r3, pc, #560	@ (adr r3, 804d360 <__ieee754_log+0x300>)
 804d130:	e9d3 2300 	ldrd	r2, r3, [r3]
 804d134:	f7f3 fa3c 	bl	80405b0 <__aeabi_dmul>
 804d138:	4602      	mov	r2, r0
 804d13a:	460b      	mov	r3, r1
 804d13c:	4620      	mov	r0, r4
 804d13e:	4629      	mov	r1, r5
 804d140:	e7bb      	b.n	804d0ba <__ieee754_log+0x5a>
 804d142:	a389      	add	r3, pc, #548	@ (adr r3, 804d368 <__ieee754_log+0x308>)
 804d144:	e9d3 2300 	ldrd	r2, r3, [r3]
 804d148:	4650      	mov	r0, sl
 804d14a:	4659      	mov	r1, fp
 804d14c:	f7f3 fa30 	bl	80405b0 <__aeabi_dmul>
 804d150:	4602      	mov	r2, r0
 804d152:	460b      	mov	r3, r1
 804d154:	2000      	movs	r0, #0
 804d156:	499a      	ldr	r1, [pc, #616]	@ (804d3c0 <__ieee754_log+0x360>)
 804d158:	f7f3 f872 	bl	8040240 <__aeabi_dsub>
 804d15c:	4606      	mov	r6, r0
 804d15e:	460f      	mov	r7, r1
 804d160:	4652      	mov	r2, sl
 804d162:	465b      	mov	r3, fp
 804d164:	4650      	mov	r0, sl
 804d166:	4659      	mov	r1, fp
 804d168:	f7f3 fa22 	bl	80405b0 <__aeabi_dmul>
 804d16c:	4602      	mov	r2, r0
 804d16e:	460b      	mov	r3, r1
 804d170:	4630      	mov	r0, r6
 804d172:	4639      	mov	r1, r7
 804d174:	f7f3 fa1c 	bl	80405b0 <__aeabi_dmul>
 804d178:	4606      	mov	r6, r0
 804d17a:	460f      	mov	r7, r1
 804d17c:	b914      	cbnz	r4, 804d184 <__ieee754_log+0x124>
 804d17e:	4632      	mov	r2, r6
 804d180:	463b      	mov	r3, r7
 804d182:	e0a0      	b.n	804d2c6 <__ieee754_log+0x266>
 804d184:	4620      	mov	r0, r4
 804d186:	f7f3 f9a9 	bl	80404dc <__aeabi_i2d>
 804d18a:	4680      	mov	r8, r0
 804d18c:	4689      	mov	r9, r1
 804d18e:	a372      	add	r3, pc, #456	@ (adr r3, 804d358 <__ieee754_log+0x2f8>)
 804d190:	e9d3 2300 	ldrd	r2, r3, [r3]
 804d194:	f7f3 fa0c 	bl	80405b0 <__aeabi_dmul>
 804d198:	4604      	mov	r4, r0
 804d19a:	460d      	mov	r5, r1
 804d19c:	4640      	mov	r0, r8
 804d19e:	4649      	mov	r1, r9
 804d1a0:	a36f      	add	r3, pc, #444	@ (adr r3, 804d360 <__ieee754_log+0x300>)
 804d1a2:	e9d3 2300 	ldrd	r2, r3, [r3]
 804d1a6:	f7f3 fa03 	bl	80405b0 <__aeabi_dmul>
 804d1aa:	e0a5      	b.n	804d2f8 <__ieee754_log+0x298>
 804d1ac:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 804d1b0:	f5a5 26c2 	sub.w	r6, r5, #397312	@ 0x61000
 804d1b4:	f7f3 f846 	bl	8040244 <__adddf3>
 804d1b8:	4602      	mov	r2, r0
 804d1ba:	460b      	mov	r3, r1
 804d1bc:	4650      	mov	r0, sl
 804d1be:	4659      	mov	r1, fp
 804d1c0:	f5c5 25d7 	rsb	r5, r5, #440320	@ 0x6b800
 804d1c4:	f7f3 fb1e 	bl	8040804 <__aeabi_ddiv>
 804d1c8:	f2a6 467a 	subw	r6, r6, #1146	@ 0x47a
 804d1cc:	3551      	adds	r5, #81	@ 0x51
 804d1ce:	e9cd 0100 	strd	r0, r1, [sp]
 804d1d2:	4620      	mov	r0, r4
 804d1d4:	4335      	orrs	r5, r6
 804d1d6:	f7f3 f981 	bl	80404dc <__aeabi_i2d>
 804d1da:	e9dd 2300 	ldrd	r2, r3, [sp]
 804d1de:	e9cd 0102 	strd	r0, r1, [sp, #8]
 804d1e2:	4610      	mov	r0, r2
 804d1e4:	4619      	mov	r1, r3
 804d1e6:	f7f3 f9e3 	bl	80405b0 <__aeabi_dmul>
 804d1ea:	4602      	mov	r2, r0
 804d1ec:	460b      	mov	r3, r1
 804d1ee:	e9cd 2304 	strd	r2, r3, [sp, #16]
 804d1f2:	f7f3 f9dd 	bl	80405b0 <__aeabi_dmul>
 804d1f6:	4680      	mov	r8, r0
 804d1f8:	4689      	mov	r9, r1
 804d1fa:	a35d      	add	r3, pc, #372	@ (adr r3, 804d370 <__ieee754_log+0x310>)
 804d1fc:	e9d3 2300 	ldrd	r2, r3, [r3]
 804d200:	f7f3 f9d6 	bl	80405b0 <__aeabi_dmul>
 804d204:	a35c      	add	r3, pc, #368	@ (adr r3, 804d378 <__ieee754_log+0x318>)
 804d206:	e9d3 2300 	ldrd	r2, r3, [r3]
 804d20a:	f7f3 f81b 	bl	8040244 <__adddf3>
 804d20e:	4642      	mov	r2, r8
 804d210:	464b      	mov	r3, r9
 804d212:	f7f3 f9cd 	bl	80405b0 <__aeabi_dmul>
 804d216:	a35a      	add	r3, pc, #360	@ (adr r3, 804d380 <__ieee754_log+0x320>)
 804d218:	e9d3 2300 	ldrd	r2, r3, [r3]
 804d21c:	f7f3 f812 	bl	8040244 <__adddf3>
 804d220:	4642      	mov	r2, r8
 804d222:	464b      	mov	r3, r9
 804d224:	f7f3 f9c4 	bl	80405b0 <__aeabi_dmul>
 804d228:	a357      	add	r3, pc, #348	@ (adr r3, 804d388 <__ieee754_log+0x328>)
 804d22a:	e9d3 2300 	ldrd	r2, r3, [r3]
 804d22e:	f7f3 f809 	bl	8040244 <__adddf3>
 804d232:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 804d236:	f7f3 f9bb 	bl	80405b0 <__aeabi_dmul>
 804d23a:	a355      	add	r3, pc, #340	@ (adr r3, 804d390 <__ieee754_log+0x330>)
 804d23c:	e9d3 2300 	ldrd	r2, r3, [r3]
 804d240:	e9cd 0104 	strd	r0, r1, [sp, #16]
 804d244:	4640      	mov	r0, r8
 804d246:	4649      	mov	r1, r9
 804d248:	f7f3 f9b2 	bl	80405b0 <__aeabi_dmul>
 804d24c:	a352      	add	r3, pc, #328	@ (adr r3, 804d398 <__ieee754_log+0x338>)
 804d24e:	e9d3 2300 	ldrd	r2, r3, [r3]
 804d252:	f7f2 fff7 	bl	8040244 <__adddf3>
 804d256:	4642      	mov	r2, r8
 804d258:	464b      	mov	r3, r9
 804d25a:	f7f3 f9a9 	bl	80405b0 <__aeabi_dmul>
 804d25e:	a350      	add	r3, pc, #320	@ (adr r3, 804d3a0 <__ieee754_log+0x340>)
 804d260:	e9d3 2300 	ldrd	r2, r3, [r3]
 804d264:	f7f2 ffee 	bl	8040244 <__adddf3>
 804d268:	4642      	mov	r2, r8
 804d26a:	464b      	mov	r3, r9
 804d26c:	f7f3 f9a0 	bl	80405b0 <__aeabi_dmul>
 804d270:	4602      	mov	r2, r0
 804d272:	460b      	mov	r3, r1
 804d274:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 804d278:	f7f2 ffe4 	bl	8040244 <__adddf3>
 804d27c:	2d00      	cmp	r5, #0
 804d27e:	4680      	mov	r8, r0
 804d280:	4689      	mov	r9, r1
 804d282:	dd48      	ble.n	804d316 <__ieee754_log+0x2b6>
 804d284:	2200      	movs	r2, #0
 804d286:	4b4e      	ldr	r3, [pc, #312]	@ (804d3c0 <__ieee754_log+0x360>)
 804d288:	4650      	mov	r0, sl
 804d28a:	4659      	mov	r1, fp
 804d28c:	f7f3 f990 	bl	80405b0 <__aeabi_dmul>
 804d290:	4652      	mov	r2, sl
 804d292:	465b      	mov	r3, fp
 804d294:	f7f3 f98c 	bl	80405b0 <__aeabi_dmul>
 804d298:	4602      	mov	r2, r0
 804d29a:	460b      	mov	r3, r1
 804d29c:	4606      	mov	r6, r0
 804d29e:	460f      	mov	r7, r1
 804d2a0:	4640      	mov	r0, r8
 804d2a2:	4649      	mov	r1, r9
 804d2a4:	f7f2 ffce 	bl	8040244 <__adddf3>
 804d2a8:	e9dd 2300 	ldrd	r2, r3, [sp]
 804d2ac:	f7f3 f980 	bl	80405b0 <__aeabi_dmul>
 804d2b0:	4680      	mov	r8, r0
 804d2b2:	4689      	mov	r9, r1
 804d2b4:	b964      	cbnz	r4, 804d2d0 <__ieee754_log+0x270>
 804d2b6:	4602      	mov	r2, r0
 804d2b8:	460b      	mov	r3, r1
 804d2ba:	4630      	mov	r0, r6
 804d2bc:	4639      	mov	r1, r7
 804d2be:	f7f2 ffbf 	bl	8040240 <__aeabi_dsub>
 804d2c2:	4602      	mov	r2, r0
 804d2c4:	460b      	mov	r3, r1
 804d2c6:	4650      	mov	r0, sl
 804d2c8:	4659      	mov	r1, fp
 804d2ca:	f7f2 ffb9 	bl	8040240 <__aeabi_dsub>
 804d2ce:	e6db      	b.n	804d088 <__ieee754_log+0x28>
 804d2d0:	a321      	add	r3, pc, #132	@ (adr r3, 804d358 <__ieee754_log+0x2f8>)
 804d2d2:	e9d3 2300 	ldrd	r2, r3, [r3]
 804d2d6:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 804d2da:	f7f3 f969 	bl	80405b0 <__aeabi_dmul>
 804d2de:	4604      	mov	r4, r0
 804d2e0:	460d      	mov	r5, r1
 804d2e2:	a31f      	add	r3, pc, #124	@ (adr r3, 804d360 <__ieee754_log+0x300>)
 804d2e4:	e9d3 2300 	ldrd	r2, r3, [r3]
 804d2e8:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 804d2ec:	f7f3 f960 	bl	80405b0 <__aeabi_dmul>
 804d2f0:	4642      	mov	r2, r8
 804d2f2:	464b      	mov	r3, r9
 804d2f4:	f7f2 ffa6 	bl	8040244 <__adddf3>
 804d2f8:	4602      	mov	r2, r0
 804d2fa:	460b      	mov	r3, r1
 804d2fc:	4630      	mov	r0, r6
 804d2fe:	4639      	mov	r1, r7
 804d300:	f7f2 ff9e 	bl	8040240 <__aeabi_dsub>
 804d304:	4652      	mov	r2, sl
 804d306:	465b      	mov	r3, fp
 804d308:	f7f2 ff9a 	bl	8040240 <__aeabi_dsub>
 804d30c:	4602      	mov	r2, r0
 804d30e:	460b      	mov	r3, r1
 804d310:	4620      	mov	r0, r4
 804d312:	4629      	mov	r1, r5
 804d314:	e7d9      	b.n	804d2ca <__ieee754_log+0x26a>
 804d316:	4602      	mov	r2, r0
 804d318:	460b      	mov	r3, r1
 804d31a:	4650      	mov	r0, sl
 804d31c:	4659      	mov	r1, fp
 804d31e:	f7f2 ff8f 	bl	8040240 <__aeabi_dsub>
 804d322:	e9dd 2300 	ldrd	r2, r3, [sp]
 804d326:	f7f3 f943 	bl	80405b0 <__aeabi_dmul>
 804d32a:	4606      	mov	r6, r0
 804d32c:	460f      	mov	r7, r1
 804d32e:	2c00      	cmp	r4, #0
 804d330:	f43f af25 	beq.w	804d17e <__ieee754_log+0x11e>
 804d334:	a308      	add	r3, pc, #32	@ (adr r3, 804d358 <__ieee754_log+0x2f8>)
 804d336:	e9d3 2300 	ldrd	r2, r3, [r3]
 804d33a:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 804d33e:	f7f3 f937 	bl	80405b0 <__aeabi_dmul>
 804d342:	4604      	mov	r4, r0
 804d344:	460d      	mov	r5, r1
 804d346:	a306      	add	r3, pc, #24	@ (adr r3, 804d360 <__ieee754_log+0x300>)
 804d348:	e9d3 2300 	ldrd	r2, r3, [r3]
 804d34c:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 804d350:	e729      	b.n	804d1a6 <__ieee754_log+0x146>
 804d352:	ed9f 0b15 	vldr	d0, [pc, #84]	@ 804d3a8 <__ieee754_log+0x348>
 804d356:	e699      	b.n	804d08c <__ieee754_log+0x2c>
 804d358:	fee00000 	.word	0xfee00000
 804d35c:	3fe62e42 	.word	0x3fe62e42
 804d360:	35793c76 	.word	0x35793c76
 804d364:	3dea39ef 	.word	0x3dea39ef
 804d368:	55555555 	.word	0x55555555
 804d36c:	3fd55555 	.word	0x3fd55555
 804d370:	df3e5244 	.word	0xdf3e5244
 804d374:	3fc2f112 	.word	0x3fc2f112
 804d378:	96cb03de 	.word	0x96cb03de
 804d37c:	3fc74664 	.word	0x3fc74664
 804d380:	94229359 	.word	0x94229359
 804d384:	3fd24924 	.word	0x3fd24924
 804d388:	55555593 	.word	0x55555593
 804d38c:	3fe55555 	.word	0x3fe55555
 804d390:	d078c69f 	.word	0xd078c69f
 804d394:	3fc39a09 	.word	0x3fc39a09
 804d398:	1d8e78af 	.word	0x1d8e78af
 804d39c:	3fcc71c5 	.word	0x3fcc71c5
 804d3a0:	9997fa04 	.word	0x9997fa04
 804d3a4:	3fd99999 	.word	0x3fd99999
	...
 804d3b0:	c3500000 	.word	0xc3500000
 804d3b4:	43500000 	.word	0x43500000
 804d3b8:	7fefffff 	.word	0x7fefffff
 804d3bc:	3ff00000 	.word	0x3ff00000
 804d3c0:	3fe00000 	.word	0x3fe00000

0804d3c4 <__kernel_cosf>:
 804d3c4:	ee10 3a10 	vmov	r3, s0
 804d3c8:	eef0 6a40 	vmov.f32	s13, s0
 804d3cc:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
 804d3d0:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
 804d3d4:	f1b3 5f48 	cmp.w	r3, #838860800	@ 0x32000000
 804d3d8:	d204      	bcs.n	804d3e4 <__kernel_cosf+0x20>
 804d3da:	eefd 7ae6 	vcvt.s32.f32	s15, s13
 804d3de:	ee17 2a90 	vmov	r2, s15
 804d3e2:	b342      	cbz	r2, 804d436 <__kernel_cosf+0x72>
 804d3e4:	ee26 7aa6 	vmul.f32	s14, s13, s13
 804d3e8:	eddf 7a1a 	vldr	s15, [pc, #104]	@ 804d454 <__kernel_cosf+0x90>
 804d3ec:	ed9f 6a1a 	vldr	s12, [pc, #104]	@ 804d458 <__kernel_cosf+0x94>
 804d3f0:	ee60 0ae6 	vnmul.f32	s1, s1, s13
 804d3f4:	4a19      	ldr	r2, [pc, #100]	@ (804d45c <__kernel_cosf+0x98>)
 804d3f6:	eea7 6a27 	vfma.f32	s12, s14, s15
 804d3fa:	eddf 7a19 	vldr	s15, [pc, #100]	@ 804d460 <__kernel_cosf+0x9c>
 804d3fe:	4293      	cmp	r3, r2
 804d400:	eee6 7a07 	vfma.f32	s15, s12, s14
 804d404:	ed9f 6a17 	vldr	s12, [pc, #92]	@ 804d464 <__kernel_cosf+0xa0>
 804d408:	eea7 6a87 	vfma.f32	s12, s15, s14
 804d40c:	eddf 7a16 	vldr	s15, [pc, #88]	@ 804d468 <__kernel_cosf+0xa4>
 804d410:	eee6 7a07 	vfma.f32	s15, s12, s14
 804d414:	ed9f 6a15 	vldr	s12, [pc, #84]	@ 804d46c <__kernel_cosf+0xa8>
 804d418:	eea7 6a87 	vfma.f32	s12, s15, s14
 804d41c:	eef6 7a00 	vmov.f32	s15, #96	@ 0x3f000000  0.5
 804d420:	ee67 7a27 	vmul.f32	s15, s14, s15
 804d424:	ee26 6a07 	vmul.f32	s12, s12, s14
 804d428:	eee7 0a06 	vfma.f32	s1, s14, s12
 804d42c:	d804      	bhi.n	804d438 <__kernel_cosf+0x74>
 804d42e:	ee77 7ae0 	vsub.f32	s15, s15, s1
 804d432:	ee30 0a67 	vsub.f32	s0, s0, s15
 804d436:	4770      	bx	lr
 804d438:	4a0d      	ldr	r2, [pc, #52]	@ (804d470 <__kernel_cosf+0xac>)
 804d43a:	4293      	cmp	r3, r2
 804d43c:	bf96      	itet	ls
 804d43e:	f103 437f 	addls.w	r3, r3, #4278190080	@ 0xff000000
 804d442:	eeb5 7a02 	vmovhi.f32	s14, #82	@ 0x3e900000  0.2812500
 804d446:	ee07 3a10 	vmovls	s14, r3
 804d44a:	ee30 0a47 	vsub.f32	s0, s0, s14
 804d44e:	ee77 7ac7 	vsub.f32	s15, s15, s14
 804d452:	e7ec      	b.n	804d42e <__kernel_cosf+0x6a>
 804d454:	ad47d74e 	.word	0xad47d74e
 804d458:	310f74f6 	.word	0x310f74f6
 804d45c:	3e999999 	.word	0x3e999999
 804d460:	b493f27c 	.word	0xb493f27c
 804d464:	37d00d01 	.word	0x37d00d01
 804d468:	bab60b61 	.word	0xbab60b61
 804d46c:	3d2aaaab 	.word	0x3d2aaaab
 804d470:	3f480000 	.word	0x3f480000

0804d474 <__kernel_sinf>:
 804d474:	ee10 3a10 	vmov	r3, s0
 804d478:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
 804d47c:	f1b3 5f48 	cmp.w	r3, #838860800	@ 0x32000000
 804d480:	d204      	bcs.n	804d48c <__kernel_sinf+0x18>
 804d482:	eefd 7ac0 	vcvt.s32.f32	s15, s0
 804d486:	ee17 3a90 	vmov	r3, s15
 804d48a:	b35b      	cbz	r3, 804d4e4 <__kernel_sinf+0x70>
 804d48c:	ee20 7a00 	vmul.f32	s14, s0, s0
 804d490:	eddf 7a15 	vldr	s15, [pc, #84]	@ 804d4e8 <__kernel_sinf+0x74>
 804d494:	ed9f 6a15 	vldr	s12, [pc, #84]	@ 804d4ec <__kernel_sinf+0x78>
 804d498:	eea7 6a27 	vfma.f32	s12, s14, s15
 804d49c:	eddf 7a14 	vldr	s15, [pc, #80]	@ 804d4f0 <__kernel_sinf+0x7c>
 804d4a0:	ee60 6a07 	vmul.f32	s13, s0, s14
 804d4a4:	eee6 7a07 	vfma.f32	s15, s12, s14
 804d4a8:	ed9f 6a12 	vldr	s12, [pc, #72]	@ 804d4f4 <__kernel_sinf+0x80>
 804d4ac:	eea7 6a87 	vfma.f32	s12, s15, s14
 804d4b0:	eddf 7a11 	vldr	s15, [pc, #68]	@ 804d4f8 <__kernel_sinf+0x84>
 804d4b4:	eee6 7a07 	vfma.f32	s15, s12, s14
 804d4b8:	b930      	cbnz	r0, 804d4c8 <__kernel_sinf+0x54>
 804d4ba:	ed9f 6a10 	vldr	s12, [pc, #64]	@ 804d4fc <__kernel_sinf+0x88>
 804d4be:	eea7 6a27 	vfma.f32	s12, s14, s15
 804d4c2:	eea6 0a26 	vfma.f32	s0, s12, s13
 804d4c6:	4770      	bx	lr
 804d4c8:	ee67 7ae6 	vnmul.f32	s15, s15, s13
 804d4cc:	eeb6 6a00 	vmov.f32	s12, #96	@ 0x3f000000  0.5
 804d4d0:	eee0 7a86 	vfma.f32	s15, s1, s12
 804d4d4:	eed7 0a87 	vfnms.f32	s1, s15, s14
 804d4d8:	eddf 7a09 	vldr	s15, [pc, #36]	@ 804d500 <__kernel_sinf+0x8c>
 804d4dc:	eee6 0aa7 	vfma.f32	s1, s13, s15
 804d4e0:	ee30 0a60 	vsub.f32	s0, s0, s1
 804d4e4:	4770      	bx	lr
 804d4e6:	bf00      	nop
 804d4e8:	2f2ec9d3 	.word	0x2f2ec9d3
 804d4ec:	b2d72f34 	.word	0xb2d72f34
 804d4f0:	3638ef1b 	.word	0x3638ef1b
 804d4f4:	b9500d01 	.word	0xb9500d01
 804d4f8:	3c088889 	.word	0x3c088889
 804d4fc:	be2aaaab 	.word	0xbe2aaaab
 804d500:	3e2aaaab 	.word	0x3e2aaaab

0804d504 <__ieee754_expf>:
 804d504:	ee10 2a10 	vmov	r2, s0
 804d508:	f022 4300 	bic.w	r3, r2, #2147483648	@ 0x80000000
 804d50c:	f1b3 4fff 	cmp.w	r3, #2139095040	@ 0x7f800000
 804d510:	d902      	bls.n	804d518 <__ieee754_expf+0x14>
 804d512:	ee30 0a00 	vadd.f32	s0, s0, s0
 804d516:	4770      	bx	lr
 804d518:	ea4f 71d2 	mov.w	r1, r2, lsr #31
 804d51c:	d105      	bne.n	804d52a <__ieee754_expf+0x26>
 804d51e:	2900      	cmp	r1, #0
 804d520:	eddf 7a4d 	vldr	s15, [pc, #308]	@ 804d658 <__ieee754_expf+0x154>
 804d524:	fe00 0a27 	vseleq.f32	s0, s0, s15
 804d528:	4770      	bx	lr
 804d52a:	484c      	ldr	r0, [pc, #304]	@ (804d65c <__ieee754_expf+0x158>)
 804d52c:	4282      	cmp	r2, r0
 804d52e:	dd02      	ble.n	804d536 <__ieee754_expf+0x32>
 804d530:	2000      	movs	r0, #0
 804d532:	f000 baf9 	b.w	804db28 <__math_oflowf>
 804d536:	2a00      	cmp	r2, #0
 804d538:	da05      	bge.n	804d546 <__ieee754_expf+0x42>
 804d53a:	4a49      	ldr	r2, [pc, #292]	@ (804d660 <__ieee754_expf+0x15c>)
 804d53c:	4293      	cmp	r3, r2
 804d53e:	d902      	bls.n	804d546 <__ieee754_expf+0x42>
 804d540:	2000      	movs	r0, #0
 804d542:	f000 baeb 	b.w	804db1c <__math_uflowf>
 804d546:	4a47      	ldr	r2, [pc, #284]	@ (804d664 <__ieee754_expf+0x160>)
 804d548:	eef7 5a00 	vmov.f32	s11, #112	@ 0x3f800000  1.0
 804d54c:	4293      	cmp	r3, r2
 804d54e:	d952      	bls.n	804d5f6 <__ieee754_expf+0xf2>
 804d550:	4a45      	ldr	r2, [pc, #276]	@ (804d668 <__ieee754_expf+0x164>)
 804d552:	4293      	cmp	r3, r2
 804d554:	ea4f 0281 	mov.w	r2, r1, lsl #2
 804d558:	d834      	bhi.n	804d5c4 <__ieee754_expf+0xc0>
 804d55a:	4b44      	ldr	r3, [pc, #272]	@ (804d66c <__ieee754_expf+0x168>)
 804d55c:	4413      	add	r3, r2
 804d55e:	ed93 7a00 	vldr	s14, [r3]
 804d562:	4b43      	ldr	r3, [pc, #268]	@ (804d670 <__ieee754_expf+0x16c>)
 804d564:	ee30 7a47 	vsub.f32	s14, s0, s14
 804d568:	4413      	add	r3, r2
 804d56a:	f1c1 0201 	rsb	r2, r1, #1
 804d56e:	edd3 7a00 	vldr	s15, [r3]
 804d572:	1a52      	subs	r2, r2, r1
 804d574:	ee37 0a67 	vsub.f32	s0, s14, s15
 804d578:	ee20 6a00 	vmul.f32	s12, s0, s0
 804d57c:	ed9f 5a3d 	vldr	s10, [pc, #244]	@ 804d674 <__ieee754_expf+0x170>
 804d580:	eddf 6a3d 	vldr	s13, [pc, #244]	@ 804d678 <__ieee754_expf+0x174>
 804d584:	eee6 6a05 	vfma.f32	s13, s12, s10
 804d588:	ed9f 5a3c 	vldr	s10, [pc, #240]	@ 804d67c <__ieee754_expf+0x178>
 804d58c:	eea6 5a86 	vfma.f32	s10, s13, s12
 804d590:	eddf 6a3b 	vldr	s13, [pc, #236]	@ 804d680 <__ieee754_expf+0x17c>
 804d594:	eee5 6a06 	vfma.f32	s13, s10, s12
 804d598:	ed9f 5a3a 	vldr	s10, [pc, #232]	@ 804d684 <__ieee754_expf+0x180>
 804d59c:	eea6 5a86 	vfma.f32	s10, s13, s12
 804d5a0:	eef0 6a40 	vmov.f32	s13, s0
 804d5a4:	eee5 6a46 	vfms.f32	s13, s10, s12
 804d5a8:	eeb0 6a00 	vmov.f32	s12, #0	@ 0x40000000  2.0
 804d5ac:	ee20 5a26 	vmul.f32	s10, s0, s13
 804d5b0:	bb92      	cbnz	r2, 804d618 <__ieee754_expf+0x114>
 804d5b2:	ee76 6ac6 	vsub.f32	s13, s13, s12
 804d5b6:	eec5 7a26 	vdiv.f32	s15, s10, s13
 804d5ba:	ee37 0ac0 	vsub.f32	s0, s15, s0
 804d5be:	ee35 0ac0 	vsub.f32	s0, s11, s0
 804d5c2:	4770      	bx	lr
 804d5c4:	4b30      	ldr	r3, [pc, #192]	@ (804d688 <__ieee754_expf+0x184>)
 804d5c6:	ed9f 7a31 	vldr	s14, [pc, #196]	@ 804d68c <__ieee754_expf+0x188>
 804d5ca:	4413      	add	r3, r2
 804d5cc:	eddf 6a30 	vldr	s13, [pc, #192]	@ 804d690 <__ieee754_expf+0x18c>
 804d5d0:	edd3 7a00 	vldr	s15, [r3]
 804d5d4:	eee0 7a07 	vfma.f32	s15, s0, s14
 804d5d8:	eeb0 7a40 	vmov.f32	s14, s0
 804d5dc:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 804d5e0:	ee17 2a90 	vmov	r2, s15
 804d5e4:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 804d5e8:	eea7 7ae6 	vfms.f32	s14, s15, s13
 804d5ec:	eddf 6a29 	vldr	s13, [pc, #164]	@ 804d694 <__ieee754_expf+0x190>
 804d5f0:	ee67 7aa6 	vmul.f32	s15, s15, s13
 804d5f4:	e7be      	b.n	804d574 <__ieee754_expf+0x70>
 804d5f6:	f1b3 5f50 	cmp.w	r3, #872415232	@ 0x34000000
 804d5fa:	d20b      	bcs.n	804d614 <__ieee754_expf+0x110>
 804d5fc:	eddf 6a26 	vldr	s13, [pc, #152]	@ 804d698 <__ieee754_expf+0x194>
 804d600:	ee70 6a26 	vadd.f32	s13, s0, s13
 804d604:	eef4 6ae5 	vcmpe.f32	s13, s11
 804d608:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 804d60c:	dd02      	ble.n	804d614 <__ieee754_expf+0x110>
 804d60e:	ee30 0a25 	vadd.f32	s0, s0, s11
 804d612:	4770      	bx	lr
 804d614:	2200      	movs	r2, #0
 804d616:	e7af      	b.n	804d578 <__ieee754_expf+0x74>
 804d618:	ee36 6a66 	vsub.f32	s12, s12, s13
 804d61c:	f112 0f7d 	cmn.w	r2, #125	@ 0x7d
 804d620:	bfb8      	it	lt
 804d622:	3264      	addlt	r2, #100	@ 0x64
 804d624:	eec5 6a06 	vdiv.f32	s13, s10, s12
 804d628:	ee77 7ae6 	vsub.f32	s15, s15, s13
 804d62c:	ee77 7ac7 	vsub.f32	s15, s15, s14
 804d630:	ee75 7ae7 	vsub.f32	s15, s11, s15
 804d634:	ee17 3a90 	vmov	r3, s15
 804d638:	bfb5      	itete	lt
 804d63a:	eddf 7a18 	vldrlt	s15, [pc, #96]	@ 804d69c <__ieee754_expf+0x198>
 804d63e:	eb03 53c2 	addge.w	r3, r3, r2, lsl #23
 804d642:	eb03 53c2 	addlt.w	r3, r3, r2, lsl #23
 804d646:	ee00 3a10 	vmovge	s0, r3
 804d64a:	bfbc      	itt	lt
 804d64c:	ee00 3a10 	vmovlt	s0, r3
 804d650:	ee20 0a27 	vmullt.f32	s0, s0, s15
 804d654:	4770      	bx	lr
 804d656:	bf00      	nop
 804d658:	00000000 	.word	0x00000000
 804d65c:	42b17217 	.word	0x42b17217
 804d660:	42cff1b5 	.word	0x42cff1b5
 804d664:	3eb17218 	.word	0x3eb17218
 804d668:	3f851591 	.word	0x3f851591
 804d66c:	0804e62c 	.word	0x0804e62c
 804d670:	0804e624 	.word	0x0804e624
 804d674:	3331bb4c 	.word	0x3331bb4c
 804d678:	b5ddea0e 	.word	0xb5ddea0e
 804d67c:	388ab355 	.word	0x388ab355
 804d680:	bb360b61 	.word	0xbb360b61
 804d684:	3e2aaaab 	.word	0x3e2aaaab
 804d688:	0804e634 	.word	0x0804e634
 804d68c:	3fb8aa3b 	.word	0x3fb8aa3b
 804d690:	3f317180 	.word	0x3f317180
 804d694:	3717f7d1 	.word	0x3717f7d1
 804d698:	7149f2ca 	.word	0x7149f2ca
 804d69c:	0d800000 	.word	0x0d800000

0804d6a0 <__ieee754_logf>:
 804d6a0:	ee10 3a10 	vmov	r3, s0
 804d6a4:	f033 4200 	bics.w	r2, r3, #2147483648	@ 0x80000000
 804d6a8:	d106      	bne.n	804d6b8 <__ieee754_logf+0x18>
 804d6aa:	ed9f 7a65 	vldr	s14, [pc, #404]	@ 804d840 <__ieee754_logf+0x1a0>
 804d6ae:	eddf 7a65 	vldr	s15, [pc, #404]	@ 804d844 <__ieee754_logf+0x1a4>
 804d6b2:	ee87 0a27 	vdiv.f32	s0, s14, s15
 804d6b6:	4770      	bx	lr
 804d6b8:	2b00      	cmp	r3, #0
 804d6ba:	461a      	mov	r2, r3
 804d6bc:	da02      	bge.n	804d6c4 <__ieee754_logf+0x24>
 804d6be:	ee30 7a40 	vsub.f32	s14, s0, s0
 804d6c2:	e7f4      	b.n	804d6ae <__ieee754_logf+0xe>
 804d6c4:	f1b3 4fff 	cmp.w	r3, #2139095040	@ 0x7f800000
 804d6c8:	db02      	blt.n	804d6d0 <__ieee754_logf+0x30>
 804d6ca:	ee30 0a00 	vadd.f32	s0, s0, s0
 804d6ce:	4770      	bx	lr
 804d6d0:	f5b3 0f00 	cmp.w	r3, #8388608	@ 0x800000
 804d6d4:	485c      	ldr	r0, [pc, #368]	@ (804d848 <__ieee754_logf+0x1a8>)
 804d6d6:	bfbb      	ittet	lt
 804d6d8:	eddf 7a5c 	vldrlt	s15, [pc, #368]	@ 804d84c <__ieee754_logf+0x1ac>
 804d6dc:	f06f 0118 	mvnlt.w	r1, #24
 804d6e0:	2100      	movge	r1, #0
 804d6e2:	ee60 7a27 	vmullt.f32	s15, s0, s15
 804d6e6:	bfb8      	it	lt
 804d6e8:	ee17 2a90 	vmovlt	r2, s15
 804d6ec:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 804d6f0:	15d3      	asrs	r3, r2, #23
 804d6f2:	f3c2 0216 	ubfx	r2, r2, #0, #23
 804d6f6:	3b7f      	subs	r3, #127	@ 0x7f
 804d6f8:	4410      	add	r0, r2
 804d6fa:	440b      	add	r3, r1
 804d6fc:	f400 0100 	and.w	r1, r0, #8388608	@ 0x800000
 804d700:	f081 517e 	eor.w	r1, r1, #1065353216	@ 0x3f800000
 804d704:	eb03 53d0 	add.w	r3, r3, r0, lsr #23
 804d708:	f102 000f 	add.w	r0, r2, #15
 804d70c:	4311      	orrs	r1, r2
 804d70e:	ee00 1a10 	vmov	s0, r1
 804d712:	494f      	ldr	r1, [pc, #316]	@ (804d850 <__ieee754_logf+0x1b0>)
 804d714:	4001      	ands	r1, r0
 804d716:	ee30 0a67 	vsub.f32	s0, s0, s15
 804d71a:	bb89      	cbnz	r1, 804d780 <__ieee754_logf+0xe0>
 804d71c:	eeb5 0a40 	vcmp.f32	s0, #0.0
 804d720:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 804d724:	d10f      	bne.n	804d746 <__ieee754_logf+0xa6>
 804d726:	2b00      	cmp	r3, #0
 804d728:	f000 8087 	beq.w	804d83a <__ieee754_logf+0x19a>
 804d72c:	ee07 3a90 	vmov	s15, r3
 804d730:	ed9f 0a48 	vldr	s0, [pc, #288]	@ 804d854 <__ieee754_logf+0x1b4>
 804d734:	ed9f 7a48 	vldr	s14, [pc, #288]	@ 804d858 <__ieee754_logf+0x1b8>
 804d738:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 804d73c:	ee27 0a80 	vmul.f32	s0, s15, s0
 804d740:	eea7 0a87 	vfma.f32	s0, s15, s14
 804d744:	4770      	bx	lr
 804d746:	eef6 7a00 	vmov.f32	s15, #96	@ 0x3f000000  0.5
 804d74a:	eddf 6a44 	vldr	s13, [pc, #272]	@ 804d85c <__ieee754_logf+0x1bc>
 804d74e:	ee20 7a00 	vmul.f32	s14, s0, s0
 804d752:	eee0 7a66 	vfms.f32	s15, s0, s13
 804d756:	ee27 7a27 	vmul.f32	s14, s14, s15
 804d75a:	b913      	cbnz	r3, 804d762 <__ieee754_logf+0xc2>
 804d75c:	ee30 0a47 	vsub.f32	s0, s0, s14
 804d760:	4770      	bx	lr
 804d762:	ee07 3a90 	vmov	s15, r3
 804d766:	eddf 6a3b 	vldr	s13, [pc, #236]	@ 804d854 <__ieee754_logf+0x1b4>
 804d76a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 804d76e:	eea7 7ae6 	vfms.f32	s14, s15, s13
 804d772:	ee37 0a40 	vsub.f32	s0, s14, s0
 804d776:	ed9f 7a38 	vldr	s14, [pc, #224]	@ 804d858 <__ieee754_logf+0x1b8>
 804d77a:	ee97 0a87 	vfnms.f32	s0, s15, s14
 804d77e:	4770      	bx	lr
 804d780:	eef0 7a00 	vmov.f32	s15, #0	@ 0x40000000  2.0
 804d784:	eddf 5a36 	vldr	s11, [pc, #216]	@ 804d860 <__ieee754_logf+0x1c0>
 804d788:	eddf 4a36 	vldr	s9, [pc, #216]	@ 804d864 <__ieee754_logf+0x1c4>
 804d78c:	4936      	ldr	r1, [pc, #216]	@ (804d868 <__ieee754_logf+0x1c8>)
 804d78e:	ee70 7a27 	vadd.f32	s15, s0, s15
 804d792:	4411      	add	r1, r2
 804d794:	f5c2 1257 	rsb	r2, r2, #3522560	@ 0x35c000
 804d798:	ee80 6a27 	vdiv.f32	s12, s0, s15
 804d79c:	ee07 3a90 	vmov	s15, r3
 804d7a0:	f502 7222 	add.w	r2, r2, #648	@ 0x288
 804d7a4:	430a      	orrs	r2, r1
 804d7a6:	eef8 6ae7 	vcvt.f32.s32	s13, s15
 804d7aa:	eddf 7a30 	vldr	s15, [pc, #192]	@ 804d86c <__ieee754_logf+0x1cc>
 804d7ae:	2a00      	cmp	r2, #0
 804d7b0:	ee26 5a06 	vmul.f32	s10, s12, s12
 804d7b4:	ee25 7a05 	vmul.f32	s14, s10, s10
 804d7b8:	eee7 7a25 	vfma.f32	s15, s14, s11
 804d7bc:	eddf 5a2c 	vldr	s11, [pc, #176]	@ 804d870 <__ieee754_logf+0x1d0>
 804d7c0:	eee7 5a87 	vfma.f32	s11, s15, s14
 804d7c4:	eddf 7a2b 	vldr	s15, [pc, #172]	@ 804d874 <__ieee754_logf+0x1d4>
 804d7c8:	eee7 7a24 	vfma.f32	s15, s14, s9
 804d7cc:	eddf 4a2a 	vldr	s9, [pc, #168]	@ 804d878 <__ieee754_logf+0x1d8>
 804d7d0:	eee7 4a87 	vfma.f32	s9, s15, s14
 804d7d4:	eddf 7a29 	vldr	s15, [pc, #164]	@ 804d87c <__ieee754_logf+0x1dc>
 804d7d8:	eee4 7a87 	vfma.f32	s15, s9, s14
 804d7dc:	ee67 7a85 	vmul.f32	s15, s15, s10
 804d7e0:	eee5 7a87 	vfma.f32	s15, s11, s14
 804d7e4:	dd1a      	ble.n	804d81c <__ieee754_logf+0x17c>
 804d7e6:	eeb6 7a00 	vmov.f32	s14, #96	@ 0x3f000000  0.5
 804d7ea:	ee20 7a07 	vmul.f32	s14, s0, s14
 804d7ee:	ee27 7a00 	vmul.f32	s14, s14, s0
 804d7f2:	ee77 7a87 	vadd.f32	s15, s15, s14
 804d7f6:	ee67 7a86 	vmul.f32	s15, s15, s12
 804d7fa:	b913      	cbnz	r3, 804d802 <__ieee754_logf+0x162>
 804d7fc:	ee37 7a67 	vsub.f32	s14, s14, s15
 804d800:	e7ac      	b.n	804d75c <__ieee754_logf+0xbc>
 804d802:	ed9f 6a14 	vldr	s12, [pc, #80]	@ 804d854 <__ieee754_logf+0x1b4>
 804d806:	eee6 7a86 	vfma.f32	s15, s13, s12
 804d80a:	ee37 7a67 	vsub.f32	s14, s14, s15
 804d80e:	ee37 0a40 	vsub.f32	s0, s14, s0
 804d812:	eddf 7a11 	vldr	s15, [pc, #68]	@ 804d858 <__ieee754_logf+0x1b8>
 804d816:	ee96 0aa7 	vfnms.f32	s0, s13, s15
 804d81a:	4770      	bx	lr
 804d81c:	ee70 7a67 	vsub.f32	s15, s0, s15
 804d820:	ee67 7a86 	vmul.f32	s15, s15, s12
 804d824:	b913      	cbnz	r3, 804d82c <__ieee754_logf+0x18c>
 804d826:	ee30 0a67 	vsub.f32	s0, s0, s15
 804d82a:	4770      	bx	lr
 804d82c:	ed9f 7a09 	vldr	s14, [pc, #36]	@ 804d854 <__ieee754_logf+0x1b4>
 804d830:	eee6 7ac7 	vfms.f32	s15, s13, s14
 804d834:	ee37 0ac0 	vsub.f32	s0, s15, s0
 804d838:	e7eb      	b.n	804d812 <__ieee754_logf+0x172>
 804d83a:	ed9f 0a02 	vldr	s0, [pc, #8]	@ 804d844 <__ieee754_logf+0x1a4>
 804d83e:	4770      	bx	lr
 804d840:	cc000000 	.word	0xcc000000
 804d844:	00000000 	.word	0x00000000
 804d848:	004afb20 	.word	0x004afb20
 804d84c:	4c000000 	.word	0x4c000000
 804d850:	007ffff0 	.word	0x007ffff0
 804d854:	3717f7d1 	.word	0x3717f7d1
 804d858:	3f317180 	.word	0x3f317180
 804d85c:	3eaaaaab 	.word	0x3eaaaaab
 804d860:	3e1cd04f 	.word	0x3e1cd04f
 804d864:	3e178897 	.word	0x3e178897
 804d868:	ffcf5c30 	.word	0xffcf5c30
 804d86c:	3e638e29 	.word	0x3e638e29
 804d870:	3ecccccd 	.word	0x3ecccccd
 804d874:	3e3a3325 	.word	0x3e3a3325
 804d878:	3e924925 	.word	0x3e924925
 804d87c:	3f2aaaab 	.word	0x3f2aaaab

0804d880 <__ieee754_rem_pio2f>:
 804d880:	b5f0      	push	{r4, r5, r6, r7, lr}
 804d882:	ee10 6a10 	vmov	r6, s0
 804d886:	4b87      	ldr	r3, [pc, #540]	@ (804daa4 <__ieee754_rem_pio2f+0x224>)
 804d888:	b087      	sub	sp, #28
 804d88a:	4604      	mov	r4, r0
 804d88c:	f026 4500 	bic.w	r5, r6, #2147483648	@ 0x80000000
 804d890:	429d      	cmp	r5, r3
 804d892:	d805      	bhi.n	804d8a0 <__ieee754_rem_pio2f+0x20>
 804d894:	2300      	movs	r3, #0
 804d896:	ed80 0a00 	vstr	s0, [r0]
 804d89a:	6043      	str	r3, [r0, #4]
 804d89c:	2000      	movs	r0, #0
 804d89e:	e022      	b.n	804d8e6 <__ieee754_rem_pio2f+0x66>
 804d8a0:	4b81      	ldr	r3, [pc, #516]	@ (804daa8 <__ieee754_rem_pio2f+0x228>)
 804d8a2:	429d      	cmp	r5, r3
 804d8a4:	d83a      	bhi.n	804d91c <__ieee754_rem_pio2f+0x9c>
 804d8a6:	f026 4300 	bic.w	r3, r6, #2147483648	@ 0x80000000
 804d8aa:	2e00      	cmp	r6, #0
 804d8ac:	ed9f 7a7f 	vldr	s14, [pc, #508]	@ 804daac <__ieee754_rem_pio2f+0x22c>
 804d8b0:	f023 030f 	bic.w	r3, r3, #15
 804d8b4:	4a7e      	ldr	r2, [pc, #504]	@ (804dab0 <__ieee754_rem_pio2f+0x230>)
 804d8b6:	dd18      	ble.n	804d8ea <__ieee754_rem_pio2f+0x6a>
 804d8b8:	4293      	cmp	r3, r2
 804d8ba:	ee70 7a47 	vsub.f32	s15, s0, s14
 804d8be:	bf09      	itett	eq
 804d8c0:	ed9f 7a7c 	vldreq	s14, [pc, #496]	@ 804dab4 <__ieee754_rem_pio2f+0x234>
 804d8c4:	eddf 6a7c 	vldrne	s13, [pc, #496]	@ 804dab8 <__ieee754_rem_pio2f+0x238>
 804d8c8:	ee77 7ac7 	vsubeq.f32	s15, s15, s14
 804d8cc:	eddf 6a7b 	vldreq	s13, [pc, #492]	@ 804dabc <__ieee754_rem_pio2f+0x23c>
 804d8d0:	ee37 7ae6 	vsub.f32	s14, s15, s13
 804d8d4:	ee77 7ac7 	vsub.f32	s15, s15, s14
 804d8d8:	ed80 7a00 	vstr	s14, [r0]
 804d8dc:	ee77 7ae6 	vsub.f32	s15, s15, s13
 804d8e0:	edc0 7a01 	vstr	s15, [r0, #4]
 804d8e4:	2001      	movs	r0, #1
 804d8e6:	b007      	add	sp, #28
 804d8e8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 804d8ea:	4293      	cmp	r3, r2
 804d8ec:	ee70 7a07 	vadd.f32	s15, s0, s14
 804d8f0:	bf09      	itett	eq
 804d8f2:	ed9f 7a70 	vldreq	s14, [pc, #448]	@ 804dab4 <__ieee754_rem_pio2f+0x234>
 804d8f6:	eddf 6a70 	vldrne	s13, [pc, #448]	@ 804dab8 <__ieee754_rem_pio2f+0x238>
 804d8fa:	ee77 7a87 	vaddeq.f32	s15, s15, s14
 804d8fe:	eddf 6a6f 	vldreq	s13, [pc, #444]	@ 804dabc <__ieee754_rem_pio2f+0x23c>
 804d902:	ee37 7aa6 	vadd.f32	s14, s15, s13
 804d906:	ee77 7ac7 	vsub.f32	s15, s15, s14
 804d90a:	ed80 7a00 	vstr	s14, [r0]
 804d90e:	ee77 7aa6 	vadd.f32	s15, s15, s13
 804d912:	edc0 7a01 	vstr	s15, [r0, #4]
 804d916:	f04f 30ff 	mov.w	r0, #4294967295
 804d91a:	e7e4      	b.n	804d8e6 <__ieee754_rem_pio2f+0x66>
 804d91c:	4b68      	ldr	r3, [pc, #416]	@ (804dac0 <__ieee754_rem_pio2f+0x240>)
 804d91e:	429d      	cmp	r5, r3
 804d920:	d872      	bhi.n	804da08 <__ieee754_rem_pio2f+0x188>
 804d922:	f000 f8db 	bl	804dadc <fabsf>
 804d926:	eef6 7a00 	vmov.f32	s15, #96	@ 0x3f000000  0.5
 804d92a:	ed9f 7a66 	vldr	s14, [pc, #408]	@ 804dac4 <__ieee754_rem_pio2f+0x244>
 804d92e:	eee0 7a07 	vfma.f32	s15, s0, s14
 804d932:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 804d936:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 804d93a:	ee17 0a90 	vmov	r0, s15
 804d93e:	eddf 7a5b 	vldr	s15, [pc, #364]	@ 804daac <__ieee754_rem_pio2f+0x22c>
 804d942:	281f      	cmp	r0, #31
 804d944:	eea7 0a67 	vfms.f32	s0, s14, s15
 804d948:	eddf 7a5b 	vldr	s15, [pc, #364]	@ 804dab8 <__ieee754_rem_pio2f+0x238>
 804d94c:	eeb1 6a47 	vneg.f32	s12, s14
 804d950:	ee67 7a27 	vmul.f32	s15, s14, s15
 804d954:	ee70 6a67 	vsub.f32	s13, s0, s15
 804d958:	ee16 1a90 	vmov	r1, s13
 804d95c:	dc09      	bgt.n	804d972 <__ieee754_rem_pio2f+0xf2>
 804d95e:	f026 4300 	bic.w	r3, r6, #2147483648	@ 0x80000000
 804d962:	1e47      	subs	r7, r0, #1
 804d964:	4a58      	ldr	r2, [pc, #352]	@ (804dac8 <__ieee754_rem_pio2f+0x248>)
 804d966:	f023 03ff 	bic.w	r3, r3, #255	@ 0xff
 804d96a:	f852 2027 	ldr.w	r2, [r2, r7, lsl #2]
 804d96e:	4293      	cmp	r3, r2
 804d970:	d106      	bne.n	804d980 <__ieee754_rem_pio2f+0x100>
 804d972:	f3c1 52c7 	ubfx	r2, r1, #23, #8
 804d976:	15eb      	asrs	r3, r5, #23
 804d978:	ebc2 52d5 	rsb	r2, r2, r5, lsr #23
 804d97c:	2a08      	cmp	r2, #8
 804d97e:	dc14      	bgt.n	804d9aa <__ieee754_rem_pio2f+0x12a>
 804d980:	6021      	str	r1, [r4, #0]
 804d982:	ed94 7a00 	vldr	s14, [r4]
 804d986:	2e00      	cmp	r6, #0
 804d988:	ee30 0a47 	vsub.f32	s0, s0, s14
 804d98c:	ee30 0a67 	vsub.f32	s0, s0, s15
 804d990:	ed84 0a01 	vstr	s0, [r4, #4]
 804d994:	daa7      	bge.n	804d8e6 <__ieee754_rem_pio2f+0x66>
 804d996:	eeb1 7a47 	vneg.f32	s14, s14
 804d99a:	eeb1 0a40 	vneg.f32	s0, s0
 804d99e:	ed84 7a00 	vstr	s14, [r4]
 804d9a2:	ed84 0a01 	vstr	s0, [r4, #4]
 804d9a6:	4240      	negs	r0, r0
 804d9a8:	e79d      	b.n	804d8e6 <__ieee754_rem_pio2f+0x66>
 804d9aa:	eef0 6a40 	vmov.f32	s13, s0
 804d9ae:	eddf 5a41 	vldr	s11, [pc, #260]	@ 804dab4 <__ieee754_rem_pio2f+0x234>
 804d9b2:	eee6 6a25 	vfma.f32	s13, s12, s11
 804d9b6:	ee70 7a66 	vsub.f32	s15, s0, s13
 804d9ba:	eee6 7a25 	vfma.f32	s15, s12, s11
 804d9be:	eddf 5a3f 	vldr	s11, [pc, #252]	@ 804dabc <__ieee754_rem_pio2f+0x23c>
 804d9c2:	eed7 7a25 	vfnms.f32	s15, s14, s11
 804d9c6:	ee76 5ae7 	vsub.f32	s11, s13, s15
 804d9ca:	ee15 2a90 	vmov	r2, s11
 804d9ce:	f3c2 51c7 	ubfx	r1, r2, #23, #8
 804d9d2:	1a5b      	subs	r3, r3, r1
 804d9d4:	2b19      	cmp	r3, #25
 804d9d6:	dc04      	bgt.n	804d9e2 <__ieee754_rem_pio2f+0x162>
 804d9d8:	eeb0 0a66 	vmov.f32	s0, s13
 804d9dc:	edc4 5a00 	vstr	s11, [r4]
 804d9e0:	e7cf      	b.n	804d982 <__ieee754_rem_pio2f+0x102>
 804d9e2:	eeb0 0a66 	vmov.f32	s0, s13
 804d9e6:	eddf 5a39 	vldr	s11, [pc, #228]	@ 804dacc <__ieee754_rem_pio2f+0x24c>
 804d9ea:	eea6 0a25 	vfma.f32	s0, s12, s11
 804d9ee:	ee76 7ac0 	vsub.f32	s15, s13, s0
 804d9f2:	eddf 6a37 	vldr	s13, [pc, #220]	@ 804dad0 <__ieee754_rem_pio2f+0x250>
 804d9f6:	eee6 7a25 	vfma.f32	s15, s12, s11
 804d9fa:	eed7 7a26 	vfnms.f32	s15, s14, s13
 804d9fe:	ee30 7a67 	vsub.f32	s14, s0, s15
 804da02:	ed84 7a00 	vstr	s14, [r4]
 804da06:	e7bc      	b.n	804d982 <__ieee754_rem_pio2f+0x102>
 804da08:	f1b5 4fff 	cmp.w	r5, #2139095040	@ 0x7f800000
 804da0c:	d306      	bcc.n	804da1c <__ieee754_rem_pio2f+0x19c>
 804da0e:	ee70 7a40 	vsub.f32	s15, s0, s0
 804da12:	edc0 7a01 	vstr	s15, [r0, #4]
 804da16:	edc0 7a00 	vstr	s15, [r0]
 804da1a:	e73f      	b.n	804d89c <__ieee754_rem_pio2f+0x1c>
 804da1c:	15ea      	asrs	r2, r5, #23
 804da1e:	eddf 6a2d 	vldr	s13, [pc, #180]	@ 804dad4 <__ieee754_rem_pio2f+0x254>
 804da22:	3a86      	subs	r2, #134	@ 0x86
 804da24:	eba5 53c2 	sub.w	r3, r5, r2, lsl #23
 804da28:	ee07 3a90 	vmov	s15, r3
 804da2c:	eebd 7ae7 	vcvt.s32.f32	s14, s15
 804da30:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 804da34:	ee77 7ac7 	vsub.f32	s15, s15, s14
 804da38:	ed8d 7a03 	vstr	s14, [sp, #12]
 804da3c:	ee67 7aa6 	vmul.f32	s15, s15, s13
 804da40:	eebd 7ae7 	vcvt.s32.f32	s14, s15
 804da44:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 804da48:	ee77 7ac7 	vsub.f32	s15, s15, s14
 804da4c:	ed8d 7a04 	vstr	s14, [sp, #16]
 804da50:	ee67 7aa6 	vmul.f32	s15, s15, s13
 804da54:	eef5 7a40 	vcmp.f32	s15, #0.0
 804da58:	edcd 7a05 	vstr	s15, [sp, #20]
 804da5c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 804da60:	d11e      	bne.n	804daa0 <__ieee754_rem_pio2f+0x220>
 804da62:	eeb5 7a40 	vcmp.f32	s14, #0.0
 804da66:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 804da6a:	bf0c      	ite	eq
 804da6c:	2301      	moveq	r3, #1
 804da6e:	2302      	movne	r3, #2
 804da70:	4919      	ldr	r1, [pc, #100]	@ (804dad8 <__ieee754_rem_pio2f+0x258>)
 804da72:	a803      	add	r0, sp, #12
 804da74:	9101      	str	r1, [sp, #4]
 804da76:	2102      	movs	r1, #2
 804da78:	9100      	str	r1, [sp, #0]
 804da7a:	4621      	mov	r1, r4
 804da7c:	f000 f85a 	bl	804db34 <__kernel_rem_pio2f>
 804da80:	2e00      	cmp	r6, #0
 804da82:	f6bf af30 	bge.w	804d8e6 <__ieee754_rem_pio2f+0x66>
 804da86:	edd4 7a00 	vldr	s15, [r4]
 804da8a:	eef1 7a67 	vneg.f32	s15, s15
 804da8e:	edc4 7a00 	vstr	s15, [r4]
 804da92:	edd4 7a01 	vldr	s15, [r4, #4]
 804da96:	eef1 7a67 	vneg.f32	s15, s15
 804da9a:	edc4 7a01 	vstr	s15, [r4, #4]
 804da9e:	e782      	b.n	804d9a6 <__ieee754_rem_pio2f+0x126>
 804daa0:	2303      	movs	r3, #3
 804daa2:	e7e5      	b.n	804da70 <__ieee754_rem_pio2f+0x1f0>
 804daa4:	3f490fd8 	.word	0x3f490fd8
 804daa8:	4016cbe3 	.word	0x4016cbe3
 804daac:	3fc90f80 	.word	0x3fc90f80
 804dab0:	3fc90fd0 	.word	0x3fc90fd0
 804dab4:	37354400 	.word	0x37354400
 804dab8:	37354443 	.word	0x37354443
 804dabc:	2e85a308 	.word	0x2e85a308
 804dac0:	43490f80 	.word	0x43490f80
 804dac4:	3f22f984 	.word	0x3f22f984
 804dac8:	0804e63c 	.word	0x0804e63c
 804dacc:	2e85a300 	.word	0x2e85a300
 804dad0:	248d3132 	.word	0x248d3132
 804dad4:	43800000 	.word	0x43800000
 804dad8:	0804e6bc 	.word	0x0804e6bc

0804dadc <fabsf>:
 804dadc:	ee10 3a10 	vmov	r3, s0
 804dae0:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
 804dae4:	ee00 3a10 	vmov	s0, r3
 804dae8:	4770      	bx	lr

0804daea <with_errnof>:
 804daea:	b510      	push	{r4, lr}
 804daec:	ed2d 8b02 	vpush	{d8}
 804daf0:	eeb0 8a40 	vmov.f32	s16, s0
 804daf4:	4604      	mov	r4, r0
 804daf6:	f7fe fa31 	bl	804bf5c <__errno>
 804dafa:	6004      	str	r4, [r0, #0]
 804dafc:	eeb0 0a48 	vmov.f32	s0, s16
 804db00:	ecbd 8b02 	vpop	{d8}
 804db04:	bd10      	pop	{r4, pc}

0804db06 <xflowf>:
 804db06:	b130      	cbz	r0, 804db16 <xflowf+0x10>
 804db08:	eef1 7a40 	vneg.f32	s15, s0
 804db0c:	ee27 0a80 	vmul.f32	s0, s15, s0
 804db10:	2022      	movs	r0, #34	@ 0x22
 804db12:	f7ff bfea 	b.w	804daea <with_errnof>
 804db16:	eef0 7a40 	vmov.f32	s15, s0
 804db1a:	e7f7      	b.n	804db0c <xflowf+0x6>

0804db1c <__math_uflowf>:
 804db1c:	ed9f 0a01 	vldr	s0, [pc, #4]	@ 804db24 <__math_uflowf+0x8>
 804db20:	f7ff bff1 	b.w	804db06 <xflowf>
 804db24:	10000000 	.word	0x10000000

0804db28 <__math_oflowf>:
 804db28:	ed9f 0a01 	vldr	s0, [pc, #4]	@ 804db30 <__math_oflowf+0x8>
 804db2c:	f7ff bfeb 	b.w	804db06 <xflowf>
 804db30:	70000000 	.word	0x70000000

0804db34 <__kernel_rem_pio2f>:
 804db34:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 804db38:	4690      	mov	r8, r2
 804db3a:	4abc      	ldr	r2, [pc, #752]	@ (804de2c <__kernel_rem_pio2f+0x2f8>)
 804db3c:	460f      	mov	r7, r1
 804db3e:	f103 3bff 	add.w	fp, r3, #4294967295
 804db42:	f118 0f04 	cmn.w	r8, #4
 804db46:	ed2d 8b04 	vpush	{d8-d9}
 804db4a:	b0d9      	sub	sp, #356	@ 0x164
 804db4c:	9001      	str	r0, [sp, #4]
 804db4e:	9866      	ldr	r0, [sp, #408]	@ 0x198
 804db50:	f852 a020 	ldr.w	sl, [r2, r0, lsl #2]
 804db54:	db27      	blt.n	804dba6 <__kernel_rem_pio2f+0x72>
 804db56:	f1b8 0203 	subs.w	r2, r8, #3
 804db5a:	bf48      	it	mi
 804db5c:	f108 0204 	addmi.w	r2, r8, #4
 804db60:	10d2      	asrs	r2, r2, #3
 804db62:	1c55      	adds	r5, r2, #1
 804db64:	eba2 060b 	sub.w	r6, r2, fp
 804db68:	9967      	ldr	r1, [sp, #412]	@ 0x19c
 804db6a:	eb0a 0c0b 	add.w	ip, sl, fp
 804db6e:	00e8      	lsls	r0, r5, #3
 804db70:	ac1c      	add	r4, sp, #112	@ 0x70
 804db72:	eba8 05c5 	sub.w	r5, r8, r5, lsl #3
 804db76:	ed9f 7ab1 	vldr	s14, [pc, #708]	@ 804de3c <__kernel_rem_pio2f+0x308>
 804db7a:	9002      	str	r0, [sp, #8]
 804db7c:	eb01 0e86 	add.w	lr, r1, r6, lsl #2
 804db80:	2000      	movs	r0, #0
 804db82:	4560      	cmp	r0, ip
 804db84:	dd11      	ble.n	804dbaa <__kernel_rem_pio2f+0x76>
 804db86:	a91c      	add	r1, sp, #112	@ 0x70
 804db88:	f50d 7988 	add.w	r9, sp, #272	@ 0x110
 804db8c:	f04f 0c00 	mov.w	ip, #0
 804db90:	eb01 0083 	add.w	r0, r1, r3, lsl #2
 804db94:	45d4      	cmp	ip, sl
 804db96:	dc29      	bgt.n	804dbec <__kernel_rem_pio2f+0xb8>
 804db98:	f8dd e004 	ldr.w	lr, [sp, #4]
 804db9c:	4606      	mov	r6, r0
 804db9e:	eddf 7aa7 	vldr	s15, [pc, #668]	@ 804de3c <__kernel_rem_pio2f+0x308>
 804dba2:	2400      	movs	r4, #0
 804dba4:	e018      	b.n	804dbd8 <__kernel_rem_pio2f+0xa4>
 804dba6:	2200      	movs	r2, #0
 804dba8:	e7db      	b.n	804db62 <__kernel_rem_pio2f+0x2e>
 804dbaa:	42c6      	cmn	r6, r0
 804dbac:	bf54      	ite	pl
 804dbae:	f85e 1020 	ldrpl.w	r1, [lr, r0, lsl #2]
 804dbb2:	eef0 7a47 	vmovmi.f32	s15, s14
 804dbb6:	f100 0001 	add.w	r0, r0, #1
 804dbba:	bf5c      	itt	pl
 804dbbc:	ee07 1a90 	vmovpl	s15, r1
 804dbc0:	eef8 7ae7 	vcvtpl.f32.s32	s15, s15
 804dbc4:	ece4 7a01 	vstmia	r4!, {s15}
 804dbc8:	e7db      	b.n	804db82 <__kernel_rem_pio2f+0x4e>
 804dbca:	ecfe 6a01 	vldmia	lr!, {s13}
 804dbce:	3401      	adds	r4, #1
 804dbd0:	ed96 7a00 	vldr	s14, [r6]
 804dbd4:	eee6 7a87 	vfma.f32	s15, s13, s14
 804dbd8:	455c      	cmp	r4, fp
 804dbda:	f1a6 0604 	sub.w	r6, r6, #4
 804dbde:	ddf4      	ble.n	804dbca <__kernel_rem_pio2f+0x96>
 804dbe0:	f10c 0c01 	add.w	ip, ip, #1
 804dbe4:	3004      	adds	r0, #4
 804dbe6:	ece9 7a01 	vstmia	r9!, {s15}
 804dbea:	e7d3      	b.n	804db94 <__kernel_rem_pio2f+0x60>
 804dbec:	a908      	add	r1, sp, #32
 804dbee:	4654      	mov	r4, sl
 804dbf0:	eddf 8a91 	vldr	s17, [pc, #580]	@ 804de38 <__kernel_rem_pio2f+0x304>
 804dbf4:	eb01 018a 	add.w	r1, r1, sl, lsl #2
 804dbf8:	ed9f 9a8e 	vldr	s18, [pc, #568]	@ 804de34 <__kernel_rem_pio2f+0x300>
 804dbfc:	9104      	str	r1, [sp, #16]
 804dbfe:	9967      	ldr	r1, [sp, #412]	@ 0x19c
 804dc00:	eb01 0282 	add.w	r2, r1, r2, lsl #2
 804dc04:	9203      	str	r2, [sp, #12]
 804dc06:	00a2      	lsls	r2, r4, #2
 804dc08:	a944      	add	r1, sp, #272	@ 0x110
 804dc0a:	4626      	mov	r6, r4
 804dc0c:	9205      	str	r2, [sp, #20]
 804dc0e:	aa58      	add	r2, sp, #352	@ 0x160
 804dc10:	eb01 0084 	add.w	r0, r1, r4, lsl #2
 804dc14:	eb02 0284 	add.w	r2, r2, r4, lsl #2
 804dc18:	ed12 0a14 	vldr	s0, [r2, #-80]	@ 0xffffffb0
 804dc1c:	aa08      	add	r2, sp, #32
 804dc1e:	4694      	mov	ip, r2
 804dc20:	2e00      	cmp	r6, #0
 804dc22:	f1a0 0004 	sub.w	r0, r0, #4
 804dc26:	dc4c      	bgt.n	804dcc2 <__kernel_rem_pio2f+0x18e>
 804dc28:	4628      	mov	r0, r5
 804dc2a:	e9cd 2306 	strd	r2, r3, [sp, #24]
 804dc2e:	f000 f9f5 	bl	804e01c <scalbnf>
 804dc32:	eeb0 8a40 	vmov.f32	s16, s0
 804dc36:	eeb4 0a00 	vmov.f32	s0, #64	@ 0x3e000000  0.125
 804dc3a:	ee28 0a00 	vmul.f32	s0, s16, s0
 804dc3e:	f000 fa51 	bl	804e0e4 <floorf>
 804dc42:	eef2 7a00 	vmov.f32	s15, #32	@ 0x41000000  8.0
 804dc46:	2d00      	cmp	r5, #0
 804dc48:	eea0 8a67 	vfms.f32	s16, s0, s15
 804dc4c:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
 804dc50:	eefd 7ac8 	vcvt.s32.f32	s15, s16
 804dc54:	ee17 9a90 	vmov	r9, s15
 804dc58:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 804dc5c:	ee38 8a67 	vsub.f32	s16, s16, s15
 804dc60:	dd41      	ble.n	804dce6 <__kernel_rem_pio2f+0x1b2>
 804dc62:	f104 3cff 	add.w	ip, r4, #4294967295
 804dc66:	a908      	add	r1, sp, #32
 804dc68:	f1c5 0e08 	rsb	lr, r5, #8
 804dc6c:	f851 602c 	ldr.w	r6, [r1, ip, lsl #2]
 804dc70:	fa46 f00e 	asr.w	r0, r6, lr
 804dc74:	4481      	add	r9, r0
 804dc76:	fa00 f00e 	lsl.w	r0, r0, lr
 804dc7a:	1a36      	subs	r6, r6, r0
 804dc7c:	f1c5 0007 	rsb	r0, r5, #7
 804dc80:	f841 602c 	str.w	r6, [r1, ip, lsl #2]
 804dc84:	4106      	asrs	r6, r0
 804dc86:	2e00      	cmp	r6, #0
 804dc88:	dd3c      	ble.n	804dd04 <__kernel_rem_pio2f+0x1d0>
 804dc8a:	f04f 0e00 	mov.w	lr, #0
 804dc8e:	f109 0901 	add.w	r9, r9, #1
 804dc92:	4670      	mov	r0, lr
 804dc94:	4574      	cmp	r4, lr
 804dc96:	dc68      	bgt.n	804dd6a <__kernel_rem_pio2f+0x236>
 804dc98:	2d00      	cmp	r5, #0
 804dc9a:	dd03      	ble.n	804dca4 <__kernel_rem_pio2f+0x170>
 804dc9c:	2d01      	cmp	r5, #1
 804dc9e:	d074      	beq.n	804dd8a <__kernel_rem_pio2f+0x256>
 804dca0:	2d02      	cmp	r5, #2
 804dca2:	d07d      	beq.n	804dda0 <__kernel_rem_pio2f+0x26c>
 804dca4:	2e02      	cmp	r6, #2
 804dca6:	d12d      	bne.n	804dd04 <__kernel_rem_pio2f+0x1d0>
 804dca8:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
 804dcac:	ee30 8a48 	vsub.f32	s16, s0, s16
 804dcb0:	b340      	cbz	r0, 804dd04 <__kernel_rem_pio2f+0x1d0>
 804dcb2:	4628      	mov	r0, r5
 804dcb4:	9306      	str	r3, [sp, #24]
 804dcb6:	f000 f9b1 	bl	804e01c <scalbnf>
 804dcba:	9b06      	ldr	r3, [sp, #24]
 804dcbc:	ee38 8a40 	vsub.f32	s16, s16, s0
 804dcc0:	e020      	b.n	804dd04 <__kernel_rem_pio2f+0x1d0>
 804dcc2:	ee60 7a28 	vmul.f32	s15, s0, s17
 804dcc6:	3e01      	subs	r6, #1
 804dcc8:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 804dccc:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 804dcd0:	eea7 0ac9 	vfms.f32	s0, s15, s18
 804dcd4:	eebd 0ac0 	vcvt.s32.f32	s0, s0
 804dcd8:	ecac 0a01 	vstmia	ip!, {s0}
 804dcdc:	ed90 0a00 	vldr	s0, [r0]
 804dce0:	ee37 0a80 	vadd.f32	s0, s15, s0
 804dce4:	e79c      	b.n	804dc20 <__kernel_rem_pio2f+0xec>
 804dce6:	d105      	bne.n	804dcf4 <__kernel_rem_pio2f+0x1c0>
 804dce8:	1e60      	subs	r0, r4, #1
 804dcea:	a908      	add	r1, sp, #32
 804dcec:	f851 6020 	ldr.w	r6, [r1, r0, lsl #2]
 804dcf0:	11f6      	asrs	r6, r6, #7
 804dcf2:	e7c8      	b.n	804dc86 <__kernel_rem_pio2f+0x152>
 804dcf4:	eef6 7a00 	vmov.f32	s15, #96	@ 0x3f000000  0.5
 804dcf8:	eeb4 8ae7 	vcmpe.f32	s16, s15
 804dcfc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 804dd00:	da31      	bge.n	804dd66 <__kernel_rem_pio2f+0x232>
 804dd02:	2600      	movs	r6, #0
 804dd04:	eeb5 8a40 	vcmp.f32	s16, #0.0
 804dd08:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 804dd0c:	f040 8098 	bne.w	804de40 <__kernel_rem_pio2f+0x30c>
 804dd10:	1e60      	subs	r0, r4, #1
 804dd12:	2200      	movs	r2, #0
 804dd14:	4550      	cmp	r0, sl
 804dd16:	da4b      	bge.n	804ddb0 <__kernel_rem_pio2f+0x27c>
 804dd18:	2a00      	cmp	r2, #0
 804dd1a:	d065      	beq.n	804dde8 <__kernel_rem_pio2f+0x2b4>
 804dd1c:	3c01      	subs	r4, #1
 804dd1e:	ab08      	add	r3, sp, #32
 804dd20:	3d08      	subs	r5, #8
 804dd22:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
 804dd26:	2b00      	cmp	r3, #0
 804dd28:	d0f8      	beq.n	804dd1c <__kernel_rem_pio2f+0x1e8>
 804dd2a:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
 804dd2e:	4628      	mov	r0, r5
 804dd30:	f000 f974 	bl	804e01c <scalbnf>
 804dd34:	1c63      	adds	r3, r4, #1
 804dd36:	aa44      	add	r2, sp, #272	@ 0x110
 804dd38:	ed9f 7a3f 	vldr	s14, [pc, #252]	@ 804de38 <__kernel_rem_pio2f+0x304>
 804dd3c:	0099      	lsls	r1, r3, #2
 804dd3e:	eb02 0283 	add.w	r2, r2, r3, lsl #2
 804dd42:	4623      	mov	r3, r4
 804dd44:	2b00      	cmp	r3, #0
 804dd46:	f280 80a9 	bge.w	804de9c <__kernel_rem_pio2f+0x368>
 804dd4a:	4623      	mov	r3, r4
 804dd4c:	2b00      	cmp	r3, #0
 804dd4e:	f2c0 80c7 	blt.w	804dee0 <__kernel_rem_pio2f+0x3ac>
 804dd52:	aa44      	add	r2, sp, #272	@ 0x110
 804dd54:	f8df c0d8 	ldr.w	ip, [pc, #216]	@ 804de30 <__kernel_rem_pio2f+0x2fc>
 804dd58:	eddf 7a38 	vldr	s15, [pc, #224]	@ 804de3c <__kernel_rem_pio2f+0x308>
 804dd5c:	2000      	movs	r0, #0
 804dd5e:	eb02 0583 	add.w	r5, r2, r3, lsl #2
 804dd62:	1ae2      	subs	r2, r4, r3
 804dd64:	e0b1      	b.n	804deca <__kernel_rem_pio2f+0x396>
 804dd66:	2602      	movs	r6, #2
 804dd68:	e78f      	b.n	804dc8a <__kernel_rem_pio2f+0x156>
 804dd6a:	f852 1b04 	ldr.w	r1, [r2], #4
 804dd6e:	b948      	cbnz	r0, 804dd84 <__kernel_rem_pio2f+0x250>
 804dd70:	b121      	cbz	r1, 804dd7c <__kernel_rem_pio2f+0x248>
 804dd72:	f5c1 7180 	rsb	r1, r1, #256	@ 0x100
 804dd76:	f842 1c04 	str.w	r1, [r2, #-4]
 804dd7a:	2101      	movs	r1, #1
 804dd7c:	f10e 0e01 	add.w	lr, lr, #1
 804dd80:	4608      	mov	r0, r1
 804dd82:	e787      	b.n	804dc94 <__kernel_rem_pio2f+0x160>
 804dd84:	f1c1 01ff 	rsb	r1, r1, #255	@ 0xff
 804dd88:	e7f5      	b.n	804dd76 <__kernel_rem_pio2f+0x242>
 804dd8a:	f104 3cff 	add.w	ip, r4, #4294967295
 804dd8e:	aa08      	add	r2, sp, #32
 804dd90:	f852 202c 	ldr.w	r2, [r2, ip, lsl #2]
 804dd94:	f002 027f 	and.w	r2, r2, #127	@ 0x7f
 804dd98:	a908      	add	r1, sp, #32
 804dd9a:	f841 202c 	str.w	r2, [r1, ip, lsl #2]
 804dd9e:	e781      	b.n	804dca4 <__kernel_rem_pio2f+0x170>
 804dda0:	f104 3cff 	add.w	ip, r4, #4294967295
 804dda4:	aa08      	add	r2, sp, #32
 804dda6:	f852 202c 	ldr.w	r2, [r2, ip, lsl #2]
 804ddaa:	f002 023f 	and.w	r2, r2, #63	@ 0x3f
 804ddae:	e7f3      	b.n	804dd98 <__kernel_rem_pio2f+0x264>
 804ddb0:	a908      	add	r1, sp, #32
 804ddb2:	f851 1020 	ldr.w	r1, [r1, r0, lsl #2]
 804ddb6:	3801      	subs	r0, #1
 804ddb8:	430a      	orrs	r2, r1
 804ddba:	e7ab      	b.n	804dd14 <__kernel_rem_pio2f+0x1e0>
 804ddbc:	3201      	adds	r2, #1
 804ddbe:	f850 6d04 	ldr.w	r6, [r0, #-4]!
 804ddc2:	2e00      	cmp	r6, #0
 804ddc4:	d0fa      	beq.n	804ddbc <__kernel_rem_pio2f+0x288>
 804ddc6:	9905      	ldr	r1, [sp, #20]
 804ddc8:	18e6      	adds	r6, r4, r3
 804ddca:	f104 0c01 	add.w	ip, r4, #1
 804ddce:	4422      	add	r2, r4
 804ddd0:	f501 71b0 	add.w	r1, r1, #352	@ 0x160
 804ddd4:	eb0d 0001 	add.w	r0, sp, r1
 804ddd8:	a91c      	add	r1, sp, #112	@ 0x70
 804ddda:	384c      	subs	r0, #76	@ 0x4c
 804dddc:	eb01 0686 	add.w	r6, r1, r6, lsl #2
 804dde0:	4562      	cmp	r2, ip
 804dde2:	da04      	bge.n	804ddee <__kernel_rem_pio2f+0x2ba>
 804dde4:	4614      	mov	r4, r2
 804dde6:	e70e      	b.n	804dc06 <__kernel_rem_pio2f+0xd2>
 804dde8:	9804      	ldr	r0, [sp, #16]
 804ddea:	2201      	movs	r2, #1
 804ddec:	e7e7      	b.n	804ddbe <__kernel_rem_pio2f+0x28a>
 804ddee:	9903      	ldr	r1, [sp, #12]
 804ddf0:	2400      	movs	r4, #0
 804ddf2:	f8dd e004 	ldr.w	lr, [sp, #4]
 804ddf6:	f851 102c 	ldr.w	r1, [r1, ip, lsl #2]
 804ddfa:	ee07 1a90 	vmov	s15, r1
 804ddfe:	9105      	str	r1, [sp, #20]
 804de00:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 804de04:	ece6 7a01 	vstmia	r6!, {s15}
 804de08:	46b1      	mov	r9, r6
 804de0a:	eddf 7a0c 	vldr	s15, [pc, #48]	@ 804de3c <__kernel_rem_pio2f+0x308>
 804de0e:	455c      	cmp	r4, fp
 804de10:	dd04      	ble.n	804de1c <__kernel_rem_pio2f+0x2e8>
 804de12:	f10c 0c01 	add.w	ip, ip, #1
 804de16:	ece0 7a01 	vstmia	r0!, {s15}
 804de1a:	e7e1      	b.n	804dde0 <__kernel_rem_pio2f+0x2ac>
 804de1c:	ecfe 6a01 	vldmia	lr!, {s13}
 804de20:	3401      	adds	r4, #1
 804de22:	ed39 7a01 	vldmdb	r9!, {s14}
 804de26:	eee6 7a87 	vfma.f32	s15, s13, s14
 804de2a:	e7f0      	b.n	804de0e <__kernel_rem_pio2f+0x2da>
 804de2c:	0804ea00 	.word	0x0804ea00
 804de30:	0804e9d4 	.word	0x0804e9d4
 804de34:	43800000 	.word	0x43800000
 804de38:	3b800000 	.word	0x3b800000
 804de3c:	00000000 	.word	0x00000000
 804de40:	9b02      	ldr	r3, [sp, #8]
 804de42:	eeb0 0a48 	vmov.f32	s0, s16
 804de46:	eba3 0008 	sub.w	r0, r3, r8
 804de4a:	f000 f8e7 	bl	804e01c <scalbnf>
 804de4e:	ed1f 7a07 	vldr	s14, [pc, #-28]	@ 804de34 <__kernel_rem_pio2f+0x300>
 804de52:	eeb4 0ac7 	vcmpe.f32	s0, s14
 804de56:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 804de5a:	db19      	blt.n	804de90 <__kernel_rem_pio2f+0x35c>
 804de5c:	ed5f 7a0a 	vldr	s15, [pc, #-40]	@ 804de38 <__kernel_rem_pio2f+0x304>
 804de60:	aa08      	add	r2, sp, #32
 804de62:	3508      	adds	r5, #8
 804de64:	ee60 7a27 	vmul.f32	s15, s0, s15
 804de68:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 804de6c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 804de70:	eea7 0ac7 	vfms.f32	s0, s15, s14
 804de74:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 804de78:	eebd 0ac0 	vcvt.s32.f32	s0, s0
 804de7c:	ee10 3a10 	vmov	r3, s0
 804de80:	f842 3024 	str.w	r3, [r2, r4, lsl #2]
 804de84:	3401      	adds	r4, #1
 804de86:	ee17 3a90 	vmov	r3, s15
 804de8a:	f842 3024 	str.w	r3, [r2, r4, lsl #2]
 804de8e:	e74c      	b.n	804dd2a <__kernel_rem_pio2f+0x1f6>
 804de90:	eebd 0ac0 	vcvt.s32.f32	s0, s0
 804de94:	aa08      	add	r2, sp, #32
 804de96:	ee10 3a10 	vmov	r3, s0
 804de9a:	e7f6      	b.n	804de8a <__kernel_rem_pio2f+0x356>
 804de9c:	a808      	add	r0, sp, #32
 804de9e:	f850 0023 	ldr.w	r0, [r0, r3, lsl #2]
 804dea2:	3b01      	subs	r3, #1
 804dea4:	ee07 0a90 	vmov	s15, r0
 804dea8:	9001      	str	r0, [sp, #4]
 804deaa:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 804deae:	ee67 7a80 	vmul.f32	s15, s15, s0
 804deb2:	ee20 0a07 	vmul.f32	s0, s0, s14
 804deb6:	ed62 7a01 	vstmdb	r2!, {s15}
 804deba:	e743      	b.n	804dd44 <__kernel_rem_pio2f+0x210>
 804debc:	ecfc 6a01 	vldmia	ip!, {s13}
 804dec0:	3001      	adds	r0, #1
 804dec2:	ecb5 7a01 	vldmia	r5!, {s14}
 804dec6:	eee6 7a87 	vfma.f32	s15, s13, s14
 804deca:	4550      	cmp	r0, sl
 804decc:	dc01      	bgt.n	804ded2 <__kernel_rem_pio2f+0x39e>
 804dece:	4282      	cmp	r2, r0
 804ded0:	daf4      	bge.n	804debc <__kernel_rem_pio2f+0x388>
 804ded2:	a858      	add	r0, sp, #352	@ 0x160
 804ded4:	3b01      	subs	r3, #1
 804ded6:	eb00 0282 	add.w	r2, r0, r2, lsl #2
 804deda:	ed42 7a28 	vstr	s15, [r2, #-160]	@ 0xffffff60
 804dede:	e735      	b.n	804dd4c <__kernel_rem_pio2f+0x218>
 804dee0:	9b66      	ldr	r3, [sp, #408]	@ 0x198
 804dee2:	2b02      	cmp	r3, #2
 804dee4:	dc09      	bgt.n	804defa <__kernel_rem_pio2f+0x3c6>
 804dee6:	2b00      	cmp	r3, #0
 804dee8:	dc2b      	bgt.n	804df42 <__kernel_rem_pio2f+0x40e>
 804deea:	d044      	beq.n	804df76 <__kernel_rem_pio2f+0x442>
 804deec:	f009 0007 	and.w	r0, r9, #7
 804def0:	b059      	add	sp, #356	@ 0x164
 804def2:	ecbd 8b04 	vpop	{d8-d9}
 804def6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 804defa:	9b66      	ldr	r3, [sp, #408]	@ 0x198
 804defc:	2b03      	cmp	r3, #3
 804defe:	d1f5      	bne.n	804deec <__kernel_rem_pio2f+0x3b8>
 804df00:	aa30      	add	r2, sp, #192	@ 0xc0
 804df02:	1f0b      	subs	r3, r1, #4
 804df04:	4620      	mov	r0, r4
 804df06:	4413      	add	r3, r2
 804df08:	461a      	mov	r2, r3
 804df0a:	2800      	cmp	r0, #0
 804df0c:	f1a2 0204 	sub.w	r2, r2, #4
 804df10:	dc52      	bgt.n	804dfb8 <__kernel_rem_pio2f+0x484>
 804df12:	4622      	mov	r2, r4
 804df14:	2a01      	cmp	r2, #1
 804df16:	f1a3 0304 	sub.w	r3, r3, #4
 804df1a:	dc5d      	bgt.n	804dfd8 <__kernel_rem_pio2f+0x4a4>
 804df1c:	ab30      	add	r3, sp, #192	@ 0xc0
 804df1e:	ed5f 7a39 	vldr	s15, [pc, #-228]	@ 804de3c <__kernel_rem_pio2f+0x308>
 804df22:	440b      	add	r3, r1
 804df24:	2c01      	cmp	r4, #1
 804df26:	dc67      	bgt.n	804dff8 <__kernel_rem_pio2f+0x4c4>
 804df28:	eddd 6a30 	vldr	s13, [sp, #192]	@ 0xc0
 804df2c:	ed9d 7a31 	vldr	s14, [sp, #196]	@ 0xc4
 804df30:	2e00      	cmp	r6, #0
 804df32:	d167      	bne.n	804e004 <__kernel_rem_pio2f+0x4d0>
 804df34:	edc7 6a00 	vstr	s13, [r7]
 804df38:	ed87 7a01 	vstr	s14, [r7, #4]
 804df3c:	edc7 7a02 	vstr	s15, [r7, #8]
 804df40:	e7d4      	b.n	804deec <__kernel_rem_pio2f+0x3b8>
 804df42:	ab30      	add	r3, sp, #192	@ 0xc0
 804df44:	4622      	mov	r2, r4
 804df46:	ed1f 7a43 	vldr	s14, [pc, #-268]	@ 804de3c <__kernel_rem_pio2f+0x308>
 804df4a:	440b      	add	r3, r1
 804df4c:	2a00      	cmp	r2, #0
 804df4e:	da24      	bge.n	804df9a <__kernel_rem_pio2f+0x466>
 804df50:	b34e      	cbz	r6, 804dfa6 <__kernel_rem_pio2f+0x472>
 804df52:	eef1 7a47 	vneg.f32	s15, s14
 804df56:	edc7 7a00 	vstr	s15, [r7]
 804df5a:	aa31      	add	r2, sp, #196	@ 0xc4
 804df5c:	eddd 7a30 	vldr	s15, [sp, #192]	@ 0xc0
 804df60:	2301      	movs	r3, #1
 804df62:	ee77 7ac7 	vsub.f32	s15, s15, s14
 804df66:	429c      	cmp	r4, r3
 804df68:	da20      	bge.n	804dfac <__kernel_rem_pio2f+0x478>
 804df6a:	b10e      	cbz	r6, 804df70 <__kernel_rem_pio2f+0x43c>
 804df6c:	eef1 7a67 	vneg.f32	s15, s15
 804df70:	edc7 7a01 	vstr	s15, [r7, #4]
 804df74:	e7ba      	b.n	804deec <__kernel_rem_pio2f+0x3b8>
 804df76:	ab30      	add	r3, sp, #192	@ 0xc0
 804df78:	ed5f 7a50 	vldr	s15, [pc, #-320]	@ 804de3c <__kernel_rem_pio2f+0x308>
 804df7c:	440b      	add	r3, r1
 804df7e:	2c00      	cmp	r4, #0
 804df80:	da05      	bge.n	804df8e <__kernel_rem_pio2f+0x45a>
 804df82:	b10e      	cbz	r6, 804df88 <__kernel_rem_pio2f+0x454>
 804df84:	eef1 7a67 	vneg.f32	s15, s15
 804df88:	edc7 7a00 	vstr	s15, [r7]
 804df8c:	e7ae      	b.n	804deec <__kernel_rem_pio2f+0x3b8>
 804df8e:	ed33 7a01 	vldmdb	r3!, {s14}
 804df92:	3c01      	subs	r4, #1
 804df94:	ee77 7a87 	vadd.f32	s15, s15, s14
 804df98:	e7f1      	b.n	804df7e <__kernel_rem_pio2f+0x44a>
 804df9a:	ed73 7a01 	vldmdb	r3!, {s15}
 804df9e:	3a01      	subs	r2, #1
 804dfa0:	ee37 7a27 	vadd.f32	s14, s14, s15
 804dfa4:	e7d2      	b.n	804df4c <__kernel_rem_pio2f+0x418>
 804dfa6:	eef0 7a47 	vmov.f32	s15, s14
 804dfaa:	e7d4      	b.n	804df56 <__kernel_rem_pio2f+0x422>
 804dfac:	ecb2 7a01 	vldmia	r2!, {s14}
 804dfb0:	3301      	adds	r3, #1
 804dfb2:	ee77 7a87 	vadd.f32	s15, s15, s14
 804dfb6:	e7d6      	b.n	804df66 <__kernel_rem_pio2f+0x432>
 804dfb8:	edd2 7a00 	vldr	s15, [r2]
 804dfbc:	3801      	subs	r0, #1
 804dfbe:	edd2 6a01 	vldr	s13, [r2, #4]
 804dfc2:	ee37 7aa6 	vadd.f32	s14, s15, s13
 804dfc6:	ee77 7ac7 	vsub.f32	s15, s15, s14
 804dfca:	ed82 7a00 	vstr	s14, [r2]
 804dfce:	ee77 7aa6 	vadd.f32	s15, s15, s13
 804dfd2:	edc2 7a01 	vstr	s15, [r2, #4]
 804dfd6:	e798      	b.n	804df0a <__kernel_rem_pio2f+0x3d6>
 804dfd8:	edd3 7a00 	vldr	s15, [r3]
 804dfdc:	3a01      	subs	r2, #1
 804dfde:	edd3 6a01 	vldr	s13, [r3, #4]
 804dfe2:	ee37 7aa6 	vadd.f32	s14, s15, s13
 804dfe6:	ee77 7ac7 	vsub.f32	s15, s15, s14
 804dfea:	ed83 7a00 	vstr	s14, [r3]
 804dfee:	ee77 7aa6 	vadd.f32	s15, s15, s13
 804dff2:	edc3 7a01 	vstr	s15, [r3, #4]
 804dff6:	e78d      	b.n	804df14 <__kernel_rem_pio2f+0x3e0>
 804dff8:	ed33 7a01 	vldmdb	r3!, {s14}
 804dffc:	3c01      	subs	r4, #1
 804dffe:	ee77 7a87 	vadd.f32	s15, s15, s14
 804e002:	e78f      	b.n	804df24 <__kernel_rem_pio2f+0x3f0>
 804e004:	eef1 6a66 	vneg.f32	s13, s13
 804e008:	eeb1 7a47 	vneg.f32	s14, s14
 804e00c:	eef1 7a67 	vneg.f32	s15, s15
 804e010:	edc7 6a00 	vstr	s13, [r7]
 804e014:	ed87 7a01 	vstr	s14, [r7, #4]
 804e018:	e790      	b.n	804df3c <__kernel_rem_pio2f+0x408>
 804e01a:	bf00      	nop

0804e01c <scalbnf>:
 804e01c:	ee10 3a10 	vmov	r3, s0
 804e020:	f033 4200 	bics.w	r2, r3, #2147483648	@ 0x80000000
 804e024:	d02a      	beq.n	804e07c <scalbnf+0x60>
 804e026:	f1b2 4fff 	cmp.w	r2, #2139095040	@ 0x7f800000
 804e02a:	d302      	bcc.n	804e032 <scalbnf+0x16>
 804e02c:	ee30 0a00 	vadd.f32	s0, s0, s0
 804e030:	4770      	bx	lr
 804e032:	f013 4fff 	tst.w	r3, #2139095040	@ 0x7f800000
 804e036:	d122      	bne.n	804e07e <scalbnf+0x62>
 804e038:	4b23      	ldr	r3, [pc, #140]	@ (804e0c8 <scalbnf+0xac>)
 804e03a:	eddf 7a24 	vldr	s15, [pc, #144]	@ 804e0cc <scalbnf+0xb0>
 804e03e:	4298      	cmp	r0, r3
 804e040:	ee20 0a27 	vmul.f32	s0, s0, s15
 804e044:	db16      	blt.n	804e074 <scalbnf+0x58>
 804e046:	ee10 3a10 	vmov	r3, s0
 804e04a:	f3c3 52c7 	ubfx	r2, r3, #23, #8
 804e04e:	3a19      	subs	r2, #25
 804e050:	f24c 3150 	movw	r1, #50000	@ 0xc350
 804e054:	4288      	cmp	r0, r1
 804e056:	dd14      	ble.n	804e082 <scalbnf+0x66>
 804e058:	eddf 7a1d 	vldr	s15, [pc, #116]	@ 804e0d0 <scalbnf+0xb4>
 804e05c:	ee10 3a10 	vmov	r3, s0
 804e060:	eddf 6a1c 	vldr	s13, [pc, #112]	@ 804e0d4 <scalbnf+0xb8>
 804e064:	eeb0 7a67 	vmov.f32	s14, s15
 804e068:	2b00      	cmp	r3, #0
 804e06a:	fe67 7aa6 	vselge.f32	s15, s15, s13
 804e06e:	ee27 0a87 	vmul.f32	s0, s15, s14
 804e072:	4770      	bx	lr
 804e074:	eddf 7a18 	vldr	s15, [pc, #96]	@ 804e0d8 <scalbnf+0xbc>
 804e078:	ee27 0a80 	vmul.f32	s0, s15, s0
 804e07c:	4770      	bx	lr
 804e07e:	0dd2      	lsrs	r2, r2, #23
 804e080:	e7e6      	b.n	804e050 <scalbnf+0x34>
 804e082:	4410      	add	r0, r2
 804e084:	28fe      	cmp	r0, #254	@ 0xfe
 804e086:	dce7      	bgt.n	804e058 <scalbnf+0x3c>
 804e088:	2800      	cmp	r0, #0
 804e08a:	dd06      	ble.n	804e09a <scalbnf+0x7e>
 804e08c:	f023 43ff 	bic.w	r3, r3, #2139095040	@ 0x7f800000
 804e090:	ea43 53c0 	orr.w	r3, r3, r0, lsl #23
 804e094:	ee00 3a10 	vmov	s0, r3
 804e098:	4770      	bx	lr
 804e09a:	f110 0f16 	cmn.w	r0, #22
 804e09e:	da09      	bge.n	804e0b4 <scalbnf+0x98>
 804e0a0:	eddf 7a0d 	vldr	s15, [pc, #52]	@ 804e0d8 <scalbnf+0xbc>
 804e0a4:	ee10 3a10 	vmov	r3, s0
 804e0a8:	eddf 6a0c 	vldr	s13, [pc, #48]	@ 804e0dc <scalbnf+0xc0>
 804e0ac:	eeb0 7a67 	vmov.f32	s14, s15
 804e0b0:	2b00      	cmp	r3, #0
 804e0b2:	e7da      	b.n	804e06a <scalbnf+0x4e>
 804e0b4:	3019      	adds	r0, #25
 804e0b6:	f023 43ff 	bic.w	r3, r3, #2139095040	@ 0x7f800000
 804e0ba:	ed9f 0a09 	vldr	s0, [pc, #36]	@ 804e0e0 <scalbnf+0xc4>
 804e0be:	ea43 53c0 	orr.w	r3, r3, r0, lsl #23
 804e0c2:	ee07 3a90 	vmov	s15, r3
 804e0c6:	e7d7      	b.n	804e078 <scalbnf+0x5c>
 804e0c8:	ffff3cb0 	.word	0xffff3cb0
 804e0cc:	4c000000 	.word	0x4c000000
 804e0d0:	7149f2ca 	.word	0x7149f2ca
 804e0d4:	f149f2ca 	.word	0xf149f2ca
 804e0d8:	0da24260 	.word	0x0da24260
 804e0dc:	8da24260 	.word	0x8da24260
 804e0e0:	33000000 	.word	0x33000000

0804e0e4 <floorf>:
 804e0e4:	febb 0a40 	vrintm.f32	s0, s0
 804e0e8:	4770      	bx	lr
	...

0804e0ec <_gettimeofday>:
 804e0ec:	4b02      	ldr	r3, [pc, #8]	@ (804e0f8 <_gettimeofday+0xc>)
 804e0ee:	2258      	movs	r2, #88	@ 0x58
 804e0f0:	f04f 30ff 	mov.w	r0, #4294967295
 804e0f4:	601a      	str	r2, [r3, #0]
 804e0f6:	4770      	bx	lr
 804e0f8:	20018494 	.word	0x20018494

0804e0fc <_init>:
 804e0fc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 804e0fe:	bf00      	nop
 804e100:	bcf8      	pop	{r3, r4, r5, r6, r7}
 804e102:	bc08      	pop	{r3}
 804e104:	469e      	mov	lr, r3
 804e106:	4770      	bx	lr

0804e108 <_fini>:
 804e108:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 804e10a:	bf00      	nop
 804e10c:	bcf8      	pop	{r3, r4, r5, r6, r7}
 804e10e:	bc08      	pop	{r3}
 804e110:	469e      	mov	lr, r3
 804e112:	4770      	bx	lr
 804e114:	0000      	movs	r0, r0
	...

0804e118 <__SECURE_send_veneer>:
 804e118:	f85f f000 	ldr.w	pc, [pc]	@ 804e11c <__SECURE_send_veneer+0x4>
 804e11c:	0c03e021 	.word	0x0c03e021

0804e120 <__SECURE_pox_veneer>:
 804e120:	f85f f000 	ldr.w	pc, [pc]	@ 804e124 <__SECURE_pox_veneer+0x4>
 804e124:	0c03e029 	.word	0x0c03e029

0804e128 <__SECURE_checkState_veneer>:
 804e128:	f85f f000 	ldr.w	pc, [pc]	@ 804e12c <__SECURE_checkState_veneer+0x4>
 804e12c:	0c03e031 	.word	0x0c03e031

0804e130 <__SECURE_recv_veneer>:
 804e130:	f85f f000 	ldr.w	pc, [pc]	@ 804e134 <__SECURE_recv_veneer+0x4>
 804e134:	0c03e009 	.word	0x0c03e009

0804e138 <__SECURE_SystemCoreClockUpdate_veneer>:
 804e138:	f85f f000 	ldr.w	pc, [pc]	@ 804e13c <__SECURE_SystemCoreClockUpdate_veneer+0x4>
 804e13c:	0c03e001 	.word	0x0c03e001

0804e140 <__SECURE_RegisterCallback_veneer>:
 804e140:	f85f f000 	ldr.w	pc, [pc]	@ 804e144 <__SECURE_RegisterCallback_veneer+0x4>
 804e144:	0c03e019 	.word	0x0c03e019

0804e148 <__SECURE_setState_veneer>:
 804e148:	f85f f000 	ldr.w	pc, [pc]	@ 804e14c <__SECURE_setState_veneer+0x4>
 804e14c:	0c03e011 	.word	0x0c03e011
