
TRACES_NonSecure.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000001f4  08040000  08040000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         0000dfd0  080401f8  080401f8  000011f8  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       000008f8  0804e1c8  0804e1c8  0000f1c8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  0804eac0  0804eac0  000101a0  2**0
                  CONTENTS
  4 .ARM          00000000  0804eac0  0804eac0  000101a0  2**0
                  CONTENTS
  5 .preinit_array 00000000  0804eac0  0804eac0  000101a0  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  0804eac0  0804eac0  0000fac0  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000004  0804eac4  0804eac4  0000fac4  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         000001a0  20018000  0804eac8  00010000  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          00000a84  200181a0  0804ec68  000101a0  2**2
                  ALLOC
 10 ._user_heap_stack 00020004  20018c24  0804ec68  00010c24  2**0
                  ALLOC
 11 .ARM.attributes 00000036  00000000  00000000  000101a0  2**0
                  CONTENTS, READONLY
 12 .debug_info   0001c7c9  00000000  00000000  000101d6  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_abbrev 00002711  00000000  00000000  0002c99f  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_aranges 00000a00  00000000  00000000  0002f0b0  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_rnglists 0000320e  00000000  00000000  0002fab0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_macro  00029b0d  00000000  00000000  00032cbe  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_line   0001b90c  00000000  00000000  0005c7cb  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_str    00105de1  00000000  00000000  000780d7  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .comment      00000043  00000000  00000000  0017deb8  2**0
                  CONTENTS, READONLY
 20 .debug_frame  000038f4  00000000  00000000  0017defc  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .debug_loclists 0001879b  00000000  00000000  001817f0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 22 .debug_line_str 0000006f  00000000  00000000  00199f8b  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

080401f8 <__do_global_dtors_aux>:
 80401f8:	b510      	push	{r4, lr}
 80401fa:	4c05      	ldr	r4, [pc, #20]	@ (8040210 <__do_global_dtors_aux+0x18>)
 80401fc:	7823      	ldrb	r3, [r4, #0]
 80401fe:	b933      	cbnz	r3, 804020e <__do_global_dtors_aux+0x16>
 8040200:	4b04      	ldr	r3, [pc, #16]	@ (8040214 <__do_global_dtors_aux+0x1c>)
 8040202:	b113      	cbz	r3, 804020a <__do_global_dtors_aux+0x12>
 8040204:	4804      	ldr	r0, [pc, #16]	@ (8040218 <__do_global_dtors_aux+0x20>)
 8040206:	f3af 8000 	nop.w
 804020a:	2301      	movs	r3, #1
 804020c:	7023      	strb	r3, [r4, #0]
 804020e:	bd10      	pop	{r4, pc}
 8040210:	200181a0 	.word	0x200181a0
 8040214:	00000000 	.word	0x00000000
 8040218:	0804e174 	.word	0x0804e174

0804021c <frame_dummy>:
 804021c:	b508      	push	{r3, lr}
 804021e:	4b03      	ldr	r3, [pc, #12]	@ (804022c <frame_dummy+0x10>)
 8040220:	b11b      	cbz	r3, 804022a <frame_dummy+0xe>
 8040222:	4903      	ldr	r1, [pc, #12]	@ (8040230 <frame_dummy+0x14>)
 8040224:	4803      	ldr	r0, [pc, #12]	@ (8040234 <frame_dummy+0x18>)
 8040226:	f3af 8000 	nop.w
 804022a:	bd08      	pop	{r3, pc}
 804022c:	00000000 	.word	0x00000000
 8040230:	200181a4 	.word	0x200181a4
 8040234:	0804e174 	.word	0x0804e174

08040238 <__aeabi_drsub>:
 8040238:	f081 4100 	eor.w	r1, r1, #2147483648	@ 0x80000000
 804023c:	e002      	b.n	8040244 <__adddf3>
 804023e:	bf00      	nop

08040240 <__aeabi_dsub>:
 8040240:	f083 4300 	eor.w	r3, r3, #2147483648	@ 0x80000000

08040244 <__adddf3>:
 8040244:	b530      	push	{r4, r5, lr}
 8040246:	ea4f 0441 	mov.w	r4, r1, lsl #1
 804024a:	ea4f 0543 	mov.w	r5, r3, lsl #1
 804024e:	ea94 0f05 	teq	r4, r5
 8040252:	bf08      	it	eq
 8040254:	ea90 0f02 	teqeq	r0, r2
 8040258:	bf1f      	itttt	ne
 804025a:	ea54 0c00 	orrsne.w	ip, r4, r0
 804025e:	ea55 0c02 	orrsne.w	ip, r5, r2
 8040262:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 8040266:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 804026a:	f000 80e2 	beq.w	8040432 <__adddf3+0x1ee>
 804026e:	ea4f 5454 	mov.w	r4, r4, lsr #21
 8040272:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 8040276:	bfb8      	it	lt
 8040278:	426d      	neglt	r5, r5
 804027a:	dd0c      	ble.n	8040296 <__adddf3+0x52>
 804027c:	442c      	add	r4, r5
 804027e:	ea80 0202 	eor.w	r2, r0, r2
 8040282:	ea81 0303 	eor.w	r3, r1, r3
 8040286:	ea82 0000 	eor.w	r0, r2, r0
 804028a:	ea83 0101 	eor.w	r1, r3, r1
 804028e:	ea80 0202 	eor.w	r2, r0, r2
 8040292:	ea81 0303 	eor.w	r3, r1, r3
 8040296:	2d36      	cmp	r5, #54	@ 0x36
 8040298:	bf88      	it	hi
 804029a:	bd30      	pophi	{r4, r5, pc}
 804029c:	f011 4f00 	tst.w	r1, #2147483648	@ 0x80000000
 80402a0:	ea4f 3101 	mov.w	r1, r1, lsl #12
 80402a4:	f44f 1c80 	mov.w	ip, #1048576	@ 0x100000
 80402a8:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 80402ac:	d002      	beq.n	80402b4 <__adddf3+0x70>
 80402ae:	4240      	negs	r0, r0
 80402b0:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 80402b4:	f013 4f00 	tst.w	r3, #2147483648	@ 0x80000000
 80402b8:	ea4f 3303 	mov.w	r3, r3, lsl #12
 80402bc:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 80402c0:	d002      	beq.n	80402c8 <__adddf3+0x84>
 80402c2:	4252      	negs	r2, r2
 80402c4:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 80402c8:	ea94 0f05 	teq	r4, r5
 80402cc:	f000 80a7 	beq.w	804041e <__adddf3+0x1da>
 80402d0:	f1a4 0401 	sub.w	r4, r4, #1
 80402d4:	f1d5 0e20 	rsbs	lr, r5, #32
 80402d8:	db0d      	blt.n	80402f6 <__adddf3+0xb2>
 80402da:	fa02 fc0e 	lsl.w	ip, r2, lr
 80402de:	fa22 f205 	lsr.w	r2, r2, r5
 80402e2:	1880      	adds	r0, r0, r2
 80402e4:	f141 0100 	adc.w	r1, r1, #0
 80402e8:	fa03 f20e 	lsl.w	r2, r3, lr
 80402ec:	1880      	adds	r0, r0, r2
 80402ee:	fa43 f305 	asr.w	r3, r3, r5
 80402f2:	4159      	adcs	r1, r3
 80402f4:	e00e      	b.n	8040314 <__adddf3+0xd0>
 80402f6:	f1a5 0520 	sub.w	r5, r5, #32
 80402fa:	f10e 0e20 	add.w	lr, lr, #32
 80402fe:	2a01      	cmp	r2, #1
 8040300:	fa03 fc0e 	lsl.w	ip, r3, lr
 8040304:	bf28      	it	cs
 8040306:	f04c 0c02 	orrcs.w	ip, ip, #2
 804030a:	fa43 f305 	asr.w	r3, r3, r5
 804030e:	18c0      	adds	r0, r0, r3
 8040310:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 8040314:	f001 4500 	and.w	r5, r1, #2147483648	@ 0x80000000
 8040318:	d507      	bpl.n	804032a <__adddf3+0xe6>
 804031a:	f04f 0e00 	mov.w	lr, #0
 804031e:	f1dc 0c00 	rsbs	ip, ip, #0
 8040322:	eb7e 0000 	sbcs.w	r0, lr, r0
 8040326:	eb6e 0101 	sbc.w	r1, lr, r1
 804032a:	f5b1 1f80 	cmp.w	r1, #1048576	@ 0x100000
 804032e:	d31b      	bcc.n	8040368 <__adddf3+0x124>
 8040330:	f5b1 1f00 	cmp.w	r1, #2097152	@ 0x200000
 8040334:	d30c      	bcc.n	8040350 <__adddf3+0x10c>
 8040336:	0849      	lsrs	r1, r1, #1
 8040338:	ea5f 0030 	movs.w	r0, r0, rrx
 804033c:	ea4f 0c3c 	mov.w	ip, ip, rrx
 8040340:	f104 0401 	add.w	r4, r4, #1
 8040344:	ea4f 5244 	mov.w	r2, r4, lsl #21
 8040348:	f512 0f80 	cmn.w	r2, #4194304	@ 0x400000
 804034c:	f080 809a 	bcs.w	8040484 <__adddf3+0x240>
 8040350:	f1bc 4f00 	cmp.w	ip, #2147483648	@ 0x80000000
 8040354:	bf08      	it	eq
 8040356:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 804035a:	f150 0000 	adcs.w	r0, r0, #0
 804035e:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 8040362:	ea41 0105 	orr.w	r1, r1, r5
 8040366:	bd30      	pop	{r4, r5, pc}
 8040368:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 804036c:	4140      	adcs	r0, r0
 804036e:	eb41 0101 	adc.w	r1, r1, r1
 8040372:	3c01      	subs	r4, #1
 8040374:	bf28      	it	cs
 8040376:	f5b1 1f80 	cmpcs.w	r1, #1048576	@ 0x100000
 804037a:	d2e9      	bcs.n	8040350 <__adddf3+0x10c>
 804037c:	f091 0f00 	teq	r1, #0
 8040380:	bf04      	itt	eq
 8040382:	4601      	moveq	r1, r0
 8040384:	2000      	moveq	r0, #0
 8040386:	fab1 f381 	clz	r3, r1
 804038a:	bf08      	it	eq
 804038c:	3320      	addeq	r3, #32
 804038e:	f1a3 030b 	sub.w	r3, r3, #11
 8040392:	f1b3 0220 	subs.w	r2, r3, #32
 8040396:	da0c      	bge.n	80403b2 <__adddf3+0x16e>
 8040398:	320c      	adds	r2, #12
 804039a:	dd08      	ble.n	80403ae <__adddf3+0x16a>
 804039c:	f102 0c14 	add.w	ip, r2, #20
 80403a0:	f1c2 020c 	rsb	r2, r2, #12
 80403a4:	fa01 f00c 	lsl.w	r0, r1, ip
 80403a8:	fa21 f102 	lsr.w	r1, r1, r2
 80403ac:	e00c      	b.n	80403c8 <__adddf3+0x184>
 80403ae:	f102 0214 	add.w	r2, r2, #20
 80403b2:	bfd8      	it	le
 80403b4:	f1c2 0c20 	rsble	ip, r2, #32
 80403b8:	fa01 f102 	lsl.w	r1, r1, r2
 80403bc:	fa20 fc0c 	lsr.w	ip, r0, ip
 80403c0:	bfdc      	itt	le
 80403c2:	ea41 010c 	orrle.w	r1, r1, ip
 80403c6:	4090      	lslle	r0, r2
 80403c8:	1ae4      	subs	r4, r4, r3
 80403ca:	bfa2      	ittt	ge
 80403cc:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 80403d0:	4329      	orrge	r1, r5
 80403d2:	bd30      	popge	{r4, r5, pc}
 80403d4:	ea6f 0404 	mvn.w	r4, r4
 80403d8:	3c1f      	subs	r4, #31
 80403da:	da1c      	bge.n	8040416 <__adddf3+0x1d2>
 80403dc:	340c      	adds	r4, #12
 80403de:	dc0e      	bgt.n	80403fe <__adddf3+0x1ba>
 80403e0:	f104 0414 	add.w	r4, r4, #20
 80403e4:	f1c4 0220 	rsb	r2, r4, #32
 80403e8:	fa20 f004 	lsr.w	r0, r0, r4
 80403ec:	fa01 f302 	lsl.w	r3, r1, r2
 80403f0:	ea40 0003 	orr.w	r0, r0, r3
 80403f4:	fa21 f304 	lsr.w	r3, r1, r4
 80403f8:	ea45 0103 	orr.w	r1, r5, r3
 80403fc:	bd30      	pop	{r4, r5, pc}
 80403fe:	f1c4 040c 	rsb	r4, r4, #12
 8040402:	f1c4 0220 	rsb	r2, r4, #32
 8040406:	fa20 f002 	lsr.w	r0, r0, r2
 804040a:	fa01 f304 	lsl.w	r3, r1, r4
 804040e:	ea40 0003 	orr.w	r0, r0, r3
 8040412:	4629      	mov	r1, r5
 8040414:	bd30      	pop	{r4, r5, pc}
 8040416:	fa21 f004 	lsr.w	r0, r1, r4
 804041a:	4629      	mov	r1, r5
 804041c:	bd30      	pop	{r4, r5, pc}
 804041e:	f094 0f00 	teq	r4, #0
 8040422:	f483 1380 	eor.w	r3, r3, #1048576	@ 0x100000
 8040426:	bf06      	itte	eq
 8040428:	f481 1180 	eoreq.w	r1, r1, #1048576	@ 0x100000
 804042c:	3401      	addeq	r4, #1
 804042e:	3d01      	subne	r5, #1
 8040430:	e74e      	b.n	80402d0 <__adddf3+0x8c>
 8040432:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 8040436:	bf18      	it	ne
 8040438:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 804043c:	d029      	beq.n	8040492 <__adddf3+0x24e>
 804043e:	ea94 0f05 	teq	r4, r5
 8040442:	bf08      	it	eq
 8040444:	ea90 0f02 	teqeq	r0, r2
 8040448:	d005      	beq.n	8040456 <__adddf3+0x212>
 804044a:	ea54 0c00 	orrs.w	ip, r4, r0
 804044e:	bf04      	itt	eq
 8040450:	4619      	moveq	r1, r3
 8040452:	4610      	moveq	r0, r2
 8040454:	bd30      	pop	{r4, r5, pc}
 8040456:	ea91 0f03 	teq	r1, r3
 804045a:	bf1e      	ittt	ne
 804045c:	2100      	movne	r1, #0
 804045e:	2000      	movne	r0, #0
 8040460:	bd30      	popne	{r4, r5, pc}
 8040462:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 8040466:	d105      	bne.n	8040474 <__adddf3+0x230>
 8040468:	0040      	lsls	r0, r0, #1
 804046a:	4149      	adcs	r1, r1
 804046c:	bf28      	it	cs
 804046e:	f041 4100 	orrcs.w	r1, r1, #2147483648	@ 0x80000000
 8040472:	bd30      	pop	{r4, r5, pc}
 8040474:	f514 0480 	adds.w	r4, r4, #4194304	@ 0x400000
 8040478:	bf3c      	itt	cc
 804047a:	f501 1180 	addcc.w	r1, r1, #1048576	@ 0x100000
 804047e:	bd30      	popcc	{r4, r5, pc}
 8040480:	f001 4500 	and.w	r5, r1, #2147483648	@ 0x80000000
 8040484:	f045 41fe 	orr.w	r1, r5, #2130706432	@ 0x7f000000
 8040488:	f441 0170 	orr.w	r1, r1, #15728640	@ 0xf00000
 804048c:	f04f 0000 	mov.w	r0, #0
 8040490:	bd30      	pop	{r4, r5, pc}
 8040492:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 8040496:	bf1a      	itte	ne
 8040498:	4619      	movne	r1, r3
 804049a:	4610      	movne	r0, r2
 804049c:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 80404a0:	bf1c      	itt	ne
 80404a2:	460b      	movne	r3, r1
 80404a4:	4602      	movne	r2, r0
 80404a6:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 80404aa:	bf06      	itte	eq
 80404ac:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 80404b0:	ea91 0f03 	teqeq	r1, r3
 80404b4:	f441 2100 	orrne.w	r1, r1, #524288	@ 0x80000
 80404b8:	bd30      	pop	{r4, r5, pc}
 80404ba:	bf00      	nop

080404bc <__aeabi_ui2d>:
 80404bc:	f090 0f00 	teq	r0, #0
 80404c0:	bf04      	itt	eq
 80404c2:	2100      	moveq	r1, #0
 80404c4:	4770      	bxeq	lr
 80404c6:	b530      	push	{r4, r5, lr}
 80404c8:	f44f 6480 	mov.w	r4, #1024	@ 0x400
 80404cc:	f104 0432 	add.w	r4, r4, #50	@ 0x32
 80404d0:	f04f 0500 	mov.w	r5, #0
 80404d4:	f04f 0100 	mov.w	r1, #0
 80404d8:	e750      	b.n	804037c <__adddf3+0x138>
 80404da:	bf00      	nop

080404dc <__aeabi_i2d>:
 80404dc:	f090 0f00 	teq	r0, #0
 80404e0:	bf04      	itt	eq
 80404e2:	2100      	moveq	r1, #0
 80404e4:	4770      	bxeq	lr
 80404e6:	b530      	push	{r4, r5, lr}
 80404e8:	f44f 6480 	mov.w	r4, #1024	@ 0x400
 80404ec:	f104 0432 	add.w	r4, r4, #50	@ 0x32
 80404f0:	f010 4500 	ands.w	r5, r0, #2147483648	@ 0x80000000
 80404f4:	bf48      	it	mi
 80404f6:	4240      	negmi	r0, r0
 80404f8:	f04f 0100 	mov.w	r1, #0
 80404fc:	e73e      	b.n	804037c <__adddf3+0x138>
 80404fe:	bf00      	nop

08040500 <__aeabi_f2d>:
 8040500:	0042      	lsls	r2, r0, #1
 8040502:	ea4f 01e2 	mov.w	r1, r2, asr #3
 8040506:	ea4f 0131 	mov.w	r1, r1, rrx
 804050a:	ea4f 7002 	mov.w	r0, r2, lsl #28
 804050e:	bf1f      	itttt	ne
 8040510:	f012 437f 	andsne.w	r3, r2, #4278190080	@ 0xff000000
 8040514:	f093 4f7f 	teqne	r3, #4278190080	@ 0xff000000
 8040518:	f081 5160 	eorne.w	r1, r1, #939524096	@ 0x38000000
 804051c:	4770      	bxne	lr
 804051e:	f032 427f 	bics.w	r2, r2, #4278190080	@ 0xff000000
 8040522:	bf08      	it	eq
 8040524:	4770      	bxeq	lr
 8040526:	f093 4f7f 	teq	r3, #4278190080	@ 0xff000000
 804052a:	bf04      	itt	eq
 804052c:	f441 2100 	orreq.w	r1, r1, #524288	@ 0x80000
 8040530:	4770      	bxeq	lr
 8040532:	b530      	push	{r4, r5, lr}
 8040534:	f44f 7460 	mov.w	r4, #896	@ 0x380
 8040538:	f001 4500 	and.w	r5, r1, #2147483648	@ 0x80000000
 804053c:	f021 4100 	bic.w	r1, r1, #2147483648	@ 0x80000000
 8040540:	e71c      	b.n	804037c <__adddf3+0x138>
 8040542:	bf00      	nop

08040544 <__aeabi_ul2d>:
 8040544:	ea50 0201 	orrs.w	r2, r0, r1
 8040548:	bf08      	it	eq
 804054a:	4770      	bxeq	lr
 804054c:	b530      	push	{r4, r5, lr}
 804054e:	f04f 0500 	mov.w	r5, #0
 8040552:	e00a      	b.n	804056a <__aeabi_l2d+0x16>

08040554 <__aeabi_l2d>:
 8040554:	ea50 0201 	orrs.w	r2, r0, r1
 8040558:	bf08      	it	eq
 804055a:	4770      	bxeq	lr
 804055c:	b530      	push	{r4, r5, lr}
 804055e:	f011 4500 	ands.w	r5, r1, #2147483648	@ 0x80000000
 8040562:	d502      	bpl.n	804056a <__aeabi_l2d+0x16>
 8040564:	4240      	negs	r0, r0
 8040566:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 804056a:	f44f 6480 	mov.w	r4, #1024	@ 0x400
 804056e:	f104 0432 	add.w	r4, r4, #50	@ 0x32
 8040572:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 8040576:	f43f aed8 	beq.w	804032a <__adddf3+0xe6>
 804057a:	f04f 0203 	mov.w	r2, #3
 804057e:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 8040582:	bf18      	it	ne
 8040584:	3203      	addne	r2, #3
 8040586:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 804058a:	bf18      	it	ne
 804058c:	3203      	addne	r2, #3
 804058e:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 8040592:	f1c2 0320 	rsb	r3, r2, #32
 8040596:	fa00 fc03 	lsl.w	ip, r0, r3
 804059a:	fa20 f002 	lsr.w	r0, r0, r2
 804059e:	fa01 fe03 	lsl.w	lr, r1, r3
 80405a2:	ea40 000e 	orr.w	r0, r0, lr
 80405a6:	fa21 f102 	lsr.w	r1, r1, r2
 80405aa:	4414      	add	r4, r2
 80405ac:	e6bd      	b.n	804032a <__adddf3+0xe6>
 80405ae:	bf00      	nop

080405b0 <__aeabi_dmul>:
 80405b0:	b570      	push	{r4, r5, r6, lr}
 80405b2:	f04f 0cff 	mov.w	ip, #255	@ 0xff
 80405b6:	f44c 6ce0 	orr.w	ip, ip, #1792	@ 0x700
 80405ba:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 80405be:	bf1d      	ittte	ne
 80405c0:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 80405c4:	ea94 0f0c 	teqne	r4, ip
 80405c8:	ea95 0f0c 	teqne	r5, ip
 80405cc:	f000 f8de 	bleq	804078c <__aeabi_dmul+0x1dc>
 80405d0:	442c      	add	r4, r5
 80405d2:	ea81 0603 	eor.w	r6, r1, r3
 80405d6:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
 80405da:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
 80405de:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
 80405e2:	bf18      	it	ne
 80405e4:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
 80405e8:	f441 1180 	orr.w	r1, r1, #1048576	@ 0x100000
 80405ec:	f443 1380 	orr.w	r3, r3, #1048576	@ 0x100000
 80405f0:	d038      	beq.n	8040664 <__aeabi_dmul+0xb4>
 80405f2:	fba0 ce02 	umull	ip, lr, r0, r2
 80405f6:	f04f 0500 	mov.w	r5, #0
 80405fa:	fbe1 e502 	umlal	lr, r5, r1, r2
 80405fe:	f006 4200 	and.w	r2, r6, #2147483648	@ 0x80000000
 8040602:	fbe0 e503 	umlal	lr, r5, r0, r3
 8040606:	f04f 0600 	mov.w	r6, #0
 804060a:	fbe1 5603 	umlal	r5, r6, r1, r3
 804060e:	f09c 0f00 	teq	ip, #0
 8040612:	bf18      	it	ne
 8040614:	f04e 0e01 	orrne.w	lr, lr, #1
 8040618:	f1a4 04ff 	sub.w	r4, r4, #255	@ 0xff
 804061c:	f5b6 7f00 	cmp.w	r6, #512	@ 0x200
 8040620:	f564 7440 	sbc.w	r4, r4, #768	@ 0x300
 8040624:	d204      	bcs.n	8040630 <__aeabi_dmul+0x80>
 8040626:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
 804062a:	416d      	adcs	r5, r5
 804062c:	eb46 0606 	adc.w	r6, r6, r6
 8040630:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
 8040634:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
 8040638:	ea4f 20c5 	mov.w	r0, r5, lsl #11
 804063c:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
 8040640:	ea4f 2ece 	mov.w	lr, lr, lsl #11
 8040644:	f1b4 0cfd 	subs.w	ip, r4, #253	@ 0xfd
 8040648:	bf88      	it	hi
 804064a:	f5bc 6fe0 	cmphi.w	ip, #1792	@ 0x700
 804064e:	d81e      	bhi.n	804068e <__aeabi_dmul+0xde>
 8040650:	f1be 4f00 	cmp.w	lr, #2147483648	@ 0x80000000
 8040654:	bf08      	it	eq
 8040656:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
 804065a:	f150 0000 	adcs.w	r0, r0, #0
 804065e:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 8040662:	bd70      	pop	{r4, r5, r6, pc}
 8040664:	f006 4600 	and.w	r6, r6, #2147483648	@ 0x80000000
 8040668:	ea46 0101 	orr.w	r1, r6, r1
 804066c:	ea40 0002 	orr.w	r0, r0, r2
 8040670:	ea81 0103 	eor.w	r1, r1, r3
 8040674:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
 8040678:	bfc2      	ittt	gt
 804067a:	ebd4 050c 	rsbsgt	r5, r4, ip
 804067e:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 8040682:	bd70      	popgt	{r4, r5, r6, pc}
 8040684:	f441 1180 	orr.w	r1, r1, #1048576	@ 0x100000
 8040688:	f04f 0e00 	mov.w	lr, #0
 804068c:	3c01      	subs	r4, #1
 804068e:	f300 80ab 	bgt.w	80407e8 <__aeabi_dmul+0x238>
 8040692:	f114 0f36 	cmn.w	r4, #54	@ 0x36
 8040696:	bfde      	ittt	le
 8040698:	2000      	movle	r0, #0
 804069a:	f001 4100 	andle.w	r1, r1, #2147483648	@ 0x80000000
 804069e:	bd70      	pople	{r4, r5, r6, pc}
 80406a0:	f1c4 0400 	rsb	r4, r4, #0
 80406a4:	3c20      	subs	r4, #32
 80406a6:	da35      	bge.n	8040714 <__aeabi_dmul+0x164>
 80406a8:	340c      	adds	r4, #12
 80406aa:	dc1b      	bgt.n	80406e4 <__aeabi_dmul+0x134>
 80406ac:	f104 0414 	add.w	r4, r4, #20
 80406b0:	f1c4 0520 	rsb	r5, r4, #32
 80406b4:	fa00 f305 	lsl.w	r3, r0, r5
 80406b8:	fa20 f004 	lsr.w	r0, r0, r4
 80406bc:	fa01 f205 	lsl.w	r2, r1, r5
 80406c0:	ea40 0002 	orr.w	r0, r0, r2
 80406c4:	f001 4200 	and.w	r2, r1, #2147483648	@ 0x80000000
 80406c8:	f021 4100 	bic.w	r1, r1, #2147483648	@ 0x80000000
 80406cc:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 80406d0:	fa21 f604 	lsr.w	r6, r1, r4
 80406d4:	eb42 0106 	adc.w	r1, r2, r6
 80406d8:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 80406dc:	bf08      	it	eq
 80406de:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 80406e2:	bd70      	pop	{r4, r5, r6, pc}
 80406e4:	f1c4 040c 	rsb	r4, r4, #12
 80406e8:	f1c4 0520 	rsb	r5, r4, #32
 80406ec:	fa00 f304 	lsl.w	r3, r0, r4
 80406f0:	fa20 f005 	lsr.w	r0, r0, r5
 80406f4:	fa01 f204 	lsl.w	r2, r1, r4
 80406f8:	ea40 0002 	orr.w	r0, r0, r2
 80406fc:	f001 4100 	and.w	r1, r1, #2147483648	@ 0x80000000
 8040700:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 8040704:	f141 0100 	adc.w	r1, r1, #0
 8040708:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 804070c:	bf08      	it	eq
 804070e:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 8040712:	bd70      	pop	{r4, r5, r6, pc}
 8040714:	f1c4 0520 	rsb	r5, r4, #32
 8040718:	fa00 f205 	lsl.w	r2, r0, r5
 804071c:	ea4e 0e02 	orr.w	lr, lr, r2
 8040720:	fa20 f304 	lsr.w	r3, r0, r4
 8040724:	fa01 f205 	lsl.w	r2, r1, r5
 8040728:	ea43 0302 	orr.w	r3, r3, r2
 804072c:	fa21 f004 	lsr.w	r0, r1, r4
 8040730:	f001 4100 	and.w	r1, r1, #2147483648	@ 0x80000000
 8040734:	fa21 f204 	lsr.w	r2, r1, r4
 8040738:	ea20 0002 	bic.w	r0, r0, r2
 804073c:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
 8040740:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8040744:	bf08      	it	eq
 8040746:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 804074a:	bd70      	pop	{r4, r5, r6, pc}
 804074c:	f094 0f00 	teq	r4, #0
 8040750:	d10f      	bne.n	8040772 <__aeabi_dmul+0x1c2>
 8040752:	f001 4600 	and.w	r6, r1, #2147483648	@ 0x80000000
 8040756:	0040      	lsls	r0, r0, #1
 8040758:	eb41 0101 	adc.w	r1, r1, r1
 804075c:	f411 1f80 	tst.w	r1, #1048576	@ 0x100000
 8040760:	bf08      	it	eq
 8040762:	3c01      	subeq	r4, #1
 8040764:	d0f7      	beq.n	8040756 <__aeabi_dmul+0x1a6>
 8040766:	ea41 0106 	orr.w	r1, r1, r6
 804076a:	f095 0f00 	teq	r5, #0
 804076e:	bf18      	it	ne
 8040770:	4770      	bxne	lr
 8040772:	f003 4600 	and.w	r6, r3, #2147483648	@ 0x80000000
 8040776:	0052      	lsls	r2, r2, #1
 8040778:	eb43 0303 	adc.w	r3, r3, r3
 804077c:	f413 1f80 	tst.w	r3, #1048576	@ 0x100000
 8040780:	bf08      	it	eq
 8040782:	3d01      	subeq	r5, #1
 8040784:	d0f7      	beq.n	8040776 <__aeabi_dmul+0x1c6>
 8040786:	ea43 0306 	orr.w	r3, r3, r6
 804078a:	4770      	bx	lr
 804078c:	ea94 0f0c 	teq	r4, ip
 8040790:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 8040794:	bf18      	it	ne
 8040796:	ea95 0f0c 	teqne	r5, ip
 804079a:	d00c      	beq.n	80407b6 <__aeabi_dmul+0x206>
 804079c:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 80407a0:	bf18      	it	ne
 80407a2:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 80407a6:	d1d1      	bne.n	804074c <__aeabi_dmul+0x19c>
 80407a8:	ea81 0103 	eor.w	r1, r1, r3
 80407ac:	f001 4100 	and.w	r1, r1, #2147483648	@ 0x80000000
 80407b0:	f04f 0000 	mov.w	r0, #0
 80407b4:	bd70      	pop	{r4, r5, r6, pc}
 80407b6:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 80407ba:	bf06      	itte	eq
 80407bc:	4610      	moveq	r0, r2
 80407be:	4619      	moveq	r1, r3
 80407c0:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 80407c4:	d019      	beq.n	80407fa <__aeabi_dmul+0x24a>
 80407c6:	ea94 0f0c 	teq	r4, ip
 80407ca:	d102      	bne.n	80407d2 <__aeabi_dmul+0x222>
 80407cc:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
 80407d0:	d113      	bne.n	80407fa <__aeabi_dmul+0x24a>
 80407d2:	ea95 0f0c 	teq	r5, ip
 80407d6:	d105      	bne.n	80407e4 <__aeabi_dmul+0x234>
 80407d8:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
 80407dc:	bf1c      	itt	ne
 80407de:	4610      	movne	r0, r2
 80407e0:	4619      	movne	r1, r3
 80407e2:	d10a      	bne.n	80407fa <__aeabi_dmul+0x24a>
 80407e4:	ea81 0103 	eor.w	r1, r1, r3
 80407e8:	f001 4100 	and.w	r1, r1, #2147483648	@ 0x80000000
 80407ec:	f041 41fe 	orr.w	r1, r1, #2130706432	@ 0x7f000000
 80407f0:	f441 0170 	orr.w	r1, r1, #15728640	@ 0xf00000
 80407f4:	f04f 0000 	mov.w	r0, #0
 80407f8:	bd70      	pop	{r4, r5, r6, pc}
 80407fa:	f041 41fe 	orr.w	r1, r1, #2130706432	@ 0x7f000000
 80407fe:	f441 0178 	orr.w	r1, r1, #16252928	@ 0xf80000
 8040802:	bd70      	pop	{r4, r5, r6, pc}

08040804 <__aeabi_ddiv>:
 8040804:	b570      	push	{r4, r5, r6, lr}
 8040806:	f04f 0cff 	mov.w	ip, #255	@ 0xff
 804080a:	f44c 6ce0 	orr.w	ip, ip, #1792	@ 0x700
 804080e:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 8040812:	bf1d      	ittte	ne
 8040814:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 8040818:	ea94 0f0c 	teqne	r4, ip
 804081c:	ea95 0f0c 	teqne	r5, ip
 8040820:	f000 f8a7 	bleq	8040972 <__aeabi_ddiv+0x16e>
 8040824:	eba4 0405 	sub.w	r4, r4, r5
 8040828:	ea81 0e03 	eor.w	lr, r1, r3
 804082c:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 8040830:	ea4f 3101 	mov.w	r1, r1, lsl #12
 8040834:	f000 8088 	beq.w	8040948 <__aeabi_ddiv+0x144>
 8040838:	ea4f 3303 	mov.w	r3, r3, lsl #12
 804083c:	f04f 5580 	mov.w	r5, #268435456	@ 0x10000000
 8040840:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
 8040844:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 8040848:	ea4f 2202 	mov.w	r2, r2, lsl #8
 804084c:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
 8040850:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
 8040854:	ea4f 2600 	mov.w	r6, r0, lsl #8
 8040858:	f00e 4100 	and.w	r1, lr, #2147483648	@ 0x80000000
 804085c:	429d      	cmp	r5, r3
 804085e:	bf08      	it	eq
 8040860:	4296      	cmpeq	r6, r2
 8040862:	f144 04fd 	adc.w	r4, r4, #253	@ 0xfd
 8040866:	f504 7440 	add.w	r4, r4, #768	@ 0x300
 804086a:	d202      	bcs.n	8040872 <__aeabi_ddiv+0x6e>
 804086c:	085b      	lsrs	r3, r3, #1
 804086e:	ea4f 0232 	mov.w	r2, r2, rrx
 8040872:	1ab6      	subs	r6, r6, r2
 8040874:	eb65 0503 	sbc.w	r5, r5, r3
 8040878:	085b      	lsrs	r3, r3, #1
 804087a:	ea4f 0232 	mov.w	r2, r2, rrx
 804087e:	f44f 1080 	mov.w	r0, #1048576	@ 0x100000
 8040882:	f44f 2c00 	mov.w	ip, #524288	@ 0x80000
 8040886:	ebb6 0e02 	subs.w	lr, r6, r2
 804088a:	eb75 0e03 	sbcs.w	lr, r5, r3
 804088e:	bf22      	ittt	cs
 8040890:	1ab6      	subcs	r6, r6, r2
 8040892:	4675      	movcs	r5, lr
 8040894:	ea40 000c 	orrcs.w	r0, r0, ip
 8040898:	085b      	lsrs	r3, r3, #1
 804089a:	ea4f 0232 	mov.w	r2, r2, rrx
 804089e:	ebb6 0e02 	subs.w	lr, r6, r2
 80408a2:	eb75 0e03 	sbcs.w	lr, r5, r3
 80408a6:	bf22      	ittt	cs
 80408a8:	1ab6      	subcs	r6, r6, r2
 80408aa:	4675      	movcs	r5, lr
 80408ac:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 80408b0:	085b      	lsrs	r3, r3, #1
 80408b2:	ea4f 0232 	mov.w	r2, r2, rrx
 80408b6:	ebb6 0e02 	subs.w	lr, r6, r2
 80408ba:	eb75 0e03 	sbcs.w	lr, r5, r3
 80408be:	bf22      	ittt	cs
 80408c0:	1ab6      	subcs	r6, r6, r2
 80408c2:	4675      	movcs	r5, lr
 80408c4:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 80408c8:	085b      	lsrs	r3, r3, #1
 80408ca:	ea4f 0232 	mov.w	r2, r2, rrx
 80408ce:	ebb6 0e02 	subs.w	lr, r6, r2
 80408d2:	eb75 0e03 	sbcs.w	lr, r5, r3
 80408d6:	bf22      	ittt	cs
 80408d8:	1ab6      	subcs	r6, r6, r2
 80408da:	4675      	movcs	r5, lr
 80408dc:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 80408e0:	ea55 0e06 	orrs.w	lr, r5, r6
 80408e4:	d018      	beq.n	8040918 <__aeabi_ddiv+0x114>
 80408e6:	ea4f 1505 	mov.w	r5, r5, lsl #4
 80408ea:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
 80408ee:	ea4f 1606 	mov.w	r6, r6, lsl #4
 80408f2:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 80408f6:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
 80408fa:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 80408fe:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
 8040902:	d1c0      	bne.n	8040886 <__aeabi_ddiv+0x82>
 8040904:	f411 1f80 	tst.w	r1, #1048576	@ 0x100000
 8040908:	d10b      	bne.n	8040922 <__aeabi_ddiv+0x11e>
 804090a:	ea41 0100 	orr.w	r1, r1, r0
 804090e:	f04f 0000 	mov.w	r0, #0
 8040912:	f04f 4c00 	mov.w	ip, #2147483648	@ 0x80000000
 8040916:	e7b6      	b.n	8040886 <__aeabi_ddiv+0x82>
 8040918:	f411 1f80 	tst.w	r1, #1048576	@ 0x100000
 804091c:	bf04      	itt	eq
 804091e:	4301      	orreq	r1, r0
 8040920:	2000      	moveq	r0, #0
 8040922:	f1b4 0cfd 	subs.w	ip, r4, #253	@ 0xfd
 8040926:	bf88      	it	hi
 8040928:	f5bc 6fe0 	cmphi.w	ip, #1792	@ 0x700
 804092c:	f63f aeaf 	bhi.w	804068e <__aeabi_dmul+0xde>
 8040930:	ebb5 0c03 	subs.w	ip, r5, r3
 8040934:	bf04      	itt	eq
 8040936:	ebb6 0c02 	subseq.w	ip, r6, r2
 804093a:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 804093e:	f150 0000 	adcs.w	r0, r0, #0
 8040942:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 8040946:	bd70      	pop	{r4, r5, r6, pc}
 8040948:	f00e 4e00 	and.w	lr, lr, #2147483648	@ 0x80000000
 804094c:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
 8040950:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
 8040954:	bfc2      	ittt	gt
 8040956:	ebd4 050c 	rsbsgt	r5, r4, ip
 804095a:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 804095e:	bd70      	popgt	{r4, r5, r6, pc}
 8040960:	f441 1180 	orr.w	r1, r1, #1048576	@ 0x100000
 8040964:	f04f 0e00 	mov.w	lr, #0
 8040968:	3c01      	subs	r4, #1
 804096a:	e690      	b.n	804068e <__aeabi_dmul+0xde>
 804096c:	ea45 0e06 	orr.w	lr, r5, r6
 8040970:	e68d      	b.n	804068e <__aeabi_dmul+0xde>
 8040972:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 8040976:	ea94 0f0c 	teq	r4, ip
 804097a:	bf08      	it	eq
 804097c:	ea95 0f0c 	teqeq	r5, ip
 8040980:	f43f af3b 	beq.w	80407fa <__aeabi_dmul+0x24a>
 8040984:	ea94 0f0c 	teq	r4, ip
 8040988:	d10a      	bne.n	80409a0 <__aeabi_ddiv+0x19c>
 804098a:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 804098e:	f47f af34 	bne.w	80407fa <__aeabi_dmul+0x24a>
 8040992:	ea95 0f0c 	teq	r5, ip
 8040996:	f47f af25 	bne.w	80407e4 <__aeabi_dmul+0x234>
 804099a:	4610      	mov	r0, r2
 804099c:	4619      	mov	r1, r3
 804099e:	e72c      	b.n	80407fa <__aeabi_dmul+0x24a>
 80409a0:	ea95 0f0c 	teq	r5, ip
 80409a4:	d106      	bne.n	80409b4 <__aeabi_ddiv+0x1b0>
 80409a6:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 80409aa:	f43f aefd 	beq.w	80407a8 <__aeabi_dmul+0x1f8>
 80409ae:	4610      	mov	r0, r2
 80409b0:	4619      	mov	r1, r3
 80409b2:	e722      	b.n	80407fa <__aeabi_dmul+0x24a>
 80409b4:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 80409b8:	bf18      	it	ne
 80409ba:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 80409be:	f47f aec5 	bne.w	804074c <__aeabi_dmul+0x19c>
 80409c2:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
 80409c6:	f47f af0d 	bne.w	80407e4 <__aeabi_dmul+0x234>
 80409ca:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
 80409ce:	f47f aeeb 	bne.w	80407a8 <__aeabi_dmul+0x1f8>
 80409d2:	e712      	b.n	80407fa <__aeabi_dmul+0x24a>

080409d4 <__gedf2>:
 80409d4:	f04f 3cff 	mov.w	ip, #4294967295
 80409d8:	e006      	b.n	80409e8 <__cmpdf2+0x4>
 80409da:	bf00      	nop

080409dc <__ledf2>:
 80409dc:	f04f 0c01 	mov.w	ip, #1
 80409e0:	e002      	b.n	80409e8 <__cmpdf2+0x4>
 80409e2:	bf00      	nop

080409e4 <__cmpdf2>:
 80409e4:	f04f 0c01 	mov.w	ip, #1
 80409e8:	f84d cd04 	str.w	ip, [sp, #-4]!
 80409ec:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 80409f0:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 80409f4:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 80409f8:	bf18      	it	ne
 80409fa:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
 80409fe:	d01b      	beq.n	8040a38 <__cmpdf2+0x54>
 8040a00:	b001      	add	sp, #4
 8040a02:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
 8040a06:	bf0c      	ite	eq
 8040a08:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
 8040a0c:	ea91 0f03 	teqne	r1, r3
 8040a10:	bf02      	ittt	eq
 8040a12:	ea90 0f02 	teqeq	r0, r2
 8040a16:	2000      	moveq	r0, #0
 8040a18:	4770      	bxeq	lr
 8040a1a:	f110 0f00 	cmn.w	r0, #0
 8040a1e:	ea91 0f03 	teq	r1, r3
 8040a22:	bf58      	it	pl
 8040a24:	4299      	cmppl	r1, r3
 8040a26:	bf08      	it	eq
 8040a28:	4290      	cmpeq	r0, r2
 8040a2a:	bf2c      	ite	cs
 8040a2c:	17d8      	asrcs	r0, r3, #31
 8040a2e:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
 8040a32:	f040 0001 	orr.w	r0, r0, #1
 8040a36:	4770      	bx	lr
 8040a38:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8040a3c:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8040a40:	d102      	bne.n	8040a48 <__cmpdf2+0x64>
 8040a42:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 8040a46:	d107      	bne.n	8040a58 <__cmpdf2+0x74>
 8040a48:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8040a4c:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8040a50:	d1d6      	bne.n	8040a00 <__cmpdf2+0x1c>
 8040a52:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 8040a56:	d0d3      	beq.n	8040a00 <__cmpdf2+0x1c>
 8040a58:	f85d 0b04 	ldr.w	r0, [sp], #4
 8040a5c:	4770      	bx	lr
 8040a5e:	bf00      	nop

08040a60 <__aeabi_cdrcmple>:
 8040a60:	4684      	mov	ip, r0
 8040a62:	4610      	mov	r0, r2
 8040a64:	4662      	mov	r2, ip
 8040a66:	468c      	mov	ip, r1
 8040a68:	4619      	mov	r1, r3
 8040a6a:	4663      	mov	r3, ip
 8040a6c:	e000      	b.n	8040a70 <__aeabi_cdcmpeq>
 8040a6e:	bf00      	nop

08040a70 <__aeabi_cdcmpeq>:
 8040a70:	b501      	push	{r0, lr}
 8040a72:	f7ff ffb7 	bl	80409e4 <__cmpdf2>
 8040a76:	2800      	cmp	r0, #0
 8040a78:	bf48      	it	mi
 8040a7a:	f110 0f00 	cmnmi.w	r0, #0
 8040a7e:	bd01      	pop	{r0, pc}

08040a80 <__aeabi_dcmpeq>:
 8040a80:	f84d ed08 	str.w	lr, [sp, #-8]!
 8040a84:	f7ff fff4 	bl	8040a70 <__aeabi_cdcmpeq>
 8040a88:	bf0c      	ite	eq
 8040a8a:	2001      	moveq	r0, #1
 8040a8c:	2000      	movne	r0, #0
 8040a8e:	f85d fb08 	ldr.w	pc, [sp], #8
 8040a92:	bf00      	nop

08040a94 <__aeabi_dcmplt>:
 8040a94:	f84d ed08 	str.w	lr, [sp, #-8]!
 8040a98:	f7ff ffea 	bl	8040a70 <__aeabi_cdcmpeq>
 8040a9c:	bf34      	ite	cc
 8040a9e:	2001      	movcc	r0, #1
 8040aa0:	2000      	movcs	r0, #0
 8040aa2:	f85d fb08 	ldr.w	pc, [sp], #8
 8040aa6:	bf00      	nop

08040aa8 <__aeabi_dcmple>:
 8040aa8:	f84d ed08 	str.w	lr, [sp, #-8]!
 8040aac:	f7ff ffe0 	bl	8040a70 <__aeabi_cdcmpeq>
 8040ab0:	bf94      	ite	ls
 8040ab2:	2001      	movls	r0, #1
 8040ab4:	2000      	movhi	r0, #0
 8040ab6:	f85d fb08 	ldr.w	pc, [sp], #8
 8040aba:	bf00      	nop

08040abc <__aeabi_dcmpge>:
 8040abc:	f84d ed08 	str.w	lr, [sp, #-8]!
 8040ac0:	f7ff ffce 	bl	8040a60 <__aeabi_cdrcmple>
 8040ac4:	bf94      	ite	ls
 8040ac6:	2001      	movls	r0, #1
 8040ac8:	2000      	movhi	r0, #0
 8040aca:	f85d fb08 	ldr.w	pc, [sp], #8
 8040ace:	bf00      	nop

08040ad0 <__aeabi_dcmpgt>:
 8040ad0:	f84d ed08 	str.w	lr, [sp, #-8]!
 8040ad4:	f7ff ffc4 	bl	8040a60 <__aeabi_cdrcmple>
 8040ad8:	bf34      	ite	cc
 8040ada:	2001      	movcc	r0, #1
 8040adc:	2000      	movcs	r0, #0
 8040ade:	f85d fb08 	ldr.w	pc, [sp], #8
 8040ae2:	bf00      	nop

08040ae4 <__aeabi_dcmpun>:
 8040ae4:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8040ae8:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8040aec:	d102      	bne.n	8040af4 <__aeabi_dcmpun+0x10>
 8040aee:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 8040af2:	d10a      	bne.n	8040b0a <__aeabi_dcmpun+0x26>
 8040af4:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8040af8:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8040afc:	d102      	bne.n	8040b04 <__aeabi_dcmpun+0x20>
 8040afe:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 8040b02:	d102      	bne.n	8040b0a <__aeabi_dcmpun+0x26>
 8040b04:	f04f 0000 	mov.w	r0, #0
 8040b08:	4770      	bx	lr
 8040b0a:	f04f 0001 	mov.w	r0, #1
 8040b0e:	4770      	bx	lr

08040b10 <__aeabi_d2iz>:
 8040b10:	ea4f 0241 	mov.w	r2, r1, lsl #1
 8040b14:	f512 1200 	adds.w	r2, r2, #2097152	@ 0x200000
 8040b18:	d215      	bcs.n	8040b46 <__aeabi_d2iz+0x36>
 8040b1a:	d511      	bpl.n	8040b40 <__aeabi_d2iz+0x30>
 8040b1c:	f46f 7378 	mvn.w	r3, #992	@ 0x3e0
 8040b20:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 8040b24:	d912      	bls.n	8040b4c <__aeabi_d2iz+0x3c>
 8040b26:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 8040b2a:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
 8040b2e:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 8040b32:	f011 4f00 	tst.w	r1, #2147483648	@ 0x80000000
 8040b36:	fa23 f002 	lsr.w	r0, r3, r2
 8040b3a:	bf18      	it	ne
 8040b3c:	4240      	negne	r0, r0
 8040b3e:	4770      	bx	lr
 8040b40:	f04f 0000 	mov.w	r0, #0
 8040b44:	4770      	bx	lr
 8040b46:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 8040b4a:	d105      	bne.n	8040b58 <__aeabi_d2iz+0x48>
 8040b4c:	f011 4000 	ands.w	r0, r1, #2147483648	@ 0x80000000
 8040b50:	bf08      	it	eq
 8040b52:	f06f 4000 	mvneq.w	r0, #2147483648	@ 0x80000000
 8040b56:	4770      	bx	lr
 8040b58:	f04f 0000 	mov.w	r0, #0
 8040b5c:	4770      	bx	lr
 8040b5e:	bf00      	nop

08040b60 <__aeabi_d2f>:
 8040b60:	ea4f 0241 	mov.w	r2, r1, lsl #1
 8040b64:	f1b2 43e0 	subs.w	r3, r2, #1879048192	@ 0x70000000
 8040b68:	bf24      	itt	cs
 8040b6a:	f5b3 1c00 	subscs.w	ip, r3, #2097152	@ 0x200000
 8040b6e:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	@ 0x1fc00000
 8040b72:	d90d      	bls.n	8040b90 <__aeabi_d2f+0x30>
 8040b74:	f001 4c00 	and.w	ip, r1, #2147483648	@ 0x80000000
 8040b78:	ea4f 02c0 	mov.w	r2, r0, lsl #3
 8040b7c:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
 8040b80:	f1b2 4f00 	cmp.w	r2, #2147483648	@ 0x80000000
 8040b84:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
 8040b88:	bf08      	it	eq
 8040b8a:	f020 0001 	biceq.w	r0, r0, #1
 8040b8e:	4770      	bx	lr
 8040b90:	f011 4f80 	tst.w	r1, #1073741824	@ 0x40000000
 8040b94:	d121      	bne.n	8040bda <__aeabi_d2f+0x7a>
 8040b96:	f113 7238 	adds.w	r2, r3, #48234496	@ 0x2e00000
 8040b9a:	bfbc      	itt	lt
 8040b9c:	f001 4000 	andlt.w	r0, r1, #2147483648	@ 0x80000000
 8040ba0:	4770      	bxlt	lr
 8040ba2:	f441 1180 	orr.w	r1, r1, #1048576	@ 0x100000
 8040ba6:	ea4f 5252 	mov.w	r2, r2, lsr #21
 8040baa:	f1c2 0218 	rsb	r2, r2, #24
 8040bae:	f1c2 0c20 	rsb	ip, r2, #32
 8040bb2:	fa10 f30c 	lsls.w	r3, r0, ip
 8040bb6:	fa20 f002 	lsr.w	r0, r0, r2
 8040bba:	bf18      	it	ne
 8040bbc:	f040 0001 	orrne.w	r0, r0, #1
 8040bc0:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 8040bc4:	ea4f 23d3 	mov.w	r3, r3, lsr #11
 8040bc8:	fa03 fc0c 	lsl.w	ip, r3, ip
 8040bcc:	ea40 000c 	orr.w	r0, r0, ip
 8040bd0:	fa23 f302 	lsr.w	r3, r3, r2
 8040bd4:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8040bd8:	e7cc      	b.n	8040b74 <__aeabi_d2f+0x14>
 8040bda:	ea7f 5362 	mvns.w	r3, r2, asr #21
 8040bde:	d107      	bne.n	8040bf0 <__aeabi_d2f+0x90>
 8040be0:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
 8040be4:	bf1e      	ittt	ne
 8040be6:	f04f 40fe 	movne.w	r0, #2130706432	@ 0x7f000000
 8040bea:	f440 0040 	orrne.w	r0, r0, #12582912	@ 0xc00000
 8040bee:	4770      	bxne	lr
 8040bf0:	f001 4000 	and.w	r0, r1, #2147483648	@ 0x80000000
 8040bf4:	f040 40fe 	orr.w	r0, r0, #2130706432	@ 0x7f000000
 8040bf8:	f440 0000 	orr.w	r0, r0, #8388608	@ 0x800000
 8040bfc:	4770      	bx	lr
 8040bfe:	bf00      	nop

08040c00 <MX_GPIO_Init>:
/* USER CODE END 1 */

/** Configure pins
*/
void MX_GPIO_Init(void)
{
 8040c00:	b5f0      	push	{r4, r5, r6, r7, lr}

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8040c02:	2400      	movs	r4, #0
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(BTN_BLUE_GPIO_Port, &GPIO_InitStruct);

  /*Configure GPIO pin : PtPin */
  GPIO_InitStruct.Pin = LED_GREEN_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8040c04:	2601      	movs	r6, #1
{
 8040c06:	b089      	sub	sp, #36	@ 0x24
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8040c08:	e9cd 4402 	strd	r4, r4, [sp, #8]
 8040c0c:	e9cd 4404 	strd	r4, r4, [sp, #16]
  __HAL_RCC_GPIOC_CLK_ENABLE();
 8040c10:	4b1e      	ldr	r3, [pc, #120]	@ (8040c8c <MX_GPIO_Init+0x8c>)
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8040c12:	9406      	str	r4, [sp, #24]
  __HAL_RCC_GPIOC_CLK_ENABLE();
 8040c14:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
  HAL_GPIO_WritePin(LED_GREEN_GPIO_Port, LED_GREEN_Pin, GPIO_PIN_RESET);
 8040c16:	4d1e      	ldr	r5, [pc, #120]	@ (8040c90 <MX_GPIO_Init+0x90>)
  __HAL_RCC_GPIOC_CLK_ENABLE();
 8040c18:	f042 0204 	orr.w	r2, r2, #4
 8040c1c:	64da      	str	r2, [r3, #76]	@ 0x4c
 8040c1e:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
  HAL_GPIO_WritePin(LED_RED_GPIO_Port, LED_RED_Pin, GPIO_PIN_RESET);
 8040c20:	4f1c      	ldr	r7, [pc, #112]	@ (8040c94 <MX_GPIO_Init+0x94>)
  __HAL_RCC_GPIOC_CLK_ENABLE();
 8040c22:	f002 0204 	and.w	r2, r2, #4
 8040c26:	9200      	str	r2, [sp, #0]
 8040c28:	9a00      	ldr	r2, [sp, #0]
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8040c2a:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
  HAL_GPIO_WritePin(LED_GREEN_GPIO_Port, LED_GREEN_Pin, GPIO_PIN_RESET);
 8040c2c:	4628      	mov	r0, r5
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8040c2e:	4332      	orrs	r2, r6
 8040c30:	64da      	str	r2, [r3, #76]	@ 0x4c
 8040c32:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
  HAL_GPIO_WritePin(LED_GREEN_GPIO_Port, LED_GREEN_Pin, GPIO_PIN_RESET);
 8040c34:	4622      	mov	r2, r4
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8040c36:	4033      	ands	r3, r6
 8040c38:	9301      	str	r3, [sp, #4]
  HAL_GPIO_WritePin(LED_GREEN_GPIO_Port, LED_GREEN_Pin, GPIO_PIN_RESET);
 8040c3a:	2180      	movs	r1, #128	@ 0x80
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8040c3c:	9b01      	ldr	r3, [sp, #4]
  HAL_GPIO_WritePin(LED_GREEN_GPIO_Port, LED_GREEN_Pin, GPIO_PIN_RESET);
 8040c3e:	f00a fdc3 	bl	804b7c8 <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(LED_RED_GPIO_Port, LED_RED_Pin, GPIO_PIN_RESET);
 8040c42:	4622      	mov	r2, r4
 8040c44:	4638      	mov	r0, r7
 8040c46:	f44f 7100 	mov.w	r1, #512	@ 0x200
 8040c4a:	f00a fdbd 	bl	804b7c8 <HAL_GPIO_WritePin>
  GPIO_InitStruct.Pin = BTN_BLUE_Pin;
 8040c4e:	f44f 5200 	mov.w	r2, #8192	@ 0x2000
 8040c52:	2300      	movs	r3, #0
  HAL_GPIO_Init(BTN_BLUE_GPIO_Port, &GPIO_InitStruct);
 8040c54:	4628      	mov	r0, r5
 8040c56:	a902      	add	r1, sp, #8
  GPIO_InitStruct.Pin = BTN_BLUE_Pin;
 8040c58:	e9cd 2302 	strd	r2, r3, [sp, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8040c5c:	9404      	str	r4, [sp, #16]
  HAL_GPIO_Init(BTN_BLUE_GPIO_Port, &GPIO_InitStruct);
 8040c5e:	f00a fca3 	bl	804b5a8 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = LED_GREEN_Pin;
 8040c62:	2380      	movs	r3, #128	@ 0x80
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(LED_GREEN_GPIO_Port, &GPIO_InitStruct);
 8040c64:	4628      	mov	r0, r5
 8040c66:	a902      	add	r1, sp, #8
  GPIO_InitStruct.Pin = LED_GREEN_Pin;
 8040c68:	9302      	str	r3, [sp, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8040c6a:	e9cd 6403 	strd	r6, r4, [sp, #12]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8040c6e:	9405      	str	r4, [sp, #20]
  HAL_GPIO_Init(LED_GREEN_GPIO_Port, &GPIO_InitStruct);
 8040c70:	f00a fc9a 	bl	804b5a8 <HAL_GPIO_Init>

  /*Configure GPIO pin : PtPin */
  GPIO_InitStruct.Pin = LED_RED_Pin;
 8040c74:	f44f 7300 	mov.w	r3, #512	@ 0x200
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(LED_RED_GPIO_Port, &GPIO_InitStruct);
 8040c78:	4638      	mov	r0, r7
 8040c7a:	a902      	add	r1, sp, #8
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8040c7c:	e9cd 6403 	strd	r6, r4, [sp, #12]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8040c80:	9405      	str	r4, [sp, #20]
  GPIO_InitStruct.Pin = LED_RED_Pin;
 8040c82:	9302      	str	r3, [sp, #8]
  HAL_GPIO_Init(LED_RED_GPIO_Port, &GPIO_InitStruct);
 8040c84:	f00a fc90 	bl	804b5a8 <HAL_GPIO_Init>

}
 8040c88:	b009      	add	sp, #36	@ 0x24
 8040c8a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8040c8c:	40021000 	.word	0x40021000
 8040c90:	42020800 	.word	0x42020800
 8040c94:	42020000 	.word	0x42020000

08040c98 <SecureFault_Callback>:
}

//secure fault generated by IDAU/SAU check */
void SecureFault_Callback(void)
{
  HAL_GPIO_WritePin(LED_RED_GPIO_Port, LED_RED_Pin, GPIO_PIN_SET);
 8040c98:	2201      	movs	r2, #1
 8040c9a:	f44f 7100 	mov.w	r1, #512	@ 0x200
{
 8040c9e:	b508      	push	{r3, lr}
  HAL_GPIO_WritePin(LED_RED_GPIO_Port, LED_RED_Pin, GPIO_PIN_SET);
 8040ca0:	4802      	ldr	r0, [pc, #8]	@ (8040cac <SecureFault_Callback+0x14>)
 8040ca2:	f00a fd91 	bl	804b7c8 <HAL_GPIO_WritePin>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8040ca6:	b672      	cpsid	i
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
 8040ca8:	e7fe      	b.n	8040ca8 <SecureFault_Callback+0x10>
 8040caa:	bf00      	nop
 8040cac:	42020000 	.word	0x42020000

08040cb0 <SecureError_Callback>:
void SecureError_Callback(void)
 8040cb0:	b508      	push	{r3, lr}
 8040cb2:	f7ff fff1 	bl	8040c98 <SecureFault_Callback>
 8040cb6:	bf00      	nop

08040cb8 <wrapper_init>:
void wrapper_init() {
 8040cb8:	b508      	push	{r3, lr}
	SECURE_checkState(&s, sizeof(State));
 8040cba:	4813      	ldr	r0, [pc, #76]	@ (8040d08 <wrapper_init+0x50>)
 8040cbc:	f640 0104 	movw	r1, #2052	@ 0x804
 8040cc0:	f00d fa6e 	bl	804e1a0 <__SECURE_checkState_veneer>
	char current_char = start_char;
 8040cc4:	2341      	movs	r3, #65	@ 0x41
 8040cc6:	4a11      	ldr	r2, [pc, #68]	@ (8040d0c <wrapper_init+0x54>)
        s.input[j] = current_char;
 8040cc8:	469c      	mov	ip, r3
 8040cca:	f502 6000 	add.w	r0, r2, #2048	@ 0x800
 8040cce:	e007      	b.n	8040ce0 <wrapper_init+0x28>
	for(int j=0; j<INPUT_SIZE; j++) {
 8040cd0:	4288      	cmp	r0, r1
 8040cd2:	d00f      	beq.n	8040cf4 <wrapper_init+0x3c>
        s.input[j] = current_char;
 8040cd4:	f802 cf02 	strb.w	ip, [r2, #2]!
	for(int j=0; j<INPUT_SIZE; j++) {
 8040cd8:	4290      	cmp	r0, r2
        current_char++;
 8040cda:	f04f 0342 	mov.w	r3, #66	@ 0x42
	for(int j=0; j<INPUT_SIZE; j++) {
 8040cde:	d009      	beq.n	8040cf4 <wrapper_init+0x3c>
        current_char++;
 8040ce0:	1c59      	adds	r1, r3, #1
        s.input[j] = current_char;
 8040ce2:	7053      	strb	r3, [r2, #1]
        current_char++;
 8040ce4:	b2cb      	uxtb	r3, r1
        if (current_char > start_char+num_unique) {
 8040ce6:	2b5a      	cmp	r3, #90	@ 0x5a
        s.input[j] = current_char;
 8040ce8:	f102 0101 	add.w	r1, r2, #1
        if (current_char > start_char+num_unique) {
 8040cec:	d0f0      	beq.n	8040cd0 <wrapper_init+0x18>
        s.input[j] = current_char;
 8040cee:	460a      	mov	r2, r1
	for(int j=0; j<INPUT_SIZE; j++) {
 8040cf0:	4290      	cmp	r0, r2
 8040cf2:	d1f5      	bne.n	8040ce0 <wrapper_init+0x28>
	s.curIdx = 0;
 8040cf4:	2300      	movs	r3, #0
 8040cf6:	4804      	ldr	r0, [pc, #16]	@ (8040d08 <wrapper_init+0x50>)
	SECURE_setState(&s, sizeof(State));
 8040cf8:	f640 0104 	movw	r1, #2052	@ 0x804
	s.curIdx = 0;
 8040cfc:	f8c0 3800 	str.w	r3, [r0, #2048]	@ 0x800
}
 8040d00:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	SECURE_setState(&s, sizeof(State));
 8040d04:	f00d ba5c 	b.w	804e1c0 <__SECURE_setState_veneer>
 8040d08:	200181bc 	.word	0x200181bc
 8040d0c:	200181bb 	.word	0x200181bb

08040d10 <wrapper_collect>:
void wrapper_collect() {
 8040d10:	b538      	push	{r3, r4, r5, lr}
	SECURE_checkState(&s, sizeof(State));
 8040d12:	4c0f      	ldr	r4, [pc, #60]	@ (8040d50 <wrapper_collect+0x40>)
 8040d14:	f640 0104 	movw	r1, #2052	@ 0x804
 8040d18:	4620      	mov	r0, r4
 8040d1a:	f00d fa41 	bl	804e1a0 <__SECURE_checkState_veneer>
	s.input[s.curIdx] = 15;
 8040d1e:	f04f 0c0f 	mov.w	ip, #15
 8040d22:	f8d4 5800 	ldr.w	r5, [r4, #2048]	@ 0x800
	SECURE_setState(&s, sizeof(State));
 8040d26:	4620      	mov	r0, r4
	s.curIdx = (s.curIdx+1)%INPUT_SIZE;
 8040d28:	1c6b      	adds	r3, r5, #1
 8040d2a:	425a      	negs	r2, r3
 8040d2c:	f3c2 0209 	ubfx	r2, r2, #0, #10
 8040d30:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8040d34:	bf58      	it	pl
 8040d36:	4253      	negpl	r3, r2
 8040d38:	005b      	lsls	r3, r3, #1
	s.input[s.curIdx] = 15;
 8040d3a:	f804 c005 	strb.w	ip, [r4, r5]
	s.curIdx = (s.curIdx+1)%INPUT_SIZE;
 8040d3e:	f8c4 3800 	str.w	r3, [r4, #2048]	@ 0x800
	SECURE_setState(&s, sizeof(State));
 8040d42:	f640 0104 	movw	r1, #2052	@ 0x804
}
 8040d46:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	SECURE_setState(&s, sizeof(State));
 8040d4a:	f00d ba39 	b.w	804e1c0 <__SECURE_setState_veneer>
 8040d4e:	bf00      	nop
 8040d50:	200181bc 	.word	0x200181bc

08040d54 <sendline>:
	while(s[i] != '\n') i++;
 8040d54:	7803      	ldrb	r3, [r0, #0]
 8040d56:	2b0a      	cmp	r3, #10
 8040d58:	d009      	beq.n	8040d6e <sendline+0x1a>
 8040d5a:	4603      	mov	r3, r0
 8040d5c:	4619      	mov	r1, r3
 8040d5e:	f813 2f01 	ldrb.w	r2, [r3, #1]!
 8040d62:	2a0a      	cmp	r2, #10
 8040d64:	d1fa      	bne.n	8040d5c <sendline+0x8>
 8040d66:	1a09      	subs	r1, r1, r0
	SECURE_send((uint8_t*)s, (i+1));
 8040d68:	3102      	adds	r1, #2
 8040d6a:	f00d ba11 	b.w	804e190 <__SECURE_send_veneer>
	while(s[i] != '\n') i++;
 8040d6e:	2101      	movs	r1, #1
	SECURE_send((uint8_t*)s, (i+1));
 8040d70:	f00d ba0e 	b.w	804e190 <__SECURE_send_veneer>

08040d74 <train>:
void train(float init_val, int epochs, float rate) {
 8040d74:	b5f0      	push	{r4, r5, r6, r7, lr}
 8040d76:	ed2d 8b02 	vpush	{d8}
	int i=0;
 8040d7a:	2200      	movs	r2, #0
void train(float init_val, int epochs, float rate) {
 8040d7c:	4605      	mov	r5, r0
 8040d7e:	eeb0 8a60 	vmov.f32	s16, s1
 8040d82:	4b47      	ldr	r3, [pc, #284]	@ (8040ea0 <train+0x12c>)
 8040d84:	b0a1      	sub	sp, #132	@ 0x84
	while(s[i] != '\n') i++;
 8040d86:	f813 0f01 	ldrb.w	r0, [r3, #1]!
 8040d8a:	4611      	mov	r1, r2
 8040d8c:	280a      	cmp	r0, #10
 8040d8e:	f102 0201 	add.w	r2, r2, #1
 8040d92:	d1f8      	bne.n	8040d86 <train+0x12>
	uint8_t buff[100]={};
 8040d94:	2400      	movs	r4, #0
	SECURE_send((uint8_t*)s, (i+1));
 8040d96:	4842      	ldr	r0, [pc, #264]	@ (8040ea0 <train+0x12c>)
 8040d98:	3102      	adds	r1, #2
 8040d9a:	f00d f9f9 	bl	804e190 <__SECURE_send_veneer>
	uint8_t buff[100]={};
 8040d9e:	2260      	movs	r2, #96	@ 0x60
 8040da0:	4621      	mov	r1, r4
 8040da2:	a808      	add	r0, sp, #32
 8040da4:	9407      	str	r4, [sp, #28]
 8040da6:	f00b f845 	bl	804be34 <memset>
	sprintf(buff, "[Test] Training: lr=%d, epoch=%d done [/Test]\n", (int) (rate*10000), epochs);
 8040daa:	eddf 7a3e 	vldr	s15, [pc, #248]	@ 8040ea4 <train+0x130>
 8040dae:	ee68 7a27 	vmul.f32	s15, s16, s15
 8040db2:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8040db6:	462b      	mov	r3, r5
 8040db8:	ee17 2a90 	vmov	r2, s15
 8040dbc:	493a      	ldr	r1, [pc, #232]	@ (8040ea8 <train+0x134>)
 8040dbe:	a807      	add	r0, sp, #28
 8040dc0:	f00a ff40 	bl	804bc44 <siprintf>
	while(s[i] != '\n') i++;
 8040dc4:	f89d 301c 	ldrb.w	r3, [sp, #28]
 8040dc8:	2b0a      	cmp	r3, #10
 8040dca:	d066      	beq.n	8040e9a <train+0x126>
	int i=0;
 8040dcc:	4622      	mov	r2, r4
 8040dce:	ab07      	add	r3, sp, #28
	while(s[i] != '\n') i++;
 8040dd0:	f813 0f01 	ldrb.w	r0, [r3, #1]!
 8040dd4:	4611      	mov	r1, r2
 8040dd6:	280a      	cmp	r0, #10
 8040dd8:	f102 0201 	add.w	r2, r2, #1
 8040ddc:	d1f8      	bne.n	8040dd0 <train+0x5c>
	SECURE_send((uint8_t*)s, (i+1));
 8040dde:	3102      	adds	r1, #2
 8040de0:	a807      	add	r0, sp, #28
 8040de2:	f00d f9d5 	bl	804e190 <__SECURE_send_veneer>
	tg = tg_init_with_data(s.input, INPUT_SIZE);
 8040de6:	f44f 6100 	mov.w	r1, #2048	@ 0x800
 8040dea:	4830      	ldr	r0, [pc, #192]	@ (8040eac <train+0x138>)
 8040dec:	f000 fbc2 	bl	8041574 <tg_init_with_data>
	int i=0;
 8040df0:	2200      	movs	r2, #0
	tg = tg_init_with_data(s.input, INPUT_SIZE);
 8040df2:	4606      	mov	r6, r0
	while(s[i] != '\n') i++;
 8040df4:	4b2e      	ldr	r3, [pc, #184]	@ (8040eb0 <train+0x13c>)
 8040df6:	f813 0f01 	ldrb.w	r0, [r3, #1]!
 8040dfa:	4611      	mov	r1, r2
 8040dfc:	280a      	cmp	r0, #10
 8040dfe:	f102 0201 	add.w	r2, r2, #1
 8040e02:	d1f8      	bne.n	8040df6 <train+0x82>
	SECURE_send((uint8_t*)s, (i+1));
 8040e04:	482a      	ldr	r0, [pc, #168]	@ (8040eb0 <train+0x13c>)
 8040e06:	3102      	adds	r1, #2
 8040e08:	f00d f9c2 	bl	804e190 <__SECURE_send_veneer>
	ann = model_gen(model, tg->n_char, n_h_layers, n_h_neurons, h_dropout, use_norm);
 8040e0c:	2201      	movs	r2, #1
 8040e0e:	2308      	movs	r3, #8
 8040e10:	6871      	ldr	r1, [r6, #4]
 8040e12:	ed9f 0a28 	vldr	s0, [pc, #160]	@ 8040eb4 <train+0x140>
 8040e16:	9200      	str	r2, [sp, #0]
 8040e18:	2002      	movs	r0, #2
 8040e1a:	f000 fee3 	bl	8041be4 <model_gen>
	int i=0;
 8040e1e:	2200      	movs	r2, #0
	ann = model_gen(model, tg->n_char, n_h_layers, n_h_neurons, h_dropout, use_norm);
 8040e20:	4607      	mov	r7, r0
	while(s[i] != '\n') i++;
 8040e22:	4b25      	ldr	r3, [pc, #148]	@ (8040eb8 <train+0x144>)
 8040e24:	f813 4f01 	ldrb.w	r4, [r3, #1]!
 8040e28:	4611      	mov	r1, r2
 8040e2a:	2c0a      	cmp	r4, #10
 8040e2c:	f102 0201 	add.w	r2, r2, #1
 8040e30:	d1f8      	bne.n	8040e24 <train+0xb0>
	SECURE_send((uint8_t*)s, (i+1));
 8040e32:	4821      	ldr	r0, [pc, #132]	@ (8040eb8 <train+0x144>)
 8040e34:	3102      	adds	r1, #2
 8040e36:	f00d f9ab 	bl	804e190 <__SECURE_send_veneer>
	tg_train(ann, tg, lr, ulen, vlen, cs, mbs, max_epoch, grad_clip, batch_len, n_threads);
 8040e3a:	2301      	movs	r3, #1
 8040e3c:	2204      	movs	r2, #4
 8040e3e:	9502      	str	r5, [sp, #8]
 8040e40:	f44f 757a 	mov.w	r5, #1000	@ 0x3e8
 8040e44:	9201      	str	r2, [sp, #4]
 8040e46:	e9cd 5303 	strd	r5, r3, [sp, #12]
 8040e4a:	461a      	mov	r2, r3
 8040e4c:	eddf 0a19 	vldr	s1, [pc, #100]	@ 8040eb4 <train+0x140>
 8040e50:	eeb0 0a48 	vmov.f32	s0, s16
 8040e54:	4638      	mov	r0, r7
 8040e56:	4631      	mov	r1, r6
 8040e58:	9400      	str	r4, [sp, #0]
 8040e5a:	f000 fc93 	bl	8041784 <tg_train>
	int i=0;
 8040e5e:	2300      	movs	r3, #0
 8040e60:	4a16      	ldr	r2, [pc, #88]	@ (8040ebc <train+0x148>)
	while(s[i] != '\n') i++;
 8040e62:	f812 0f01 	ldrb.w	r0, [r2, #1]!
 8040e66:	4619      	mov	r1, r3
 8040e68:	280a      	cmp	r0, #10
 8040e6a:	f103 0301 	add.w	r3, r3, #1
 8040e6e:	d1f8      	bne.n	8040e62 <train+0xee>
	SECURE_send((uint8_t*)s, (i+1));
 8040e70:	3102      	adds	r1, #2
 8040e72:	4812      	ldr	r0, [pc, #72]	@ (8040ebc <train+0x148>)
 8040e74:	f00d f98c 	bl	804e190 <__SECURE_send_veneer>
	free(tg->data); free(tg);
 8040e78:	68b0      	ldr	r0, [r6, #8]
 8040e7a:	f00a fcf5 	bl	804b868 <free>
 8040e7e:	4630      	mov	r0, r6
 8040e80:	f00a fcf2 	bl	804b868 <free>
	memcpy(pox_output, tg->c2i, POX_OUTPUT_SIZE);
 8040e84:	f44f 7280 	mov.w	r2, #256	@ 0x100
 8040e88:	f106 010c 	add.w	r1, r6, #12
 8040e8c:	480c      	ldr	r0, [pc, #48]	@ (8040ec0 <train+0x14c>)
 8040e8e:	f00b f8ce 	bl	804c02e <memcpy>
}
 8040e92:	b021      	add	sp, #132	@ 0x84
 8040e94:	ecbd 8b02 	vpop	{d8}
 8040e98:	bdf0      	pop	{r4, r5, r6, r7, pc}
	while(s[i] != '\n') i++;
 8040e9a:	2101      	movs	r1, #1
 8040e9c:	e7a0      	b.n	8040de0 <train+0x6c>
 8040e9e:	bf00      	nop
 8040ea0:	0804e1c8 	.word	0x0804e1c8
 8040ea4:	461c4000 	.word	0x461c4000
 8040ea8:	0804e1d4 	.word	0x0804e1d4
 8040eac:	200181bc 	.word	0x200181bc
 8040eb0:	0804e204 	.word	0x0804e204
 8040eb4:	00000000 	.word	0x00000000
 8040eb8:	0804e210 	.word	0x0804e210
 8040ebc:	0804e220 	.word	0x0804e220
 8040ec0:	200189c0 	.word	0x200189c0

08040ec4 <wrapper_train>:
void wrapper_train() {
 8040ec4:	b510      	push	{r4, lr}
	SECURE_checkState(&s, sizeof(State));
 8040ec6:	4c0d      	ldr	r4, [pc, #52]	@ (8040efc <wrapper_train+0x38>)
 8040ec8:	f640 0104 	movw	r1, #2052	@ 0x804
 8040ecc:	4620      	mov	r0, r4
 8040ece:	f00d f967 	bl	804e1a0 <__SECURE_checkState_veneer>
	float lr = *(float*)(pox_input);
 8040ed2:	4b0b      	ldr	r3, [pc, #44]	@ (8040f00 <wrapper_train+0x3c>)
	int numEpochs = (int) (*(float*)(pox_input+4));
 8040ed4:	edd3 7a01 	vldr	s15, [r3, #4]
	train(init_val, numEpochs, lr);
 8040ed8:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8040edc:	edd3 0a00 	vldr	s1, [r3]
 8040ee0:	ee17 0a90 	vmov	r0, s15
 8040ee4:	ed93 0a02 	vldr	s0, [r3, #8]
 8040ee8:	f7ff ff44 	bl	8040d74 <train>
	SECURE_setState(&s, sizeof(State));
 8040eec:	4620      	mov	r0, r4
}
 8040eee:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	SECURE_setState(&s, sizeof(State));
 8040ef2:	f640 0104 	movw	r1, #2052	@ 0x804
 8040ef6:	f00d b963 	b.w	804e1c0 <__SECURE_setState_veneer>
 8040efa:	bf00      	nop
 8040efc:	200181bc 	.word	0x200181bc
 8040f00:	20018ac0 	.word	0x20018ac0

08040f04 <single>:
	int i=0;
 8040f04:	2300      	movs	r3, #0
void single() {
 8040f06:	b5f0      	push	{r4, r5, r6, r7, lr}
 8040f08:	4ab6      	ldr	r2, [pc, #728]	@ (80411e4 <single+0x2e0>)
 8040f0a:	b0c1      	sub	sp, #260	@ 0x104
	while(s[i] != '\n') i++;
 8040f0c:	f812 0f01 	ldrb.w	r0, [r2, #1]!
 8040f10:	4619      	mov	r1, r3
 8040f12:	280a      	cmp	r0, #10
 8040f14:	f103 0301 	add.w	r3, r3, #1
 8040f18:	d1f8      	bne.n	8040f0c <single+0x8>
	SECURE_send((uint8_t*)s, (i+1));
 8040f1a:	48b2      	ldr	r0, [pc, #712]	@ (80411e4 <single+0x2e0>)
 8040f1c:	3102      	adds	r1, #2
 8040f1e:	f00d f937 	bl	804e190 <__SECURE_send_veneer>
	for(volatile int i=0; i<10000; i++);
 8040f22:	2300      	movs	r3, #0
 8040f24:	f242 720f 	movw	r2, #9999	@ 0x270f
 8040f28:	9305      	str	r3, [sp, #20]
 8040f2a:	9b05      	ldr	r3, [sp, #20]
 8040f2c:	4293      	cmp	r3, r2
 8040f2e:	dc05      	bgt.n	8040f3c <single+0x38>
 8040f30:	9b05      	ldr	r3, [sp, #20]
 8040f32:	3301      	adds	r3, #1
 8040f34:	9305      	str	r3, [sp, #20]
 8040f36:	9b05      	ldr	r3, [sp, #20]
 8040f38:	4293      	cmp	r3, r2
 8040f3a:	ddf9      	ble.n	8040f30 <single+0x2c>
		uint8_t req[100]={};
 8040f3c:	2400      	movs	r4, #0
 8040f3e:	2260      	movs	r2, #96	@ 0x60
 8040f40:	4621      	mov	r1, r4
 8040f42:	a80f      	add	r0, sp, #60	@ 0x3c
		SECURE_recv(req, REQUEST_SIZE);
 8040f44:	ad0e      	add	r5, sp, #56	@ 0x38
		uint8_t req[100]={};
 8040f46:	940e      	str	r4, [sp, #56]	@ 0x38
 8040f48:	f00a ff74 	bl	804be34 <memset>
		uint8_t buff[100]={};
 8040f4c:	2260      	movs	r2, #96	@ 0x60
 8040f4e:	4621      	mov	r1, r4
 8040f50:	a828      	add	r0, sp, #160	@ 0xa0
 8040f52:	9427      	str	r4, [sp, #156]	@ 0x9c
 8040f54:	f00a ff6e 	bl	804be34 <memset>
		SECURE_recv(req, REQUEST_SIZE);
 8040f58:	2139      	movs	r1, #57	@ 0x39
 8040f5a:	4628      	mov	r0, r5
 8040f5c:	f00d f924 	bl	804e1a8 <__SECURE_recv_veneer>
		sprintf(buff, "wrapper_init=%p, wrapper_collect=%p, wrapper_train=%p\n",
 8040f60:	4aa1      	ldr	r2, [pc, #644]	@ (80411e8 <single+0x2e4>)
 8040f62:	4ba2      	ldr	r3, [pc, #648]	@ (80411ec <single+0x2e8>)
 8040f64:	49a2      	ldr	r1, [pc, #648]	@ (80411f0 <single+0x2ec>)
 8040f66:	9200      	str	r2, [sp, #0]
 8040f68:	a827      	add	r0, sp, #156	@ 0x9c
 8040f6a:	4aa2      	ldr	r2, [pc, #648]	@ (80411f4 <single+0x2f0>)
 8040f6c:	f00a fe6a 	bl	804bc44 <siprintf>
	while(s[i] != '\n') i++;
 8040f70:	f89d 309c 	ldrb.w	r3, [sp, #156]	@ 0x9c
 8040f74:	2b0a      	cmp	r3, #10
 8040f76:	bf08      	it	eq
 8040f78:	2101      	moveq	r1, #1
 8040f7a:	d009      	beq.n	8040f90 <single+0x8c>
	int i=0;
 8040f7c:	4621      	mov	r1, r4
 8040f7e:	ab27      	add	r3, sp, #156	@ 0x9c
	while(s[i] != '\n') i++;
 8040f80:	f813 2f01 	ldrb.w	r2, [r3, #1]!
 8040f84:	4608      	mov	r0, r1
 8040f86:	2a0a      	cmp	r2, #10
 8040f88:	f101 0101 	add.w	r1, r1, #1
 8040f8c:	d1f8      	bne.n	8040f80 <single+0x7c>
	SECURE_send((uint8_t*)s, (i+1));
 8040f8e:	1c81      	adds	r1, r0, #2
 8040f90:	a827      	add	r0, sp, #156	@ 0x9c
 8040f92:	f00d f8fd 	bl	804e190 <__SECURE_send_veneer>
		pc.command_size = 5; // assume to be fixed
 8040f96:	2105      	movs	r1, #5
		pc.input = pox_input;
 8040f98:	4a97      	ldr	r2, [pc, #604]	@ (80411f8 <single+0x2f4>)
		pc.output = pox_output;
 8040f9a:	4b98      	ldr	r3, [pc, #608]	@ (80411fc <single+0x2f8>)
		pc.input = pox_input;
 8040f9c:	9207      	str	r2, [sp, #28]
		pc.output = pox_output;
 8040f9e:	9309      	str	r3, [sp, #36]	@ 0x24
		if(memcmp(pc.command, "[stp]", pc.command_size) == 0 ||
 8040fa0:	4a97      	ldr	r2, [pc, #604]	@ (8041200 <single+0x2fc>)
 8040fa2:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
		pc.command = req; // either [stp] or [clt]
 8040fa4:	950c      	str	r5, [sp, #48]	@ 0x30
		if(memcmp(pc.command, "[stp]", pc.command_size) == 0 ||
 8040fa6:	4293      	cmp	r3, r2
		pc.command_size = 5; // assume to be fixed
 8040fa8:	f88d 1034 	strb.w	r1, [sp, #52]	@ 0x34
		if(memcmp(pc.command, "[stp]", pc.command_size) == 0 ||
 8040fac:	d01e      	beq.n	8040fec <single+0xe8>
				memcmp(pc.command, "[clt]", pc.command_size) == 0) {
 8040fae:	4a95      	ldr	r2, [pc, #596]	@ (8041204 <single+0x300>)
 8040fb0:	4293      	cmp	r3, r2
 8040fb2:	d07a      	beq.n	80410aa <single+0x1a6>
		} else if(memcmp(pc.command, "[trn]", pc.command_size) == 0) {
 8040fb4:	4a94      	ldr	r2, [pc, #592]	@ (8041208 <single+0x304>)
 8040fb6:	4293      	cmp	r3, r2
 8040fb8:	d07d      	beq.n	80410b6 <single+0x1b2>
			sprintf(buff, "failed to parse command: %s\n", req);
 8040fba:	462a      	mov	r2, r5
 8040fbc:	4993      	ldr	r1, [pc, #588]	@ (804120c <single+0x308>)
 8040fbe:	a827      	add	r0, sp, #156	@ 0x9c
 8040fc0:	f00a fe40 	bl	804bc44 <siprintf>
	while(s[i] != '\n') i++;
 8040fc4:	f89d 309c 	ldrb.w	r3, [sp, #156]	@ 0x9c
 8040fc8:	2b0a      	cmp	r3, #10
 8040fca:	f000 8108 	beq.w	80411de <single+0x2da>
	int i=0;
 8040fce:	2300      	movs	r3, #0
 8040fd0:	aa27      	add	r2, sp, #156	@ 0x9c
	while(s[i] != '\n') i++;
 8040fd2:	f812 0f01 	ldrb.w	r0, [r2, #1]!
 8040fd6:	4619      	mov	r1, r3
 8040fd8:	280a      	cmp	r0, #10
 8040fda:	f103 0301 	add.w	r3, r3, #1
 8040fde:	d1f8      	bne.n	8040fd2 <single+0xce>
	SECURE_send((uint8_t*)s, (i+1));
 8040fe0:	3102      	adds	r1, #2
 8040fe2:	a827      	add	r0, sp, #156	@ 0x9c
 8040fe4:	f00d f8d4 	bl	804e190 <__SECURE_send_veneer>
}
 8040fe8:	b041      	add	sp, #260	@ 0x104
 8040fea:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if(memcmp(pc.command, "[stp]", pc.command_size) == 0 ||
 8040fec:	792a      	ldrb	r2, [r5, #4]
 8040fee:	2a5d      	cmp	r2, #93	@ 0x5d
 8040ff0:	d1dd      	bne.n	8040fae <single+0xaa>
			uint32_t counter = *((uint32_t*)(req+5));
 8040ff2:	f8dd 503d 	ldr.w	r5, [sp, #61]	@ 0x3d
			uint32_t func = *((uint32_t*)(req+5+4));
 8040ff6:	f8dd 4041 	ldr.w	r4, [sp, #65]	@ 0x41
			sprintf(buff, "[Test] Setup/collect: counter=%d, func=%x, done [/Test]\n", counter, func);
 8040ffa:	462a      	mov	r2, r5
 8040ffc:	4623      	mov	r3, r4
 8040ffe:	4984      	ldr	r1, [pc, #528]	@ (8041210 <single+0x30c>)
 8041000:	a827      	add	r0, sp, #156	@ 0x9c
 8041002:	f00a fe1f 	bl	804bc44 <siprintf>
	while(s[i] != '\n') i++;
 8041006:	f89d 309c 	ldrb.w	r3, [sp, #156]	@ 0x9c
 804100a:	2b0a      	cmp	r3, #10
 804100c:	f000 80e1 	beq.w	80411d2 <single+0x2ce>
	int i=0;
 8041010:	2300      	movs	r3, #0
 8041012:	aa27      	add	r2, sp, #156	@ 0x9c
	while(s[i] != '\n') i++;
 8041014:	f812 0f01 	ldrb.w	r0, [r2, #1]!
 8041018:	4619      	mov	r1, r3
 804101a:	280a      	cmp	r0, #10
 804101c:	f103 0301 	add.w	r3, r3, #1
 8041020:	d1f8      	bne.n	8041014 <single+0x110>
	SECURE_send((uint8_t*)s, (i+1));
 8041022:	3102      	adds	r1, #2
			pc.output_size = 32;
 8041024:	2620      	movs	r6, #32
			pc.input_size = 12;
 8041026:	270c      	movs	r7, #12
	SECURE_send((uint8_t*)s, (i+1));
 8041028:	a827      	add	r0, sp, #156	@ 0x9c
 804102a:	f00d f8b1 	bl	804e190 <__SECURE_send_veneer>
			memcpy(pox_input, req+5+4*2, 12);
 804102e:	f8dd 204d 	ldr.w	r2, [sp, #77]	@ 0x4d
 8041032:	f8dd 0045 	ldr.w	r0, [sp, #69]	@ 0x45
 8041036:	f8dd 1049 	ldr.w	r1, [sp, #73]	@ 0x49
 804103a:	4b6f      	ldr	r3, [pc, #444]	@ (80411f8 <single+0x2f4>)
			pc.counter = counter;
 804103c:	950b      	str	r5, [sp, #44]	@ 0x2c
			memcpy(pox_input, req+5+4*2, 12);
 804103e:	c307      	stmia	r3!, {r0, r1, r2}
			SECURE_pox(&pc, token);
 8041040:	f10d 0151 	add.w	r1, sp, #81	@ 0x51
 8041044:	a806      	add	r0, sp, #24
			pc.addr = func;
 8041046:	9406      	str	r4, [sp, #24]
			pc.output_size = 32;
 8041048:	960a      	str	r6, [sp, #40]	@ 0x28
			pc.input_size = 12;
 804104a:	9708      	str	r7, [sp, #32]
			SECURE_pox(&pc, token);
 804104c:	f00d f8a4 	bl	804e198 <__SECURE_pox_veneer>
			SECURE_send("[OS]", 4);
 8041050:	2104      	movs	r1, #4
 8041052:	4870      	ldr	r0, [pc, #448]	@ (8041214 <single+0x310>)
 8041054:	f00d f89c 	bl	804e190 <__SECURE_send_veneer>
			SECURE_send(pox_output, 32);
 8041058:	4631      	mov	r1, r6
 804105a:	4868      	ldr	r0, [pc, #416]	@ (80411fc <single+0x2f8>)
 804105c:	f00d f898 	bl	804e190 <__SECURE_send_veneer>
			SECURE_send(" ", 1);
 8041060:	2101      	movs	r1, #1
 8041062:	486d      	ldr	r0, [pc, #436]	@ (8041218 <single+0x314>)
 8041064:	f00d f894 	bl	804e190 <__SECURE_send_veneer>
			SECURE_send(token, 32);
 8041068:	4631      	mov	r1, r6
 804106a:	f10d 0051 	add.w	r0, sp, #81	@ 0x51
 804106e:	f00d f88f 	bl	804e190 <__SECURE_send_veneer>
	int i=0;
 8041072:	2300      	movs	r3, #0
 8041074:	4a69      	ldr	r2, [pc, #420]	@ (804121c <single+0x318>)
	while(s[i] != '\n') i++;
 8041076:	f812 0f01 	ldrb.w	r0, [r2, #1]!
 804107a:	4619      	mov	r1, r3
 804107c:	280a      	cmp	r0, #10
 804107e:	f103 0301 	add.w	r3, r3, #1
 8041082:	d1f8      	bne.n	8041076 <single+0x172>
	SECURE_send((uint8_t*)s, (i+1));
 8041084:	4865      	ldr	r0, [pc, #404]	@ (804121c <single+0x318>)
 8041086:	3102      	adds	r1, #2
 8041088:	f00d f882 	bl	804e190 <__SECURE_send_veneer>
	int i=0;
 804108c:	2300      	movs	r3, #0
 804108e:	4a64      	ldr	r2, [pc, #400]	@ (8041220 <single+0x31c>)
	while(s[i] != '\n') i++;
 8041090:	f812 0f01 	ldrb.w	r0, [r2, #1]!
 8041094:	4619      	mov	r1, r3
 8041096:	280a      	cmp	r0, #10
 8041098:	f103 0301 	add.w	r3, r3, #1
 804109c:	d1f8      	bne.n	8041090 <single+0x18c>
	SECURE_send((uint8_t*)s, (i+1));
 804109e:	4860      	ldr	r0, [pc, #384]	@ (8041220 <single+0x31c>)
 80410a0:	3102      	adds	r1, #2
 80410a2:	f00d f875 	bl	804e190 <__SECURE_send_veneer>
}
 80410a6:	b041      	add	sp, #260	@ 0x104
 80410a8:	bdf0      	pop	{r4, r5, r6, r7, pc}
				memcmp(pc.command, "[clt]", pc.command_size) == 0) {
 80410aa:	792a      	ldrb	r2, [r5, #4]
 80410ac:	2a5d      	cmp	r2, #93	@ 0x5d
 80410ae:	d0a0      	beq.n	8040ff2 <single+0xee>
		} else if(memcmp(pc.command, "[trn]", pc.command_size) == 0) {
 80410b0:	4a55      	ldr	r2, [pc, #340]	@ (8041208 <single+0x304>)
 80410b2:	4293      	cmp	r3, r2
 80410b4:	d181      	bne.n	8040fba <single+0xb6>
 80410b6:	792b      	ldrb	r3, [r5, #4]
 80410b8:	2b5d      	cmp	r3, #93	@ 0x5d
 80410ba:	f47f af7e 	bne.w	8040fba <single+0xb6>
			float lr = *((float*)(req+5+4*2));
 80410be:	f8dd 3045 	ldr.w	r3, [sp, #69]	@ 0x45
			float init_val = *((float*)(req+5+4*4));
 80410c2:	f8dd 204d 	ldr.w	r2, [sp, #77]	@ 0x4d
					counter, func, (int) (lr*10000), numEpochs, (int) (init_val*10000));
 80410c6:	eddf 6a57 	vldr	s13, [pc, #348]	@ 8041224 <single+0x320>
			float lr = *((float*)(req+5+4*2));
 80410ca:	ee07 3a90 	vmov	s15, r3
			float init_val = *((float*)(req+5+4*4));
 80410ce:	ee07 2a10 	vmov	s14, r2
			int numEpochs = *((float*)(req+5+4*3));
 80410d2:	f8dd 3049 	ldr.w	r3, [sp, #73]	@ 0x49
					counter, func, (int) (lr*10000), numEpochs, (int) (init_val*10000));
 80410d6:	ee27 7a26 	vmul.f32	s14, s14, s13
			int numEpochs = *((float*)(req+5+4*3));
 80410da:	ee06 3a10 	vmov	s12, r3
					counter, func, (int) (lr*10000), numEpochs, (int) (init_val*10000));
 80410de:	ee67 7aa6 	vmul.f32	s15, s15, s13
			pc.input_size = 12;
 80410e2:	200c      	movs	r0, #12
			int numEpochs = *((float*)(req+5+4*3));
 80410e4:	eebd 6ac6 	vcvt.s32.f32	s12, s12
			pc.output_size = POX_OUTPUT_SIZE;
 80410e8:	f44f 7180 	mov.w	r1, #256	@ 0x100
			sprintf(buff, "[Test] Training: counter=%d, func=%x, lr=%d, epoch=%d, init_val=%d done [/Test]\n",
 80410ec:	eebd 7ac7 	vcvt.s32.f32	s14, s14
 80410f0:	eefd 7ae7 	vcvt.s32.f32	s15, s15
			uint32_t func = *((uint32_t*)(req+5+4));
 80410f4:	f8dd 3041 	ldr.w	r3, [sp, #65]	@ 0x41
			uint32_t counter = *((uint32_t*)(req+5));
 80410f8:	f8dd 203d 	ldr.w	r2, [sp, #61]	@ 0x3d
			pc.input_size = 12;
 80410fc:	9008      	str	r0, [sp, #32]
			pc.output_size = POX_OUTPUT_SIZE;
 80410fe:	910a      	str	r1, [sp, #40]	@ 0x28
			sprintf(buff, "[Test] Training: counter=%d, func=%x, lr=%d, epoch=%d, init_val=%d done [/Test]\n",
 8041100:	ed8d 6a01 	vstr	s12, [sp, #4]
 8041104:	ed8d 7a02 	vstr	s14, [sp, #8]
 8041108:	edcd 7a00 	vstr	s15, [sp]
 804110c:	4946      	ldr	r1, [pc, #280]	@ (8041228 <single+0x324>)
 804110e:	a827      	add	r0, sp, #156	@ 0x9c
			pc.addr = func;
 8041110:	9306      	str	r3, [sp, #24]
			pc.counter = counter;
 8041112:	920b      	str	r2, [sp, #44]	@ 0x2c
			sprintf(buff, "[Test] Training: counter=%d, func=%x, lr=%d, epoch=%d, init_val=%d done [/Test]\n",
 8041114:	f00a fd96 	bl	804bc44 <siprintf>
	while(s[i] != '\n') i++;
 8041118:	f89d 309c 	ldrb.w	r3, [sp, #156]	@ 0x9c
		} else if(memcmp(pc.command, "[trn]", pc.command_size) == 0) {
 804111c:	2400      	movs	r4, #0
	while(s[i] != '\n') i++;
 804111e:	2b0a      	cmp	r3, #10
 8041120:	d05b      	beq.n	80411da <single+0x2d6>
	int i=0;
 8041122:	4623      	mov	r3, r4
 8041124:	aa27      	add	r2, sp, #156	@ 0x9c
	while(s[i] != '\n') i++;
 8041126:	f812 0f01 	ldrb.w	r0, [r2, #1]!
 804112a:	4619      	mov	r1, r3
 804112c:	280a      	cmp	r0, #10
 804112e:	f103 0301 	add.w	r3, r3, #1
 8041132:	d1f8      	bne.n	8041126 <single+0x222>
	SECURE_send((uint8_t*)s, (i+1));
 8041134:	3102      	adds	r1, #2
 8041136:	a827      	add	r0, sp, #156	@ 0x9c
 8041138:	f00d f82a 	bl	804e190 <__SECURE_send_veneer>
			memcpy(pox_input, req+5+4*2, 12);
 804113c:	f8dd 0045 	ldr.w	r0, [sp, #69]	@ 0x45
 8041140:	f8dd 1049 	ldr.w	r1, [sp, #73]	@ 0x49
 8041144:	f8dd 204d 	ldr.w	r2, [sp, #77]	@ 0x4d
 8041148:	4b2b      	ldr	r3, [pc, #172]	@ (80411f8 <single+0x2f4>)
 804114a:	c307      	stmia	r3!, {r0, r1, r2}
			SECURE_pox(&pc, token);
 804114c:	f10d 0151 	add.w	r1, sp, #81	@ 0x51
 8041150:	a806      	add	r0, sp, #24
 8041152:	f00d f821 	bl	804e198 <__SECURE_pox_veneer>
			sprintf(buff, "Heap Usage: %d\n",heapSize);
 8041156:	4b35      	ldr	r3, [pc, #212]	@ (804122c <single+0x328>)
 8041158:	4935      	ldr	r1, [pc, #212]	@ (8041230 <single+0x32c>)
 804115a:	681a      	ldr	r2, [r3, #0]
 804115c:	a827      	add	r0, sp, #156	@ 0x9c
 804115e:	f00a fd71 	bl	804bc44 <siprintf>
	while(s[i] != '\n') i++;
 8041162:	f89d 309c 	ldrb.w	r3, [sp, #156]	@ 0x9c
 8041166:	2b0a      	cmp	r3, #10
 8041168:	d035      	beq.n	80411d6 <single+0x2d2>
	int i=0;
 804116a:	2300      	movs	r3, #0
 804116c:	aa27      	add	r2, sp, #156	@ 0x9c
	while(s[i] != '\n') i++;
 804116e:	f812 0f01 	ldrb.w	r0, [r2, #1]!
 8041172:	4619      	mov	r1, r3
 8041174:	280a      	cmp	r0, #10
 8041176:	f103 0301 	add.w	r3, r3, #1
 804117a:	d1f8      	bne.n	804116e <single+0x26a>
	SECURE_send((uint8_t*)s, (i+1));
 804117c:	3102      	adds	r1, #2
 804117e:	a827      	add	r0, sp, #156	@ 0x9c
 8041180:	f00d f806 	bl	804e190 <__SECURE_send_veneer>
			SECURE_send("[OS]", 4);
 8041184:	2104      	movs	r1, #4
 8041186:	4823      	ldr	r0, [pc, #140]	@ (8041214 <single+0x310>)
 8041188:	f00d f802 	bl	804e190 <__SECURE_send_veneer>
			SECURE_send(pc.output, pc.output_size);
 804118c:	e9dd 0109 	ldrd	r0, r1, [sp, #36]	@ 0x24
 8041190:	f00c fffe 	bl	804e190 <__SECURE_send_veneer>
			SECURE_send(" ", 1);
 8041194:	2101      	movs	r1, #1
 8041196:	4820      	ldr	r0, [pc, #128]	@ (8041218 <single+0x314>)
 8041198:	f00c fffa 	bl	804e190 <__SECURE_send_veneer>
			SECURE_send(token, 32);
 804119c:	2120      	movs	r1, #32
 804119e:	f10d 0051 	add.w	r0, sp, #81	@ 0x51
 80411a2:	f00c fff5 	bl	804e190 <__SECURE_send_veneer>
	int i=0;
 80411a6:	2300      	movs	r3, #0
 80411a8:	4a1c      	ldr	r2, [pc, #112]	@ (804121c <single+0x318>)
	while(s[i] != '\n') i++;
 80411aa:	f812 0f01 	ldrb.w	r0, [r2, #1]!
 80411ae:	4619      	mov	r1, r3
 80411b0:	280a      	cmp	r0, #10
 80411b2:	f103 0301 	add.w	r3, r3, #1
 80411b6:	d1f8      	bne.n	80411aa <single+0x2a6>
	SECURE_send((uint8_t*)s, (i+1));
 80411b8:	4818      	ldr	r0, [pc, #96]	@ (804121c <single+0x318>)
 80411ba:	3102      	adds	r1, #2
 80411bc:	f00c ffe8 	bl	804e190 <__SECURE_send_veneer>
	while(s[i] != '\n') i++;
 80411c0:	4b17      	ldr	r3, [pc, #92]	@ (8041220 <single+0x31c>)
 80411c2:	f813 2f01 	ldrb.w	r2, [r3, #1]!
 80411c6:	4621      	mov	r1, r4
 80411c8:	2a0a      	cmp	r2, #10
 80411ca:	f104 0401 	add.w	r4, r4, #1
 80411ce:	d1f8      	bne.n	80411c2 <single+0x2be>
 80411d0:	e765      	b.n	804109e <single+0x19a>
 80411d2:	2101      	movs	r1, #1
 80411d4:	e726      	b.n	8041024 <single+0x120>
 80411d6:	2101      	movs	r1, #1
 80411d8:	e7d1      	b.n	804117e <single+0x27a>
 80411da:	2101      	movs	r1, #1
 80411dc:	e7ab      	b.n	8041136 <single+0x232>
 80411de:	2101      	movs	r1, #1
 80411e0:	e6ff      	b.n	8040fe2 <single+0xde>
 80411e2:	bf00      	nop
 80411e4:	0804e230 	.word	0x0804e230
 80411e8:	08040ec5 	.word	0x08040ec5
 80411ec:	08040d11 	.word	0x08040d11
 80411f0:	0804e23c 	.word	0x0804e23c
 80411f4:	08040cb9 	.word	0x08040cb9
 80411f8:	20018ac0 	.word	0x20018ac0
 80411fc:	200189c0 	.word	0x200189c0
 8041200:	7074735b 	.word	0x7074735b
 8041204:	746c635b 	.word	0x746c635b
 8041208:	6e72745b 	.word	0x6e72745b
 804120c:	0804e348 	.word	0x0804e348
 8041210:	0804e284 	.word	0x0804e284
 8041214:	0804e2c0 	.word	0x0804e2c0
 8041218:	0804e2c8 	.word	0x0804e2c8
 804121c:	0804e2cc 	.word	0x0804e2cc
 8041220:	0804e2d4 	.word	0x0804e2d4
 8041224:	461c4000 	.word	0x461c4000
 8041228:	0804e2e4 	.word	0x0804e2e4
 804122c:	20018acc 	.word	0x20018acc
 8041230:	0804e338 	.word	0x0804e338

08041234 <main>:
{
 8041234:	b508      	push	{r3, lr}
  HAL_Init();
 8041236:	f00a f931 	bl	804b49c <HAL_Init>
   MX_GPIO_Init();
 804123a:	f7ff fce1 	bl	8040c00 <MX_GPIO_Init>
  SECURE_RegisterCallback(SECURE_FAULT_CB_ID, (void *)SecureFault_Callback);
 804123e:	2000      	movs	r0, #0
 8041240:	4907      	ldr	r1, [pc, #28]	@ (8041260 <main+0x2c>)
 8041242:	f00c ffb9 	bl	804e1b8 <__SECURE_RegisterCallback_veneer>
  SECURE_RegisterCallback(GTZC_ERROR_CB_ID, (void *)SecureError_Callback);
 8041246:	2001      	movs	r0, #1
 8041248:	4906      	ldr	r1, [pc, #24]	@ (8041264 <main+0x30>)
 804124a:	f00c ffb5 	bl	804e1b8 <__SECURE_RegisterCallback_veneer>
  srand(time(NULL));
 804124e:	2000      	movs	r0, #0
 8041250:	f00a fe28 	bl	804bea4 <time>
 8041254:	f00a fbbe 	bl	804b9d4 <srand>
	single();
 8041258:	f7ff fe54 	bl	8040f04 <single>
  while (1)
 804125c:	e7fc      	b.n	8041258 <main+0x24>
 804125e:	bf00      	nop
 8041260:	08040c99 	.word	0x08040c99
 8041264:	08040cb1 	.word	0x08040cb1

08041268 <HAL_MspInit>:
{
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8041268:	4b0a      	ldr	r3, [pc, #40]	@ (8041294 <HAL_MspInit+0x2c>)
{
 804126a:	b082      	sub	sp, #8
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 804126c:	6e1a      	ldr	r2, [r3, #96]	@ 0x60
 804126e:	f042 0201 	orr.w	r2, r2, #1
 8041272:	661a      	str	r2, [r3, #96]	@ 0x60
 8041274:	6e1a      	ldr	r2, [r3, #96]	@ 0x60
 8041276:	f002 0201 	and.w	r2, r2, #1
 804127a:	9200      	str	r2, [sp, #0]
 804127c:	9a00      	ldr	r2, [sp, #0]
  __HAL_RCC_PWR_CLK_ENABLE();
 804127e:	6d9a      	ldr	r2, [r3, #88]	@ 0x58
 8041280:	f042 5280 	orr.w	r2, r2, #268435456	@ 0x10000000
 8041284:	659a      	str	r2, [r3, #88]	@ 0x58
 8041286:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 8041288:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
 804128c:	9301      	str	r3, [sp, #4]
 804128e:	9b01      	ldr	r3, [sp, #4]
  /* System interrupt init*/

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 8041290:	b002      	add	sp, #8
 8041292:	4770      	bx	lr
 8041294:	40021000 	.word	0x40021000

08041298 <MemManage_Handler>:
void MemManage_Handler(void)
{
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
 8041298:	e7fe      	b.n	8041298 <MemManage_Handler>
 804129a:	bf00      	nop

0804129c <UsageFault_Handler>:
void UsageFault_Handler(void)
{
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
 804129c:	e7fe      	b.n	804129c <UsageFault_Handler>
 804129e:	bf00      	nop

080412a0 <SVC_Handler>:

  /* USER CODE END SVCall_IRQn 0 */
  /* USER CODE BEGIN SVCall_IRQn 1 */

  /* USER CODE END SVCall_IRQn 1 */
}
 80412a0:	4770      	bx	lr
 80412a2:	bf00      	nop

080412a4 <PendSV_Handler>:

/**
  * @brief This function handles Pendable request for system service.
  */
void PendSV_Handler(void)
 80412a4:	4770      	bx	lr
 80412a6:	bf00      	nop

080412a8 <SysTick_Handler>:
void SysTick_Handler(void)
{
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 80412a8:	f00a b90a 	b.w	804b4c0 <HAL_IncTick>

080412ac <_getpid>:
}

int _getpid(void)
{
	return 1;
}
 80412ac:	2001      	movs	r0, #1
 80412ae:	4770      	bx	lr

080412b0 <_kill>:

int _kill(int pid, int sig)
{
 80412b0:	b508      	push	{r3, lr}
	errno = EINVAL;
 80412b2:	f00a fe8f 	bl	804bfd4 <__errno>
 80412b6:	2216      	movs	r2, #22
 80412b8:	4603      	mov	r3, r0
	return -1;
}
 80412ba:	f04f 30ff 	mov.w	r0, #4294967295
	errno = EINVAL;
 80412be:	601a      	str	r2, [r3, #0]
}
 80412c0:	bd08      	pop	{r3, pc}
 80412c2:	bf00      	nop

080412c4 <_exit>:

void _exit (int status)
{
 80412c4:	b508      	push	{r3, lr}
	errno = EINVAL;
 80412c6:	f00a fe85 	bl	804bfd4 <__errno>
 80412ca:	2316      	movs	r3, #22
 80412cc:	6003      	str	r3, [r0, #0]
	_kill(status, -1);
	while (1) {}		/* Make sure we hang here */
 80412ce:	e7fe      	b.n	80412ce <_exit+0xa>

080412d0 <_read>:
}

__attribute__((weak)) int _read(int file, char *ptr, int len)
{
 80412d0:	b570      	push	{r4, r5, r6, lr}
	int DataIdx;

	for (DataIdx = 0; DataIdx < len; DataIdx++)
 80412d2:	1e16      	subs	r6, r2, #0
 80412d4:	dd07      	ble.n	80412e6 <_read+0x16>
 80412d6:	460c      	mov	r4, r1
 80412d8:	198d      	adds	r5, r1, r6
	{
		*ptr++ = __io_getchar();
 80412da:	f3af 8000 	nop.w
 80412de:	f804 0b01 	strb.w	r0, [r4], #1
	for (DataIdx = 0; DataIdx < len; DataIdx++)
 80412e2:	42a5      	cmp	r5, r4
 80412e4:	d1f9      	bne.n	80412da <_read+0xa>
	}

return len;
}
 80412e6:	4630      	mov	r0, r6
 80412e8:	bd70      	pop	{r4, r5, r6, pc}
 80412ea:	bf00      	nop

080412ec <_write>:

__attribute__((weak)) int _write(int file, char *ptr, int len)
{
 80412ec:	b570      	push	{r4, r5, r6, lr}
	int DataIdx;

	for (DataIdx = 0; DataIdx < len; DataIdx++)
 80412ee:	1e16      	subs	r6, r2, #0
 80412f0:	dd07      	ble.n	8041302 <_write+0x16>
 80412f2:	460c      	mov	r4, r1
 80412f4:	198d      	adds	r5, r1, r6
	{
		__io_putchar(*ptr++);
 80412f6:	f814 0b01 	ldrb.w	r0, [r4], #1
 80412fa:	f3af 8000 	nop.w
	for (DataIdx = 0; DataIdx < len; DataIdx++)
 80412fe:	42ac      	cmp	r4, r5
 8041300:	d1f9      	bne.n	80412f6 <_write+0xa>
	}
	return len;
}
 8041302:	4630      	mov	r0, r6
 8041304:	bd70      	pop	{r4, r5, r6, pc}
 8041306:	bf00      	nop

08041308 <_close>:

int _close(int file)
{
	return -1;
}
 8041308:	f04f 30ff 	mov.w	r0, #4294967295
 804130c:	4770      	bx	lr
 804130e:	bf00      	nop

08041310 <_fstat>:


int _fstat(int file, struct stat *st)
{
	st->st_mode = S_IFCHR;
 8041310:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
	return 0;
}
 8041314:	2000      	movs	r0, #0
	st->st_mode = S_IFCHR;
 8041316:	604b      	str	r3, [r1, #4]
}
 8041318:	4770      	bx	lr
 804131a:	bf00      	nop

0804131c <_isatty>:

int _isatty(int file)
{
	return 1;
}
 804131c:	2001      	movs	r0, #1
 804131e:	4770      	bx	lr

08041320 <_lseek>:

int _lseek(int file, int ptr, int dir)
{
	return 0;
}
 8041320:	2000      	movs	r0, #0
 8041322:	4770      	bx	lr

08041324 <_sbrk>:
  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;
  const uint8_t *max_heap = (uint8_t *)stack_limit;
  uint8_t *prev_heap_end;

  /* Initialize heap end at first call */
  if (NULL == __sbrk_heap_end)
 8041324:	490d      	ldr	r1, [pc, #52]	@ (804135c <_sbrk+0x38>)
{
 8041326:	4603      	mov	r3, r0
 8041328:	b510      	push	{r4, lr}
  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;
 804132a:	4a0d      	ldr	r2, [pc, #52]	@ (8041360 <_sbrk+0x3c>)
 804132c:	4c0d      	ldr	r4, [pc, #52]	@ (8041364 <_sbrk+0x40>)
  if (NULL == __sbrk_heap_end)
 804132e:	6808      	ldr	r0, [r1, #0]
  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;
 8041330:	1b12      	subs	r2, r2, r4
  if (NULL == __sbrk_heap_end)
 8041332:	b120      	cbz	r0, 804133e <_sbrk+0x1a>
  {
    __sbrk_heap_end = &_end;
  }

  /* Protect heap from growing into the reserved MSP stack */
  if (__sbrk_heap_end + incr > max_heap)
 8041334:	4403      	add	r3, r0
 8041336:	4293      	cmp	r3, r2
 8041338:	d807      	bhi.n	804134a <_sbrk+0x26>
    errno = ENOMEM;
    return (void *)-1;
  }

  prev_heap_end = __sbrk_heap_end;
  __sbrk_heap_end += incr;
 804133a:	600b      	str	r3, [r1, #0]

  return (void *)prev_heap_end;
}
 804133c:	bd10      	pop	{r4, pc}
    __sbrk_heap_end = &_end;
 804133e:	4c0a      	ldr	r4, [pc, #40]	@ (8041368 <_sbrk+0x44>)
 8041340:	4620      	mov	r0, r4
  if (__sbrk_heap_end + incr > max_heap)
 8041342:	4403      	add	r3, r0
 8041344:	4293      	cmp	r3, r2
    __sbrk_heap_end = &_end;
 8041346:	600c      	str	r4, [r1, #0]
  if (__sbrk_heap_end + incr > max_heap)
 8041348:	d9f7      	bls.n	804133a <_sbrk+0x16>
    errno = ENOMEM;
 804134a:	f00a fe43 	bl	804bfd4 <__errno>
 804134e:	220c      	movs	r2, #12
 8041350:	4603      	mov	r3, r0
    return (void *)-1;
 8041352:	f04f 30ff 	mov.w	r0, #4294967295
    errno = ENOMEM;
 8041356:	601a      	str	r2, [r3, #0]
}
 8041358:	bd10      	pop	{r4, pc}
 804135a:	bf00      	nop
 804135c:	20018ad0 	.word	0x20018ad0
 8041360:	20040000 	.word	0x20040000
 8041364:	00008000 	.word	0x00008000
 8041368:	20018c28 	.word	0x20018c28

0804136c <SystemInit>:
#endif

  /* Non-secure main application shall call SystemCoreClockUpdate() to update */
  /* the SystemCoreClock variable to insure non-secure application relies on  */
  /* the initial clock reference set by secure application.                   */
}
 804136c:	4770      	bx	lr
 804136e:	bf00      	nop

08041370 <SystemCoreClockUpdate>:
  *           value for HSE crystal.
  *
  * @retval None
  */
void SystemCoreClockUpdate(void)
{
 8041370:	b508      	push	{r3, lr}
  /* Get the SystemCoreClock value from the secure domain */
  SystemCoreClock = SECURE_SystemCoreClockUpdate();
 8041372:	f00c ff1d 	bl	804e1b0 <__SECURE_SystemCoreClockUpdate_veneer>
 8041376:	4b01      	ldr	r3, [pc, #4]	@ (804137c <SystemCoreClockUpdate+0xc>)
 8041378:	6018      	str	r0, [r3, #0]
}
 804137a:	bd08      	pop	{r3, pc}
 804137c:	20018000 	.word	0x20018000

08041380 <tg_gen.constprop.0>:
	for (i = 0; i < tg->len; ++i)
		tg->data[i] = tg->c2i[tg->data[i]];
	return tg;
}

void tg_gen(kann_t *ann, float temp, int len, const int c2i[256])
 8041380:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8041384:	ed2d 8b02 	vpush	{d8}
 8041388:	f6ad 0d24 	subw	sp, sp, #2084	@ 0x824
{
	int i, c, n_char, i2c[256], i_temp;
	float x[256];
	memset(i2c, 0, 256 * sizeof(int));
 804138c:	f10d 0820 	add.w	r8, sp, #32
void tg_gen(kann_t *ann, float temp, int len, const int c2i[256])
 8041390:	468b      	mov	fp, r1
 8041392:	4682      	mov	sl, r0
	memset(i2c, 0, 256 * sizeof(int));
 8041394:	2100      	movs	r1, #0
 8041396:	f44f 6280 	mov.w	r2, #1024	@ 0x400
 804139a:	4640      	mov	r0, r8
 804139c:	f00a fd4a 	bl	804be34 <memset>
	for (i = 0; i < 256; ++i)
 80413a0:	2300      	movs	r3, #0
 80413a2:	f1ab 0104 	sub.w	r1, fp, #4
		if (c2i[i] >= 0) i2c[c2i[i]] = i;
 80413a6:	f851 2f04 	ldr.w	r2, [r1, #4]!
 80413aa:	2a00      	cmp	r2, #0
 80413ac:	bfa8      	it	ge
 80413ae:	f848 3022 	strge.w	r3, [r8, r2, lsl #2]
	for (i = 0; i < 256; ++i)
 80413b2:	3301      	adds	r3, #1
 80413b4:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 80413b8:	d1f5      	bne.n	80413a6 <tg_gen.constprop.0+0x26>
	n_char = kann_dim_in(ann);
 80413ba:	2200      	movs	r2, #0
 80413bc:	2101      	movs	r1, #1
 80413be:	4650      	mov	r0, sl
 80413c0:	f000 feda 	bl	8042178 <kann_feed_dim>
	i_temp = kann_find(ann, 0, -1);
 80413c4:	f04f 32ff 	mov.w	r2, #4294967295
	n_char = kann_dim_in(ann);
 80413c8:	4604      	mov	r4, r0
	i_temp = kann_find(ann, 0, -1);
 80413ca:	2100      	movs	r1, #0
 80413cc:	4650      	mov	r0, sl
 80413ce:	f000 fe0f 	bl	8041ff0 <kann_find>
	if (i_temp >= 0) ann->v[i_temp]->x[0] = 1.0f / temp;
 80413d2:	1e05      	subs	r5, r0, #0
 80413d4:	db06      	blt.n	80413e4 <tg_gen.constprop.0+0x64>
 80413d6:	f8da 3004 	ldr.w	r3, [sl, #4]
 80413da:	4a63      	ldr	r2, [pc, #396]	@ (8041568 <tg_gen.constprop.0+0x1e8>)
 80413dc:	f853 3025 	ldr.w	r3, [r3, r5, lsl #2]
 80413e0:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80413e2:	601a      	str	r2, [r3, #0]
	kann_rnn_start(ann);
 80413e4:	4650      	mov	r0, sl
 80413e6:	f000 ff11 	bl	804220c <kann_rnn_start>
	for (c = 0; c < ann->n; ++c) {
 80413ea:	f8da 2000 	ldr.w	r2, [sl]
 80413ee:	2a00      	cmp	r2, #0
 80413f0:	dd43      	ble.n	804147a <tg_gen.constprop.0+0xfa>
 80413f2:	f04f 0900 	mov.w	r9, #0
		kad_node_t *p = ann->v[c];
		if (p->pre) {
			int l = kad_len(p);
			for (i = 0; i < l; ++i)
				p->x[i] = 2.0 * kann_drand() - 1.0;
 80413f6:	e9cd 4500 	strd	r4, r5, [sp]
 80413fa:	e003      	b.n	8041404 <tg_gen.constprop.0+0x84>
	for (c = 0; c < ann->n; ++c) {
 80413fc:	f109 0901 	add.w	r9, r9, #1
 8041400:	4591      	cmp	r9, r2
 8041402:	da38      	bge.n	8041476 <tg_gen.constprop.0+0xf6>
		kad_node_t *p = ann->v[c];
 8041404:	f8da 3004 	ldr.w	r3, [sl, #4]
 8041408:	f853 4029 	ldr.w	r4, [r3, r9, lsl #2]
		if (p->pre) {
 804140c:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
 804140e:	2b00      	cmp	r3, #0
 8041410:	d0f4      	beq.n	80413fc <tg_gen.constprop.0+0x7c>
extern char *kad_op_name[KAD_MAX_OP];

static inline int kad_len(const kad_node_t *p) /* calculate the size of p->x */
{
	int n = 1, i;
	for (i = 0; i < p->n_d; ++i) n *= p->d[i];
 8041412:	7820      	ldrb	r0, [r4, #0]
 8041414:	2800      	cmp	r0, #0
 8041416:	f000 808b 	beq.w	8041530 <tg_gen.constprop.0+0x1b0>
 804141a:	2801      	cmp	r0, #1
 804141c:	6925      	ldr	r5, [r4, #16]
 804141e:	d00b      	beq.n	8041438 <tg_gen.constprop.0+0xb8>
 8041420:	6963      	ldr	r3, [r4, #20]
 8041422:	2802      	cmp	r0, #2
 8041424:	fb03 f505 	mul.w	r5, r3, r5
 8041428:	d006      	beq.n	8041438 <tg_gen.constprop.0+0xb8>
 804142a:	69a3      	ldr	r3, [r4, #24]
 804142c:	2803      	cmp	r0, #3
 804142e:	fb03 f505 	mul.w	r5, r3, r5
 8041432:	bf1c      	itt	ne
 8041434:	69e3      	ldrne	r3, [r4, #28]
 8041436:	435d      	mulne	r5, r3
			for (i = 0; i < l; ++i)
 8041438:	2d00      	cmp	r5, #0
 804143a:	dddf      	ble.n	80413fc <tg_gen.constprop.0+0x7c>
 804143c:	2600      	movs	r6, #0
				p->x[i] = 2.0 * kann_drand() - 1.0;
 804143e:	2000      	movs	r0, #0
 8041440:	f009 fe18 	bl	804b074 <kad_drand>
 8041444:	ec53 2b10 	vmov	r2, r3, d0
 8041448:	4610      	mov	r0, r2
 804144a:	4619      	mov	r1, r3
 804144c:	f7fe fefa 	bl	8040244 <__adddf3>
 8041450:	2200      	movs	r2, #0
 8041452:	4b46      	ldr	r3, [pc, #280]	@ (804156c <tg_gen.constprop.0+0x1ec>)
 8041454:	f7fe fef4 	bl	8040240 <__aeabi_dsub>
 8041458:	f7ff fb82 	bl	8040b60 <__aeabi_d2f>
 804145c:	6aa7      	ldr	r7, [r4, #40]	@ 0x28
 804145e:	eb07 0786 	add.w	r7, r7, r6, lsl #2
			for (i = 0; i < l; ++i)
 8041462:	3601      	adds	r6, #1
 8041464:	42ae      	cmp	r6, r5
				p->x[i] = 2.0 * kann_drand() - 1.0;
 8041466:	6038      	str	r0, [r7, #0]
			for (i = 0; i < l; ++i)
 8041468:	dbe9      	blt.n	804143e <tg_gen.constprop.0+0xbe>
	for (c = 0; c < ann->n; ++c) {
 804146a:	f8da 2000 	ldr.w	r2, [sl]
 804146e:	f109 0901 	add.w	r9, r9, #1
 8041472:	4591      	cmp	r9, r2
 8041474:	dbc6      	blt.n	8041404 <tg_gen.constprop.0+0x84>
 8041476:	e9dd 4500 	ldrd	r4, r5, [sp]
		}
	}
	c= c2i[(int)' '];

	char buffer[20] = {0};
 804147a:	2300      	movs	r3, #0

	for (i = 0; i < len; ++i) {
		float s, r;
		const float *y;
		memset(x, 0, n_char * sizeof(float));
		x[c] = 1.0f;
 804147c:	eeb7 8a00 	vmov.f32	s16, #112	@ 0x3f800000  1.0
	char buffer[20] = {0};
 8041480:	e9cd 3303 	strd	r3, r3, [sp, #12]
 8041484:	e9cd 3305 	strd	r3, r3, [sp, #20]
	c= c2i[(int)' '];
 8041488:	f8db 6080 	ldr.w	r6, [fp, #128]	@ 0x80
		memset(x, 0, n_char * sizeof(float));
 804148c:	ea4f 0984 	mov.w	r9, r4, lsl #2
 8041490:	f10d 0b0b 	add.w	fp, sp, #11
 8041494:	f10d 071f 	add.w	r7, sp, #31
	char buffer[20] = {0};
 8041498:	9307      	str	r3, [sp, #28]
		memset(x, 0, n_char * sizeof(float));
 804149a:	464a      	mov	r2, r9
 804149c:	2100      	movs	r1, #0
 804149e:	f50d 6084 	add.w	r0, sp, #1056	@ 0x420
 80414a2:	f00a fcc7 	bl	804be34 <memset>
		y = kann_apply1(ann, x);
 80414a6:	f50d 6184 	add.w	r1, sp, #1056	@ 0x420
		x[c] = 1.0f;
 80414aa:	eb01 0686 	add.w	r6, r1, r6, lsl #2
		y = kann_apply1(ann, x);
 80414ae:	4650      	mov	r0, sl
		x[c] = 1.0f;
 80414b0:	ed86 8a00 	vstr	s16, [r6]
		y = kann_apply1(ann, x);
 80414b4:	f001 fb72 	bl	8042b9c <kann_apply1>
 80414b8:	4606      	mov	r6, r0
		r = kann_drand();
 80414ba:	2000      	movs	r0, #0
 80414bc:	f009 fdda 	bl	804b074 <kad_drand>
 80414c0:	ec51 0b10 	vmov	r0, r1, d0
 80414c4:	f7ff fb4c 	bl	8040b60 <__aeabi_d2f>
		for (c = 0, s = 0.0f; c < n_char; ++c)
 80414c8:	2c00      	cmp	r4, #0
		r = kann_drand();
 80414ca:	ee06 0a90 	vmov	s13, r0
		for (c = 0, s = 0.0f; c < n_char; ++c)
 80414ce:	dd42      	ble.n	8041556 <tg_gen.constprop.0+0x1d6>
 80414d0:	4630      	mov	r0, r6
 80414d2:	eddf 7a27 	vldr	s15, [pc, #156]	@ 8041570 <tg_gen.constprop.0+0x1f0>
 80414d6:	2600      	movs	r6, #0
 80414d8:	e002      	b.n	80414e0 <tg_gen.constprop.0+0x160>
 80414da:	3601      	adds	r6, #1
 80414dc:	42b4      	cmp	r4, r6
 80414de:	d008      	beq.n	80414f2 <tg_gen.constprop.0+0x172>
			if (s + y[c] >= r) break;
 80414e0:	ecb0 7a01 	vldmia	r0!, {s14}
 80414e4:	ee77 7a87 	vadd.f32	s15, s15, s14
 80414e8:	eef4 6ae7 	vcmpe.f32	s13, s15
 80414ec:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80414f0:	d8f3      	bhi.n	80414da <tg_gen.constprop.0+0x15a>
			else s += y[c];

		buffer[i] = i2c[c];
 80414f2:	f858 3026 	ldr.w	r3, [r8, r6, lsl #2]
 80414f6:	f80b 3f01 	strb.w	r3, [fp, #1]!
	for (i = 0; i < len; ++i) {
 80414fa:	45bb      	cmp	fp, r7
 80414fc:	d1cd      	bne.n	804149a <tg_gen.constprop.0+0x11a>
	}

	buffer[len] = '\n';
 80414fe:	230a      	movs	r3, #10
	sendline(buffer);
 8041500:	a803      	add	r0, sp, #12
	buffer[len] = '\n';
 8041502:	f88d 3020 	strb.w	r3, [sp, #32]
	sendline(buffer);
 8041506:	f7ff fc25 	bl	8040d54 <sendline>

	kann_rnn_end(ann);
 804150a:	4650      	mov	r0, sl
 804150c:	f000 fed2 	bl	80422b4 <kann_rnn_end>
	if (i_temp >= 0) ann->v[i_temp]->x[0] = 1.0f;
 8041510:	2d00      	cmp	r5, #0
 8041512:	db07      	blt.n	8041524 <tg_gen.constprop.0+0x1a4>
 8041514:	f04f 527e 	mov.w	r2, #1065353216	@ 0x3f800000
 8041518:	f8da 3004 	ldr.w	r3, [sl, #4]
 804151c:	f853 3025 	ldr.w	r3, [r3, r5, lsl #2]
 8041520:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8041522:	601a      	str	r2, [r3, #0]
}
 8041524:	f60d 0d24 	addw	sp, sp, #2084	@ 0x824
 8041528:	ecbd 8b02 	vpop	{d8}
 804152c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				p->x[i] = 2.0 * kann_drand() - 1.0;
 8041530:	f009 fda0 	bl	804b074 <kad_drand>
 8041534:	ec53 2b10 	vmov	r2, r3, d0
 8041538:	4610      	mov	r0, r2
 804153a:	4619      	mov	r1, r3
 804153c:	f7fe fe82 	bl	8040244 <__adddf3>
 8041540:	2200      	movs	r2, #0
 8041542:	4b0a      	ldr	r3, [pc, #40]	@ (804156c <tg_gen.constprop.0+0x1ec>)
 8041544:	f7fe fe7c 	bl	8040240 <__aeabi_dsub>
 8041548:	f7ff fb0a 	bl	8040b60 <__aeabi_d2f>
 804154c:	6aa6      	ldr	r6, [r4, #40]	@ 0x28
	for (c = 0; c < ann->n; ++c) {
 804154e:	f8da 2000 	ldr.w	r2, [sl]
				p->x[i] = 2.0 * kann_drand() - 1.0;
 8041552:	6030      	str	r0, [r6, #0]
			for (i = 0; i < l; ++i)
 8041554:	e78b      	b.n	804146e <tg_gen.constprop.0+0xee>
		for (c = 0, s = 0.0f; c < n_char; ++c)
 8041556:	2600      	movs	r6, #0
		buffer[i] = i2c[c];
 8041558:	f858 3026 	ldr.w	r3, [r8, r6, lsl #2]
 804155c:	f80b 3f01 	strb.w	r3, [fp, #1]!
	for (i = 0; i < len; ++i) {
 8041560:	45bb      	cmp	fp, r7
 8041562:	d19a      	bne.n	804149a <tg_gen.constprop.0+0x11a>
 8041564:	e7cb      	b.n	80414fe <tg_gen.constprop.0+0x17e>
 8041566:	bf00      	nop
 8041568:	40200000 	.word	0x40200000
 804156c:	3ff00000 	.word	0x3ff00000
 8041570:	00000000 	.word	0x00000000

08041574 <tg_init_with_data>:
{
 8041574:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8041578:	460e      	mov	r6, r1
 804157a:	4680      	mov	r8, r0
	tg = (tg_data_t*)calloc(1, sizeof(tg_data_t));
 804157c:	f240 410c 	movw	r1, #1036	@ 0x40c
 8041580:	2001      	movs	r0, #1
 8041582:	f00a f94d 	bl	804b820 <calloc>
 8041586:	4604      	mov	r4, r0
	heapSize += 1* sizeof(tg_data_t);
 8041588:	4f22      	ldr	r7, [pc, #136]	@ (8041614 <tg_init_with_data+0xa0>)
	tg->data = calloc(tg->len, sizeof(uint8_t));
 804158a:	2101      	movs	r1, #1
	heapSize += 1* sizeof(tg_data_t);
 804158c:	683b      	ldr	r3, [r7, #0]
	tg->data = calloc(tg->len, sizeof(uint8_t));
 804158e:	4630      	mov	r0, r6
	heapSize += 1* sizeof(tg_data_t);
 8041590:	f203 430c 	addw	r3, r3, #1036	@ 0x40c
	tg->len = len;
 8041594:	6026      	str	r6, [r4, #0]
	heapSize += 1* sizeof(tg_data_t);
 8041596:	603b      	str	r3, [r7, #0]
	tg->data = calloc(tg->len, sizeof(uint8_t));
 8041598:	f00a f942 	bl	804b820 <calloc>
	heapSize += tg->len * sizeof(uint8_t);
 804159c:	683b      	ldr	r3, [r7, #0]
	memcpy(tg->data, input, len);
 804159e:	4641      	mov	r1, r8
	heapSize += tg->len * sizeof(uint8_t);
 80415a0:	4433      	add	r3, r6
	memcpy(tg->data, input, len);
 80415a2:	4632      	mov	r2, r6
	tg->data = calloc(tg->len, sizeof(uint8_t));
 80415a4:	60a0      	str	r0, [r4, #8]
 80415a6:	4605      	mov	r5, r0
	heapSize += tg->len * sizeof(uint8_t);
 80415a8:	603b      	str	r3, [r7, #0]
	memcpy(tg->data, input, len);
 80415aa:	f00a fd40 	bl	804c02e <memcpy>
	for (i = 0; i < tg->len; ++i)
 80415ae:	2e00      	cmp	r6, #0
 80415b0:	dd0a      	ble.n	80415c8 <tg_init_with_data+0x54>
		tg->c2i[tg->data[i]] = 1;
 80415b2:	2001      	movs	r0, #1
 80415b4:	1e71      	subs	r1, r6, #1
 80415b6:	1e6a      	subs	r2, r5, #1
 80415b8:	4429      	add	r1, r5
 80415ba:	f812 3f01 	ldrb.w	r3, [r2, #1]!
 80415be:	eb04 0383 	add.w	r3, r4, r3, lsl #2
	for (i = 0; i < tg->len; ++i)
 80415c2:	428a      	cmp	r2, r1
		tg->c2i[tg->data[i]] = 1;
 80415c4:	60d8      	str	r0, [r3, #12]
	for (i = 0; i < tg->len; ++i)
 80415c6:	d1f8      	bne.n	80415ba <tg_init_with_data+0x46>
	for (i = j = 0; i < 256; ++i)
 80415c8:	2000      	movs	r0, #0
 80415ca:	f104 0308 	add.w	r3, r4, #8
 80415ce:	f504 6c81 	add.w	ip, r4, #1032	@ 0x408
 80415d2:	e005      	b.n	80415e0 <tg_init_with_data+0x6c>
		else tg->c2i[i] = j++;
 80415d4:	4601      	mov	r1, r0
	for (i = j = 0; i < 256; ++i)
 80415d6:	4563      	cmp	r3, ip
		else tg->c2i[i] = j++;
 80415d8:	f100 0001 	add.w	r0, r0, #1
 80415dc:	6019      	str	r1, [r3, #0]
	for (i = j = 0; i < 256; ++i)
 80415de:	d008      	beq.n	80415f2 <tg_init_with_data+0x7e>
		if (tg->c2i[i] == 0) tg->c2i[i] = -1;
 80415e0:	f853 1f04 	ldr.w	r1, [r3, #4]!
 80415e4:	2900      	cmp	r1, #0
 80415e6:	d1f5      	bne.n	80415d4 <tg_init_with_data+0x60>
 80415e8:	f04f 31ff 	mov.w	r1, #4294967295
	for (i = j = 0; i < 256; ++i)
 80415ec:	4563      	cmp	r3, ip
 80415ee:	6019      	str	r1, [r3, #0]
 80415f0:	d1f6      	bne.n	80415e0 <tg_init_with_data+0x6c>
	for (i = 0; i < tg->len; ++i)
 80415f2:	2e00      	cmp	r6, #0
	tg->n_char = j;
 80415f4:	6060      	str	r0, [r4, #4]
	for (i = 0; i < tg->len; ++i)
 80415f6:	dd0a      	ble.n	804160e <tg_init_with_data+0x9a>
 80415f8:	3e01      	subs	r6, #1
 80415fa:	1e6b      	subs	r3, r5, #1
 80415fc:	4435      	add	r5, r6
		tg->data[i] = tg->c2i[tg->data[i]];
 80415fe:	f813 2f01 	ldrb.w	r2, [r3, #1]!
 8041602:	eb04 0282 	add.w	r2, r4, r2, lsl #2
 8041606:	68d2      	ldr	r2, [r2, #12]
	for (i = 0; i < tg->len; ++i)
 8041608:	42ab      	cmp	r3, r5
		tg->data[i] = tg->c2i[tg->data[i]];
 804160a:	701a      	strb	r2, [r3, #0]
	for (i = 0; i < tg->len; ++i)
 804160c:	d1f7      	bne.n	80415fe <tg_init_with_data+0x8a>
}
 804160e:	4620      	mov	r0, r4
 8041610:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8041614:	20018acc 	.word	0x20018acc

08041618 <tg_urnn_start>:

int tg_urnn_start(kann_t *ann, int batch_size)
{
 8041618:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 804161c:	4607      	mov	r7, r0
	int i, j, n, cnt = 0;
	for (i = 0; i < ann->n; ++i) {
 804161e:	6800      	ldr	r0, [r0, #0]
{
 8041620:	4689      	mov	r9, r1
	for (i = 0; i < ann->n; ++i) {
 8041622:	2800      	cmp	r0, #0
		kad_node_t *p = ann->v[i];
		if (p->pre && p->n_d >= 2 && p->pre->n_d == p->n_d && p->pre->n_child == 0 && kad_len(p)/p->d[0] == kad_len(p->pre)/p->pre->d[0])
			p->pre->flag = 0;
	}
	kann_set_batch_size(ann, batch_size);
 8041624:	6879      	ldr	r1, [r7, #4]
	for (i = 0; i < ann->n; ++i) {
 8041626:	dd39      	ble.n	804169c <tg_urnn_start+0x84>
 8041628:	1f0b      	subs	r3, r1, #4
 804162a:	eb03 0c80 	add.w	ip, r3, r0, lsl #2
 804162e:	e001      	b.n	8041634 <tg_urnn_start+0x1c>
 8041630:	4563      	cmp	r3, ip
 8041632:	d033      	beq.n	804169c <tg_urnn_start+0x84>
		kad_node_t *p = ann->v[i];
 8041634:	f853 4f04 	ldr.w	r4, [r3, #4]!
		if (p->pre && p->n_d >= 2 && p->pre->n_d == p->n_d && p->pre->n_child == 0 && kad_len(p)/p->d[0] == kad_len(p->pre)/p->pre->d[0])
 8041638:	6be5      	ldr	r5, [r4, #60]	@ 0x3c
 804163a:	2d00      	cmp	r5, #0
 804163c:	d0f8      	beq.n	8041630 <tg_urnn_start+0x18>
 804163e:	7826      	ldrb	r6, [r4, #0]
 8041640:	2e01      	cmp	r6, #1
 8041642:	d9f5      	bls.n	8041630 <tg_urnn_start+0x18>
 8041644:	f895 e000 	ldrb.w	lr, [r5]
 8041648:	4576      	cmp	r6, lr
 804164a:	d1f1      	bne.n	8041630 <tg_urnn_start+0x18>
 804164c:	686a      	ldr	r2, [r5, #4]
 804164e:	2a00      	cmp	r2, #0
 8041650:	d1ee      	bne.n	8041630 <tg_urnn_start+0x18>
 8041652:	e9d4 8e04 	ldrd	r8, lr, [r4, #16]
 8041656:	2e02      	cmp	r6, #2
 8041658:	d00b      	beq.n	8041672 <tg_urnn_start+0x5a>
 804165a:	fb08 fe0e 	mul.w	lr, r8, lr
 804165e:	69a2      	ldr	r2, [r4, #24]
 8041660:	2e03      	cmp	r6, #3
 8041662:	fb02 fe0e 	mul.w	lr, r2, lr
 8041666:	bf1c      	itt	ne
 8041668:	69e4      	ldrne	r4, [r4, #28]
 804166a:	fb04 fe0e 	mulne.w	lr, r4, lr
 804166e:	fb9e fef8 	sdiv	lr, lr, r8
 8041672:	e9d5 8404 	ldrd	r8, r4, [r5, #16]
 8041676:	2e02      	cmp	r6, #2
 8041678:	fb04 f408 	mul.w	r4, r4, r8
 804167c:	d006      	beq.n	804168c <tg_urnn_start+0x74>
 804167e:	69aa      	ldr	r2, [r5, #24]
 8041680:	2e03      	cmp	r6, #3
 8041682:	fb02 f404 	mul.w	r4, r2, r4
 8041686:	bf1c      	itt	ne
 8041688:	69ee      	ldrne	r6, [r5, #28]
 804168a:	4374      	mulne	r4, r6
 804168c:	fb94 f4f8 	sdiv	r4, r4, r8
 8041690:	4574      	cmp	r4, lr
			p->pre->flag = 0;
 8041692:	bf04      	itt	eq
 8041694:	2400      	moveq	r4, #0
 8041696:	706c      	strbeq	r4, [r5, #1]
	for (i = 0; i < ann->n; ++i) {
 8041698:	4563      	cmp	r3, ip
 804169a:	d1cb      	bne.n	8041634 <tg_urnn_start+0x1c>
	int i, j, n, cnt = 0;
 804169c:	f04f 0800 	mov.w	r8, #0
	kann_set_batch_size(ann, batch_size);
 80416a0:	464a      	mov	r2, r9
 80416a2:	f008 fd85 	bl	804a1b0 <kad_sync_dim>
	for (i = 0; i < ann->n; ++i) {
 80416a6:	683a      	ldr	r2, [r7, #0]
 80416a8:	2a00      	cmp	r2, #0
 80416aa:	bfc8      	it	gt
 80416ac:	4644      	movgt	r4, r8
 80416ae:	dc03      	bgt.n	80416b8 <tg_urnn_start+0xa0>
 80416b0:	e04c      	b.n	804174c <tg_urnn_start+0x134>
 80416b2:	3401      	adds	r4, #1
 80416b4:	4294      	cmp	r4, r2
 80416b6:	da49      	bge.n	804174c <tg_urnn_start+0x134>
		kad_node_t *p = ann->v[i];
 80416b8:	687b      	ldr	r3, [r7, #4]
 80416ba:	f853 5024 	ldr.w	r5, [r3, r4, lsl #2]
		if (p->pre && p->n_d >= 2 && p->pre->n_d == p->n_d && p->pre->n_child == 0 && kad_len(p) == kad_len(p->pre)) {
 80416be:	6bee      	ldr	r6, [r5, #60]	@ 0x3c
 80416c0:	2e00      	cmp	r6, #0
 80416c2:	d0f6      	beq.n	80416b2 <tg_urnn_start+0x9a>
 80416c4:	782b      	ldrb	r3, [r5, #0]
 80416c6:	2b01      	cmp	r3, #1
 80416c8:	d9f3      	bls.n	80416b2 <tg_urnn_start+0x9a>
 80416ca:	7831      	ldrb	r1, [r6, #0]
 80416cc:	428b      	cmp	r3, r1
 80416ce:	d1f0      	bne.n	80416b2 <tg_urnn_start+0x9a>
 80416d0:	f8d6 9004 	ldr.w	r9, [r6, #4]
 80416d4:	f1b9 0f00 	cmp.w	r9, #0
 80416d8:	d1eb      	bne.n	80416b2 <tg_urnn_start+0x9a>
 80416da:	e9d5 c104 	ldrd	ip, r1, [r5, #16]
 80416de:	2b02      	cmp	r3, #2
 80416e0:	fb01 fe0c 	mul.w	lr, r1, ip
 80416e4:	d035      	beq.n	8041752 <tg_urnn_start+0x13a>
 80416e6:	69a9      	ldr	r1, [r5, #24]
 80416e8:	2b03      	cmp	r3, #3
 80416ea:	fb01 fb0e 	mul.w	fp, r1, lr
 80416ee:	bf1c      	itt	ne
 80416f0:	69e8      	ldrne	r0, [r5, #28]
 80416f2:	fb00 fb0b 	mulne.w	fp, r0, fp
 80416f6:	6930      	ldr	r0, [r6, #16]
 80416f8:	6971      	ldr	r1, [r6, #20]
 80416fa:	2b02      	cmp	r3, #2
 80416fc:	fb01 fa00 	mul.w	sl, r1, r0
 8041700:	d007      	beq.n	8041712 <tg_urnn_start+0xfa>
 8041702:	69b0      	ldr	r0, [r6, #24]
 8041704:	2b03      	cmp	r3, #3
 8041706:	fb00 fa0a 	mul.w	sl, r0, sl
 804170a:	bf1c      	itt	ne
 804170c:	69f0      	ldrne	r0, [r6, #28]
 804170e:	fb00 fa0a 	mulne.w	sl, r0, sl
 8041712:	45d3      	cmp	fp, sl
 8041714:	d1cd      	bne.n	80416b2 <tg_urnn_start+0x9a>
 8041716:	2b02      	cmp	r3, #2
 8041718:	d007      	beq.n	804172a <tg_urnn_start+0x112>
 804171a:	69aa      	ldr	r2, [r5, #24]
 804171c:	2b03      	cmp	r3, #3
 804171e:	fb02 fe0e 	mul.w	lr, r2, lr
 8041722:	bf1c      	itt	ne
 8041724:	69eb      	ldrne	r3, [r5, #28]
 8041726:	fb03 fe0e 	mulne.w	lr, r3, lr
			kad_node_t *q = p->pre;
			n = kad_len(p) / p->d[0];
 804172a:	fb9e fbfc 	sdiv	fp, lr, ip
			memset(p->x, 0, p->d[0] * n * sizeof(float));
 804172e:	fb0c f20b 	mul.w	r2, ip, fp
 8041732:	2100      	movs	r1, #0
 8041734:	6aa8      	ldr	r0, [r5, #40]	@ 0x28
 8041736:	0092      	lsls	r2, r2, #2
 8041738:	f00a fb7c 	bl	804be34 <memset>
			if (q->x)
 804173c:	6ab1      	ldr	r1, [r6, #40]	@ 0x28
 804173e:	b959      	cbnz	r1, 8041758 <tg_urnn_start+0x140>
				for (j = 0; j < p->d[0]; ++j)
					memcpy(&p->x[j * n], q->x, n * sizeof(float));
			q->x = p->x;
 8041740:	6aab      	ldr	r3, [r5, #40]	@ 0x28
	for (i = 0; i < ann->n; ++i) {
 8041742:	683a      	ldr	r2, [r7, #0]
			++cnt;
 8041744:	f108 0801 	add.w	r8, r8, #1
			q->x = p->x;
 8041748:	62b3      	str	r3, [r6, #40]	@ 0x28
			++cnt;
 804174a:	e7b2      	b.n	80416b2 <tg_urnn_start+0x9a>
		}
	}
	return cnt;
}
 804174c:	4640      	mov	r0, r8
 804174e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8041752:	46f3      	mov	fp, lr
 8041754:	6930      	ldr	r0, [r6, #16]
 8041756:	e7cf      	b.n	80416f8 <tg_urnn_start+0xe0>
				for (j = 0; j < p->d[0]; ++j)
 8041758:	692b      	ldr	r3, [r5, #16]
 804175a:	2b00      	cmp	r3, #0
 804175c:	ddf0      	ble.n	8041740 <tg_urnn_start+0x128>
					memcpy(&p->x[j * n], q->x, n * sizeof(float));
 804175e:	f04f 0a00 	mov.w	sl, #0
 8041762:	ea4f 0b8b 	mov.w	fp, fp, lsl #2
 8041766:	e000      	b.n	804176a <tg_urnn_start+0x152>
 8041768:	6ab1      	ldr	r1, [r6, #40]	@ 0x28
 804176a:	6aa8      	ldr	r0, [r5, #40]	@ 0x28
 804176c:	465a      	mov	r2, fp
 804176e:	4450      	add	r0, sl
 8041770:	f00a fc5d 	bl	804c02e <memcpy>
				for (j = 0; j < p->d[0]; ++j)
 8041774:	692b      	ldr	r3, [r5, #16]
 8041776:	f109 0901 	add.w	r9, r9, #1
 804177a:	454b      	cmp	r3, r9
 804177c:	44da      	add	sl, fp
 804177e:	dcf3      	bgt.n	8041768 <tg_urnn_start+0x150>
 8041780:	e7de      	b.n	8041740 <tg_urnn_start+0x128>
 8041782:	bf00      	nop

08041784 <tg_train>:

extern void sendline(char* s);

void tg_train(kann_t *ann, const tg_data_t *tg, float lr, int ulen, int vlen, int cs, int mbs, int max_epoch, float grad_clip, int batch_len, int n_threads)
{
 8041784:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8041788:	ed2d 8b04 	vpush	{d8-d9}
 804178c:	460f      	mov	r7, r1
 804178e:	b09d      	sub	sp, #116	@ 0x74
 8041790:	9d2b      	ldr	r5, [sp, #172]	@ 0xac
 8041792:	4680      	mov	r8, r0
 8041794:	982a      	ldr	r0, [sp, #168]	@ 0xa8
 8041796:	9507      	str	r5, [sp, #28]
 8041798:	9d2c      	ldr	r5, [sp, #176]	@ 0xb0
 804179a:	900a      	str	r0, [sp, #40]	@ 0x28
	int i, epoch, u, n_var, n_char;
	float **x, **y, *r;
	const uint8_t **p;
	kann_t *ua;

	sendline("TG_TRAIN 1\n");
 804179c:	487e      	ldr	r0, [pc, #504]	@ (8041998 <tg_train+0x214>)
{
 804179e:	9c2d      	ldr	r4, [sp, #180]	@ 0xb4
 80417a0:	eef0 8a40 	vmov.f32	s17, s0
 80417a4:	9513      	str	r5, [sp, #76]	@ 0x4c
 80417a6:	9112      	str	r1, [sp, #72]	@ 0x48
 80417a8:	4615      	mov	r5, r2
 80417aa:	9305      	str	r3, [sp, #20]
	sendline("TG_TRAIN 1\n");
 80417ac:	f7ff fad2 	bl	8040d54 <sendline>

	batch_len = batch_len < tg->len? batch_len : tg->len;
 80417b0:	683b      	ldr	r3, [r7, #0]


	n_char = kann_dim_in(ann);
 80417b2:	2200      	movs	r2, #0
	batch_len = batch_len < tg->len? batch_len : tg->len;
 80417b4:	429c      	cmp	r4, r3
 80417b6:	bfa8      	it	ge
 80417b8:	461c      	movge	r4, r3
	n_char = kann_dim_in(ann);
 80417ba:	2101      	movs	r1, #1
 80417bc:	4640      	mov	r0, r8
	batch_len = batch_len < tg->len? batch_len : tg->len;
 80417be:	9410      	str	r4, [sp, #64]	@ 0x40
	n_char = kann_dim_in(ann);
 80417c0:	f000 fcda 	bl	8042178 <kann_feed_dim>
 80417c4:	4603      	mov	r3, r0
	x = (float**)calloc(ulen, sizeof(float*));
 80417c6:	2104      	movs	r1, #4
	heapSize += ulen*sizeof(float*);
 80417c8:	00ac      	lsls	r4, r5, #2
	x = (float**)calloc(ulen, sizeof(float*));
 80417ca:	4628      	mov	r0, r5
	n_char = kann_dim_in(ann);
 80417cc:	e9cd 430e 	strd	r4, r3, [sp, #56]	@ 0x38
	x = (float**)calloc(ulen, sizeof(float*));
 80417d0:	f00a f826 	bl	804b820 <calloc>
 80417d4:	4682      	mov	sl, r0
	heapSize += ulen*sizeof(float*);
 80417d6:	4e71      	ldr	r6, [pc, #452]	@ (804199c <tg_train+0x218>)
	y = (float**)calloc(ulen, sizeof(float*));
 80417d8:	2104      	movs	r1, #4
	heapSize += ulen*sizeof(float*);
 80417da:	6833      	ldr	r3, [r6, #0]
	y = (float**)calloc(ulen, sizeof(float*));
 80417dc:	4628      	mov	r0, r5
	heapSize += ulen*sizeof(float*);
 80417de:	eb03 0385 	add.w	r3, r3, r5, lsl #2
 80417e2:	6033      	str	r3, [r6, #0]
	x = (float**)calloc(ulen, sizeof(float*));
 80417e4:	f8cd a008 	str.w	sl, [sp, #8]
	y = (float**)calloc(ulen, sizeof(float*));
 80417e8:	f00a f81a 	bl	804b820 <calloc>
	heapSize += ulen*sizeof(float*);
 80417ec:	6833      	ldr	r3, [r6, #0]

	for (u = 0; u < ulen; ++u) {
 80417ee:	2d00      	cmp	r5, #0
	heapSize += ulen*sizeof(float*);
 80417f0:	4423      	add	r3, r4
 80417f2:	6033      	str	r3, [r6, #0]
	y = (float**)calloc(ulen, sizeof(float*));
 80417f4:	9003      	str	r0, [sp, #12]
	for (u = 0; u < ulen; ++u) {
 80417f6:	dd22      	ble.n	804183e <tg_train+0xba>
		x[u] = (float*)calloc(n_char * mbs, sizeof(float));
 80417f8:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
 80417fa:	9a07      	ldr	r2, [sp, #28]
 80417fc:	9902      	ldr	r1, [sp, #8]
 80417fe:	fb02 f903 	mul.w	r9, r2, r3
 8041802:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
 8041804:	1f0f      	subs	r7, r1, #4
 8041806:	3b04      	subs	r3, #4
 8041808:	18ca      	adds	r2, r1, r3
 804180a:	4692      	mov	sl, r2
 804180c:	9b03      	ldr	r3, [sp, #12]
		heapSize += n_char * mbs * sizeof(float);
 804180e:	ea4f 0489 	mov.w	r4, r9, lsl #2
 8041812:	f1a3 0b04 	sub.w	fp, r3, #4
		x[u] = (float*)calloc(n_char * mbs, sizeof(float));
 8041816:	2104      	movs	r1, #4
 8041818:	4648      	mov	r0, r9
 804181a:	f00a f801 	bl	804b820 <calloc>
		heapSize += n_char * mbs * sizeof(float);
 804181e:	6833      	ldr	r3, [r6, #0]
		x[u] = (float*)calloc(n_char * mbs, sizeof(float));
 8041820:	f847 0f04 	str.w	r0, [r7, #4]!
		heapSize += n_char * mbs * sizeof(float);
 8041824:	4423      	add	r3, r4
		y[u] = (float*)calloc(n_char * mbs, sizeof(float));
 8041826:	2104      	movs	r1, #4
 8041828:	4648      	mov	r0, r9
		heapSize += n_char * mbs * sizeof(float);
 804182a:	6033      	str	r3, [r6, #0]
		y[u] = (float*)calloc(n_char * mbs, sizeof(float));
 804182c:	f009 fff8 	bl	804b820 <calloc>
		heapSize += n_char * mbs * sizeof(float);
 8041830:	6833      	ldr	r3, [r6, #0]
	for (u = 0; u < ulen; ++u) {
 8041832:	4557      	cmp	r7, sl
		heapSize += n_char * mbs * sizeof(float);
 8041834:	4423      	add	r3, r4
		y[u] = (float*)calloc(n_char * mbs, sizeof(float));
 8041836:	f84b 0f04 	str.w	r0, [fp, #4]!
		heapSize += n_char * mbs * sizeof(float);
 804183a:	6033      	str	r3, [r6, #0]
	for (u = 0; u < ulen; ++u) {
 804183c:	d1eb      	bne.n	8041816 <tg_train+0x92>
	}
	n_var = kann_size_var(ann);
 804183e:	e9d8 0100 	ldrd	r0, r1, [r8]
 8041842:	f008 fe57 	bl	804a4f4 <kad_size_var>
	r = (float*)calloc(n_var, sizeof(float));
 8041846:	2104      	movs	r1, #4
	heapSize += n_var* sizeof(float);
	p = (const uint8_t**)calloc(mbs, sizeof(const uint8_t*));
	heapSize += mbs* sizeof(const uint8_t*);
 8041848:	9c07      	ldr	r4, [sp, #28]
	n_var = kann_size_var(ann);
 804184a:	4607      	mov	r7, r0
 804184c:	900c      	str	r0, [sp, #48]	@ 0x30
	r = (float*)calloc(n_var, sizeof(float));
 804184e:	f009 ffe7 	bl	804b820 <calloc>
 8041852:	4602      	mov	r2, r0
	heapSize += n_var* sizeof(float);
 8041854:	6833      	ldr	r3, [r6, #0]
	p = (const uint8_t**)calloc(mbs, sizeof(const uint8_t*));
 8041856:	2104      	movs	r1, #4
	heapSize += n_var* sizeof(float);
 8041858:	eb03 0387 	add.w	r3, r3, r7, lsl #2
	p = (const uint8_t**)calloc(mbs, sizeof(const uint8_t*));
 804185c:	4620      	mov	r0, r4
	heapSize += n_var* sizeof(float);
 804185e:	6033      	str	r3, [r6, #0]
	r = (float*)calloc(n_var, sizeof(float));
 8041860:	920b      	str	r2, [sp, #44]	@ 0x2c
	p = (const uint8_t**)calloc(mbs, sizeof(const uint8_t*));
 8041862:	f009 ffdd 	bl	804b820 <calloc>
 8041866:	4602      	mov	r2, r0
	heapSize += mbs* sizeof(const uint8_t*);
 8041868:	6833      	ldr	r3, [r6, #0]


	sendline("TG_TRAIN 2\n");
 804186a:	484d      	ldr	r0, [pc, #308]	@ (80419a0 <tg_train+0x21c>)
	heapSize += mbs* sizeof(const uint8_t*);
 804186c:	eb03 0384 	add.w	r3, r3, r4, lsl #2
	p = (const uint8_t**)calloc(mbs, sizeof(const uint8_t*));
 8041870:	9209      	str	r2, [sp, #36]	@ 0x24
	heapSize += mbs* sizeof(const uint8_t*);
 8041872:	6033      	str	r3, [r6, #0]
	sendline("TG_TRAIN 2\n");
 8041874:	f7ff fa6e 	bl	8040d54 <sendline>

	ua = kann_unroll(ann, ulen);
 8041878:	4629      	mov	r1, r5
 804187a:	4640      	mov	r0, r8
 804187c:	f000 fb70 	bl	8041f60 <kann_unroll>
 8041880:	4603      	mov	r3, r0
 8041882:	461e      	mov	r6, r3

	sendline("TG_TRAIN 3\n");
 8041884:	4847      	ldr	r0, [pc, #284]	@ (80419a4 <tg_train+0x220>)
	ua = kann_unroll(ann, ulen);
 8041886:	9308      	str	r3, [sp, #32]
	sendline("TG_TRAIN 3\n");
 8041888:	f7ff fa64 	bl	8040d54 <sendline>
	tg_urnn_start(ua, mbs);
 804188c:	4621      	mov	r1, r4
 804188e:	4630      	mov	r0, r6
 8041890:	f7ff fec2 	bl	8041618 <tg_urnn_start>
	//kann_mt(ua, n_threads, mbs);
	//kann_switch(ua, 1);
	kann_feed_bind(ua, KANN_F_IN,  100, x);
 8041894:	2264      	movs	r2, #100	@ 0x64
 8041896:	2101      	movs	r1, #1
 8041898:	9b02      	ldr	r3, [sp, #8]
 804189a:	4630      	mov	r0, r6
 804189c:	f000 fc02 	bl	80420a4 <kann_feed_bind>
	kann_feed_bind(ua, KANN_F_TRUTH, 0, y);
 80418a0:	9b03      	ldr	r3, [sp, #12]
 80418a2:	2200      	movs	r2, #0
 80418a4:	2104      	movs	r1, #4
 80418a6:	4630      	mov	r0, r6
 80418a8:	f000 fbfc 	bl	80420a4 <kann_feed_bind>

	sendline("TG_TRAIN 4\n");
 80418ac:	483e      	ldr	r0, [pc, #248]	@ (80419a8 <tg_train+0x224>)
 80418ae:	f7ff fa51 	bl	8040d54 <sendline>

	for (epoch = 0; epoch < max_epoch; ++epoch) {
 80418b2:	9b13      	ldr	r3, [sp, #76]	@ 0x4c
	heapSize += mbs* sizeof(const uint8_t*);
 80418b4:	ea4f 0b84 	mov.w	fp, r4, lsl #2
	for (epoch = 0; epoch < max_epoch; ++epoch) {
 80418b8:	2b00      	cmp	r3, #0
 80418ba:	f340 811e 	ble.w	8041afa <tg_train+0x376>
		double cost = 0.0;
		int c, j, b, tot = 0, ctot = 0, n_cerr = 0;

		//sendline("TG_TRAIN 5\n");
		for (i = 0; i < batch_len; i += mbs * cs * ulen) {
 80418be:	9a0a      	ldr	r2, [sp, #40]	@ 0x28
 80418c0:	9b07      	ldr	r3, [sp, #28]
				if (ua->v[j]->pre)
					memset(ua->v[j]->x, 0, kad_len(ua->v[j]) * sizeof(float));
			for (c = 0; c < cs; ++c) {
				int ce_len = c? ulen : ulen - vlen;
				for (u = 0; u < ulen; ++u) {
					memset(x[u], 0, mbs * n_char * sizeof(float));
 80418c2:	990f      	ldr	r1, [sp, #60]	@ 0x3c
		for (i = 0; i < batch_len; i += mbs * cs * ulen) {
 80418c4:	fb02 f303 	mul.w	r3, r2, r3
 80418c8:	fb05 f303 	mul.w	r3, r5, r3
 80418cc:	9315      	str	r3, [sp, #84]	@ 0x54
 80418ce:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
					memset(x[u], 0, mbs * n_char * sizeof(float));
 80418d0:	fb01 f60b 	mul.w	r6, r1, fp
 80418d4:	1f1c      	subs	r4, r3, #4
 80418d6:	9b02      	ldr	r3, [sp, #8]
 80418d8:	9909      	ldr	r1, [sp, #36]	@ 0x24
 80418da:	441c      	add	r4, r3
 80418dc:	f1ab 0304 	sub.w	r3, fp, #4
 80418e0:	18cb      	adds	r3, r1, r3
 80418e2:	930d      	str	r3, [sp, #52]	@ 0x34
 80418e4:	9b05      	ldr	r3, [sp, #20]
	for (epoch = 0; epoch < max_epoch; ++epoch) {
 80418e6:	f04f 0a00 	mov.w	sl, #0
 80418ea:	42ab      	cmp	r3, r5
 80418ec:	bfa8      	it	ge
 80418ee:	462b      	movge	r3, r5
 80418f0:	4699      	mov	r9, r3
				p[b] = tg->data + (int)((tg->len - ulen * cs - 1) * kad_drand(0)) + 1;
 80418f2:	fb02 f305 	mul.w	r3, r2, r5
 80418f6:	9314      	str	r3, [sp, #80]	@ 0x50
		sprintf(buffer, "epoch: %d; error %d : error %d\n", epoch+1, (int) (100.0 * n_cerr / ctot));
		sendline(buffer);*/


		//fprintf(stderr, "epoch: %d; running cost: %g (class error: %.2f%%)\n", epoch+1, cost / tot, 100.0 * n_cerr / ctot);
		tg_gen(ann, 0.4f, 20, tg->c2i);
 80418f8:	9b12      	ldr	r3, [sp, #72]	@ 0x48
				kann_RMSprop(n_var, lr, 0, 0.9f, ua->g, ua->x, r);
 80418fa:	ed9f 9a2c 	vldr	s18, [pc, #176]	@ 80419ac <tg_train+0x228>
		tg_gen(ann, 0.4f, 20, tg->c2i);
 80418fe:	330c      	adds	r3, #12
 8041900:	e9cd 3916 	strd	r3, r9, [sp, #88]	@ 0x58
						x[u][b * n_char + p[b][u-1]] = 1.0f;
 8041904:	eeb7 8a00 	vmov.f32	s16, #112	@ 0x3f800000  1.0
 8041908:	46d1      	mov	r9, sl
		for (i = 0; i < batch_len; i += mbs * cs * ulen) {
 804190a:	9b10      	ldr	r3, [sp, #64]	@ 0x40
 804190c:	2b00      	cmp	r3, #0
 804190e:	f340 80ea 	ble.w	8041ae6 <tg_train+0x362>
 8041912:	2300      	movs	r3, #0
 8041914:	e9cd 9818 	strd	r9, r8, [sp, #96]	@ 0x60
 8041918:	f8dd b05c 	ldr.w	fp, [sp, #92]	@ 0x5c
 804191c:	9311      	str	r3, [sp, #68]	@ 0x44
			for (b = 0; b < mbs; ++b)
 804191e:	9b07      	ldr	r3, [sp, #28]
 8041920:	2b00      	cmp	r3, #0
 8041922:	dd31      	ble.n	8041988 <tg_train+0x204>
 8041924:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8041926:	951a      	str	r5, [sp, #104]	@ 0x68
 8041928:	3b04      	subs	r3, #4
 804192a:	f04f 0a00 	mov.w	sl, #0
 804192e:	461d      	mov	r5, r3
 8041930:	f8cd b06c 	str.w	fp, [sp, #108]	@ 0x6c
 8041934:	f8dd 9050 	ldr.w	r9, [sp, #80]	@ 0x50
 8041938:	f8dd 8048 	ldr.w	r8, [sp, #72]	@ 0x48
 804193c:	f8dd b01c 	ldr.w	fp, [sp, #28]
 8041940:	9604      	str	r6, [sp, #16]
 8041942:	9406      	str	r4, [sp, #24]
				p[b] = tg->data + (int)((tg->len - ulen * cs - 1) * kad_drand(0)) + 1;
 8041944:	f8d8 3000 	ldr.w	r3, [r8]
			for (b = 0; b < mbs; ++b)
 8041948:	f10a 0a01 	add.w	sl, sl, #1
				p[b] = tg->data + (int)((tg->len - ulen * cs - 1) * kad_drand(0)) + 1;
 804194c:	eba3 0309 	sub.w	r3, r3, r9
 8041950:	1e58      	subs	r0, r3, #1
 8041952:	f7fe fdc3 	bl	80404dc <__aeabi_i2d>
 8041956:	4606      	mov	r6, r0
 8041958:	2000      	movs	r0, #0
 804195a:	460f      	mov	r7, r1
 804195c:	f8d8 4008 	ldr.w	r4, [r8, #8]
 8041960:	f009 fb88 	bl	804b074 <kad_drand>
 8041964:	4630      	mov	r0, r6
 8041966:	ec53 2b10 	vmov	r2, r3, d0
 804196a:	4639      	mov	r1, r7
 804196c:	f7fe fe20 	bl	80405b0 <__aeabi_dmul>
 8041970:	f7ff f8ce 	bl	8040b10 <__aeabi_d2iz>
 8041974:	1c43      	adds	r3, r0, #1
 8041976:	441c      	add	r4, r3
			for (b = 0; b < mbs; ++b)
 8041978:	45d3      	cmp	fp, sl
				p[b] = tg->data + (int)((tg->len - ulen * cs - 1) * kad_drand(0)) + 1;
 804197a:	f845 4f04 	str.w	r4, [r5, #4]!
			for (b = 0; b < mbs; ++b)
 804197e:	d1e1      	bne.n	8041944 <tg_train+0x1c0>
 8041980:	e9dd 5b1a 	ldrd	r5, fp, [sp, #104]	@ 0x68
 8041984:	9e04      	ldr	r6, [sp, #16]
 8041986:	9c06      	ldr	r4, [sp, #24]
			for (j = 0; j < ua->n; ++j) // reset initial hidden values to zero
 8041988:	9b08      	ldr	r3, [sp, #32]
 804198a:	6819      	ldr	r1, [r3, #0]
 804198c:	2900      	cmp	r1, #0
 804198e:	dd37      	ble.n	8041a00 <tg_train+0x27c>
 8041990:	4699      	mov	r9, r3
 8041992:	2700      	movs	r7, #0
 8041994:	46a0      	mov	r8, r4
 8041996:	e00e      	b.n	80419b6 <tg_train+0x232>
 8041998:	0804e368 	.word	0x0804e368
 804199c:	20018acc 	.word	0x20018acc
 80419a0:	0804e374 	.word	0x0804e374
 80419a4:	0804e380 	.word	0x0804e380
 80419a8:	0804e38c 	.word	0x0804e38c
 80419ac:	3f666666 	.word	0x3f666666
 80419b0:	3701      	adds	r7, #1
 80419b2:	428f      	cmp	r7, r1
 80419b4:	da23      	bge.n	80419fe <tg_train+0x27a>
				if (ua->v[j]->pre)
 80419b6:	f8d9 3004 	ldr.w	r3, [r9, #4]
 80419ba:	f853 3027 	ldr.w	r3, [r3, r7, lsl #2]
 80419be:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
 80419c0:	2a00      	cmp	r2, #0
 80419c2:	d0f5      	beq.n	80419b0 <tg_train+0x22c>
 80419c4:	7819      	ldrb	r1, [r3, #0]
					memset(ua->v[j]->x, 0, kad_len(ua->v[j]) * sizeof(float));
 80419c6:	6a98      	ldr	r0, [r3, #40]	@ 0x28
 80419c8:	2900      	cmp	r1, #0
 80419ca:	f000 8106 	beq.w	8041bda <tg_train+0x456>
 80419ce:	2901      	cmp	r1, #1
 80419d0:	691a      	ldr	r2, [r3, #16]
 80419d2:	d00b      	beq.n	80419ec <tg_train+0x268>
 80419d4:	695c      	ldr	r4, [r3, #20]
 80419d6:	2902      	cmp	r1, #2
 80419d8:	fb04 f202 	mul.w	r2, r4, r2
 80419dc:	d006      	beq.n	80419ec <tg_train+0x268>
 80419de:	699c      	ldr	r4, [r3, #24]
 80419e0:	2903      	cmp	r1, #3
 80419e2:	fb04 f202 	mul.w	r2, r4, r2
 80419e6:	bf1c      	itt	ne
 80419e8:	69db      	ldrne	r3, [r3, #28]
 80419ea:	435a      	mulne	r2, r3
 80419ec:	0092      	lsls	r2, r2, #2
 80419ee:	2100      	movs	r1, #0
 80419f0:	f00a fa20 	bl	804be34 <memset>
			for (j = 0; j < ua->n; ++j) // reset initial hidden values to zero
 80419f4:	f8d9 1000 	ldr.w	r1, [r9]
 80419f8:	3701      	adds	r7, #1
 80419fa:	428f      	cmp	r7, r1
 80419fc:	dbdb      	blt.n	80419b6 <tg_train+0x232>
 80419fe:	4644      	mov	r4, r8
			for (c = 0; c < cs; ++c) {
 8041a00:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 8041a02:	2b00      	cmp	r3, #0
 8041a04:	dd65      	ble.n	8041ad2 <tg_train+0x34e>
 8041a06:	2700      	movs	r7, #0
 8041a08:	f8dd a03c 	ldr.w	sl, [sp, #60]	@ 0x3c
				for (u = 0; u < ulen; ++u) {
 8041a0c:	2d00      	cmp	r5, #0
 8041a0e:	dd13      	ble.n	8041a38 <tg_train+0x2b4>
 8041a10:	9b02      	ldr	r3, [sp, #8]
 8041a12:	f1a3 0904 	sub.w	r9, r3, #4
 8041a16:	9b03      	ldr	r3, [sp, #12]
 8041a18:	f1a3 0804 	sub.w	r8, r3, #4
					memset(x[u], 0, mbs * n_char * sizeof(float));
 8041a1c:	2100      	movs	r1, #0
 8041a1e:	4632      	mov	r2, r6
 8041a20:	f859 0f04 	ldr.w	r0, [r9, #4]!
 8041a24:	f00a fa06 	bl	804be34 <memset>
					memset(y[u], 0, mbs * n_char * sizeof(float));
 8041a28:	4632      	mov	r2, r6
 8041a2a:	2100      	movs	r1, #0
 8041a2c:	f858 0f04 	ldr.w	r0, [r8, #4]!
 8041a30:	f00a fa00 	bl	804be34 <memset>
				for (u = 0; u < ulen; ++u) {
 8041a34:	45a1      	cmp	r9, r4
 8041a36:	d1f1      	bne.n	8041a1c <tg_train+0x298>
				for (b = 0; b < mbs; ++b) {
 8041a38:	9b07      	ldr	r3, [sp, #28]
 8041a3a:	2b00      	cmp	r3, #0
 8041a3c:	dd2f      	ble.n	8041a9e <tg_train+0x31a>
 8041a3e:	2300      	movs	r3, #0
 8041a40:	4639      	mov	r1, r7
 8041a42:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 8041a44:	f8dd 9034 	ldr.w	r9, [sp, #52]	@ 0x34
 8041a48:	f1a2 0804 	sub.w	r8, r2, #4
 8041a4c:	9606      	str	r6, [sp, #24]
					for (u = 0; u < ulen; ++u) {
 8041a4e:	2d00      	cmp	r5, #0
					p[b] += ulen;
 8041a50:	f858 7f04 	ldr.w	r7, [r8, #4]!
					for (u = 0; u < ulen; ++u) {
 8041a54:	dd1b      	ble.n	8041a8e <tg_train+0x30a>
 8041a56:	2900      	cmp	r1, #0
 8041a58:	d079      	beq.n	8041b4e <tg_train+0x3ca>
 8041a5a:	9a02      	ldr	r2, [sp, #8]
 8041a5c:	1e7e      	subs	r6, r7, #1
 8041a5e:	f1a2 0c04 	sub.w	ip, r2, #4
 8041a62:	9a03      	ldr	r2, [sp, #12]
 8041a64:	f1a2 0e04 	sub.w	lr, r2, #4
						x[u][b * n_char + p[b][u-1]] = 1.0f;
 8041a68:	7830      	ldrb	r0, [r6, #0]
 8041a6a:	f85c 2f04 	ldr.w	r2, [ip, #4]!
 8041a6e:	4418      	add	r0, r3
 8041a70:	eb02 0280 	add.w	r2, r2, r0, lsl #2
 8041a74:	ed82 8a00 	vstr	s16, [r2]
							y[u][b * n_char + p[b][u]] = 1.0f;
 8041a78:	f816 0f01 	ldrb.w	r0, [r6, #1]!
 8041a7c:	f85e 2f04 	ldr.w	r2, [lr, #4]!
 8041a80:	4418      	add	r0, r3
 8041a82:	eb02 0280 	add.w	r2, r2, r0, lsl #2
					for (u = 0; u < ulen; ++u) {
 8041a86:	45a4      	cmp	ip, r4
							y[u][b * n_char + p[b][u]] = 1.0f;
 8041a88:	ed82 8a00 	vstr	s16, [r2]
					for (u = 0; u < ulen; ++u) {
 8041a8c:	d1ec      	bne.n	8041a68 <tg_train+0x2e4>
					p[b] += ulen;
 8041a8e:	442f      	add	r7, r5
				for (b = 0; b < mbs; ++b) {
 8041a90:	45c1      	cmp	r9, r8
					p[b] += ulen;
 8041a92:	f8c8 7000 	str.w	r7, [r8]
				for (b = 0; b < mbs; ++b) {
 8041a96:	4453      	add	r3, sl
 8041a98:	d1d9      	bne.n	8041a4e <tg_train+0x2ca>
 8041a9a:	460f      	mov	r7, r1
 8041a9c:	9e06      	ldr	r6, [sp, #24]
				cost += kann_cost(ua, 0, 1) * ulen * mbs;
 8041a9e:	f8dd 8020 	ldr.w	r8, [sp, #32]
 8041aa2:	2201      	movs	r2, #1
 8041aa4:	2100      	movs	r1, #0
 8041aa6:	4640      	mov	r0, r8
 8041aa8:	f000 fcb4 	bl	8042414 <kann_cost>
				kann_RMSprop(n_var, lr, 0, 0.9f, ua->g, ua->x, r);
 8041aac:	990b      	ldr	r1, [sp, #44]	@ 0x2c
 8041aae:	f8d8 3008 	ldr.w	r3, [r8, #8]
 8041ab2:	f8d8 200c 	ldr.w	r2, [r8, #12]
 8041ab6:	eef0 0a49 	vmov.f32	s1, s18
 8041aba:	9100      	str	r1, [sp, #0]
 8041abc:	eeb0 0a68 	vmov.f32	s0, s17
 8041ac0:	2100      	movs	r1, #0
 8041ac2:	980c      	ldr	r0, [sp, #48]	@ 0x30
 8041ac4:	9304      	str	r3, [sp, #16]
 8041ac6:	f000 ffd3 	bl	8042a70 <kann_RMSprop>
			for (c = 0; c < cs; ++c) {
 8041aca:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 8041acc:	3701      	adds	r7, #1
 8041ace:	42bb      	cmp	r3, r7
 8041ad0:	d19c      	bne.n	8041a0c <tg_train+0x288>
		for (i = 0; i < batch_len; i += mbs * cs * ulen) {
 8041ad2:	9b11      	ldr	r3, [sp, #68]	@ 0x44
 8041ad4:	9a15      	ldr	r2, [sp, #84]	@ 0x54
 8041ad6:	4413      	add	r3, r2
 8041ad8:	9a10      	ldr	r2, [sp, #64]	@ 0x40
 8041ada:	9311      	str	r3, [sp, #68]	@ 0x44
 8041adc:	429a      	cmp	r2, r3
 8041ade:	f73f af1e 	bgt.w	804191e <tg_train+0x19a>
 8041ae2:	e9dd 9818 	ldrd	r9, r8, [sp, #96]	@ 0x60
		tg_gen(ann, 0.4f, 20, tg->c2i);
 8041ae6:	4640      	mov	r0, r8
 8041ae8:	9916      	ldr	r1, [sp, #88]	@ 0x58
 8041aea:	f7ff fc49 	bl	8041380 <tg_gen.constprop.0>
	for (epoch = 0; epoch < max_epoch; ++epoch) {
 8041aee:	9b13      	ldr	r3, [sp, #76]	@ 0x4c
 8041af0:	f109 0901 	add.w	r9, r9, #1
 8041af4:	454b      	cmp	r3, r9
 8041af6:	f47f af08 	bne.w	804190a <tg_train+0x186>
		//if (fn) tg_save(fn, ann, tg->c2i);
	}
	kann_delete_unrolled(ua);
 8041afa:	9808      	ldr	r0, [sp, #32]
 8041afc:	f000 fa6a 	bl	8041fd4 <kann_delete_unrolled>

	sendline("DONE!\n");
 8041b00:	4837      	ldr	r0, [pc, #220]	@ (8041be0 <tg_train+0x45c>)
 8041b02:	f7ff f927 	bl	8040d54 <sendline>

	for (u = 0; u < ulen; ++u) {
 8041b06:	2d00      	cmp	r5, #0
 8041b08:	dd10      	ble.n	8041b2c <tg_train+0x3a8>
 8041b0a:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
 8041b0c:	1f1c      	subs	r4, r3, #4
 8041b0e:	9b02      	ldr	r3, [sp, #8]
 8041b10:	441c      	add	r4, r3
 8041b12:	1f1d      	subs	r5, r3, #4
 8041b14:	9b03      	ldr	r3, [sp, #12]
 8041b16:	1f1e      	subs	r6, r3, #4
		free(x[u]); free(y[u]);
 8041b18:	f855 0f04 	ldr.w	r0, [r5, #4]!
 8041b1c:	f009 fea4 	bl	804b868 <free>
 8041b20:	f856 0f04 	ldr.w	r0, [r6, #4]!
 8041b24:	f009 fea0 	bl	804b868 <free>
	for (u = 0; u < ulen; ++u) {
 8041b28:	42a5      	cmp	r5, r4
 8041b2a:	d1f5      	bne.n	8041b18 <tg_train+0x394>
	}

	free(r); free(y); free(x); free(p);
 8041b2c:	980b      	ldr	r0, [sp, #44]	@ 0x2c
 8041b2e:	f009 fe9b 	bl	804b868 <free>
 8041b32:	9803      	ldr	r0, [sp, #12]
 8041b34:	f009 fe98 	bl	804b868 <free>
 8041b38:	9802      	ldr	r0, [sp, #8]
 8041b3a:	f009 fe95 	bl	804b868 <free>
 8041b3e:	9809      	ldr	r0, [sp, #36]	@ 0x24
}
 8041b40:	b01d      	add	sp, #116	@ 0x74
 8041b42:	ecbd 8b04 	vpop	{d8-d9}
 8041b46:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	free(r); free(y); free(x); free(p);
 8041b4a:	f009 be8d 	b.w	804b868 <free>
 8041b4e:	9a05      	ldr	r2, [sp, #20]
 8041b50:	2a00      	cmp	r2, #0
						x[u][b * n_char + p[b][u-1]] = 1.0f;
 8041b52:	460a      	mov	r2, r1
 8041b54:	dd12      	ble.n	8041b7c <tg_train+0x3f8>
 8041b56:	9802      	ldr	r0, [sp, #8]
 8041b58:	f1a7 0c02 	sub.w	ip, r7, #2
 8041b5c:	f1a0 0e04 	sub.w	lr, r0, #4
 8041b60:	f81c 6f01 	ldrb.w	r6, [ip, #1]!
 8041b64:	f85e 0f04 	ldr.w	r0, [lr, #4]!
 8041b68:	441e      	add	r6, r3
					for (u = 0; u < ulen; ++u) {
 8041b6a:	3201      	adds	r2, #1
						x[u][b * n_char + p[b][u-1]] = 1.0f;
 8041b6c:	eb00 0086 	add.w	r0, r0, r6, lsl #2
					for (u = 0; u < ulen; ++u) {
 8041b70:	4593      	cmp	fp, r2
						x[u][b * n_char + p[b][u-1]] = 1.0f;
 8041b72:	ed80 8a00 	vstr	s16, [r0]
					for (u = 0; u < ulen; ++u) {
 8041b76:	dcf3      	bgt.n	8041b60 <tg_train+0x3dc>
 8041b78:	4295      	cmp	r5, r2
 8041b7a:	dd88      	ble.n	8041a8e <tg_train+0x30a>
 8041b7c:	9802      	ldr	r0, [sp, #8]
 8041b7e:	f102 4680 	add.w	r6, r2, #1073741824	@ 0x40000000
 8041b82:	3e01      	subs	r6, #1
 8041b84:	eb00 0c86 	add.w	ip, r0, r6, lsl #2
 8041b88:	9803      	ldr	r0, [sp, #12]
 8041b8a:	3a01      	subs	r2, #1
 8041b8c:	443a      	add	r2, r7
 8041b8e:	eb00 0686 	add.w	r6, r0, r6, lsl #2
 8041b92:	f1c7 0e01 	rsb	lr, r7, #1
 8041b96:	f8cd 9010 	str.w	r9, [sp, #16]
						x[u][b * n_char + p[b][u-1]] = 1.0f;
 8041b9a:	f892 9000 	ldrb.w	r9, [r2]
 8041b9e:	f85c 0f04 	ldr.w	r0, [ip, #4]!
 8041ba2:	4499      	add	r9, r3
 8041ba4:	eb00 0089 	add.w	r0, r0, r9, lsl #2
 8041ba8:	ed80 8a00 	vstr	s16, [r0]
							y[u][b * n_char + p[b][u]] = 1.0f;
 8041bac:	f812 9f01 	ldrb.w	r9, [r2, #1]!
 8041bb0:	f856 0f04 	ldr.w	r0, [r6, #4]!
 8041bb4:	4499      	add	r9, r3
 8041bb6:	eb00 0089 	add.w	r0, r0, r9, lsl #2
 8041bba:	ed80 8a00 	vstr	s16, [r0]
					for (u = 0; u < ulen; ++u) {
 8041bbe:	eb0e 0002 	add.w	r0, lr, r2
 8041bc2:	4285      	cmp	r5, r0
 8041bc4:	dce9      	bgt.n	8041b9a <tg_train+0x416>
 8041bc6:	f8dd 9010 	ldr.w	r9, [sp, #16]
					p[b] += ulen;
 8041bca:	442f      	add	r7, r5
				for (b = 0; b < mbs; ++b) {
 8041bcc:	45c1      	cmp	r9, r8
					p[b] += ulen;
 8041bce:	f8c8 7000 	str.w	r7, [r8]
				for (b = 0; b < mbs; ++b) {
 8041bd2:	4453      	add	r3, sl
 8041bd4:	f47f af3b 	bne.w	8041a4e <tg_train+0x2ca>
 8041bd8:	e75f      	b.n	8041a9a <tg_train+0x316>
 8041bda:	2204      	movs	r2, #4
 8041bdc:	e707      	b.n	80419ee <tg_train+0x26a>
 8041bde:	bf00      	nop
 8041be0:	0804e398 	.word	0x0804e398

08041be4 <model_gen>:

kann_t *model_gen(int model, int n_char, int n_h_layers, int n_h_neurons, float h_dropout, int use_norm)
{
 8041be4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8041be8:	9d06      	ldr	r5, [sp, #24]
 8041bea:	4617      	mov	r7, r2
	int i, flag = use_norm? KANN_RNN_NORM : 0;
 8041bec:	3d00      	subs	r5, #0
	kad_node_t *t, *t1;
	t = kann_layer_input(n_char), t->ext_label = 100;
 8041bee:	4608      	mov	r0, r1
	int i, flag = use_norm? KANN_RNN_NORM : 0;
 8041bf0:	bf18      	it	ne
 8041bf2:	2501      	movne	r5, #1
{
 8041bf4:	4698      	mov	r8, r3
 8041bf6:	460e      	mov	r6, r1
	t = kann_layer_input(n_char), t->ext_label = 100;
 8041bf8:	f000 fdb0 	bl	804275c <kann_layer_input>
 8041bfc:	2364      	movs	r3, #100	@ 0x64
	for (i = 0; i < n_h_layers; ++i) {
 8041bfe:	2f00      	cmp	r7, #0
	t = kann_layer_input(n_char), t->ext_label = 100;
 8041c00:	6203      	str	r3, [r0, #32]
	for (i = 0; i < n_h_layers; ++i) {
 8041c02:	dd08      	ble.n	8041c16 <model_gen+0x32>
 8041c04:	2400      	movs	r4, #0
 8041c06:	006d      	lsls	r5, r5, #1
		//if (model == 0) t = kann_layer_rnn(t, n_h_neurons, flag);
		//else if (model == 1) t = kann_layer_lstm(t, n_h_neurons, flag);
		//else if (model == 2) t = kann_layer_gru(t, n_h_neurons, flag);
		t = kann_layer_lstm(t, n_h_neurons, flag);
 8041c08:	462a      	mov	r2, r5
 8041c0a:	4641      	mov	r1, r8
	for (i = 0; i < n_h_layers; ++i) {
 8041c0c:	3401      	adds	r4, #1
		t = kann_layer_lstm(t, n_h_neurons, flag);
 8041c0e:	f000 fdeb 	bl	80427e8 <kann_layer_lstm>
	for (i = 0; i < n_h_layers; ++i) {
 8041c12:	42a7      	cmp	r7, r4
 8041c14:	d1f8      	bne.n	8041c08 <model_gen+0x24>
		//t = kann_layer_dropout(t, h_dropout);
	}
	t = kann_layer_dense(t, n_char);
 8041c16:	4631      	mov	r1, r6
 8041c18:	f000 fdac 	bl	8042774 <kann_layer_dense>
	t1 = kann_new_scalar(KAD_CONST, 1.0f), t1->ext_label = -1; // -1 is for backward compatibility
 8041c1c:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
	t = kann_layer_dense(t, n_char);
 8041c20:	4604      	mov	r4, r0
	t1 = kann_new_scalar(KAD_CONST, 1.0f), t1->ext_label = -1; // -1 is for backward compatibility
 8041c22:	2002      	movs	r0, #2
 8041c24:	f000 fd94 	bl	8042750 <kann_new_scalar>
 8041c28:	f04f 33ff 	mov.w	r3, #4294967295
 8041c2c:	4601      	mov	r1, r0
	t = kad_mul(t, t1); // t1 is the inverse of temperature
 8041c2e:	4620      	mov	r0, r4
	t1 = kann_new_scalar(KAD_CONST, 1.0f), t1->ext_label = -1; // -1 is for backward compatibility
 8041c30:	620b      	str	r3, [r1, #32]
	t = kad_mul(t, t1); // t1 is the inverse of temperature
 8041c32:	f008 f847 	bl	8049cc4 <kad_mul>
	t = kad_softmax(t), t->ext_flag |= KANN_F_OUT;
 8041c36:	f008 f9cb 	bl	8049fd0 <kad_softmax>
 8041c3a:	4604      	mov	r4, r0
	t1 = kad_feed(2, 1, n_char), t1->ext_flag |= KANN_F_TRUTH;
 8041c3c:	2002      	movs	r0, #2
	t = kad_softmax(t), t->ext_flag |= KANN_F_OUT;
 8041c3e:	6a63      	ldr	r3, [r4, #36]	@ 0x24
	t1 = kad_feed(2, 1, n_char), t1->ext_flag |= KANN_F_TRUTH;
 8041c40:	4632      	mov	r2, r6
	t = kad_softmax(t), t->ext_flag |= KANN_F_OUT;
 8041c42:	4303      	orrs	r3, r0
 8041c44:	6263      	str	r3, [r4, #36]	@ 0x24
	t1 = kad_feed(2, 1, n_char), t1->ext_flag |= KANN_F_TRUTH;
 8041c46:	2101      	movs	r1, #1
 8041c48:	f007 ff92 	bl	8049b70 <kad_feed>
 8041c4c:	4601      	mov	r1, r0
 8041c4e:	6a4b      	ldr	r3, [r1, #36]	@ 0x24
	t = kad_ce_multi(t, t1), t->ext_flag |= KANN_F_COST;
 8041c50:	4620      	mov	r0, r4
	t1 = kad_feed(2, 1, n_char), t1->ext_flag |= KANN_F_TRUTH;
 8041c52:	f043 0304 	orr.w	r3, r3, #4
 8041c56:	624b      	str	r3, [r1, #36]	@ 0x24
	t = kad_ce_multi(t, t1), t->ext_flag |= KANN_F_COST;
 8041c58:	f008 f8d4 	bl	8049e04 <kad_ce_multi>
	return kann_new(t, 0);
}
 8041c5c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	t = kad_ce_multi(t, t1), t->ext_flag |= KANN_F_COST;
 8041c60:	6a42      	ldr	r2, [r0, #36]	@ 0x24
	return kann_new(t, 0);
 8041c62:	2100      	movs	r1, #0
	t = kad_ce_multi(t, t1), t->ext_flag |= KANN_F_COST;
 8041c64:	f042 0208 	orr.w	r2, r2, #8
 8041c68:	6242      	str	r2, [r0, #36]	@ 0x24
	return kann_new(t, 0);
 8041c6a:	f000 b8ef 	b.w	8041e4c <kann_new>
 8041c6e:	bf00      	nop

08041c70 <kad_ext_collate>:
/******************************************
 *** @@BASIC: fundamental KANN routines ***
 ******************************************/

static void kad_ext_collate(int n, kad_node_t **a, float **_x, float **_g, float **_c)
{
 8041c70:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8041c74:	b085      	sub	sp, #20
 8041c76:	4617      	mov	r7, r2
 8041c78:	4698      	mov	r8, r3
 8041c7a:	4606      	mov	r6, r0
 8041c7c:	460d      	mov	r5, r1
 8041c7e:	f8dd b038 	ldr.w	fp, [sp, #56]	@ 0x38
	int i, j, k, l, n_var;
	float *x, *g, *c;
	n_var = kad_size_var(n, a);
 8041c82:	f008 fc37 	bl	804a4f4 <kad_size_var>
	x = *_x = (float*)realloc(*_x, n_var * sizeof(float));
 8041c86:	0084      	lsls	r4, r0, #2
 8041c88:	4621      	mov	r1, r4
 8041c8a:	6838      	ldr	r0, [r7, #0]
 8041c8c:	f009 fed0 	bl	804ba30 <realloc>
 8041c90:	6038      	str	r0, [r7, #0]
	g = *_g = (float*)realloc(*_g, n_var * sizeof(float));
 8041c92:	4621      	mov	r1, r4
	x = *_x = (float*)realloc(*_x, n_var * sizeof(float));
 8041c94:	9001      	str	r0, [sp, #4]
	g = *_g = (float*)realloc(*_g, n_var * sizeof(float));
 8041c96:	f8d8 0000 	ldr.w	r0, [r8]
 8041c9a:	f009 fec9 	bl	804ba30 <realloc>
 8041c9e:	4607      	mov	r7, r0
	c = *_c = (float*)realloc(*_c, kad_size_const(n, a) * sizeof(float));
 8041ca0:	4629      	mov	r1, r5
	g = *_g = (float*)realloc(*_g, n_var * sizeof(float));
 8041ca2:	f8c8 7000 	str.w	r7, [r8]
	c = *_c = (float*)realloc(*_c, kad_size_const(n, a) * sizeof(float));
 8041ca6:	4630      	mov	r0, r6
 8041ca8:	f8db 8000 	ldr.w	r8, [fp]
 8041cac:	f008 fc5c 	bl	804a568 <kad_size_const>
 8041cb0:	4601      	mov	r1, r0
 8041cb2:	4640      	mov	r0, r8
 8041cb4:	0089      	lsls	r1, r1, #2
 8041cb6:	f009 febb 	bl	804ba30 <realloc>
 8041cba:	4682      	mov	sl, r0
	memset(g, 0, n_var * sizeof(float));
 8041cbc:	4622      	mov	r2, r4
 8041cbe:	2100      	movs	r1, #0
 8041cc0:	4638      	mov	r0, r7
	c = *_c = (float*)realloc(*_c, kad_size_const(n, a) * sizeof(float));
 8041cc2:	f8cb a000 	str.w	sl, [fp]
	memset(g, 0, n_var * sizeof(float));
 8041cc6:	f00a f8b5 	bl	804be34 <memset>
	for (i = j = k = 0; i < n; ++i) {
 8041cca:	2e00      	cmp	r6, #0
 8041ccc:	dd3e      	ble.n	8041d4c <kad_ext_collate+0xdc>
 8041cce:	f04f 0900 	mov.w	r9, #0
 8041cd2:	3d04      	subs	r5, #4
 8041cd4:	46c8      	mov	r8, r9
 8041cd6:	e9cd 7a02 	strd	r7, sl, [sp, #8]
 8041cda:	eb05 0686 	add.w	r6, r5, r6, lsl #2
 8041cde:	e003      	b.n	8041ce8 <kad_ext_collate+0x78>
			memcpy(&x[j], v->x, l * sizeof(float));
			free(v->x);
			v->x = &x[j];
			v->g = &g[j];
			j += l;
		} else if (kad_is_const(v)) {
 8041ce0:	079b      	lsls	r3, r3, #30
 8041ce2:	d436      	bmi.n	8041d52 <kad_ext_collate+0xe2>
	for (i = j = k = 0; i < n; ++i) {
 8041ce4:	42ae      	cmp	r6, r5
 8041ce6:	d031      	beq.n	8041d4c <kad_ext_collate+0xdc>
		kad_node_t *v = a[i];
 8041ce8:	f855 4f04 	ldr.w	r4, [r5, #4]!
		if (kad_is_var(v)) {
 8041cec:	6863      	ldr	r3, [r4, #4]
 8041cee:	2b00      	cmp	r3, #0
 8041cf0:	d1f8      	bne.n	8041ce4 <kad_ext_collate+0x74>
 8041cf2:	7863      	ldrb	r3, [r4, #1]
 8041cf4:	07da      	lsls	r2, r3, #31
 8041cf6:	d5f3      	bpl.n	8041ce0 <kad_ext_collate+0x70>
extern char *kad_op_name[KAD_MAX_OP];

static inline int kad_len(const kad_node_t *p) /* calculate the size of p->x */
{
	int n = 1, i;
	for (i = 0; i < p->n_d; ++i) n *= p->d[i];
 8041cf8:	7823      	ldrb	r3, [r4, #0]
 8041cfa:	2b00      	cmp	r3, #0
 8041cfc:	d049      	beq.n	8041d92 <kad_ext_collate+0x122>
 8041cfe:	2b01      	cmp	r3, #1
 8041d00:	f8d4 b010 	ldr.w	fp, [r4, #16]
 8041d04:	d00c      	beq.n	8041d20 <kad_ext_collate+0xb0>
 8041d06:	6962      	ldr	r2, [r4, #20]
 8041d08:	2b02      	cmp	r3, #2
 8041d0a:	fb02 fb0b 	mul.w	fp, r2, fp
 8041d0e:	d007      	beq.n	8041d20 <kad_ext_collate+0xb0>
 8041d10:	69a2      	ldr	r2, [r4, #24]
 8041d12:	2b03      	cmp	r3, #3
 8041d14:	fb02 fb0b 	mul.w	fp, r2, fp
 8041d18:	bf1c      	itt	ne
 8041d1a:	69e3      	ldrne	r3, [r4, #28]
 8041d1c:	fb03 fb0b 	mulne.w	fp, r3, fp
			memcpy(&x[j], v->x, l * sizeof(float));
 8041d20:	ea4f 028b 	mov.w	r2, fp, lsl #2
 8041d24:	9b01      	ldr	r3, [sp, #4]
 8041d26:	6aa1      	ldr	r1, [r4, #40]	@ 0x28
 8041d28:	eb03 0788 	add.w	r7, r3, r8, lsl #2
 8041d2c:	4638      	mov	r0, r7
 8041d2e:	f00a f97e 	bl	804c02e <memcpy>
			free(v->x);
 8041d32:	6aa0      	ldr	r0, [r4, #40]	@ 0x28
 8041d34:	f009 fd98 	bl	804b868 <free>
			v->g = &g[j];
 8041d38:	9b02      	ldr	r3, [sp, #8]
			memcpy(&x[j], v->x, l * sizeof(float));
 8041d3a:	ea4f 0a88 	mov.w	sl, r8, lsl #2
			v->g = &g[j];
 8041d3e:	eb03 020a 	add.w	r2, r3, sl
	for (i = j = k = 0; i < n; ++i) {
 8041d42:	42ae      	cmp	r6, r5
			j += l;
 8041d44:	44d8      	add	r8, fp
			v->x = &x[j];
 8041d46:	62a7      	str	r7, [r4, #40]	@ 0x28
			v->g = &g[j];
 8041d48:	62e2      	str	r2, [r4, #44]	@ 0x2c
	for (i = j = k = 0; i < n; ++i) {
 8041d4a:	d1cd      	bne.n	8041ce8 <kad_ext_collate+0x78>
			free(v->x);
			v->x = &c[k];
			k += l;
		}
	}
}
 8041d4c:	b005      	add	sp, #20
 8041d4e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8041d52:	7822      	ldrb	r2, [r4, #0]
 8041d54:	b30a      	cbz	r2, 8041d9a <kad_ext_collate+0x12a>
 8041d56:	2a01      	cmp	r2, #1
 8041d58:	6923      	ldr	r3, [r4, #16]
 8041d5a:	d00b      	beq.n	8041d74 <kad_ext_collate+0x104>
 8041d5c:	6961      	ldr	r1, [r4, #20]
 8041d5e:	2a02      	cmp	r2, #2
 8041d60:	fb01 f303 	mul.w	r3, r1, r3
 8041d64:	d006      	beq.n	8041d74 <kad_ext_collate+0x104>
 8041d66:	69a1      	ldr	r1, [r4, #24]
 8041d68:	2a03      	cmp	r2, #3
 8041d6a:	fb01 f303 	mul.w	r3, r1, r3
 8041d6e:	bf1c      	itt	ne
 8041d70:	69e2      	ldrne	r2, [r4, #28]
 8041d72:	4353      	mulne	r3, r2
			memcpy(&c[k], v->x, l * sizeof(float));
 8041d74:	009a      	lsls	r2, r3, #2
 8041d76:	9903      	ldr	r1, [sp, #12]
 8041d78:	eb01 0b89 	add.w	fp, r1, r9, lsl #2
 8041d7c:	4658      	mov	r0, fp
 8041d7e:	6aa1      	ldr	r1, [r4, #40]	@ 0x28
			k += l;
 8041d80:	4499      	add	r9, r3
			memcpy(&c[k], v->x, l * sizeof(float));
 8041d82:	f00a f954 	bl	804c02e <memcpy>
			free(v->x);
 8041d86:	6aa0      	ldr	r0, [r4, #40]	@ 0x28
 8041d88:	f009 fd6e 	bl	804b868 <free>
			v->x = &c[k];
 8041d8c:	f8c4 b028 	str.w	fp, [r4, #40]	@ 0x28
			k += l;
 8041d90:	e7a8      	b.n	8041ce4 <kad_ext_collate+0x74>
 8041d92:	2204      	movs	r2, #4
	int n = 1, i;
 8041d94:	f04f 0b01 	mov.w	fp, #1
 8041d98:	e7c4      	b.n	8041d24 <kad_ext_collate+0xb4>
	for (i = 0; i < p->n_d; ++i) n *= p->d[i];
 8041d9a:	2204      	movs	r2, #4
	int n = 1, i;
 8041d9c:	2301      	movs	r3, #1
 8041d9e:	e7ea      	b.n	8041d76 <kad_ext_collate+0x106>

08041da0 <kann_new_leaf_array.constprop.0>:
 *** @@LAYER: layers and model generation ***
 **********************************************/

/********** General but more complex APIs **********/

kad_node_t *kann_new_leaf_array(int *offset, kad_node_p *par, uint8_t flag, float x0_01, int n_d, int32_t d[KAD_MAX_DIM])
 8041da0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
{
	int i, len, off = offset && par? *offset : -1;
 8041da4:	4605      	mov	r5, r0
kad_node_t *kann_new_leaf_array(int *offset, kad_node_p *par, uint8_t flag, float x0_01, int n_d, int32_t d[KAD_MAX_DIM])
 8041da6:	ed2d 8b02 	vpush	{d8}
 8041daa:	460e      	mov	r6, r1
 8041dac:	4690      	mov	r8, r2
 8041dae:	eeb0 8a40 	vmov.f32	s16, s0
	int i, len, off = offset && par? *offset : -1;
 8041db2:	b180      	cbz	r0, 8041dd6 <kann_new_leaf_array.constprop.0+0x36>
 8041db4:	b179      	cbz	r1, 8041dd6 <kann_new_leaf_array.constprop.0+0x36>
 8041db6:	f8d0 9000 	ldr.w	r9, [r0]
	kad_node_t *p;

	if (off >= 0 && par[off]) return par[(*offset)++];
 8041dba:	f1b9 0f00 	cmp.w	r9, #0
 8041dbe:	db0c      	blt.n	8041dda <kann_new_leaf_array.constprop.0+0x3a>
 8041dc0:	f851 4029 	ldr.w	r4, [r1, r9, lsl #2]
 8041dc4:	b14c      	cbz	r4, 8041dda <kann_new_leaf_array.constprop.0+0x3a>
 8041dc6:	f109 0301 	add.w	r3, r9, #1
 8041dca:	6003      	str	r3, [r0, #0]
		for (i = 0; i < len; ++i)
			p->x[i] = (float)(kad_drand_normal(0) * sdev_inv);
	}
	if (off >= 0) par[off] = p, ++(*offset);
	return p;
}
 8041dcc:	4620      	mov	r0, r4
 8041dce:	ecbd 8b02 	vpop	{d8}
 8041dd2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	int i, len, off = offset && par? *offset : -1;
 8041dd6:	f04f 39ff 	mov.w	r9, #4294967295
	p = (kad_node_t*)calloc(1, sizeof(kad_node_t));
 8041dda:	2140      	movs	r1, #64	@ 0x40
 8041ddc:	2001      	movs	r0, #1
 8041dde:	f009 fd1f 	bl	804b820 <calloc>
	p->n_d = n_d, p->flag = flag;
 8041de2:	2200      	movs	r2, #0
	p = (kad_node_t*)calloc(1, sizeof(kad_node_t));
 8041de4:	4604      	mov	r4, r0
	heapSize += 1 * sizeof(kad_node_t);
 8041de6:	4f0f      	ldr	r7, [pc, #60]	@ (8041e24 <kann_new_leaf_array.constprop.0+0x84>)
	p->x = (float*)calloc(len, sizeof(float));
 8041de8:	2104      	movs	r1, #4
	heapSize += 1 * sizeof(kad_node_t);
 8041dea:	683b      	ldr	r3, [r7, #0]
	p->x = (float*)calloc(len, sizeof(float));
 8041dec:	2001      	movs	r0, #1
	heapSize += 1 * sizeof(kad_node_t);
 8041dee:	3340      	adds	r3, #64	@ 0x40
	p->n_d = n_d, p->flag = flag;
 8041df0:	7022      	strb	r2, [r4, #0]
 8041df2:	f884 8001 	strb.w	r8, [r4, #1]
	heapSize += 1 * sizeof(kad_node_t);
 8041df6:	603b      	str	r3, [r7, #0]
	p->x = (float*)calloc(len, sizeof(float));
 8041df8:	f009 fd12 	bl	804b820 <calloc>
	heapSize += len*sizeof(float);
 8041dfc:	683b      	ldr	r3, [r7, #0]
	if (off >= 0) par[off] = p, ++(*offset);
 8041dfe:	f1b9 0f00 	cmp.w	r9, #0
	heapSize += len*sizeof(float);
 8041e02:	f103 0304 	add.w	r3, r3, #4
			p->x[i] = x0_01;
 8041e06:	ed80 8a00 	vstr	s16, [r0]
	heapSize += len*sizeof(float);
 8041e0a:	603b      	str	r3, [r7, #0]
	p->x = (float*)calloc(len, sizeof(float));
 8041e0c:	62a0      	str	r0, [r4, #40]	@ 0x28
	if (off >= 0) par[off] = p, ++(*offset);
 8041e0e:	dbdd      	blt.n	8041dcc <kann_new_leaf_array.constprop.0+0x2c>
}
 8041e10:	ecbd 8b02 	vpop	{d8}
	if (off >= 0) par[off] = p, ++(*offset);
 8041e14:	682b      	ldr	r3, [r5, #0]
}
 8041e16:	4620      	mov	r0, r4
	if (off >= 0) par[off] = p, ++(*offset);
 8041e18:	3301      	adds	r3, #1
 8041e1a:	f846 4029 	str.w	r4, [r6, r9, lsl #2]
 8041e1e:	602b      	str	r3, [r5, #0]
}
 8041e20:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8041e24:	20018acc 	.word	0x20018acc

08041e28 <kann_new_leaf.constprop.1>:
	return out;
}

/********** APIs without offset & par **********/

kad_node_t *kann_new_leaf(uint8_t flag, float x0_01, int n_d, ...)
 8041e28:	ee00 1a10 	vmov	s0, r1
{
	int32_t i, d[KAD_MAX_DIM];
	va_list ap;
	va_start(ap, n_d); for (i = 0; i < n_d; ++i) d[i] = va_arg(ap, int); va_end(ap);
	return kann_new_leaf_array(0, 0, flag, x0_01, n_d, d);
 8041e2c:	2100      	movs	r1, #0
kad_node_t *kann_new_leaf(uint8_t flag, float x0_01, int n_d, ...)
 8041e2e:	b40c      	push	{r2, r3}
 8041e30:	b500      	push	{lr}
 8041e32:	b087      	sub	sp, #28
 8041e34:	4602      	mov	r2, r0
	va_start(ap, n_d); for (i = 0; i < n_d; ++i) d[i] = va_arg(ap, int); va_end(ap);
 8041e36:	a809      	add	r0, sp, #36	@ 0x24
 8041e38:	9001      	str	r0, [sp, #4]
	return kann_new_leaf_array(0, 0, flag, x0_01, n_d, d);
 8041e3a:	ab02      	add	r3, sp, #8
 8041e3c:	4608      	mov	r0, r1
 8041e3e:	f7ff ffaf 	bl	8041da0 <kann_new_leaf_array.constprop.0>
}
 8041e42:	b007      	add	sp, #28
 8041e44:	f85d eb04 	ldr.w	lr, [sp], #4
 8041e48:	b002      	add	sp, #8
 8041e4a:	4770      	bx	lr

08041e4c <kann_new>:
{
 8041e4c:	b40e      	push	{r1, r2, r3}
 8041e4e:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8041e52:	b086      	sub	sp, #24
 8041e54:	9003      	str	r0, [sp, #12]
	if (cost->n_d != 0) return 0;
 8041e56:	7803      	ldrb	r3, [r0, #0]
{
 8041e58:	9f0d      	ldr	r7, [sp, #52]	@ 0x34
	if (cost->n_d != 0) return 0;
 8041e5a:	2b00      	cmp	r3, #0
 8041e5c:	d15c      	bne.n	8041f18 <kann_new+0xcc>
	roots = (kad_node_t**)malloc((n_roots + 1) * sizeof(kad_node_t*));
 8041e5e:	1cbe      	adds	r6, r7, #2
 8041e60:	00b6      	lsls	r6, r6, #2
	va_start(ap, n_rest);
 8041e62:	ab0e      	add	r3, sp, #56	@ 0x38
	roots = (kad_node_t**)malloc((n_roots + 1) * sizeof(kad_node_t*));
 8041e64:	4630      	mov	r0, r6
	va_start(ap, n_rest);
 8041e66:	9305      	str	r3, [sp, #20]
	roots = (kad_node_t**)malloc((n_roots + 1) * sizeof(kad_node_t*));
 8041e68:	f009 fcf6 	bl	804b858 <malloc>
	for (i = 0; i < n_rest; ++i)
 8041e6c:	2f00      	cmp	r7, #0
	roots = (kad_node_t**)malloc((n_roots + 1) * sizeof(kad_node_t*));
 8041e6e:	4605      	mov	r5, r0
	for (i = 0; i < n_rest; ++i)
 8041e70:	dd72      	ble.n	8041f58 <kann_new+0x10c>
		roots[i] = va_arg(ap, kad_node_t*);
 8041e72:	9b05      	ldr	r3, [sp, #20]
 8041e74:	f1a6 0408 	sub.w	r4, r6, #8
 8041e78:	1f02      	subs	r2, r0, #4
 8041e7a:	1918      	adds	r0, r3, r4
 8041e7c:	f853 1b04 	ldr.w	r1, [r3], #4
	for (i = 0; i < n_rest; ++i)
 8041e80:	4283      	cmp	r3, r0
		roots[i] = va_arg(ap, kad_node_t*);
 8041e82:	f842 1f04 	str.w	r1, [r2, #4]!
	for (i = 0; i < n_rest; ++i)
 8041e86:	d1f9      	bne.n	8041e7c <kann_new+0x30>
	roots[i++] = cost;
 8041e88:	442c      	add	r4, r5
 8041e8a:	9b03      	ldr	r3, [sp, #12]
	a = (kann_t*)calloc(1, sizeof(kann_t));
 8041e8c:	2118      	movs	r1, #24
	cost->ext_flag |= KANN_F_COST;
 8041e8e:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
	roots[i++] = cost;
 8041e90:	6023      	str	r3, [r4, #0]
	cost->ext_flag |= KANN_F_COST;
 8041e92:	f042 0208 	orr.w	r2, r2, #8
 8041e96:	625a      	str	r2, [r3, #36]	@ 0x24
	a = (kann_t*)calloc(1, sizeof(kann_t));
 8041e98:	2001      	movs	r0, #1
 8041e9a:	f009 fcc1 	bl	804b820 <calloc>
	heapSize += 1 * sizeof(kann_t);
 8041e9e:	492f      	ldr	r1, [pc, #188]	@ (8041f5c <kann_new+0x110>)
	int i, n_roots = 1 + n_rest, has_pivot = 0, has_recur = 0;
 8041ea0:	f107 0901 	add.w	r9, r7, #1
	heapSize += 1 * sizeof(kann_t);
 8041ea4:	680b      	ldr	r3, [r1, #0]
	a->v = kad_compile_array(&a->n, n_roots, roots);
 8041ea6:	462a      	mov	r2, r5
	heapSize += 1 * sizeof(kann_t);
 8041ea8:	3318      	adds	r3, #24
 8041eaa:	600b      	str	r3, [r1, #0]
	a->v = kad_compile_array(&a->n, n_roots, roots);
 8041eac:	4649      	mov	r1, r9
	a = (kann_t*)calloc(1, sizeof(kann_t));
 8041eae:	4604      	mov	r4, r0
	a->v = kad_compile_array(&a->n, n_roots, roots);
 8041eb0:	f008 f9e8 	bl	804a284 <kad_compile_array>
 8041eb4:	4601      	mov	r1, r0
	for (i = 0; i < a->n; ++i) {
 8041eb6:	6820      	ldr	r0, [r4, #0]
	a->v = kad_compile_array(&a->n, n_roots, roots);
 8041eb8:	6061      	str	r1, [r4, #4]
	for (i = 0; i < a->n; ++i) {
 8041eba:	2800      	cmp	r0, #0
 8041ebc:	dd1a      	ble.n	8041ef4 <kann_new+0xa8>
	int i, n_roots = 1 + n_rest, has_pivot = 0, has_recur = 0;
 8041ebe:	2200      	movs	r2, #0
 8041ec0:	4690      	mov	r8, r2
 8041ec2:	f1a1 0c04 	sub.w	ip, r1, #4
 8041ec6:	eb0c 0e80 	add.w	lr, ip, r0, lsl #2
		if (a->v[i]->pre) has_recur = 1;
 8041eca:	f85c 3f04 	ldr.w	r3, [ip, #4]!
 8041ece:	6bdf      	ldr	r7, [r3, #60]	@ 0x3c
 8041ed0:	2f00      	cmp	r7, #0
		if (kad_is_pivot(a->v[i])) has_pivot = 1;
 8041ed2:	685f      	ldr	r7, [r3, #4]
		if (a->v[i]->pre) has_recur = 1;
 8041ed4:	bf18      	it	ne
 8041ed6:	2201      	movne	r2, #1
		if (kad_is_pivot(a->v[i])) has_pivot = 1;
 8041ed8:	2f01      	cmp	r7, #1
 8041eda:	d105      	bne.n	8041ee8 <kann_new+0x9c>
 8041edc:	785b      	ldrb	r3, [r3, #1]
 8041ede:	f013 0f04 	tst.w	r3, #4
 8041ee2:	bf18      	it	ne
 8041ee4:	f04f 0801 	movne.w	r8, #1
	for (i = 0; i < a->n; ++i) {
 8041ee8:	45e6      	cmp	lr, ip
 8041eea:	d1ee      	bne.n	8041eca <kann_new+0x7e>
	if (has_recur && !has_pivot) { /* an RNN that doesn't have a pivot; then add a pivot on top of cost and recompile */
 8041eec:	b112      	cbz	r2, 8041ef4 <kann_new+0xa8>
 8041eee:	f1b8 0f00 	cmp.w	r8, #0
 8041ef2:	d013      	beq.n	8041f1c <kann_new+0xd0>
	kad_ext_collate(a->n, a->v, &a->x, &a->g, &a->c);
 8041ef4:	f104 0310 	add.w	r3, r4, #16
 8041ef8:	9300      	str	r3, [sp, #0]
 8041efa:	f104 0208 	add.w	r2, r4, #8
 8041efe:	f104 030c 	add.w	r3, r4, #12
 8041f02:	f7ff feb5 	bl	8041c70 <kad_ext_collate>
	free(roots);
 8041f06:	4628      	mov	r0, r5
 8041f08:	f009 fcae 	bl	804b868 <free>
}
 8041f0c:	4620      	mov	r0, r4
 8041f0e:	b006      	add	sp, #24
 8041f10:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8041f14:	b003      	add	sp, #12
 8041f16:	4770      	bx	lr
	if (cost->n_d != 0) return 0;
 8041f18:	2400      	movs	r4, #0
 8041f1a:	e7f7      	b.n	8041f0c <kann_new+0xc0>
		cost->ext_flag &= ~KANN_F_COST;
 8041f1c:	9a03      	ldr	r2, [sp, #12]
		roots[n_roots-1] = cost = kad_avg(1, &cost), cost->ext_flag |= KANN_F_COST;
 8041f1e:	a903      	add	r1, sp, #12
		cost->ext_flag &= ~KANN_F_COST;
 8041f20:	6a53      	ldr	r3, [r2, #36]	@ 0x24
		roots[n_roots-1] = cost = kad_avg(1, &cost), cost->ext_flag |= KANN_F_COST;
 8041f22:	2001      	movs	r0, #1
		cost->ext_flag &= ~KANN_F_COST;
 8041f24:	f023 0308 	bic.w	r3, r3, #8
 8041f28:	6253      	str	r3, [r2, #36]	@ 0x24
		roots[n_roots-1] = cost = kad_avg(1, &cost), cost->ext_flag |= KANN_F_COST;
 8041f2a:	f008 f8e7 	bl	804a0fc <kad_avg>
 8041f2e:	4603      	mov	r3, r0
 8041f30:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 8041f32:	442e      	add	r6, r5
 8041f34:	f042 0208 	orr.w	r2, r2, #8
		free(a->v);
 8041f38:	6860      	ldr	r0, [r4, #4]
		roots[n_roots-1] = cost = kad_avg(1, &cost), cost->ext_flag |= KANN_F_COST;
 8041f3a:	f846 3c08 	str.w	r3, [r6, #-8]
 8041f3e:	625a      	str	r2, [r3, #36]	@ 0x24
 8041f40:	9303      	str	r3, [sp, #12]
		free(a->v);
 8041f42:	f009 fc91 	bl	804b868 <free>
		a->v = kad_compile_array(&a->n, n_roots, roots);
 8041f46:	4649      	mov	r1, r9
 8041f48:	462a      	mov	r2, r5
 8041f4a:	4620      	mov	r0, r4
 8041f4c:	f008 f99a 	bl	804a284 <kad_compile_array>
 8041f50:	4601      	mov	r1, r0
	kad_ext_collate(a->n, a->v, &a->x, &a->g, &a->c);
 8041f52:	6820      	ldr	r0, [r4, #0]
		a->v = kad_compile_array(&a->n, n_roots, roots);
 8041f54:	6061      	str	r1, [r4, #4]
 8041f56:	e7cd      	b.n	8041ef4 <kann_new+0xa8>
	for (i = 0; i < n_rest; ++i)
 8041f58:	4604      	mov	r4, r0
 8041f5a:	e796      	b.n	8041e8a <kann_new+0x3e>
 8041f5c:	20018acc 	.word	0x20018acc

08041f60 <kann_unroll>:
{
 8041f60:	b40f      	push	{r0, r1, r2, r3}
 8041f62:	b5f0      	push	{r4, r5, r6, r7, lr}
 8041f64:	b083      	sub	sp, #12
 8041f66:	af08      	add	r7, sp, #32
 8041f68:	f857 5b04 	ldr.w	r5, [r7], #4
	n_pivots = kad_n_pivots(a->n, a->v);
 8041f6c:	e9d5 0100 	ldrd	r0, r1, [r5]
 8041f70:	f008 fc10 	bl	804a794 <kad_n_pivots>
	len = (int*)calloc(n_pivots, sizeof(int));
 8041f74:	2104      	movs	r1, #4
	n_pivots = kad_n_pivots(a->n, a->v);
 8041f76:	4604      	mov	r4, r0
	len = (int*)calloc(n_pivots, sizeof(int));
 8041f78:	f009 fc52 	bl	804b820 <calloc>
	for (i = 0; i < n_pivots; ++i) len[i] = va_arg(ap, int);
 8041f7c:	2c00      	cmp	r4, #0
	len = (int*)calloc(n_pivots, sizeof(int));
 8041f7e:	4606      	mov	r6, r0
	va_start(ap, a);
 8041f80:	9701      	str	r7, [sp, #4]
	for (i = 0; i < n_pivots; ++i) len[i] = va_arg(ap, int);
 8041f82:	dd03      	ble.n	8041f8c <kann_unroll+0x2c>
 8041f84:	4639      	mov	r1, r7
 8041f86:	00a2      	lsls	r2, r4, #2
 8041f88:	f00a f851 	bl	804c02e <memcpy>
	b = (kann_t*)calloc(1, sizeof(kann_t));
 8041f8c:	2118      	movs	r1, #24
 8041f8e:	2001      	movs	r0, #1
 8041f90:	f009 fc46 	bl	804b820 <calloc>
 8041f94:	4604      	mov	r4, r0
	b->v = kad_unroll(a->n, a->v, &b->n, len);
 8041f96:	e9d5 0100 	ldrd	r0, r1, [r5]
	heapSize += 1 * sizeof(kann_t);
 8041f9a:	4a0d      	ldr	r2, [pc, #52]	@ (8041fd0 <kann_unroll+0x70>)
	b->x = a->x, b->g = a->g, b->c = a->c; /* these arrays are shared */
 8041f9c:	f8d5 c008 	ldr.w	ip, [r5, #8]
	heapSize += 1 * sizeof(kann_t);
 8041fa0:	6813      	ldr	r3, [r2, #0]
 8041fa2:	3318      	adds	r3, #24
 8041fa4:	6013      	str	r3, [r2, #0]
	b->x = a->x, b->g = a->g, b->c = a->c; /* these arrays are shared */
 8041fa6:	e9d5 7203 	ldrd	r7, r2, [r5, #12]
	b->v = kad_unroll(a->n, a->v, &b->n, len);
 8041faa:	4633      	mov	r3, r6
	b->x = a->x, b->g = a->g, b->c = a->c; /* these arrays are shared */
 8041fac:	e9c4 c702 	strd	ip, r7, [r4, #8]
 8041fb0:	6122      	str	r2, [r4, #16]
	b->v = kad_unroll(a->n, a->v, &b->n, len);
 8041fb2:	4622      	mov	r2, r4
 8041fb4:	f008 fcbc 	bl	804a930 <kad_unroll>
 8041fb8:	4603      	mov	r3, r0
	free(len);
 8041fba:	4630      	mov	r0, r6
	b->v = kad_unroll(a->n, a->v, &b->n, len);
 8041fbc:	6063      	str	r3, [r4, #4]
	free(len);
 8041fbe:	f009 fc53 	bl	804b868 <free>
}
 8041fc2:	4620      	mov	r0, r4
 8041fc4:	b003      	add	sp, #12
 8041fc6:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
 8041fca:	b004      	add	sp, #16
 8041fcc:	4770      	bx	lr
 8041fce:	bf00      	nop
 8041fd0:	20018acc 	.word	0x20018acc

08041fd4 <kann_delete_unrolled>:
{
 8041fd4:	b510      	push	{r4, lr}
	if (a && a->mt) kann_mt(a, 0, 0);
 8041fd6:	4604      	mov	r4, r0
 8041fd8:	b120      	cbz	r0, 8041fe4 <kann_delete_unrolled+0x10>
	if (a && a->v) kad_delete(a->n, a->v);
 8041fda:	6841      	ldr	r1, [r0, #4]
 8041fdc:	b111      	cbz	r1, 8041fe4 <kann_delete_unrolled+0x10>
 8041fde:	6800      	ldr	r0, [r0, #0]
 8041fe0:	f008 fa60 	bl	804a4a4 <kad_delete>
	free(a);
 8041fe4:	4620      	mov	r0, r4
}
 8041fe6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	free(a);
 8041fea:	f009 bc3d 	b.w	804b868 <free>
 8041fee:	bf00      	nop

08041ff0 <kann_find>:
{
 8041ff0:	b5f0      	push	{r4, r5, r6, r7, lr}
	for (i = k = 0; i < a->n; ++i)
 8041ff2:	6804      	ldr	r4, [r0, #0]
 8041ff4:	2c00      	cmp	r4, #0
 8041ff6:	dd51      	ble.n	804209c <kann_find+0xac>
 8041ff8:	4603      	mov	r3, r0
 8041ffa:	b319      	cbz	r1, 8042044 <kann_find+0x54>
 8041ffc:	2a00      	cmp	r2, #0
 8041ffe:	d03b      	beq.n	8042078 <kann_find+0x88>
		if (chk_flg(a->v[i]->ext_flag, ext_flag) && chk_lbl(a->v[i]->ext_label, ext_label))
 8042000:	f04f 0e00 	mov.w	lr, #0
 8042004:	6846      	ldr	r6, [r0, #4]
	for (i = k = 0; i < a->n; ++i)
 8042006:	46f4      	mov	ip, lr
	int i, k, r = -1;
 8042008:	f04f 30ff 	mov.w	r0, #4294967295
	for (i = k = 0; i < a->n; ++i)
 804200c:	4673      	mov	r3, lr
		if (chk_flg(a->v[i]->ext_flag, ext_flag) && chk_lbl(a->v[i]->ext_label, ext_label))
 804200e:	f856 500e 	ldr.w	r5, [r6, lr]
 8042012:	6a6f      	ldr	r7, [r5, #36]	@ 0x24
 8042014:	4239      	tst	r1, r7
 8042016:	d005      	beq.n	8042024 <kann_find+0x34>
 8042018:	6a2d      	ldr	r5, [r5, #32]
 804201a:	42aa      	cmp	r2, r5
 804201c:	d102      	bne.n	8042024 <kann_find+0x34>
			++k, r = i;
 804201e:	4618      	mov	r0, r3
 8042020:	f10c 0c01 	add.w	ip, ip, #1
	for (i = k = 0; i < a->n; ++i)
 8042024:	3301      	adds	r3, #1
 8042026:	429c      	cmp	r4, r3
 8042028:	f10e 0e04 	add.w	lr, lr, #4
 804202c:	d1ef      	bne.n	804200e <kann_find+0x1e>
	return k == 1? r : k == 0? -1 : -2;
 804202e:	f1bc 0f01 	cmp.w	ip, #1
 8042032:	d006      	beq.n	8042042 <kann_find+0x52>
 8042034:	f1bc 0f00 	cmp.w	ip, #0
 8042038:	bf14      	ite	ne
 804203a:	f06f 0001 	mvnne.w	r0, #1
 804203e:	f04f 30ff 	moveq.w	r0, #4294967295
}
 8042042:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8042044:	b192      	cbz	r2, 804206c <kann_find+0x7c>
 8042046:	685d      	ldr	r5, [r3, #4]
	for (i = k = 0; i < a->n; ++i)
 8042048:	468c      	mov	ip, r1
	int i, k, r = -1;
 804204a:	f04f 30ff 	mov.w	r0, #4294967295
	for (i = k = 0; i < a->n; ++i)
 804204e:	460b      	mov	r3, r1
		if (chk_flg(a->v[i]->ext_flag, ext_flag) && chk_lbl(a->v[i]->ext_label, ext_label))
 8042050:	f855 1023 	ldr.w	r1, [r5, r3, lsl #2]
 8042054:	6a09      	ldr	r1, [r1, #32]
 8042056:	428a      	cmp	r2, r1
			++k, r = i;
 8042058:	bf08      	it	eq
 804205a:	4618      	moveq	r0, r3
	for (i = k = 0; i < a->n; ++i)
 804205c:	f103 0301 	add.w	r3, r3, #1
			++k, r = i;
 8042060:	bf08      	it	eq
 8042062:	f10c 0c01 	addeq.w	ip, ip, #1
	for (i = k = 0; i < a->n; ++i)
 8042066:	429c      	cmp	r4, r3
 8042068:	d1f2      	bne.n	8042050 <kann_find+0x60>
 804206a:	e7e0      	b.n	804202e <kann_find+0x3e>
	return k == 1? r : k == 0? -1 : -2;
 804206c:	2c01      	cmp	r4, #1
 804206e:	bf14      	ite	ne
 8042070:	f06f 0001 	mvnne.w	r0, #1
 8042074:	2000      	moveq	r0, #0
}
 8042076:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8042078:	6845      	ldr	r5, [r0, #4]
	for (i = k = 0; i < a->n; ++i)
 804207a:	4694      	mov	ip, r2
	int i, k, r = -1;
 804207c:	f04f 30ff 	mov.w	r0, #4294967295
		if (chk_flg(a->v[i]->ext_flag, ext_flag) && chk_lbl(a->v[i]->ext_label, ext_label))
 8042080:	f855 3022 	ldr.w	r3, [r5, r2, lsl #2]
 8042084:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8042086:	4219      	tst	r1, r3
			++k, r = i;
 8042088:	bf18      	it	ne
 804208a:	4610      	movne	r0, r2
	for (i = k = 0; i < a->n; ++i)
 804208c:	f102 0201 	add.w	r2, r2, #1
			++k, r = i;
 8042090:	bf18      	it	ne
 8042092:	f10c 0c01 	addne.w	ip, ip, #1
	for (i = k = 0; i < a->n; ++i)
 8042096:	42a2      	cmp	r2, r4
 8042098:	d1f2      	bne.n	8042080 <kann_find+0x90>
 804209a:	e7c8      	b.n	804202e <kann_find+0x3e>
	return k == 1? r : k == 0? -1 : -2;
 804209c:	f04f 30ff 	mov.w	r0, #4294967295
}
 80420a0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80420a2:	bf00      	nop

080420a4 <kann_feed_bind>:
	if (x == 0) return 0;
 80420a4:	2b00      	cmp	r3, #0
 80420a6:	d062      	beq.n	804216e <kann_feed_bind+0xca>
{
 80420a8:	b570      	push	{r4, r5, r6, lr}
	for (i = k = 0; i < a->n; ++i)
 80420aa:	6805      	ldr	r5, [r0, #0]
 80420ac:	2d00      	cmp	r5, #0
 80420ae:	dd60      	ble.n	8042172 <kann_feed_bind+0xce>
		if (kad_is_feed(a->v[i]) && chk_flg(a->v[i]->ext_flag, ext_flag) && chk_lbl(a->v[i]->ext_label, ext_label))
 80420b0:	6844      	ldr	r4, [r0, #4]
 80420b2:	b1da      	cbz	r2, 80420ec <kann_feed_bind+0x48>
 80420b4:	b391      	cbz	r1, 804211c <kann_feed_bind+0x78>
	for (i = k = 0; i < a->n; ++i)
 80420b6:	2000      	movs	r0, #0
 80420b8:	f1a4 0c04 	sub.w	ip, r4, #4
 80420bc:	eb0c 0585 	add.w	r5, ip, r5, lsl #2
		if (kad_is_feed(a->v[i]) && chk_flg(a->v[i]->ext_flag, ext_flag) && chk_lbl(a->v[i]->ext_label, ext_label))
 80420c0:	f85c 4f04 	ldr.w	r4, [ip, #4]!
 80420c4:	6866      	ldr	r6, [r4, #4]
 80420c6:	b976      	cbnz	r6, 80420e6 <kann_feed_bind+0x42>
 80420c8:	f894 e001 	ldrb.w	lr, [r4, #1]
 80420cc:	f01e 0f03 	tst.w	lr, #3
 80420d0:	d109      	bne.n	80420e6 <kann_feed_bind+0x42>
 80420d2:	6a66      	ldr	r6, [r4, #36]	@ 0x24
 80420d4:	4231      	tst	r1, r6
 80420d6:	d006      	beq.n	80420e6 <kann_feed_bind+0x42>
 80420d8:	6a26      	ldr	r6, [r4, #32]
 80420da:	42b2      	cmp	r2, r6
 80420dc:	d103      	bne.n	80420e6 <kann_feed_bind+0x42>
			a->v[i]->x = x[k++];
 80420de:	f853 6020 	ldr.w	r6, [r3, r0, lsl #2]
 80420e2:	3001      	adds	r0, #1
 80420e4:	62a6      	str	r6, [r4, #40]	@ 0x28
	for (i = k = 0; i < a->n; ++i)
 80420e6:	4565      	cmp	r5, ip
 80420e8:	d1ea      	bne.n	80420c0 <kann_feed_bind+0x1c>
}
 80420ea:	bd70      	pop	{r4, r5, r6, pc}
 80420ec:	b369      	cbz	r1, 804214a <kann_feed_bind+0xa6>
	for (i = k = 0; i < a->n; ++i)
 80420ee:	4610      	mov	r0, r2
 80420f0:	1f22      	subs	r2, r4, #4
 80420f2:	eb02 0585 	add.w	r5, r2, r5, lsl #2
		if (kad_is_feed(a->v[i]) && chk_flg(a->v[i]->ext_flag, ext_flag) && chk_lbl(a->v[i]->ext_label, ext_label))
 80420f6:	f852 4f04 	ldr.w	r4, [r2, #4]!
 80420fa:	6866      	ldr	r6, [r4, #4]
 80420fc:	b95e      	cbnz	r6, 8042116 <kann_feed_bind+0x72>
 80420fe:	f894 c001 	ldrb.w	ip, [r4, #1]
 8042102:	f01c 0f03 	tst.w	ip, #3
 8042106:	d106      	bne.n	8042116 <kann_feed_bind+0x72>
 8042108:	6a66      	ldr	r6, [r4, #36]	@ 0x24
 804210a:	4231      	tst	r1, r6
 804210c:	d003      	beq.n	8042116 <kann_feed_bind+0x72>
			a->v[i]->x = x[k++];
 804210e:	f853 6020 	ldr.w	r6, [r3, r0, lsl #2]
 8042112:	3001      	adds	r0, #1
 8042114:	62a6      	str	r6, [r4, #40]	@ 0x28
	for (i = k = 0; i < a->n; ++i)
 8042116:	4295      	cmp	r5, r2
 8042118:	d1ed      	bne.n	80420f6 <kann_feed_bind+0x52>
}
 804211a:	bd70      	pop	{r4, r5, r6, pc}
	for (i = k = 0; i < a->n; ++i)
 804211c:	4608      	mov	r0, r1
 804211e:	1f21      	subs	r1, r4, #4
 8042120:	eb01 0585 	add.w	r5, r1, r5, lsl #2
		if (kad_is_feed(a->v[i]) && chk_flg(a->v[i]->ext_flag, ext_flag) && chk_lbl(a->v[i]->ext_label, ext_label))
 8042124:	f851 4f04 	ldr.w	r4, [r1, #4]!
 8042128:	6866      	ldr	r6, [r4, #4]
 804212a:	b95e      	cbnz	r6, 8042144 <kann_feed_bind+0xa0>
 804212c:	f894 c001 	ldrb.w	ip, [r4, #1]
 8042130:	f01c 0f03 	tst.w	ip, #3
 8042134:	d106      	bne.n	8042144 <kann_feed_bind+0xa0>
 8042136:	6a26      	ldr	r6, [r4, #32]
 8042138:	42b2      	cmp	r2, r6
 804213a:	d103      	bne.n	8042144 <kann_feed_bind+0xa0>
			a->v[i]->x = x[k++];
 804213c:	f853 6020 	ldr.w	r6, [r3, r0, lsl #2]
 8042140:	3001      	adds	r0, #1
 8042142:	62a6      	str	r6, [r4, #40]	@ 0x28
	for (i = k = 0; i < a->n; ++i)
 8042144:	428d      	cmp	r5, r1
 8042146:	d1ed      	bne.n	8042124 <kann_feed_bind+0x80>
}
 8042148:	bd70      	pop	{r4, r5, r6, pc}
	for (i = k = 0; i < a->n; ++i)
 804214a:	4608      	mov	r0, r1
 804214c:	1f22      	subs	r2, r4, #4
 804214e:	eb02 0585 	add.w	r5, r2, r5, lsl #2
		if (kad_is_feed(a->v[i]) && chk_flg(a->v[i]->ext_flag, ext_flag) && chk_lbl(a->v[i]->ext_label, ext_label))
 8042152:	f852 1f04 	ldr.w	r1, [r2, #4]!
 8042156:	684c      	ldr	r4, [r1, #4]
 8042158:	b934      	cbnz	r4, 8042168 <kann_feed_bind+0xc4>
 804215a:	784c      	ldrb	r4, [r1, #1]
 804215c:	07a4      	lsls	r4, r4, #30
 804215e:	d103      	bne.n	8042168 <kann_feed_bind+0xc4>
			a->v[i]->x = x[k++];
 8042160:	f853 4020 	ldr.w	r4, [r3, r0, lsl #2]
 8042164:	3001      	adds	r0, #1
 8042166:	628c      	str	r4, [r1, #40]	@ 0x28
	for (i = k = 0; i < a->n; ++i)
 8042168:	42aa      	cmp	r2, r5
 804216a:	d1f2      	bne.n	8042152 <kann_feed_bind+0xae>
}
 804216c:	bd70      	pop	{r4, r5, r6, pc}
	if (x == 0) return 0;
 804216e:	4618      	mov	r0, r3
}
 8042170:	4770      	bx	lr
	if (x == 0) return 0;
 8042172:	2000      	movs	r0, #0
}
 8042174:	bd70      	pop	{r4, r5, r6, pc}
 8042176:	bf00      	nop

08042178 <kann_feed_dim>:
{
 8042178:	b5f0      	push	{r4, r5, r6, r7, lr}
	for (i = k = 0; i < a->n; ++i)
 804217a:	6804      	ldr	r4, [r0, #0]
 804217c:	2c00      	cmp	r4, #0
 804217e:	dd42      	ble.n	8042206 <kann_feed_dim+0x8e>
 8042180:	4603      	mov	r3, r0
	int i, k, n = 0;
 8042182:	2000      	movs	r0, #0
	for (i = k = 0; i < a->n; ++i)
 8042184:	4605      	mov	r5, r0
		if (kad_is_feed(a->v[i]) && chk_flg(a->v[i]->ext_flag, ext_flag) && chk_lbl(a->v[i]->ext_label, ext_label))
 8042186:	685b      	ldr	r3, [r3, #4]
 8042188:	3b04      	subs	r3, #4
 804218a:	eb03 0c84 	add.w	ip, r3, r4, lsl #2
 804218e:	f853 4f04 	ldr.w	r4, [r3, #4]!
 8042192:	6866      	ldr	r6, [r4, #4]
 8042194:	b966      	cbnz	r6, 80421b0 <kann_feed_dim+0x38>
 8042196:	f894 e001 	ldrb.w	lr, [r4, #1]
 804219a:	f01e 0f03 	tst.w	lr, #3
 804219e:	d107      	bne.n	80421b0 <kann_feed_dim+0x38>
 80421a0:	b111      	cbz	r1, 80421a8 <kann_feed_dim+0x30>
 80421a2:	6a66      	ldr	r6, [r4, #36]	@ 0x24
 80421a4:	4231      	tst	r1, r6
 80421a6:	d003      	beq.n	80421b0 <kann_feed_dim+0x38>
 80421a8:	b16a      	cbz	r2, 80421c6 <kann_feed_dim+0x4e>
 80421aa:	6a26      	ldr	r6, [r4, #32]
 80421ac:	4296      	cmp	r6, r2
 80421ae:	d00a      	beq.n	80421c6 <kann_feed_dim+0x4e>
	for (i = k = 0; i < a->n; ++i)
 80421b0:	459c      	cmp	ip, r3
 80421b2:	d1ec      	bne.n	804218e <kann_feed_dim+0x16>
	return k == 1? n : k == 0? -1 : -2;
 80421b4:	2d01      	cmp	r5, #1
 80421b6:	d005      	beq.n	80421c4 <kann_feed_dim+0x4c>
 80421b8:	2d00      	cmp	r5, #0
 80421ba:	bf14      	ite	ne
 80421bc:	f06f 0001 	mvnne.w	r0, #1
 80421c0:	f04f 30ff 	moveq.w	r0, #4294967295
}
 80421c4:	bdf0      	pop	{r4, r5, r6, r7, pc}
			++k, n = a->v[i]->n_d > 1? kad_len(a->v[i]) / a->v[i]->d[0] : a->v[i]->n_d == 1? a->v[i]->d[0] : 1;
 80421c6:	f894 e000 	ldrb.w	lr, [r4]
 80421ca:	3501      	adds	r5, #1
 80421cc:	f1be 0f01 	cmp.w	lr, #1
 80421d0:	d805      	bhi.n	80421de <kann_feed_dim+0x66>
 80421d2:	bf14      	ite	ne
 80421d4:	2001      	movne	r0, #1
 80421d6:	6920      	ldreq	r0, [r4, #16]
	for (i = k = 0; i < a->n; ++i)
 80421d8:	459c      	cmp	ip, r3
 80421da:	d1d8      	bne.n	804218e <kann_feed_dim+0x16>
 80421dc:	e7ea      	b.n	80421b4 <kann_feed_dim+0x3c>
	for (i = 0; i < p->n_d; ++i) n *= p->d[i];
 80421de:	f1be 0f02 	cmp.w	lr, #2
 80421e2:	e9d4 6004 	ldrd	r6, r0, [r4, #16]
 80421e6:	fb06 f000 	mul.w	r0, r6, r0
 80421ea:	d007      	beq.n	80421fc <kann_feed_dim+0x84>
 80421ec:	69a7      	ldr	r7, [r4, #24]
 80421ee:	f1be 0f03 	cmp.w	lr, #3
 80421f2:	fb07 f000 	mul.w	r0, r7, r0
 80421f6:	bf1c      	itt	ne
 80421f8:	69e4      	ldrne	r4, [r4, #28]
 80421fa:	4360      	mulne	r0, r4
 80421fc:	459c      	cmp	ip, r3
			++k, n = a->v[i]->n_d > 1? kad_len(a->v[i]) / a->v[i]->d[0] : a->v[i]->n_d == 1? a->v[i]->d[0] : 1;
 80421fe:	fb90 f0f6 	sdiv	r0, r0, r6
	for (i = k = 0; i < a->n; ++i)
 8042202:	d1c4      	bne.n	804218e <kann_feed_dim+0x16>
 8042204:	e7d6      	b.n	80421b4 <kann_feed_dim+0x3c>
	return k == 1? n : k == 0? -1 : -2;
 8042206:	f04f 30ff 	mov.w	r0, #4294967295
}
 804220a:	bdf0      	pop	{r4, r5, r6, r7, pc}

0804220c <kann_rnn_start>:
{
 804220c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 804220e:	4607      	mov	r7, r0
	kann_set_batch_size(a, 1);
 8042210:	e9d0 0100 	ldrd	r0, r1, [r0]
 8042214:	2201      	movs	r2, #1
 8042216:	f007 ffcb 	bl	804a1b0 <kad_sync_dim>
	for (i = 0; i < a->n; ++i) {
 804221a:	683a      	ldr	r2, [r7, #0]
 804221c:	2a00      	cmp	r2, #0
 804221e:	dd44      	ble.n	80422aa <kann_rnn_start+0x9e>
 8042220:	2600      	movs	r6, #0
 8042222:	e020      	b.n	8042266 <kann_rnn_start+0x5a>
 8042224:	2b00      	cmp	r3, #0
 8042226:	d041      	beq.n	80422ac <kann_rnn_start+0xa0>
 8042228:	2b01      	cmp	r3, #1
 804222a:	6922      	ldr	r2, [r4, #16]
 804222c:	d00b      	beq.n	8042246 <kann_rnn_start+0x3a>
 804222e:	6960      	ldr	r0, [r4, #20]
 8042230:	2b02      	cmp	r3, #2
 8042232:	fb00 f202 	mul.w	r2, r0, r2
 8042236:	d006      	beq.n	8042246 <kann_rnn_start+0x3a>
 8042238:	69a0      	ldr	r0, [r4, #24]
 804223a:	2b03      	cmp	r3, #3
 804223c:	fb00 f202 	mul.w	r2, r0, r2
 8042240:	bf1c      	itt	ne
 8042242:	69e3      	ldrne	r3, [r4, #28]
 8042244:	435a      	mulne	r2, r3
			if (q->x) memcpy(p->x, q->x, kad_len(p) * sizeof(float));
 8042246:	0092      	lsls	r2, r2, #2
 8042248:	4660      	mov	r0, ip
 804224a:	f009 fef0 	bl	804c02e <memcpy>
			if (q->n_child > 0) free(q->x);
 804224e:	686b      	ldr	r3, [r5, #4]
 8042250:	2b00      	cmp	r3, #0
 8042252:	dd02      	ble.n	804225a <kann_rnn_start+0x4e>
 8042254:	6aa8      	ldr	r0, [r5, #40]	@ 0x28
 8042256:	f009 fb07 	bl	804b868 <free>
			q->x = p->x;
 804225a:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
	for (i = 0; i < a->n; ++i) {
 804225c:	683a      	ldr	r2, [r7, #0]
			q->x = p->x;
 804225e:	62ab      	str	r3, [r5, #40]	@ 0x28
	for (i = 0; i < a->n; ++i) {
 8042260:	3601      	adds	r6, #1
 8042262:	4296      	cmp	r6, r2
 8042264:	da21      	bge.n	80422aa <kann_rnn_start+0x9e>
		kad_node_t *p = a->v[i];
 8042266:	687b      	ldr	r3, [r7, #4]
 8042268:	f853 4026 	ldr.w	r4, [r3, r6, lsl #2]
		if (p->pre) { /* NB: BE CAREFUL of the interaction between kann_rnn_start() and kann_set_batch_size() */
 804226c:	6be5      	ldr	r5, [r4, #60]	@ 0x3c
 804226e:	2d00      	cmp	r5, #0
 8042270:	d0f6      	beq.n	8042260 <kann_rnn_start+0x54>
			if (q->x) memcpy(p->x, q->x, kad_len(p) * sizeof(float));
 8042272:	6aa9      	ldr	r1, [r5, #40]	@ 0x28
 8042274:	f8d4 c028 	ldr.w	ip, [r4, #40]	@ 0x28
 8042278:	7823      	ldrb	r3, [r4, #0]
 804227a:	2900      	cmp	r1, #0
 804227c:	d1d2      	bne.n	8042224 <kann_rnn_start+0x18>
 804227e:	b1bb      	cbz	r3, 80422b0 <kann_rnn_start+0xa4>
 8042280:	2b01      	cmp	r3, #1
 8042282:	6922      	ldr	r2, [r4, #16]
 8042284:	d00b      	beq.n	804229e <kann_rnn_start+0x92>
 8042286:	6961      	ldr	r1, [r4, #20]
 8042288:	2b02      	cmp	r3, #2
 804228a:	fb01 f202 	mul.w	r2, r1, r2
 804228e:	d006      	beq.n	804229e <kann_rnn_start+0x92>
 8042290:	69a1      	ldr	r1, [r4, #24]
 8042292:	2b03      	cmp	r3, #3
 8042294:	fb01 f202 	mul.w	r2, r1, r2
 8042298:	bf1c      	itt	ne
 804229a:	69e3      	ldrne	r3, [r4, #28]
 804229c:	435a      	mulne	r2, r3
			else memset(p->x, 0, kad_len(p) * sizeof(float));
 804229e:	0092      	lsls	r2, r2, #2
 80422a0:	2100      	movs	r1, #0
 80422a2:	4660      	mov	r0, ip
 80422a4:	f009 fdc6 	bl	804be34 <memset>
 80422a8:	e7d1      	b.n	804224e <kann_rnn_start+0x42>
}
 80422aa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80422ac:	2204      	movs	r2, #4
 80422ae:	e7cb      	b.n	8042248 <kann_rnn_start+0x3c>
 80422b0:	2204      	movs	r2, #4
 80422b2:	e7f5      	b.n	80422a0 <kann_rnn_start+0x94>

080422b4 <kann_rnn_end>:
{
 80422b4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	kad_ext_sync(a->n, a->v, a->x, a->g, a->c);
 80422b8:	e9d0 6500 	ldrd	r6, r5, [r0]
 80422bc:	e9d0 8c02 	ldrd	r8, ip, [r0, #8]
	for (i = j = k = 0; i < n; ++i) {
 80422c0:	2e00      	cmp	r6, #0
	kad_ext_sync(a->n, a->v, a->x, a->g, a->c);
 80422c2:	f8d0 e010 	ldr.w	lr, [r0, #16]
	for (i = j = k = 0; i < n; ++i) {
 80422c6:	dd6d      	ble.n	80423a4 <kann_rnn_end+0xf0>
 80422c8:	2400      	movs	r4, #0
 80422ca:	3d04      	subs	r5, #4
 80422cc:	462a      	mov	r2, r5
 80422ce:	4620      	mov	r0, r4
 80422d0:	eb05 0686 	add.w	r6, r5, r6, lsl #2
 80422d4:	e003      	b.n	80422de <kann_rnn_end+0x2a>
		} else if (kad_is_const(v)) {
 80422d6:	0789      	lsls	r1, r1, #30
 80422d8:	d466      	bmi.n	80423a8 <kann_rnn_end+0xf4>
	for (i = j = k = 0; i < n; ++i) {
 80422da:	4296      	cmp	r6, r2
 80422dc:	d028      	beq.n	8042330 <kann_rnn_end+0x7c>
		kad_node_t *v = a[i];
 80422de:	f852 3f04 	ldr.w	r3, [r2, #4]!
		if (kad_is_var(v)) {
 80422e2:	6859      	ldr	r1, [r3, #4]
 80422e4:	2900      	cmp	r1, #0
 80422e6:	d1f8      	bne.n	80422da <kann_rnn_end+0x26>
 80422e8:	7859      	ldrb	r1, [r3, #1]
 80422ea:	07cf      	lsls	r7, r1, #31
 80422ec:	d5f3      	bpl.n	80422d6 <kann_rnn_end+0x22>
			v->x = &x[j];
 80422ee:	eb08 0180 	add.w	r1, r8, r0, lsl #2
 80422f2:	f893 9000 	ldrb.w	r9, [r3]
 80422f6:	6299      	str	r1, [r3, #40]	@ 0x28
			v->g = &g[j];
 80422f8:	eb0c 0180 	add.w	r1, ip, r0, lsl #2
 80422fc:	62d9      	str	r1, [r3, #44]	@ 0x2c
 80422fe:	f1b9 0f00 	cmp.w	r9, #0
 8042302:	d07b      	beq.n	80423fc <kann_rnn_end+0x148>
 8042304:	f1b9 0f01 	cmp.w	r9, #1
 8042308:	6919      	ldr	r1, [r3, #16]
 804230a:	d00e      	beq.n	804232a <kann_rnn_end+0x76>
 804230c:	695f      	ldr	r7, [r3, #20]
 804230e:	f1b9 0f02 	cmp.w	r9, #2
 8042312:	fb07 f101 	mul.w	r1, r7, r1
 8042316:	d008      	beq.n	804232a <kann_rnn_end+0x76>
 8042318:	699f      	ldr	r7, [r3, #24]
 804231a:	f1b9 0f03 	cmp.w	r9, #3
 804231e:	fb07 f101 	mul.w	r1, r7, r1
 8042322:	d002      	beq.n	804232a <kann_rnn_end+0x76>
 8042324:	69db      	ldr	r3, [r3, #28]
 8042326:	fb03 f101 	mul.w	r1, r3, r1
			j += kad_len(v);
 804232a:	4408      	add	r0, r1
	for (i = j = k = 0; i < n; ++i) {
 804232c:	4296      	cmp	r6, r2
 804232e:	d1d6      	bne.n	80422de <kann_rnn_end+0x2a>
			heapSize += kad_len(a->v[i]->pre) * sizeof(float);
 8042330:	f8df 90dc 	ldr.w	r9, [pc, #220]	@ 8042410 <kann_rnn_end+0x15c>
 8042334:	e001      	b.n	804233a <kann_rnn_end+0x86>
	for (i = 0; i < a->n; ++i)
 8042336:	42b5      	cmp	r5, r6
 8042338:	d034      	beq.n	80423a4 <kann_rnn_end+0xf0>
		if (a->v[i]->pre && a->v[i]->pre->n_child > 0) {
 804233a:	f855 3f04 	ldr.w	r3, [r5, #4]!
 804233e:	6bdc      	ldr	r4, [r3, #60]	@ 0x3c
 8042340:	2c00      	cmp	r4, #0
 8042342:	d0f8      	beq.n	8042336 <kann_rnn_end+0x82>
 8042344:	6863      	ldr	r3, [r4, #4]
 8042346:	2b00      	cmp	r3, #0
 8042348:	ddf5      	ble.n	8042336 <kann_rnn_end+0x82>
 804234a:	f894 8000 	ldrb.w	r8, [r4]
 804234e:	f1b8 0f00 	cmp.w	r8, #0
 8042352:	d04c      	beq.n	80423ee <kann_rnn_end+0x13a>
 8042354:	f1b8 0f01 	cmp.w	r8, #1
 8042358:	6927      	ldr	r7, [r4, #16]
 804235a:	d042      	beq.n	80423e2 <kann_rnn_end+0x12e>
 804235c:	6963      	ldr	r3, [r4, #20]
 804235e:	f1b8 0f02 	cmp.w	r8, #2
 8042362:	fb03 f707 	mul.w	r7, r3, r7
 8042366:	d03c      	beq.n	80423e2 <kann_rnn_end+0x12e>
 8042368:	69a0      	ldr	r0, [r4, #24]
 804236a:	f1b8 0f03 	cmp.w	r8, #3
 804236e:	fb07 f000 	mul.w	r0, r7, r0
 8042372:	d046      	beq.n	8042402 <kann_rnn_end+0x14e>
 8042374:	69e3      	ldr	r3, [r4, #28]
			a->v[i]->pre->x = (float*)calloc(kad_len(a->v[i]->pre), sizeof(float));
 8042376:	2104      	movs	r1, #4
 8042378:	fb03 f000 	mul.w	r0, r3, r0
 804237c:	f009 fa50 	bl	804b820 <calloc>
 8042380:	69a3      	ldr	r3, [r4, #24]
 8042382:	f1b8 0f03 	cmp.w	r8, #3
 8042386:	fb03 f707 	mul.w	r7, r3, r7
 804238a:	bf18      	it	ne
 804238c:	69e3      	ldrne	r3, [r4, #28]
 804238e:	62a0      	str	r0, [r4, #40]	@ 0x28
 8042390:	bf18      	it	ne
 8042392:	435f      	mulne	r7, r3
			heapSize += kad_len(a->v[i]->pre) * sizeof(float);
 8042394:	00bf      	lsls	r7, r7, #2
 8042396:	f8d9 3000 	ldr.w	r3, [r9]
	for (i = 0; i < a->n; ++i)
 804239a:	42b5      	cmp	r5, r6
			heapSize += kad_len(a->v[i]->pre) * sizeof(float);
 804239c:	443b      	add	r3, r7
 804239e:	f8c9 3000 	str.w	r3, [r9]
	for (i = 0; i < a->n; ++i)
 80423a2:	d1ca      	bne.n	804233a <kann_rnn_end+0x86>
}
 80423a4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 80423a8:	f893 9000 	ldrb.w	r9, [r3]
			v->x = &c[k];
 80423ac:	eb0e 0184 	add.w	r1, lr, r4, lsl #2
 80423b0:	6299      	str	r1, [r3, #40]	@ 0x28
 80423b2:	f1b9 0f00 	cmp.w	r9, #0
 80423b6:	d028      	beq.n	804240a <kann_rnn_end+0x156>
 80423b8:	f1b9 0f01 	cmp.w	r9, #1
 80423bc:	6919      	ldr	r1, [r3, #16]
 80423be:	d00e      	beq.n	80423de <kann_rnn_end+0x12a>
 80423c0:	695f      	ldr	r7, [r3, #20]
 80423c2:	f1b9 0f02 	cmp.w	r9, #2
 80423c6:	fb07 f101 	mul.w	r1, r7, r1
 80423ca:	d008      	beq.n	80423de <kann_rnn_end+0x12a>
 80423cc:	699f      	ldr	r7, [r3, #24]
 80423ce:	f1b9 0f03 	cmp.w	r9, #3
 80423d2:	fb07 f101 	mul.w	r1, r7, r1
 80423d6:	d002      	beq.n	80423de <kann_rnn_end+0x12a>
 80423d8:	69db      	ldr	r3, [r3, #28]
 80423da:	fb03 f101 	mul.w	r1, r3, r1
			k += kad_len(v);
 80423de:	440c      	add	r4, r1
 80423e0:	e77b      	b.n	80422da <kann_rnn_end+0x26>
			a->v[i]->pre->x = (float*)calloc(kad_len(a->v[i]->pre), sizeof(float));
 80423e2:	2104      	movs	r1, #4
 80423e4:	4638      	mov	r0, r7
 80423e6:	f009 fa1b 	bl	804b820 <calloc>
 80423ea:	62a0      	str	r0, [r4, #40]	@ 0x28
 80423ec:	e7d2      	b.n	8042394 <kann_rnn_end+0xe0>
 80423ee:	2104      	movs	r1, #4
 80423f0:	2001      	movs	r0, #1
 80423f2:	f009 fa15 	bl	804b820 <calloc>
 80423f6:	2704      	movs	r7, #4
 80423f8:	62a0      	str	r0, [r4, #40]	@ 0x28
 80423fa:	e7cc      	b.n	8042396 <kann_rnn_end+0xe2>
	int n = 1, i;
 80423fc:	2101      	movs	r1, #1
			j += kad_len(v);
 80423fe:	4408      	add	r0, r1
 8042400:	e794      	b.n	804232c <kann_rnn_end+0x78>
			a->v[i]->pre->x = (float*)calloc(kad_len(a->v[i]->pre), sizeof(float));
 8042402:	2104      	movs	r1, #4
 8042404:	f009 fa0c 	bl	804b820 <calloc>
	for (i = 0; i < p->n_d; ++i) n *= p->d[i];
 8042408:	e7ba      	b.n	8042380 <kann_rnn_end+0xcc>
	int n = 1, i;
 804240a:	2101      	movs	r1, #1
			k += kad_len(v);
 804240c:	440c      	add	r4, r1
 804240e:	e764      	b.n	80422da <kann_rnn_end+0x26>
 8042410:	20018acc 	.word	0x20018acc

08042414 <kann_cost>:
float kann_cost(kann_t *a, int cost_label, int cal_grad) {
 8042414:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8042418:	4605      	mov	r5, r0
	for (i = k = 0; i < a->n; ++i)
 804241a:	6800      	ldr	r0, [r0, #0]
float kann_cost(kann_t *a, int cost_label, int cal_grad) {
 804241c:	ed2d 8b02 	vpush	{d8}
	for (i = k = 0; i < a->n; ++i)
 8042420:	2800      	cmp	r0, #0
 8042422:	dd1c      	ble.n	804245e <kann_cost+0x4a>
 8042424:	460b      	mov	r3, r1
 8042426:	4616      	mov	r6, r2
		if (chk_flg(a->v[i]->ext_flag, ext_flag) && chk_lbl(a->v[i]->ext_label, ext_label))
 8042428:	6869      	ldr	r1, [r5, #4]
 804242a:	b1f3      	cbz	r3, 804246a <kann_cost+0x56>
	for (i = k = 0; i < a->n; ++i)
 804242c:	f04f 0800 	mov.w	r8, #0
	int i, k, r = -1;
 8042430:	f04f 37ff 	mov.w	r7, #4294967295
	for (i = k = 0; i < a->n; ++i)
 8042434:	46c4      	mov	ip, r8
 8042436:	f1a1 0e04 	sub.w	lr, r1, #4
		if (chk_flg(a->v[i]->ext_flag, ext_flag) && chk_lbl(a->v[i]->ext_label, ext_label))
 804243a:	f85e 4f04 	ldr.w	r4, [lr, #4]!
 804243e:	6a62      	ldr	r2, [r4, #36]	@ 0x24
 8042440:	0712      	lsls	r2, r2, #28
 8042442:	d505      	bpl.n	8042450 <kann_cost+0x3c>
 8042444:	6a22      	ldr	r2, [r4, #32]
 8042446:	4293      	cmp	r3, r2
			++k, r = i;
 8042448:	bf04      	itt	eq
 804244a:	4667      	moveq	r7, ip
 804244c:	f108 0801 	addeq.w	r8, r8, #1
	for (i = k = 0; i < a->n; ++i)
 8042450:	f10c 0c01 	add.w	ip, ip, #1
 8042454:	4560      	cmp	r0, ip
 8042456:	d1f0      	bne.n	804243a <kann_cost+0x26>
	return k == 1? r : k == 0? -1 : -2;
 8042458:	f1b8 0f01 	cmp.w	r8, #1
 804245c:	d019      	beq.n	8042492 <kann_cost+0x7e>
	assert(i_cost >= 0);
 804245e:	21be      	movs	r1, #190	@ 0xbe
 8042460:	4b18      	ldr	r3, [pc, #96]	@ (80424c4 <kann_cost+0xb0>)
 8042462:	4a19      	ldr	r2, [pc, #100]	@ (80424c8 <kann_cost+0xb4>)
 8042464:	4819      	ldr	r0, [pc, #100]	@ (80424cc <kann_cost+0xb8>)
 8042466:	f009 f9bd 	bl	804b7e4 <__assert_func>
	for (i = k = 0; i < a->n; ++i)
 804246a:	4698      	mov	r8, r3
	int i, k, r = -1;
 804246c:	f04f 37ff 	mov.w	r7, #4294967295
 8042470:	1f0c      	subs	r4, r1, #4
		if (chk_flg(a->v[i]->ext_flag, ext_flag) && chk_lbl(a->v[i]->ext_label, ext_label))
 8042472:	f854 2f04 	ldr.w	r2, [r4, #4]!
 8042476:	6a52      	ldr	r2, [r2, #36]	@ 0x24
 8042478:	0712      	lsls	r2, r2, #28
			++k, r = i;
 804247a:	bf48      	it	mi
 804247c:	461f      	movmi	r7, r3
	for (i = k = 0; i < a->n; ++i)
 804247e:	f103 0301 	add.w	r3, r3, #1
			++k, r = i;
 8042482:	bf48      	it	mi
 8042484:	f108 0801 	addmi.w	r8, r8, #1
	for (i = k = 0; i < a->n; ++i)
 8042488:	4298      	cmp	r0, r3
 804248a:	d1f2      	bne.n	8042472 <kann_cost+0x5e>
	return k == 1? r : k == 0? -1 : -2;
 804248c:	f1b8 0f01 	cmp.w	r8, #1
 8042490:	d1e5      	bne.n	804245e <kann_cost+0x4a>
	assert(i_cost >= 0);
 8042492:	2f00      	cmp	r7, #0
 8042494:	dbe3      	blt.n	804245e <kann_cost+0x4a>
	cost = *kad_eval_at(a->n, a->v, i_cost);
 8042496:	463a      	mov	r2, r7
 8042498:	f008 f8a0 	bl	804a5dc <kad_eval_at>
 804249c:	ed90 8a00 	vldr	s16, [r0]
	if (cal_grad) kad_grad(a->n, a->v, i_cost);
 80424a0:	b92e      	cbnz	r6, 80424ae <kann_cost+0x9a>
}
 80424a2:	eeb0 0a48 	vmov.f32	s0, s16
 80424a6:	ecbd 8b02 	vpop	{d8}
 80424aa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (cal_grad) kad_grad(a->n, a->v, i_cost);
 80424ae:	463a      	mov	r2, r7
 80424b0:	e9d5 0100 	ldrd	r0, r1, [r5]
 80424b4:	f008 f8e0 	bl	804a678 <kad_grad>
}
 80424b8:	eeb0 0a48 	vmov.f32	s0, s16
 80424bc:	ecbd 8b02 	vpop	{d8}
 80424c0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80424c4:	0804e3a0 	.word	0x0804e3a0
 80424c8:	0804e3c4 	.word	0x0804e3c4
 80424cc:	0804e3ac 	.word	0x0804e3ac

080424d0 <kann_new_leaf_array>:
{
 80424d0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80424d4:	ed2d 8b02 	vpush	{d8}
	int i, len, off = offset && par? *offset : -1;
 80424d8:	4607      	mov	r7, r0
{
 80424da:	468a      	mov	sl, r1
 80424dc:	4616      	mov	r6, r2
 80424de:	eeb0 8a40 	vmov.f32	s16, s0
 80424e2:	4699      	mov	r9, r3
 80424e4:	b083      	sub	sp, #12
	int i, len, off = offset && par? *offset : -1;
 80424e6:	b188      	cbz	r0, 804250c <kann_new_leaf_array+0x3c>
 80424e8:	b181      	cbz	r1, 804250c <kann_new_leaf_array+0x3c>
 80424ea:	f8d0 b000 	ldr.w	fp, [r0]
	if (off >= 0 && par[off]) return par[(*offset)++];
 80424ee:	f1bb 0f00 	cmp.w	fp, #0
 80424f2:	db0d      	blt.n	8042510 <kann_new_leaf_array+0x40>
 80424f4:	f851 402b 	ldr.w	r4, [r1, fp, lsl #2]
 80424f8:	b154      	cbz	r4, 8042510 <kann_new_leaf_array+0x40>
 80424fa:	f10b 0301 	add.w	r3, fp, #1
 80424fe:	6003      	str	r3, [r0, #0]
}
 8042500:	4620      	mov	r0, r4
 8042502:	b003      	add	sp, #12
 8042504:	ecbd 8b02 	vpop	{d8}
 8042508:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	int i, len, off = offset && par? *offset : -1;
 804250c:	f04f 3bff 	mov.w	fp, #4294967295
	p = (kad_node_t*)calloc(1, sizeof(kad_node_t));
 8042510:	2140      	movs	r1, #64	@ 0x40
 8042512:	2001      	movs	r0, #1
 8042514:	f009 f984 	bl	804b820 <calloc>
	heapSize += 1 * sizeof(kad_node_t);
 8042518:	4d43      	ldr	r5, [pc, #268]	@ (8042628 <kann_new_leaf_array+0x158>)
	p->n_d = n_d, p->flag = flag;
 804251a:	fa5f f889 	uxtb.w	r8, r9
	heapSize += 1 * sizeof(kad_node_t);
 804251e:	682b      	ldr	r3, [r5, #0]
	p = (kad_node_t*)calloc(1, sizeof(kad_node_t));
 8042520:	4604      	mov	r4, r0
	heapSize += 1 * sizeof(kad_node_t);
 8042522:	3340      	adds	r3, #64	@ 0x40
	p->n_d = n_d, p->flag = flag;
 8042524:	7046      	strb	r6, [r0, #1]
 8042526:	f880 8000 	strb.w	r8, [r0]
	memcpy(p->d, d, n_d * sizeof(int32_t));
 804252a:	990e      	ldr	r1, [sp, #56]	@ 0x38
 804252c:	ea4f 0289 	mov.w	r2, r9, lsl #2
 8042530:	3010      	adds	r0, #16
	heapSize += 1 * sizeof(kad_node_t);
 8042532:	602b      	str	r3, [r5, #0]
	memcpy(p->d, d, n_d * sizeof(int32_t));
 8042534:	f009 fd7b 	bl	804c02e <memcpy>
	for (i = 0; i < p->n_d; ++i) n *= p->d[i];
 8042538:	f1b8 0f00 	cmp.w	r8, #0
 804253c:	d069      	beq.n	8042612 <kann_new_leaf_array+0x142>
 804253e:	f019 0ffe 	tst.w	r9, #254	@ 0xfe
 8042542:	6926      	ldr	r6, [r4, #16]
 8042544:	d00d      	beq.n	8042562 <kann_new_leaf_array+0x92>
 8042546:	6963      	ldr	r3, [r4, #20]
 8042548:	f1b8 0f02 	cmp.w	r8, #2
 804254c:	fb03 f606 	mul.w	r6, r3, r6
 8042550:	dd07      	ble.n	8042562 <kann_new_leaf_array+0x92>
 8042552:	69a3      	ldr	r3, [r4, #24]
 8042554:	f019 0ffc 	tst.w	r9, #252	@ 0xfc
 8042558:	fb03 f606 	mul.w	r6, r3, r6
 804255c:	bf1c      	itt	ne
 804255e:	69e3      	ldrne	r3, [r4, #28]
 8042560:	435e      	mulne	r6, r3
	p->x = (float*)calloc(len, sizeof(float));
 8042562:	2104      	movs	r1, #4
 8042564:	4630      	mov	r0, r6
 8042566:	f009 f95b 	bl	804b820 <calloc>
	heapSize += len*sizeof(float);
 804256a:	682b      	ldr	r3, [r5, #0]
	if (p->n_d <= 1) {
 804256c:	f1b8 0f01 	cmp.w	r8, #1
	heapSize += len*sizeof(float);
 8042570:	eb03 0386 	add.w	r3, r3, r6, lsl #2
 8042574:	602b      	str	r3, [r5, #0]
	p->x = (float*)calloc(len, sizeof(float));
 8042576:	62a0      	str	r0, [r4, #40]	@ 0x28
	heapSize += len*sizeof(float);
 8042578:	ea4f 0386 	mov.w	r3, r6, lsl #2
	if (p->n_d <= 1) {
 804257c:	d814      	bhi.n	80425a8 <kann_new_leaf_array+0xd8>
		for (i = 0; i < len; ++i)
 804257e:	2e00      	cmp	r6, #0
 8042580:	dd04      	ble.n	804258c <kann_new_leaf_array+0xbc>
 8042582:	4403      	add	r3, r0
			p->x[i] = x0_01;
 8042584:	eca0 8a01 	vstmia	r0!, {s16}
		for (i = 0; i < len; ++i)
 8042588:	4283      	cmp	r3, r0
 804258a:	d1fb      	bne.n	8042584 <kann_new_leaf_array+0xb4>
	if (off >= 0) par[off] = p, ++(*offset);
 804258c:	f1bb 0f00 	cmp.w	fp, #0
 8042590:	db04      	blt.n	804259c <kann_new_leaf_array+0xcc>
 8042592:	683b      	ldr	r3, [r7, #0]
 8042594:	f84a 402b 	str.w	r4, [sl, fp, lsl #2]
 8042598:	3301      	adds	r3, #1
 804259a:	603b      	str	r3, [r7, #0]
}
 804259c:	4620      	mov	r0, r4
 804259e:	b003      	add	sp, #12
 80425a0:	ecbd 8b02 	vpop	{d8}
 80425a4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		sdev_inv = 1.0 / sqrt((double)len / p->d[0]);
 80425a8:	4630      	mov	r0, r6
 80425aa:	f7fd ff97 	bl	80404dc <__aeabi_i2d>
 80425ae:	4680      	mov	r8, r0
 80425b0:	6920      	ldr	r0, [r4, #16]
 80425b2:	4689      	mov	r9, r1
 80425b4:	f7fd ff92 	bl	80404dc <__aeabi_i2d>
 80425b8:	4602      	mov	r2, r0
 80425ba:	460b      	mov	r3, r1
 80425bc:	4640      	mov	r0, r8
 80425be:	4649      	mov	r1, r9
 80425c0:	f7fe f920 	bl	8040804 <__aeabi_ddiv>
 80425c4:	ec41 0b10 	vmov	d0, r0, r1
 80425c8:	f00a fb60 	bl	804cc8c <sqrt>
 80425cc:	2000      	movs	r0, #0
 80425ce:	ec53 2b10 	vmov	r2, r3, d0
 80425d2:	4916      	ldr	r1, [pc, #88]	@ (804262c <kann_new_leaf_array+0x15c>)
 80425d4:	f7fe f916 	bl	8040804 <__aeabi_ddiv>
		for (i = 0; i < len; ++i)
 80425d8:	2e00      	cmp	r6, #0
 80425da:	ddd7      	ble.n	804258c <kann_new_leaf_array+0xbc>
 80425dc:	f8cd a004 	str.w	sl, [sp, #4]
 80425e0:	2500      	movs	r5, #0
 80425e2:	4681      	mov	r9, r0
 80425e4:	468a      	mov	sl, r1
			p->x[i] = (float)(kad_drand_normal(0) * sdev_inv);
 80425e6:	2000      	movs	r0, #0
 80425e8:	f008 fd88 	bl	804b0fc <kad_drand_normal>
 80425ec:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
 80425ee:	ec51 0b10 	vmov	r0, r1, d0
 80425f2:	eb03 0885 	add.w	r8, r3, r5, lsl #2
 80425f6:	464a      	mov	r2, r9
 80425f8:	4653      	mov	r3, sl
 80425fa:	f7fd ffd9 	bl	80405b0 <__aeabi_dmul>
 80425fe:	f7fe faaf 	bl	8040b60 <__aeabi_d2f>
		for (i = 0; i < len; ++i)
 8042602:	3501      	adds	r5, #1
 8042604:	42b5      	cmp	r5, r6
			p->x[i] = (float)(kad_drand_normal(0) * sdev_inv);
 8042606:	f8c8 0000 	str.w	r0, [r8]
		for (i = 0; i < len; ++i)
 804260a:	d1ec      	bne.n	80425e6 <kann_new_leaf_array+0x116>
 804260c:	f8dd a004 	ldr.w	sl, [sp, #4]
 8042610:	e7bc      	b.n	804258c <kann_new_leaf_array+0xbc>
	p->x = (float*)calloc(len, sizeof(float));
 8042612:	2104      	movs	r1, #4
 8042614:	2001      	movs	r0, #1
 8042616:	f009 f903 	bl	804b820 <calloc>
	heapSize += len*sizeof(float);
 804261a:	682b      	ldr	r3, [r5, #0]
	p->x = (float*)calloc(len, sizeof(float));
 804261c:	62a0      	str	r0, [r4, #40]	@ 0x28
	heapSize += len*sizeof(float);
 804261e:	3304      	adds	r3, #4
 8042620:	602b      	str	r3, [r5, #0]
 8042622:	2304      	movs	r3, #4
 8042624:	e7ad      	b.n	8042582 <kann_new_leaf_array+0xb2>
 8042626:	bf00      	nop
 8042628:	20018acc 	.word	0x20018acc
 804262c:	3ff00000 	.word	0x3ff00000

08042630 <kann_new_leaf.constprop.0>:
kad_node_t *kann_new_leaf(uint8_t flag, float x0_01, int n_d, ...)
 8042630:	b40c      	push	{r2, r3}
 8042632:	b530      	push	{r4, r5, lr}
 8042634:	ed2d 8b02 	vpush	{d8}
 8042638:	b089      	sub	sp, #36	@ 0x24
 804263a:	aa0e      	add	r2, sp, #56	@ 0x38
 804263c:	f852 4b04 	ldr.w	r4, [r2], #4
 8042640:	ee08 1a10 	vmov	s16, r1
	va_start(ap, n_d); for (i = 0; i < n_d; ++i) d[i] = va_arg(ap, int); va_end(ap);
 8042644:	2c00      	cmp	r4, #0
 8042646:	9203      	str	r2, [sp, #12]
 8042648:	ad04      	add	r5, sp, #16
 804264a:	dd04      	ble.n	8042656 <kann_new_leaf.constprop.0+0x26>
 804264c:	4611      	mov	r1, r2
 804264e:	4628      	mov	r0, r5
 8042650:	00a2      	lsls	r2, r4, #2
 8042652:	f009 fcec 	bl	804c02e <memcpy>
	return kann_new_leaf_array(0, 0, flag, x0_01, n_d, d);
 8042656:	2100      	movs	r1, #0
 8042658:	4623      	mov	r3, r4
 804265a:	eeb0 0a48 	vmov.f32	s0, s16
 804265e:	2201      	movs	r2, #1
 8042660:	4608      	mov	r0, r1
 8042662:	9500      	str	r5, [sp, #0]
 8042664:	f7ff ff34 	bl	80424d0 <kann_new_leaf_array>
}
 8042668:	b009      	add	sp, #36	@ 0x24
 804266a:	ecbd 8b02 	vpop	{d8}
 804266e:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
 8042672:	b002      	add	sp, #8
 8042674:	4770      	bx	lr
 8042676:	bf00      	nop

08042678 <kann_new_leaf2.constprop.0>:
kad_node_t *kann_new_leaf2(int *offset, kad_node_p *par, uint8_t flag, float x0_01, int n_d, ...)
 8042678:	b5f0      	push	{r4, r5, r6, r7, lr}
 804267a:	ed2d 8b02 	vpush	{d8}
 804267e:	b089      	sub	sp, #36	@ 0x24
 8042680:	aa10      	add	r2, sp, #64	@ 0x40
 8042682:	f852 6b04 	ldr.w	r6, [r2], #4
 8042686:	4604      	mov	r4, r0
	va_start(ap, n_d); for (i = 0; i < n_d; ++i) d[i] = va_arg(ap, int); va_end(ap);
 8042688:	2e00      	cmp	r6, #0
kad_node_t *kann_new_leaf2(int *offset, kad_node_p *par, uint8_t flag, float x0_01, int n_d, ...)
 804268a:	460d      	mov	r5, r1
 804268c:	ee08 3a10 	vmov	s16, r3
	va_start(ap, n_d); for (i = 0; i < n_d; ++i) d[i] = va_arg(ap, int); va_end(ap);
 8042690:	9203      	str	r2, [sp, #12]
 8042692:	af04      	add	r7, sp, #16
 8042694:	dd04      	ble.n	80426a0 <kann_new_leaf2.constprop.0+0x28>
 8042696:	4611      	mov	r1, r2
 8042698:	4638      	mov	r0, r7
 804269a:	00b2      	lsls	r2, r6, #2
 804269c:	f009 fcc7 	bl	804c02e <memcpy>
	return kann_new_leaf_array(offset, par, flag, x0_01, n_d, d);
 80426a0:	4633      	mov	r3, r6
 80426a2:	eeb0 0a48 	vmov.f32	s0, s16
 80426a6:	2201      	movs	r2, #1
 80426a8:	4629      	mov	r1, r5
 80426aa:	4620      	mov	r0, r4
 80426ac:	9700      	str	r7, [sp, #0]
 80426ae:	f7ff ff0f 	bl	80424d0 <kann_new_leaf_array>
}
 80426b2:	b009      	add	sp, #36	@ 0x24
 80426b4:	ecbd 8b02 	vpop	{d8}
 80426b8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80426ba:	bf00      	nop

080426bc <kann_layer_layernorm2>:
{
 80426bc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	n0 = in->n_d >= 2? kad_len(in) / in->d[0] : kad_len(in);
 80426c0:	7813      	ldrb	r3, [r2, #0]
{
 80426c2:	4614      	mov	r4, r2
	n0 = in->n_d >= 2? kad_len(in) / in->d[0] : kad_len(in);
 80426c4:	2b01      	cmp	r3, #1
{
 80426c6:	4607      	mov	r7, r0
 80426c8:	4688      	mov	r8, r1
 80426ca:	b082      	sub	sp, #8
	n0 = in->n_d >= 2? kad_len(in) / in->d[0] : kad_len(in);
 80426cc:	d930      	bls.n	8042730 <kann_layer_layernorm2+0x74>
 80426ce:	e9d2 2504 	ldrd	r2, r5, [r2, #16]
 80426d2:	2b02      	cmp	r3, #2
 80426d4:	fb02 f505 	mul.w	r5, r2, r5
 80426d8:	d006      	beq.n	80426e8 <kann_layer_layernorm2+0x2c>
 80426da:	69a1      	ldr	r1, [r4, #24]
 80426dc:	2b03      	cmp	r3, #3
 80426de:	fb01 f505 	mul.w	r5, r1, r5
 80426e2:	bf1c      	itt	ne
 80426e4:	69e3      	ldrne	r3, [r4, #28]
 80426e6:	435d      	mulne	r5, r3
 80426e8:	fb95 f5f2 	sdiv	r5, r5, r2
	alpha = kann_new_leaf2(offset, par, KAD_VAR, 1.0f, 1, n0);
 80426ec:	2601      	movs	r6, #1
 80426ee:	4641      	mov	r1, r8
 80426f0:	4632      	mov	r2, r6
 80426f2:	9501      	str	r5, [sp, #4]
 80426f4:	f04f 537e 	mov.w	r3, #1065353216	@ 0x3f800000
 80426f8:	4638      	mov	r0, r7
 80426fa:	9600      	str	r6, [sp, #0]
 80426fc:	f7ff ffbc 	bl	8042678 <kann_new_leaf2.constprop.0>
 8042700:	4684      	mov	ip, r0
	beta  = kann_new_leaf2(offset, par, KAD_VAR, 0.0f, 1, n0);
 8042702:	4641      	mov	r1, r8
 8042704:	4632      	mov	r2, r6
 8042706:	9501      	str	r5, [sp, #4]
 8042708:	4638      	mov	r0, r7
 804270a:	2300      	movs	r3, #0
 804270c:	9600      	str	r6, [sp, #0]
	alpha = kann_new_leaf2(offset, par, KAD_VAR, 1.0f, 1, n0);
 804270e:	4665      	mov	r5, ip
	beta  = kann_new_leaf2(offset, par, KAD_VAR, 0.0f, 1, n0);
 8042710:	f7ff ffb2 	bl	8042678 <kann_new_leaf2.constprop.0>
 8042714:	4603      	mov	r3, r0
	return kad_add(kad_mul(kad_stdnorm(in), alpha), beta);
 8042716:	4620      	mov	r0, r4
	beta  = kann_new_leaf2(offset, par, KAD_VAR, 0.0f, 1, n0);
 8042718:	461c      	mov	r4, r3
	return kad_add(kad_mul(kad_stdnorm(in), alpha), beta);
 804271a:	f007 fca3 	bl	804a064 <kad_stdnorm>
 804271e:	4629      	mov	r1, r5
 8042720:	f007 fad0 	bl	8049cc4 <kad_mul>
 8042724:	4621      	mov	r1, r4
}
 8042726:	b002      	add	sp, #8
 8042728:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	return kad_add(kad_mul(kad_stdnorm(in), alpha), beta);
 804272c:	f007 ba78 	b.w	8049c20 <kad_add>
 8042730:	b10b      	cbz	r3, 8042736 <kann_layer_layernorm2+0x7a>
 8042732:	6925      	ldr	r5, [r4, #16]
 8042734:	e7da      	b.n	80426ec <kann_layer_layernorm2+0x30>
	int n = 1, i;
 8042736:	2501      	movs	r5, #1
 8042738:	e7d8      	b.n	80426ec <kann_layer_layernorm2+0x30>
 804273a:	bf00      	nop

0804273c <kann_cmul_norm>:
	heapSize += n1*sizeof(float);
	return kann_layer_gru2(0, 0, in, h0, rnn_flag);
}

static kad_node_t *kann_cmul_norm(kad_node_t *x, kad_node_t *w)
{
 804273c:	b508      	push	{r3, lr}
	return kann_layer_layernorm(kad_cmul(x, w));
 804273e:	f007 fb0f 	bl	8049d60 <kad_cmul>
}
 8042742:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
kad_node_t *kann_layer_layernorm(kad_node_t *in) { return kann_layer_layernorm2(0, 0, in); }
 8042746:	2100      	movs	r1, #0
	return kann_layer_layernorm(kad_cmul(x, w));
 8042748:	4602      	mov	r2, r0
kad_node_t *kann_layer_layernorm(kad_node_t *in) { return kann_layer_layernorm2(0, 0, in); }
 804274a:	4608      	mov	r0, r1
 804274c:	f7ff bfb6 	b.w	80426bc <kann_layer_layernorm2>

08042750 <kann_new_scalar>:
kad_node_t *kann_new_scalar(uint8_t flag, float x) { return kann_new_leaf(flag, x, 0); }
 8042750:	ee10 1a10 	vmov	r1, s0
 8042754:	2200      	movs	r2, #0
 8042756:	f7ff bb67 	b.w	8041e28 <kann_new_leaf.constprop.1>
 804275a:	bf00      	nop

0804275c <kann_layer_input>:
{
 804275c:	4602      	mov	r2, r0
	t = kad_feed(2, 1, n1), t->ext_flag |= KANN_F_IN;
 804275e:	2101      	movs	r1, #1
{
 8042760:	b508      	push	{r3, lr}
	t = kad_feed(2, 1, n1), t->ext_flag |= KANN_F_IN;
 8042762:	2002      	movs	r0, #2
 8042764:	f007 fa04 	bl	8049b70 <kad_feed>
 8042768:	6a42      	ldr	r2, [r0, #36]	@ 0x24
 804276a:	f042 0201 	orr.w	r2, r2, #1
 804276e:	6242      	str	r2, [r0, #36]	@ 0x24
}
 8042770:	bd08      	pop	{r3, pc}
 8042772:	bf00      	nop

08042774 <kann_layer_dense>:
kad_node_t *kann_layer_dense(kad_node_t *in, int n1) { return kann_layer_dense2(0, 0, in, n1); }
 8042774:	b530      	push	{r4, r5, lr}
	n0 = in->n_d >= 2? kad_len(in) / in->d[0] : kad_len(in);
 8042776:	7802      	ldrb	r2, [r0, #0]
kad_node_t *kann_layer_dense(kad_node_t *in, int n1) { return kann_layer_dense2(0, 0, in, n1); }
 8042778:	4604      	mov	r4, r0
	n0 = in->n_d >= 2? kad_len(in) / in->d[0] : kad_len(in);
 804277a:	2a01      	cmp	r2, #1
kad_node_t *kann_layer_dense(kad_node_t *in, int n1) { return kann_layer_dense2(0, 0, in, n1); }
 804277c:	460d      	mov	r5, r1
 804277e:	b085      	sub	sp, #20
	n0 = in->n_d >= 2? kad_len(in) / in->d[0] : kad_len(in);
 8042780:	d92d      	bls.n	80427de <kann_layer_dense+0x6a>
	for (i = 0; i < p->n_d; ++i) n *= p->d[i];
 8042782:	e9d0 1304 	ldrd	r1, r3, [r0, #16]
 8042786:	2a02      	cmp	r2, #2
 8042788:	fb01 f303 	mul.w	r3, r1, r3
 804278c:	d006      	beq.n	804279c <kann_layer_dense+0x28>
 804278e:	6980      	ldr	r0, [r0, #24]
 8042790:	2a03      	cmp	r2, #3
 8042792:	fb00 f303 	mul.w	r3, r0, r3
 8042796:	bf1c      	itt	ne
 8042798:	69e2      	ldrne	r2, [r4, #28]
 804279a:	4353      	mulne	r3, r2
 804279c:	fb93 f3f1 	sdiv	r3, r3, r1
	w = kann_new_leaf2(offset, par, KAD_VAR, 0.0f, 2, n1, n0);
 80427a0:	2100      	movs	r1, #0
 80427a2:	2002      	movs	r0, #2
 80427a4:	9302      	str	r3, [sp, #8]
 80427a6:	e9cd 0500 	strd	r0, r5, [sp]
 80427aa:	2201      	movs	r2, #1
 80427ac:	2300      	movs	r3, #0
 80427ae:	4608      	mov	r0, r1
 80427b0:	f7ff ff62 	bl	8042678 <kann_new_leaf2.constprop.0>
	b = kann_new_leaf2(offset, par, KAD_VAR, 0.0f, 1, n1);
 80427b4:	2201      	movs	r2, #1
 80427b6:	2100      	movs	r1, #0
 80427b8:	9501      	str	r5, [sp, #4]
 80427ba:	9200      	str	r2, [sp, #0]
	w = kann_new_leaf2(offset, par, KAD_VAR, 0.0f, 2, n1, n0);
 80427bc:	4605      	mov	r5, r0
	b = kann_new_leaf2(offset, par, KAD_VAR, 0.0f, 1, n1);
 80427be:	2300      	movs	r3, #0
 80427c0:	4608      	mov	r0, r1
 80427c2:	f7ff ff59 	bl	8042678 <kann_new_leaf2.constprop.0>
 80427c6:	4603      	mov	r3, r0
	return kad_add(kad_cmul(in, w), b);
 80427c8:	4620      	mov	r0, r4
	b = kann_new_leaf2(offset, par, KAD_VAR, 0.0f, 1, n1);
 80427ca:	461c      	mov	r4, r3
	return kad_add(kad_cmul(in, w), b);
 80427cc:	4629      	mov	r1, r5
 80427ce:	f007 fac7 	bl	8049d60 <kad_cmul>
 80427d2:	4621      	mov	r1, r4
kad_node_t *kann_layer_dense(kad_node_t *in, int n1) { return kann_layer_dense2(0, 0, in, n1); }
 80427d4:	b005      	add	sp, #20
 80427d6:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
	return kad_add(kad_cmul(in, w), b);
 80427da:	f007 ba21 	b.w	8049c20 <kad_add>
 80427de:	b10a      	cbz	r2, 80427e4 <kann_layer_dense+0x70>
 80427e0:	6923      	ldr	r3, [r4, #16]
 80427e2:	e7dd      	b.n	80427a0 <kann_layer_dense+0x2c>
	int n = 1, i;
 80427e4:	2301      	movs	r3, #1
 80427e6:	e7db      	b.n	80427a0 <kann_layer_dense+0x2c>

080427e8 <kann_layer_lstm>:

kad_node_t *kann_layer_lstm(kad_node_t *in, int n1, int rnn_flag)
{
 80427e8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	int n0;
	kad_node_t *i, *f, *o, *g, *w, *u, *b, *h0, *c0, *c, *out;
	kad_node_t *(*cmul)(kad_node_t*, kad_node_t*) = (rnn_flag & KANN_RNN_NORM)? kann_cmul_norm : kad_cmul;
 80427ec:	4f9d      	ldr	r7, [pc, #628]	@ (8042a64 <kann_layer_lstm+0x27c>)

	n0 = in->n_d >= 2? kad_len(in) / in->d[0] : kad_len(in);
 80427ee:	7803      	ldrb	r3, [r0, #0]
{
 80427f0:	460c      	mov	r4, r1
	kad_node_t *(*cmul)(kad_node_t*, kad_node_t*) = (rnn_flag & KANN_RNN_NORM)? kann_cmul_norm : kad_cmul;
 80427f2:	f012 0102 	ands.w	r1, r2, #2
 80427f6:	4e9c      	ldr	r6, [pc, #624]	@ (8042a68 <kann_layer_lstm+0x280>)
{
 80427f8:	b087      	sub	sp, #28
	kad_node_t *(*cmul)(kad_node_t*, kad_node_t*) = (rnn_flag & KANN_RNN_NORM)? kann_cmul_norm : kad_cmul;
 80427fa:	bf08      	it	eq
 80427fc:	463e      	moveq	r6, r7
	n0 = in->n_d >= 2? kad_len(in) / in->d[0] : kad_len(in);
 80427fe:	2b01      	cmp	r3, #1
{
 8042800:	4605      	mov	r5, r0
	kad_node_t *(*cmul)(kad_node_t*, kad_node_t*) = (rnn_flag & KANN_RNN_NORM)? kann_cmul_norm : kad_cmul;
 8042802:	9103      	str	r1, [sp, #12]
	n0 = in->n_d >= 2? kad_len(in) / in->d[0] : kad_len(in);
 8042804:	f240 8123 	bls.w	8042a4e <kann_layer_lstm+0x266>
	for (i = 0; i < p->n_d; ++i) n *= p->d[i];
 8042808:	e9d0 0704 	ldrd	r0, r7, [r0, #16]
 804280c:	2b02      	cmp	r3, #2
 804280e:	fb00 f707 	mul.w	r7, r0, r7
 8042812:	d006      	beq.n	8042822 <kann_layer_lstm+0x3a>
 8042814:	69a9      	ldr	r1, [r5, #24]
 8042816:	2b03      	cmp	r3, #3
 8042818:	fb01 f707 	mul.w	r7, r1, r7
 804281c:	bf1c      	itt	ne
 804281e:	69eb      	ldrne	r3, [r5, #28]
 8042820:	435f      	mulne	r7, r3
 8042822:	fb97 f7f0 	sdiv	r7, r7, r0
	h0 = (rnn_flag & KANN_RNN_VAR_H0)? kad_var(0, 0, 2, 1, n1) : kad_const(0, 2, 1, n1);
 8042826:	f012 0901 	ands.w	r9, r2, #1
	h0->x = (float*)calloc(n1, sizeof(float));
	heapSize += n1*sizeof(float);
 804282a:	ea4f 0b84 	mov.w	fp, r4, lsl #2
	h0 = (rnn_flag & KANN_RNN_VAR_H0)? kad_var(0, 0, 2, 1, n1) : kad_const(0, 2, 1, n1);
 804282e:	f000 80f1 	beq.w	8042a14 <kann_layer_lstm+0x22c>
 8042832:	2100      	movs	r1, #0
 8042834:	2301      	movs	r3, #1
 8042836:	2202      	movs	r2, #2
 8042838:	4608      	mov	r0, r1
 804283a:	9400      	str	r4, [sp, #0]
 804283c:	f007 f9c4 	bl	8049bc8 <kad_var>
	h0->x = (float*)calloc(n1, sizeof(float));
 8042840:	2104      	movs	r1, #4
	h0 = (rnn_flag & KANN_RNN_VAR_H0)? kad_var(0, 0, 2, 1, n1) : kad_const(0, 2, 1, n1);
 8042842:	4680      	mov	r8, r0
	h0->x = (float*)calloc(n1, sizeof(float));
 8042844:	4620      	mov	r0, r4
 8042846:	f008 ffeb 	bl	804b820 <calloc>
	c0 = (rnn_flag & KANN_RNN_VAR_H0)? kad_var(0, 0, 2, 1, n1) : kad_const(0, 2, 1, n1);
 804284a:	2100      	movs	r1, #0
	heapSize += n1*sizeof(float);
 804284c:	f8df a21c 	ldr.w	sl, [pc, #540]	@ 8042a6c <kann_layer_lstm+0x284>
	h0->x = (float*)calloc(n1, sizeof(float));
 8042850:	f8c8 0028 	str.w	r0, [r8, #40]	@ 0x28
	c0 = (rnn_flag & KANN_RNN_VAR_H0)? kad_var(0, 0, 2, 1, n1) : kad_const(0, 2, 1, n1);
 8042854:	9400      	str	r4, [sp, #0]
	heapSize += n1*sizeof(float);
 8042856:	f8da 3000 	ldr.w	r3, [sl]
	c0 = (rnn_flag & KANN_RNN_VAR_H0)? kad_var(0, 0, 2, 1, n1) : kad_const(0, 2, 1, n1);
 804285a:	2202      	movs	r2, #2
	heapSize += n1*sizeof(float);
 804285c:	445b      	add	r3, fp
 804285e:	f8ca 3000 	str.w	r3, [sl]
	c0 = (rnn_flag & KANN_RNN_VAR_H0)? kad_var(0, 0, 2, 1, n1) : kad_const(0, 2, 1, n1);
 8042862:	4608      	mov	r0, r1
 8042864:	2301      	movs	r3, #1
 8042866:	f007 f9af 	bl	8049bc8 <kad_var>
 804286a:	4681      	mov	r9, r0
	c0->x = (float*)calloc(n1, sizeof(float));
 804286c:	2104      	movs	r1, #4
 804286e:	4620      	mov	r0, r4
 8042870:	f008 ffd6 	bl	804b820 <calloc>
 8042874:	f8c9 0028 	str.w	r0, [r9, #40]	@ 0x28
kad_node_t *kann_new_weight(int n_row, int n_col) { return kann_new_leaf(KAD_VAR, 0.0f, 2, n_row, n_col); }
 8042878:	9700      	str	r7, [sp, #0]
	heapSize += n1*sizeof(float);
 804287a:	f8da 3000 	ldr.w	r3, [sl]
kad_node_t *kann_new_weight(int n_row, int n_col) { return kann_new_leaf(KAD_VAR, 0.0f, 2, n_row, n_col); }
 804287e:	2202      	movs	r2, #2
	heapSize += n1*sizeof(float);
 8042880:	445b      	add	r3, fp
 8042882:	f8ca 3000 	str.w	r3, [sl]
kad_node_t *kann_new_weight(int n_row, int n_col) { return kann_new_leaf(KAD_VAR, 0.0f, 2, n_row, n_col); }
 8042886:	2100      	movs	r1, #0
 8042888:	4623      	mov	r3, r4
 804288a:	2001      	movs	r0, #1
 804288c:	f7ff fed0 	bl	8042630 <kann_new_leaf.constprop.0>
 8042890:	4623      	mov	r3, r4
 8042892:	4682      	mov	sl, r0
 8042894:	2202      	movs	r2, #2
 8042896:	2100      	movs	r1, #0
 8042898:	9400      	str	r4, [sp, #0]
 804289a:	2001      	movs	r0, #1
 804289c:	f7ff fec8 	bl	8042630 <kann_new_leaf.constprop.0>
kad_node_t *kann_new_vec(int n, float x) { return kann_new_leaf(KAD_VAR, x, 1, n); }
 80428a0:	2201      	movs	r2, #1
 80428a2:	4623      	mov	r3, r4
kad_node_t *kann_new_weight(int n_row, int n_col) { return kann_new_leaf(KAD_VAR, 0.0f, 2, n_row, n_col); }
 80428a4:	4683      	mov	fp, r0
kad_node_t *kann_new_vec(int n, float x) { return kann_new_leaf(KAD_VAR, x, 1, n); }
 80428a6:	2100      	movs	r1, #0
 80428a8:	4610      	mov	r0, r2
 80428aa:	f7ff fec1 	bl	8042630 <kann_new_leaf.constprop.0>
 80428ae:	4603      	mov	r3, r0

	/* i = sigm(x_t * W_i + h_{t-1} * U_i + b_i) */
	w = kann_new_weight(n1, n0);
	u = kann_new_weight(n1, n1);
	b = kann_new_bias(n1);
	i = kad_sigm(kad_add(kad_add(cmul(in, w), cmul(h0, u)), b));
 80428b0:	4651      	mov	r1, sl
 80428b2:	4628      	mov	r0, r5
kad_node_t *kann_new_vec(int n, float x) { return kann_new_leaf(KAD_VAR, x, 1, n); }
 80428b4:	469a      	mov	sl, r3
	i = kad_sigm(kad_add(kad_add(cmul(in, w), cmul(h0, u)), b));
 80428b6:	47b0      	blx	r6
 80428b8:	4603      	mov	r3, r0
 80428ba:	4659      	mov	r1, fp
 80428bc:	4640      	mov	r0, r8
 80428be:	469b      	mov	fp, r3
 80428c0:	47b0      	blx	r6
 80428c2:	4601      	mov	r1, r0
 80428c4:	4658      	mov	r0, fp
 80428c6:	f007 f9ab 	bl	8049c20 <kad_add>
 80428ca:	4651      	mov	r1, sl
 80428cc:	f007 f9a8 	bl	8049c20 <kad_add>
 80428d0:	f007 faea 	bl	8049ea8 <kad_sigm>
 80428d4:	4684      	mov	ip, r0
kad_node_t *kann_new_weight(int n_row, int n_col) { return kann_new_leaf(KAD_VAR, 0.0f, 2, n_row, n_col); }
 80428d6:	4623      	mov	r3, r4
 80428d8:	2202      	movs	r2, #2
 80428da:	2100      	movs	r1, #0
 80428dc:	9700      	str	r7, [sp, #0]
 80428de:	2001      	movs	r0, #1
	i = kad_sigm(kad_add(kad_add(cmul(in, w), cmul(h0, u)), b));
 80428e0:	f8cd c010 	str.w	ip, [sp, #16]
kad_node_t *kann_new_weight(int n_row, int n_col) { return kann_new_leaf(KAD_VAR, 0.0f, 2, n_row, n_col); }
 80428e4:	f7ff fea4 	bl	8042630 <kann_new_leaf.constprop.0>
 80428e8:	4623      	mov	r3, r4
 80428ea:	4682      	mov	sl, r0
 80428ec:	2202      	movs	r2, #2
 80428ee:	2100      	movs	r1, #0
 80428f0:	9400      	str	r4, [sp, #0]
 80428f2:	2001      	movs	r0, #1
 80428f4:	f7ff fe9c 	bl	8042630 <kann_new_leaf.constprop.0>
kad_node_t *kann_new_vec(int n, float x) { return kann_new_leaf(KAD_VAR, x, 1, n); }
 80428f8:	2201      	movs	r2, #1
 80428fa:	4623      	mov	r3, r4
kad_node_t *kann_new_weight(int n_row, int n_col) { return kann_new_leaf(KAD_VAR, 0.0f, 2, n_row, n_col); }
 80428fc:	4683      	mov	fp, r0
kad_node_t *kann_new_vec(int n, float x) { return kann_new_leaf(KAD_VAR, x, 1, n); }
 80428fe:	f04f 517e 	mov.w	r1, #1065353216	@ 0x3f800000
 8042902:	4610      	mov	r0, r2
 8042904:	f7ff fe94 	bl	8042630 <kann_new_leaf.constprop.0>
 8042908:	4603      	mov	r3, r0
	/* f = sigm(x_t * W_f + h_{t-1} * U_f + b_f) */
	w = kann_new_weight(n1, n0);
	u = kann_new_weight(n1, n1);
	b = kann_new_vec(n1, 1.0f); /* see Jozefowicz et al on using a large bias */
	f = kad_sigm(kad_add(kad_add(cmul(in, w), cmul(h0, u)), b));
 804290a:	4651      	mov	r1, sl
 804290c:	4628      	mov	r0, r5
kad_node_t *kann_new_vec(int n, float x) { return kann_new_leaf(KAD_VAR, x, 1, n); }
 804290e:	469a      	mov	sl, r3
	f = kad_sigm(kad_add(kad_add(cmul(in, w), cmul(h0, u)), b));
 8042910:	47b0      	blx	r6
 8042912:	4603      	mov	r3, r0
 8042914:	4659      	mov	r1, fp
 8042916:	4640      	mov	r0, r8
 8042918:	469b      	mov	fp, r3
 804291a:	47b0      	blx	r6
 804291c:	4601      	mov	r1, r0
 804291e:	4658      	mov	r0, fp
 8042920:	f007 f97e 	bl	8049c20 <kad_add>
 8042924:	4651      	mov	r1, sl
 8042926:	f007 f97b 	bl	8049c20 <kad_add>
 804292a:	f007 fabd 	bl	8049ea8 <kad_sigm>
 804292e:	4684      	mov	ip, r0
kad_node_t *kann_new_weight(int n_row, int n_col) { return kann_new_leaf(KAD_VAR, 0.0f, 2, n_row, n_col); }
 8042930:	4623      	mov	r3, r4
 8042932:	2202      	movs	r2, #2
 8042934:	2100      	movs	r1, #0
 8042936:	9700      	str	r7, [sp, #0]
 8042938:	2001      	movs	r0, #1
	f = kad_sigm(kad_add(kad_add(cmul(in, w), cmul(h0, u)), b));
 804293a:	f8cd c014 	str.w	ip, [sp, #20]
kad_node_t *kann_new_weight(int n_row, int n_col) { return kann_new_leaf(KAD_VAR, 0.0f, 2, n_row, n_col); }
 804293e:	f7ff fe77 	bl	8042630 <kann_new_leaf.constprop.0>
 8042942:	4623      	mov	r3, r4
 8042944:	4682      	mov	sl, r0
 8042946:	2202      	movs	r2, #2
 8042948:	2100      	movs	r1, #0
 804294a:	9400      	str	r4, [sp, #0]
 804294c:	2001      	movs	r0, #1
 804294e:	f7ff fe6f 	bl	8042630 <kann_new_leaf.constprop.0>
kad_node_t *kann_new_vec(int n, float x) { return kann_new_leaf(KAD_VAR, x, 1, n); }
 8042952:	2201      	movs	r2, #1
 8042954:	4623      	mov	r3, r4
kad_node_t *kann_new_weight(int n_row, int n_col) { return kann_new_leaf(KAD_VAR, 0.0f, 2, n_row, n_col); }
 8042956:	4683      	mov	fp, r0
kad_node_t *kann_new_vec(int n, float x) { return kann_new_leaf(KAD_VAR, x, 1, n); }
 8042958:	2100      	movs	r1, #0
 804295a:	4610      	mov	r0, r2
 804295c:	f7ff fe68 	bl	8042630 <kann_new_leaf.constprop.0>
 8042960:	4603      	mov	r3, r0
	/* o = sigm(x_t * W_o + h_{t-1} * U_o + b_o) */
	w = kann_new_weight(n1, n0);
	u = kann_new_weight(n1, n1);
	b = kann_new_bias(n1);
	o = kad_sigm(kad_add(kad_add(cmul(in, w), cmul(h0, u)), b));
 8042962:	4651      	mov	r1, sl
 8042964:	4628      	mov	r0, r5
kad_node_t *kann_new_vec(int n, float x) { return kann_new_leaf(KAD_VAR, x, 1, n); }
 8042966:	469a      	mov	sl, r3
	o = kad_sigm(kad_add(kad_add(cmul(in, w), cmul(h0, u)), b));
 8042968:	47b0      	blx	r6
 804296a:	4603      	mov	r3, r0
 804296c:	4659      	mov	r1, fp
 804296e:	4640      	mov	r0, r8
 8042970:	469b      	mov	fp, r3
 8042972:	47b0      	blx	r6
 8042974:	4601      	mov	r1, r0
 8042976:	4658      	mov	r0, fp
 8042978:	f007 f952 	bl	8049c20 <kad_add>
 804297c:	4651      	mov	r1, sl
 804297e:	f007 f94f 	bl	8049c20 <kad_add>
 8042982:	f007 fa91 	bl	8049ea8 <kad_sigm>
 8042986:	4684      	mov	ip, r0
kad_node_t *kann_new_weight(int n_row, int n_col) { return kann_new_leaf(KAD_VAR, 0.0f, 2, n_row, n_col); }
 8042988:	4623      	mov	r3, r4
 804298a:	2202      	movs	r2, #2
 804298c:	2100      	movs	r1, #0
 804298e:	9700      	str	r7, [sp, #0]
 8042990:	2001      	movs	r0, #1
	o = kad_sigm(kad_add(kad_add(cmul(in, w), cmul(h0, u)), b));
 8042992:	4667      	mov	r7, ip
kad_node_t *kann_new_weight(int n_row, int n_col) { return kann_new_leaf(KAD_VAR, 0.0f, 2, n_row, n_col); }
 8042994:	f7ff fe4c 	bl	8042630 <kann_new_leaf.constprop.0>
 8042998:	4623      	mov	r3, r4
 804299a:	4682      	mov	sl, r0
 804299c:	2202      	movs	r2, #2
 804299e:	2100      	movs	r1, #0
 80429a0:	9400      	str	r4, [sp, #0]
 80429a2:	2001      	movs	r0, #1
 80429a4:	f7ff fe44 	bl	8042630 <kann_new_leaf.constprop.0>
kad_node_t *kann_new_vec(int n, float x) { return kann_new_leaf(KAD_VAR, x, 1, n); }
 80429a8:	2201      	movs	r2, #1
 80429aa:	4623      	mov	r3, r4
 80429ac:	2100      	movs	r1, #0
kad_node_t *kann_new_weight(int n_row, int n_col) { return kann_new_leaf(KAD_VAR, 0.0f, 2, n_row, n_col); }
 80429ae:	4604      	mov	r4, r0
kad_node_t *kann_new_vec(int n, float x) { return kann_new_leaf(KAD_VAR, x, 1, n); }
 80429b0:	4610      	mov	r0, r2
 80429b2:	f7ff fe3d 	bl	8042630 <kann_new_leaf.constprop.0>
 80429b6:	4603      	mov	r3, r0
	/* g = tanh(x_t * W_g + h_{t-1} * U_g + b_g) */
	w = kann_new_weight(n1, n0);
	u = kann_new_weight(n1, n1);
	b = kann_new_bias(n1);
	g = kad_tanh(kad_add(kad_add(cmul(in, w), cmul(h0, u)), b));
 80429b8:	4651      	mov	r1, sl
 80429ba:	4628      	mov	r0, r5
kad_node_t *kann_new_vec(int n, float x) { return kann_new_leaf(KAD_VAR, x, 1, n); }
 80429bc:	461d      	mov	r5, r3
	g = kad_tanh(kad_add(kad_add(cmul(in, w), cmul(h0, u)), b));
 80429be:	47b0      	blx	r6
 80429c0:	4603      	mov	r3, r0
 80429c2:	4621      	mov	r1, r4
 80429c4:	4640      	mov	r0, r8
 80429c6:	461c      	mov	r4, r3
 80429c8:	47b0      	blx	r6
 80429ca:	4601      	mov	r1, r0
 80429cc:	4620      	mov	r0, r4
 80429ce:	f007 f927 	bl	8049c20 <kad_add>
 80429d2:	4629      	mov	r1, r5
 80429d4:	f007 f924 	bl	8049c20 <kad_add>
 80429d8:	f007 fab0 	bl	8049f3c <kad_tanh>
	/* c_t = c_{t-1} # f + g # i */
	c = kad_add(kad_mul(f, c0), kad_mul(g, i)); /* can't be kad_mul(c0, f)!!! */
 80429dc:	4649      	mov	r1, r9
	g = kad_tanh(kad_add(kad_add(cmul(in, w), cmul(h0, u)), b));
 80429de:	4605      	mov	r5, r0
	c = kad_add(kad_mul(f, c0), kad_mul(g, i)); /* can't be kad_mul(c0, f)!!! */
 80429e0:	9805      	ldr	r0, [sp, #20]
 80429e2:	f007 f96f 	bl	8049cc4 <kad_mul>
 80429e6:	9904      	ldr	r1, [sp, #16]
 80429e8:	4604      	mov	r4, r0
 80429ea:	4628      	mov	r0, r5
 80429ec:	f007 f96a 	bl	8049cc4 <kad_mul>
 80429f0:	4601      	mov	r1, r0
 80429f2:	4620      	mov	r0, r4
 80429f4:	f007 f914 	bl	8049c20 <kad_add>
	c->pre = c0;
	/* h_t = tanh(c_t) # o */
	if (rnn_flag & KANN_RNN_NORM) c = kann_layer_layernorm(c); /* see Ba et al (2016) about how to apply layer normalization to LSTM */
 80429f8:	9b03      	ldr	r3, [sp, #12]
	c->pre = c0;
 80429fa:	f8c0 903c 	str.w	r9, [r0, #60]	@ 0x3c
	if (rnn_flag & KANN_RNN_NORM) c = kann_layer_layernorm(c); /* see Ba et al (2016) about how to apply layer normalization to LSTM */
 80429fe:	bb4b      	cbnz	r3, 8042a54 <kann_layer_lstm+0x26c>
	out = kad_mul(kad_tanh(c), o);
 8042a00:	f007 fa9c 	bl	8049f3c <kad_tanh>
 8042a04:	4639      	mov	r1, r7
 8042a06:	f007 f95d 	bl	8049cc4 <kad_mul>
	out->pre = h0;
 8042a0a:	f8c0 803c 	str.w	r8, [r0, #60]	@ 0x3c
	return out;
}
 8042a0e:	b007      	add	sp, #28
 8042a10:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	h0 = (rnn_flag & KANN_RNN_VAR_H0)? kad_var(0, 0, 2, 1, n1) : kad_const(0, 2, 1, n1);
 8042a14:	4623      	mov	r3, r4
 8042a16:	2201      	movs	r2, #1
 8042a18:	2102      	movs	r1, #2
 8042a1a:	4648      	mov	r0, r9
 8042a1c:	f007 f87c 	bl	8049b18 <kad_const>
	h0->x = (float*)calloc(n1, sizeof(float));
 8042a20:	2104      	movs	r1, #4
	h0 = (rnn_flag & KANN_RNN_VAR_H0)? kad_var(0, 0, 2, 1, n1) : kad_const(0, 2, 1, n1);
 8042a22:	4680      	mov	r8, r0
	h0->x = (float*)calloc(n1, sizeof(float));
 8042a24:	4620      	mov	r0, r4
 8042a26:	f008 fefb 	bl	804b820 <calloc>
 8042a2a:	4603      	mov	r3, r0
	heapSize += n1*sizeof(float);
 8042a2c:	f8df a03c 	ldr.w	sl, [pc, #60]	@ 8042a6c <kann_layer_lstm+0x284>
	h0->x = (float*)calloc(n1, sizeof(float));
 8042a30:	f8c8 3028 	str.w	r3, [r8, #40]	@ 0x28
	heapSize += n1*sizeof(float);
 8042a34:	f8da 3000 	ldr.w	r3, [sl]
	c0 = (rnn_flag & KANN_RNN_VAR_H0)? kad_var(0, 0, 2, 1, n1) : kad_const(0, 2, 1, n1);
 8042a38:	4648      	mov	r0, r9
	heapSize += n1*sizeof(float);
 8042a3a:	445b      	add	r3, fp
 8042a3c:	f8ca 3000 	str.w	r3, [sl]
	c0 = (rnn_flag & KANN_RNN_VAR_H0)? kad_var(0, 0, 2, 1, n1) : kad_const(0, 2, 1, n1);
 8042a40:	2201      	movs	r2, #1
 8042a42:	4623      	mov	r3, r4
 8042a44:	2102      	movs	r1, #2
 8042a46:	f007 f867 	bl	8049b18 <kad_const>
 8042a4a:	4681      	mov	r9, r0
 8042a4c:	e70e      	b.n	804286c <kann_layer_lstm+0x84>
 8042a4e:	b13b      	cbz	r3, 8042a60 <kann_layer_lstm+0x278>
 8042a50:	692f      	ldr	r7, [r5, #16]
 8042a52:	e6e8      	b.n	8042826 <kann_layer_lstm+0x3e>
kad_node_t *kann_layer_layernorm(kad_node_t *in) { return kann_layer_layernorm2(0, 0, in); }
 8042a54:	2100      	movs	r1, #0
 8042a56:	4602      	mov	r2, r0
 8042a58:	4608      	mov	r0, r1
 8042a5a:	f7ff fe2f 	bl	80426bc <kann_layer_layernorm2>
 8042a5e:	e7cf      	b.n	8042a00 <kann_layer_lstm+0x218>
	int n = 1, i;
 8042a60:	2701      	movs	r7, #1
 8042a62:	e6e0      	b.n	8042826 <kann_layer_lstm+0x3e>
 8042a64:	08049d61 	.word	0x08049d61
 8042a68:	0804273d 	.word	0x0804273d
 8042a6c:	20018acc 	.word	0x20018acc

08042a70 <kann_RMSprop>:
 ***************************/

void kann_RMSprop(int n, float h0, const float *h, float decay, const float *g, float *t, float *r)
{
	int i;
	for (i = 0; i < n; ++i) {
 8042a70:	2800      	cmp	r0, #0
 8042a72:	dd60      	ble.n	8042b36 <kann_RMSprop+0xc6>
{
 8042a74:	b530      	push	{r4, r5, lr}
 8042a76:	ed2d 8b04 	vpush	{d8-d9}
		float lr = h? h[i] : h0;
		r[i] = (1.0f - decay) * g[i] * g[i] + decay * r[i];
 8042a7a:	eef7 8a00 	vmov.f32	s17, #112	@ 0x3f800000  1.0
{
 8042a7e:	b085      	sub	sp, #20
		r[i] = (1.0f - decay) * g[i] * g[i] + decay * r[i];
 8042a80:	ee78 8ae0 	vsub.f32	s17, s17, s1
 8042a84:	b359      	cbz	r1, 8042ade <kann_RMSprop+0x6e>
		t[i] -= lr / sqrtf(1e-6f + r[i]) * g[i];
 8042a86:	ed9f 9a44 	vldr	s18, [pc, #272]	@ 8042b98 <kann_RMSprop+0x128>
 8042a8a:	9c0c      	ldr	r4, [sp, #48]	@ 0x30
 8042a8c:	eb01 0580 	add.w	r5, r1, r0, lsl #2
		r[i] = (1.0f - decay) * g[i] * g[i] + decay * r[i];
 8042a90:	ecb2 7a01 	vldmia	r2!, {s14}
 8042a94:	edd4 7a00 	vldr	s15, [r4]
 8042a98:	ee67 6a28 	vmul.f32	s13, s14, s17
 8042a9c:	ee67 7aa0 	vmul.f32	s15, s15, s1
 8042aa0:	eee7 7a26 	vfma.f32	s15, s14, s13
		t[i] -= lr / sqrtf(1e-6f + r[i]) * g[i];
 8042aa4:	ee37 0a89 	vadd.f32	s0, s15, s18
 8042aa8:	eeb5 0a40 	vcmp.f32	s0, #0.0
 8042aac:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
		float lr = h? h[i] : h0;
 8042ab0:	ecb1 8a01 	vldmia	r1!, {s16}
		r[i] = (1.0f - decay) * g[i] * g[i] + decay * r[i];
 8042ab4:	ece4 7a01 	vstmia	r4!, {s15}
		t[i] -= lr / sqrtf(1e-6f + r[i]) * g[i];
 8042ab8:	d43e      	bmi.n	8042b38 <kann_RMSprop+0xc8>
 8042aba:	eeb1 6ac0 	vsqrt.f32	s12, s0
 8042abe:	edd3 7a00 	vldr	s15, [r3]
 8042ac2:	ed12 7a01 	vldr	s14, [r2, #-4]
 8042ac6:	eec8 6a06 	vdiv.f32	s13, s16, s12
 8042aca:	eee6 7ac7 	vfms.f32	s15, s13, s14
	for (i = 0; i < n; ++i) {
 8042ace:	42a9      	cmp	r1, r5
		t[i] -= lr / sqrtf(1e-6f + r[i]) * g[i];
 8042ad0:	ece3 7a01 	vstmia	r3!, {s15}
	for (i = 0; i < n; ++i) {
 8042ad4:	d1dc      	bne.n	8042a90 <kann_RMSprop+0x20>
	}
}
 8042ad6:	b005      	add	sp, #20
 8042ad8:	ecbd 8b04 	vpop	{d8-d9}
 8042adc:	bd30      	pop	{r4, r5, pc}
 8042ade:	eeb0 8a40 	vmov.f32	s16, s0
		t[i] -= lr / sqrtf(1e-6f + r[i]) * g[i];
 8042ae2:	ed9f 9a2d 	vldr	s18, [pc, #180]	@ 8042b98 <kann_RMSprop+0x128>
 8042ae6:	9d0c      	ldr	r5, [sp, #48]	@ 0x30
 8042ae8:	eb02 0480 	add.w	r4, r2, r0, lsl #2
		r[i] = (1.0f - decay) * g[i] * g[i] + decay * r[i];
 8042aec:	ecb2 7a01 	vldmia	r2!, {s14}
 8042af0:	edd5 7a00 	vldr	s15, [r5]
 8042af4:	ee67 6a28 	vmul.f32	s13, s14, s17
 8042af8:	ee60 7aa7 	vmul.f32	s15, s1, s15
 8042afc:	eee6 7a87 	vfma.f32	s15, s13, s14
		t[i] -= lr / sqrtf(1e-6f + r[i]) * g[i];
 8042b00:	ee37 0a89 	vadd.f32	s0, s15, s18
 8042b04:	eeb5 0a40 	vcmp.f32	s0, #0.0
 8042b08:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
		r[i] = (1.0f - decay) * g[i] * g[i] + decay * r[i];
 8042b0c:	ece5 7a01 	vstmia	r5!, {s15}
		t[i] -= lr / sqrtf(1e-6f + r[i]) * g[i];
 8042b10:	d42b      	bmi.n	8042b6a <kann_RMSprop+0xfa>
 8042b12:	eeb1 6ac0 	vsqrt.f32	s12, s0
 8042b16:	edd3 7a00 	vldr	s15, [r3]
 8042b1a:	ed52 6a01 	vldr	s13, [r2, #-4]
 8042b1e:	ee88 7a06 	vdiv.f32	s14, s16, s12
 8042b22:	eee6 7ac7 	vfms.f32	s15, s13, s14
	for (i = 0; i < n; ++i) {
 8042b26:	42a2      	cmp	r2, r4
		t[i] -= lr / sqrtf(1e-6f + r[i]) * g[i];
 8042b28:	ece3 7a01 	vstmia	r3!, {s15}
	for (i = 0; i < n; ++i) {
 8042b2c:	d1de      	bne.n	8042aec <kann_RMSprop+0x7c>
}
 8042b2e:	b005      	add	sp, #20
 8042b30:	ecbd 8b04 	vpop	{d8-d9}
 8042b34:	bd30      	pop	{r4, r5, pc}
 8042b36:	4770      	bx	lr
 8042b38:	e9cd 2301 	strd	r2, r3, [sp, #4]
 8042b3c:	edcd 0a03 	vstr	s1, [sp, #12]
 8042b40:	9100      	str	r1, [sp, #0]
		t[i] -= lr / sqrtf(1e-6f + r[i]) * g[i];
 8042b42:	f00a f933 	bl	804cdac <sqrtf>
 8042b46:	9b02      	ldr	r3, [sp, #8]
 8042b48:	9a01      	ldr	r2, [sp, #4]
 8042b4a:	edd3 7a00 	vldr	s15, [r3]
 8042b4e:	ed12 7a01 	vldr	s14, [r2, #-4]
 8042b52:	eec8 6a00 	vdiv.f32	s13, s16, s0
 8042b56:	eee6 7ac7 	vfms.f32	s15, s13, s14
	for (i = 0; i < n; ++i) {
 8042b5a:	9900      	ldr	r1, [sp, #0]
		t[i] -= lr / sqrtf(1e-6f + r[i]) * g[i];
 8042b5c:	ece3 7a01 	vstmia	r3!, {s15}
	for (i = 0; i < n; ++i) {
 8042b60:	42a9      	cmp	r1, r5
 8042b62:	eddd 0a03 	vldr	s1, [sp, #12]
 8042b66:	d193      	bne.n	8042a90 <kann_RMSprop+0x20>
 8042b68:	e7b5      	b.n	8042ad6 <kann_RMSprop+0x66>
 8042b6a:	e9cd 2300 	strd	r2, r3, [sp]
 8042b6e:	edcd 0a02 	vstr	s1, [sp, #8]
		t[i] -= lr / sqrtf(1e-6f + r[i]) * g[i];
 8042b72:	f00a f91b 	bl	804cdac <sqrtf>
 8042b76:	9b01      	ldr	r3, [sp, #4]
 8042b78:	9a00      	ldr	r2, [sp, #0]
 8042b7a:	edd3 7a00 	vldr	s15, [r3]
 8042b7e:	ed12 7a01 	vldr	s14, [r2, #-4]
 8042b82:	eec8 6a00 	vdiv.f32	s13, s16, s0
 8042b86:	eee6 7ac7 	vfms.f32	s15, s13, s14
	for (i = 0; i < n; ++i) {
 8042b8a:	42a2      	cmp	r2, r4
		t[i] -= lr / sqrtf(1e-6f + r[i]) * g[i];
 8042b8c:	ece3 7a01 	vstmia	r3!, {s15}
	for (i = 0; i < n; ++i) {
 8042b90:	eddd 0a02 	vldr	s1, [sp, #8]
 8042b94:	d1aa      	bne.n	8042aec <kann_RMSprop+0x7c>
 8042b96:	e79e      	b.n	8042ad6 <kann_RMSprop+0x66>
 8042b98:	358637bd 	.word	0x358637bd

08042b9c <kann_apply1>:
	kad_eval_at(a->n, a->v, i_out);
	return a->v[i_out]->x;
}

const float *kann_apply1(kann_t *a, float *x)
{
 8042b9c:	b5f0      	push	{r4, r5, r6, r7, lr}
 8042b9e:	4605      	mov	r5, r0
	for (i = k = 0; i < a->n; ++i)
 8042ba0:	6800      	ldr	r0, [r0, #0]
{
 8042ba2:	b083      	sub	sp, #12
	for (i = k = 0; i < a->n; ++i)
 8042ba4:	2800      	cmp	r0, #0
 8042ba6:	9101      	str	r1, [sp, #4]
 8042ba8:	dd14      	ble.n	8042bd4 <kann_apply1+0x38>
 8042baa:	2200      	movs	r2, #0
	int i, k, r = -1;
 8042bac:	f04f 34ff 	mov.w	r4, #4294967295
	for (i = k = 0; i < a->n; ++i)
 8042bb0:	4613      	mov	r3, r2
		if (chk_flg(a->v[i]->ext_flag, ext_flag) && chk_lbl(a->v[i]->ext_label, ext_label))
 8042bb2:	6869      	ldr	r1, [r5, #4]
 8042bb4:	f1a1 0c04 	sub.w	ip, r1, #4
 8042bb8:	f85c 6f04 	ldr.w	r6, [ip, #4]!
 8042bbc:	6a76      	ldr	r6, [r6, #36]	@ 0x24
 8042bbe:	07b6      	lsls	r6, r6, #30
			++k, r = i;
 8042bc0:	bf48      	it	mi
 8042bc2:	461c      	movmi	r4, r3
	for (i = k = 0; i < a->n; ++i)
 8042bc4:	f103 0301 	add.w	r3, r3, #1
			++k, r = i;
 8042bc8:	bf48      	it	mi
 8042bca:	3201      	addmi	r2, #1
	for (i = k = 0; i < a->n; ++i)
 8042bcc:	4298      	cmp	r0, r3
 8042bce:	d1f3      	bne.n	8042bb8 <kann_apply1+0x1c>
	return k == 1? r : k == 0? -1 : -2;
 8042bd0:	2a01      	cmp	r2, #1
 8042bd2:	d002      	beq.n	8042bda <kann_apply1+0x3e>
	if (i_out < 0) return 0;
 8042bd4:	2000      	movs	r0, #0
	return kann_apply1_to(a, x, KANN_F_OUT, 0);
}
 8042bd6:	b003      	add	sp, #12
 8042bd8:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (i_out < 0) return 0;
 8042bda:	2c00      	cmp	r4, #0
 8042bdc:	dbfa      	blt.n	8042bd4 <kann_apply1+0x38>
	kann_set_batch_size(a, 1);
 8042bde:	f007 fae7 	bl	804a1b0 <kad_sync_dim>
		if (kad_is_feed(a->v[i]) && chk_flg(a->v[i]->ext_flag, ext_flag) && chk_lbl(a->v[i]->ext_label, ext_label))
 8042be2:	e9d5 0100 	ldrd	r0, r1, [r5]
	for (i = k = 0; i < a->n; ++i)
 8042be6:	2800      	cmp	r0, #0
 8042be8:	dd1a      	ble.n	8042c20 <kann_apply1+0x84>
 8042bea:	f04f 0e00 	mov.w	lr, #0
 8042bee:	1f0b      	subs	r3, r1, #4
 8042bf0:	eb03 0680 	add.w	r6, r3, r0, lsl #2
		if (kad_is_feed(a->v[i]) && chk_flg(a->v[i]->ext_flag, ext_flag) && chk_lbl(a->v[i]->ext_label, ext_label))
 8042bf4:	f853 2f04 	ldr.w	r2, [r3, #4]!
 8042bf8:	6857      	ldr	r7, [r2, #4]
 8042bfa:	b97f      	cbnz	r7, 8042c1c <kann_apply1+0x80>
 8042bfc:	f892 c001 	ldrb.w	ip, [r2, #1]
 8042c00:	f01c 0f03 	tst.w	ip, #3
 8042c04:	d10a      	bne.n	8042c1c <kann_apply1+0x80>
			a->v[i]->x = x[k++];
 8042c06:	af02      	add	r7, sp, #8
 8042c08:	eb07 0c8e 	add.w	ip, r7, lr, lsl #2
		if (kad_is_feed(a->v[i]) && chk_flg(a->v[i]->ext_flag, ext_flag) && chk_lbl(a->v[i]->ext_label, ext_label))
 8042c0c:	6a57      	ldr	r7, [r2, #36]	@ 0x24
 8042c0e:	07ff      	lsls	r7, r7, #31
 8042c10:	d504      	bpl.n	8042c1c <kann_apply1+0x80>
			a->v[i]->x = x[k++];
 8042c12:	f85c 7c04 	ldr.w	r7, [ip, #-4]
 8042c16:	f10e 0e01 	add.w	lr, lr, #1
 8042c1a:	6297      	str	r7, [r2, #40]	@ 0x28
	for (i = k = 0; i < a->n; ++i)
 8042c1c:	429e      	cmp	r6, r3
 8042c1e:	d1e9      	bne.n	8042bf4 <kann_apply1+0x58>
	kad_eval_at(a->n, a->v, i_out);
 8042c20:	4622      	mov	r2, r4
 8042c22:	f007 fcdb 	bl	804a5dc <kad_eval_at>
	return a->v[i_out]->x;
 8042c26:	686b      	ldr	r3, [r5, #4]
 8042c28:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
 8042c2c:	6a98      	ldr	r0, [r3, #40]	@ 0x28
}
 8042c2e:	b003      	add	sp, #12
 8042c30:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8042c32:	bf00      	nop

08042c34 <kad_propagate_marks>:
 **********************************/

static void kad_propagate_marks(int n, kad_node_t **a)
{
	int i, j;
	for (i = n - 1; i >= 0; --i) {
 8042c34:	2800      	cmp	r0, #0
 8042c36:	dd2a      	ble.n	8042c8e <kad_propagate_marks+0x5a>
{
 8042c38:	b510      	push	{r4, lr}
		kad_node_t *p = a[i];
		if (p->tmp > 0) {
			if (kad_is_switch(p)) {
				int32_t *aux = (int32_t*)p->ptr;
				if (p->child[*aux]->tmp == 0)
					p->child[*aux]->tmp = 1;
 8042c3a:	2401      	movs	r4, #1
 8042c3c:	eb01 0e80 	add.w	lr, r1, r0, lsl #2
 8042c40:	e00c      	b.n	8042c5c <kad_propagate_marks+0x28>
			if (kad_is_switch(p)) {
 8042c42:	785a      	ldrb	r2, [r3, #1]
 8042c44:	0752      	lsls	r2, r2, #29
 8042c46:	d411      	bmi.n	8042c6c <kad_propagate_marks+0x38>
				if (p->child[*aux]->tmp == 0)
 8042c48:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 8042c4a:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8042c4c:	6812      	ldr	r2, [r2, #0]
 8042c4e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8042c52:	689a      	ldr	r2, [r3, #8]
 8042c54:	b902      	cbnz	r2, 8042c58 <kad_propagate_marks+0x24>
					p->child[*aux]->tmp = 1;
 8042c56:	609c      	str	r4, [r3, #8]
	for (i = n - 1; i >= 0; --i) {
 8042c58:	4571      	cmp	r1, lr
 8042c5a:	d017      	beq.n	8042c8c <kad_propagate_marks+0x58>
		kad_node_t *p = a[i];
 8042c5c:	f85e 3d04 	ldr.w	r3, [lr, #-4]!
		if (p->tmp > 0) {
 8042c60:	689a      	ldr	r2, [r3, #8]
 8042c62:	2a00      	cmp	r2, #0
 8042c64:	ddf8      	ble.n	8042c58 <kad_propagate_marks+0x24>
			if (kad_is_switch(p)) {
 8042c66:	885a      	ldrh	r2, [r3, #2]
 8042c68:	2a0c      	cmp	r2, #12
 8042c6a:	d0ea      	beq.n	8042c42 <kad_propagate_marks+0xe>
			} else {
				for (j = 0; j < p->n_child; ++j)
 8042c6c:	685a      	ldr	r2, [r3, #4]
 8042c6e:	2a00      	cmp	r2, #0
 8042c70:	ddf2      	ble.n	8042c58 <kad_propagate_marks+0x24>
					if (p->child[j]->tmp == 0)
 8042c72:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8042c74:	3b04      	subs	r3, #4
 8042c76:	eb03 0c82 	add.w	ip, r3, r2, lsl #2
 8042c7a:	f853 2f04 	ldr.w	r2, [r3, #4]!
 8042c7e:	6890      	ldr	r0, [r2, #8]
 8042c80:	b900      	cbnz	r0, 8042c84 <kad_propagate_marks+0x50>
						p->child[j]->tmp = 1;
 8042c82:	6094      	str	r4, [r2, #8]
				for (j = 0; j < p->n_child; ++j)
 8042c84:	4563      	cmp	r3, ip
 8042c86:	d1f8      	bne.n	8042c7a <kad_propagate_marks+0x46>
	for (i = n - 1; i >= 0; --i) {
 8042c88:	4571      	cmp	r1, lr
 8042c8a:	d1e7      	bne.n	8042c5c <kad_propagate_marks+0x28>
			}
		}
	}
}
 8042c8c:	bd10      	pop	{r4, pc}
 8042c8e:	4770      	bx	lr

08042c90 <kad_op_mse>:
}

/********** Cost functions **********/

int kad_op_mse(kad_node_t *p, int action)
{
 8042c90:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	kad_node_t *y1 = p->child[0]; /* test */
 8042c94:	6b83      	ldr	r3, [r0, #56]	@ 0x38
{
 8042c96:	4680      	mov	r8, r0
	kad_node_t *y1 = p->child[0]; /* test */
 8042c98:	e9d3 5400 	ldrd	r5, r4, [r3]
	for (i = 0; i < p->n_d; ++i) n *= p->d[i];
 8042c9c:	7823      	ldrb	r3, [r4, #0]
{
 8042c9e:	b082      	sub	sp, #8
 8042ca0:	b393      	cbz	r3, 8042d08 <kad_op_mse+0x78>
 8042ca2:	2b01      	cmp	r3, #1
 8042ca4:	6926      	ldr	r6, [r4, #16]
 8042ca6:	d00c      	beq.n	8042cc2 <kad_op_mse+0x32>
 8042ca8:	6962      	ldr	r2, [r4, #20]
 8042caa:	2b02      	cmp	r3, #2
 8042cac:	fb02 f606 	mul.w	r6, r2, r6
 8042cb0:	d007      	beq.n	8042cc2 <kad_op_mse+0x32>
 8042cb2:	69a2      	ldr	r2, [r4, #24]
 8042cb4:	2b03      	cmp	r3, #3
 8042cb6:	fb02 f606 	mul.w	r6, r2, r6
 8042cba:	d002      	beq.n	8042cc2 <kad_op_mse+0x32>
 8042cbc:	69e3      	ldr	r3, [r4, #28]
 8042cbe:	fb03 f606 	mul.w	r6, r3, r6
	kad_node_t *y0 = p->child[1]; /* truth */
	int i, n;

	n = kad_len(y0);
	if (action == KAD_SYNC_DIM) {
 8042cc2:	2904      	cmp	r1, #4
 8042cc4:	d007      	beq.n	8042cd6 <kad_op_mse+0x46>
		if (n != kad_len(y1)) return -1;
		p->n_d = 0;
	} else if (action == KAD_FORWARD) {
 8042cc6:	2902      	cmp	r1, #2
 8042cc8:	d024      	beq.n	8042d14 <kad_op_mse+0x84>
		double cost = 0.0;
		for (i = 0; i < n; ++i)
			cost += (y1->x[i] - y0->x[i]) * (y1->x[i] - y0->x[i]);
		p->x[0] = (float)(cost / n);
	} else if (action == KAD_BACKWARD && kad_is_back(y1)) {
 8042cca:	2903      	cmp	r1, #3
 8042ccc:	d058      	beq.n	8042d80 <kad_op_mse+0xf0>
		float t = 2.0f * p->g[0] / n;
		for (i = 0; i < n; ++i)
			y1->g[i] += t * (y1->x[i] - y0->x[i]);
	}
	return 0;
 8042cce:	2000      	movs	r0, #0
}
 8042cd0:	b002      	add	sp, #8
 8042cd2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8042cd6:	782a      	ldrb	r2, [r5, #0]
 8042cd8:	2a00      	cmp	r2, #0
 8042cda:	d076      	beq.n	8042dca <kad_op_mse+0x13a>
 8042cdc:	2a01      	cmp	r2, #1
 8042cde:	692b      	ldr	r3, [r5, #16]
 8042ce0:	d00c      	beq.n	8042cfc <kad_op_mse+0x6c>
 8042ce2:	6969      	ldr	r1, [r5, #20]
 8042ce4:	2a02      	cmp	r2, #2
 8042ce6:	fb01 f303 	mul.w	r3, r1, r3
 8042cea:	d007      	beq.n	8042cfc <kad_op_mse+0x6c>
 8042cec:	69a9      	ldr	r1, [r5, #24]
 8042cee:	2a03      	cmp	r2, #3
 8042cf0:	fb01 f303 	mul.w	r3, r1, r3
 8042cf4:	d002      	beq.n	8042cfc <kad_op_mse+0x6c>
 8042cf6:	69ea      	ldr	r2, [r5, #28]
 8042cf8:	fb02 f303 	mul.w	r3, r2, r3
		if (n != kad_len(y1)) return -1;
 8042cfc:	429e      	cmp	r6, r3
 8042cfe:	d16f      	bne.n	8042de0 <kad_op_mse+0x150>
		p->n_d = 0;
 8042d00:	2300      	movs	r3, #0
 8042d02:	f888 3000 	strb.w	r3, [r8]
 8042d06:	e7e2      	b.n	8042cce <kad_op_mse+0x3e>
	if (action == KAD_SYNC_DIM) {
 8042d08:	2904      	cmp	r1, #4
 8042d0a:	d034      	beq.n	8042d76 <kad_op_mse+0xe6>
	} else if (action == KAD_FORWARD) {
 8042d0c:	2902      	cmp	r1, #2
 8042d0e:	d05e      	beq.n	8042dce <kad_op_mse+0x13e>
	int n = 1, i;
 8042d10:	2601      	movs	r6, #1
 8042d12:	e7da      	b.n	8042cca <kad_op_mse+0x3a>
		p->x[0] = (float)(cost / n);
 8042d14:	4630      	mov	r0, r6
 8042d16:	f7fd fbe1 	bl	80404dc <__aeabi_i2d>
		for (i = 0; i < n; ++i)
 8042d1a:	2e00      	cmp	r6, #0
		p->x[0] = (float)(cost / n);
 8042d1c:	e9cd 0100 	strd	r0, r1, [sp]
		for (i = 0; i < n; ++i)
 8042d20:	dd5b      	ble.n	8042dda <kad_op_mse+0x14a>
 8042d22:	f8d5 a028 	ldr.w	sl, [r5, #40]	@ 0x28
 8042d26:	f8d4 9028 	ldr.w	r9, [r4, #40]	@ 0x28
 8042d2a:	2700      	movs	r7, #0
		double cost = 0.0;
 8042d2c:	2400      	movs	r4, #0
 8042d2e:	2500      	movs	r5, #0
			cost += (y1->x[i] - y0->x[i]) * (y1->x[i] - y0->x[i]);
 8042d30:	ecb9 7a01 	vldmia	r9!, {s14}
 8042d34:	ecfa 7a01 	vldmia	sl!, {s15}
 8042d38:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8042d3c:	ee67 7aa7 	vmul.f32	s15, s15, s15
 8042d40:	ee17 0a90 	vmov	r0, s15
 8042d44:	f7fd fbdc 	bl	8040500 <__aeabi_f2d>
 8042d48:	4602      	mov	r2, r0
 8042d4a:	460b      	mov	r3, r1
 8042d4c:	4620      	mov	r0, r4
 8042d4e:	4629      	mov	r1, r5
 8042d50:	f7fd fa78 	bl	8040244 <__adddf3>
		for (i = 0; i < n; ++i)
 8042d54:	3701      	adds	r7, #1
 8042d56:	42b7      	cmp	r7, r6
			cost += (y1->x[i] - y0->x[i]) * (y1->x[i] - y0->x[i]);
 8042d58:	4604      	mov	r4, r0
 8042d5a:	460d      	mov	r5, r1
		for (i = 0; i < n; ++i)
 8042d5c:	dbe8      	blt.n	8042d30 <kad_op_mse+0xa0>
		p->x[0] = (float)(cost / n);
 8042d5e:	e9dd 2300 	ldrd	r2, r3, [sp]
 8042d62:	4620      	mov	r0, r4
 8042d64:	4629      	mov	r1, r5
 8042d66:	f7fd fd4d 	bl	8040804 <__aeabi_ddiv>
 8042d6a:	f7fd fef9 	bl	8040b60 <__aeabi_d2f>
 8042d6e:	f8d8 3028 	ldr.w	r3, [r8, #40]	@ 0x28
 8042d72:	6018      	str	r0, [r3, #0]
 8042d74:	e7ab      	b.n	8042cce <kad_op_mse+0x3e>
	for (i = 0; i < p->n_d; ++i) n *= p->d[i];
 8042d76:	782a      	ldrb	r2, [r5, #0]
 8042d78:	2a00      	cmp	r2, #0
 8042d7a:	d0c1      	beq.n	8042d00 <kad_op_mse+0x70>
	int n = 1, i;
 8042d7c:	2601      	movs	r6, #1
 8042d7e:	e7ad      	b.n	8042cdc <kad_op_mse+0x4c>
	} else if (action == KAD_BACKWARD && kad_is_back(y1)) {
 8042d80:	786b      	ldrb	r3, [r5, #1]
 8042d82:	07db      	lsls	r3, r3, #31
 8042d84:	d5a3      	bpl.n	8042cce <kad_op_mse+0x3e>
		float t = 2.0f * p->g[0] / n;
 8042d86:	f8d8 302c 	ldr.w	r3, [r8, #44]	@ 0x2c
 8042d8a:	ee07 6a10 	vmov	s14, r6
 8042d8e:	edd3 7a00 	vldr	s15, [r3]
 8042d92:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 8042d96:	ee77 7aa7 	vadd.f32	s15, s15, s15
		for (i = 0; i < n; ++i)
 8042d9a:	2e00      	cmp	r6, #0
		float t = 2.0f * p->g[0] / n;
 8042d9c:	ee87 6a87 	vdiv.f32	s12, s15, s14
		for (i = 0; i < n; ++i)
 8042da0:	dd95      	ble.n	8042cce <kad_op_mse+0x3e>
 8042da2:	e9d5 130a 	ldrd	r1, r3, [r5, #40]	@ 0x28
 8042da6:	6aa2      	ldr	r2, [r4, #40]	@ 0x28
 8042da8:	eb03 0686 	add.w	r6, r3, r6, lsl #2
			y1->g[i] += t * (y1->x[i] - y0->x[i]);
 8042dac:	ecb1 7a01 	vldmia	r1!, {s14}
 8042db0:	ecf2 6a01 	vldmia	r2!, {s13}
 8042db4:	edd3 7a00 	vldr	s15, [r3]
 8042db8:	ee37 7a66 	vsub.f32	s14, s14, s13
 8042dbc:	eee7 7a06 	vfma.f32	s15, s14, s12
 8042dc0:	ece3 7a01 	vstmia	r3!, {s15}
		for (i = 0; i < n; ++i)
 8042dc4:	42b3      	cmp	r3, r6
 8042dc6:	d1f1      	bne.n	8042dac <kad_op_mse+0x11c>
 8042dc8:	e781      	b.n	8042cce <kad_op_mse+0x3e>
 8042dca:	2301      	movs	r3, #1
 8042dcc:	e796      	b.n	8042cfc <kad_op_mse+0x6c>
	} else if (action == KAD_FORWARD) {
 8042dce:	ed9f 7b06 	vldr	d7, [pc, #24]	@ 8042de8 <kad_op_mse+0x158>
 8042dd2:	2601      	movs	r6, #1
 8042dd4:	ed8d 7b00 	vstr	d7, [sp]
 8042dd8:	e7a3      	b.n	8042d22 <kad_op_mse+0x92>
		double cost = 0.0;
 8042dda:	2400      	movs	r4, #0
 8042ddc:	2500      	movs	r5, #0
 8042dde:	e7be      	b.n	8042d5e <kad_op_mse+0xce>
		if (n != kad_len(y1)) return -1;
 8042de0:	f04f 30ff 	mov.w	r0, #4294967295
 8042de4:	e774      	b.n	8042cd0 <kad_op_mse+0x40>
 8042de6:	bf00      	nop
 8042de8:	00000000 	.word	0x00000000
 8042dec:	3ff00000 	.word	0x3ff00000

08042df0 <conv2d_add_3to1>:
					y[(ik + l) * d[1] + j] = x[ijk + l];
			}
}

static void conv2d_add_3to1(int d[4], const float *y, float *x) /* convert the NHWC shape back to NCHW and add to another NCHW-shaped array */
{
 8042df0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	int i, j, k, l;
	for (i = 0; i < d[0]; ++i)
 8042df4:	f8d0 c000 	ldr.w	ip, [r0]
{
 8042df8:	b089      	sub	sp, #36	@ 0x24
	for (i = 0; i < d[0]; ++i)
 8042dfa:	f1bc 0f00 	cmp.w	ip, #0
{
 8042dfe:	9103      	str	r1, [sp, #12]
	for (i = 0; i < d[0]; ++i)
 8042e00:	dd5d      	ble.n	8042ebe <conv2d_add_3to1+0xce>
		for (j = 0; j < d[1]; ++j)
 8042e02:	6843      	ldr	r3, [r0, #4]
 8042e04:	4604      	mov	r4, r0
 8042e06:	2b00      	cmp	r3, #0
 8042e08:	9302      	str	r3, [sp, #8]
 8042e0a:	dd58      	ble.n	8042ebe <conv2d_add_3to1+0xce>
 8042e0c:	4693      	mov	fp, r2
			for (k = 0; k < d[2]; ++k) {
 8042e0e:	2200      	movs	r2, #0
 8042e10:	4625      	mov	r5, r4
	for (i = 0; i < d[0]; ++i)
 8042e12:	4611      	mov	r1, r2
 8042e14:	4667      	mov	r7, ip
 8042e16:	4614      	mov	r4, r2
			for (k = 0; k < d[2]; ++k) {
 8042e18:	6886      	ldr	r6, [r0, #8]
 8042e1a:	0098      	lsls	r0, r3, #2
		for (j = 0; j < d[1]; ++j)
 8042e1c:	2e00      	cmp	r6, #0
				int ik = (i * d[2] + k) * d[3], ijk = ((i * d[1] + j) * d[2] + k) * d[3];
 8042e1e:	fb06 f301 	mul.w	r3, r6, r1
 8042e22:	dd47      	ble.n	8042eb4 <conv2d_add_3to1+0xc4>
		for (j = 0; j < d[1]; ++j)
 8042e24:	f04f 0900 	mov.w	r9, #0
				int ik = (i * d[2] + k) * d[3], ijk = ((i * d[1] + j) * d[2] + k) * d[3];
 8042e28:	f8d5 c00c 	ldr.w	ip, [r5, #12]
 8042e2c:	9a02      	ldr	r2, [sp, #8]
 8042e2e:	fb0c f303 	mul.w	r3, ip, r3
 8042e32:	fb02 fe0c 	mul.w	lr, r2, ip
 8042e36:	fb06 fa04 	mul.w	sl, r6, r4
 8042e3a:	fb02 f303 	mul.w	r3, r2, r3
 8042e3e:	ea4f 0e8e 	mov.w	lr, lr, lsl #2
 8042e42:	ea4f 088c 	mov.w	r8, ip, lsl #2
			for (k = 0; k < d[2]; ++k) {
 8042e46:	f1bc 0f00 	cmp.w	ip, #0
 8042e4a:	dd3b      	ble.n	8042ec4 <conv2d_add_3to1+0xd4>
 8042e4c:	e9cd 1704 	strd	r1, r7, [sp, #16]
 8042e50:	e9cd 4506 	strd	r4, r5, [sp, #24]
 8042e54:	2500      	movs	r5, #0
 8042e56:	fb0a f20c 	mul.w	r2, sl, ip
 8042e5a:	9903      	ldr	r1, [sp, #12]
 8042e5c:	eb03 0409 	add.w	r4, r3, r9
 8042e60:	eb02 070c 	add.w	r7, r2, ip
 8042e64:	eb01 0484 	add.w	r4, r1, r4, lsl #2
 8042e68:	f8cd 9004 	str.w	r9, [sp, #4]
 8042e6c:	eb0b 0187 	add.w	r1, fp, r7, lsl #2
 8042e70:	46a1      	mov	r9, r4
 8042e72:	eb0b 0282 	add.w	r2, fp, r2, lsl #2
				for (l = 0; l < d[3]; ++l)
					x[ijk + l] += y[(ik + l) * d[1] + j];
 8042e76:	edd9 7a00 	vldr	s15, [r9]
 8042e7a:	ed92 7a00 	vldr	s14, [r2]
 8042e7e:	ee77 7a87 	vadd.f32	s15, s15, s14
 8042e82:	ece2 7a01 	vstmia	r2!, {s15}
				for (l = 0; l < d[3]; ++l)
 8042e86:	4291      	cmp	r1, r2
 8042e88:	4481      	add	r9, r0
 8042e8a:	d1f4      	bne.n	8042e76 <conv2d_add_3to1+0x86>
			for (k = 0; k < d[2]; ++k) {
 8042e8c:	3501      	adds	r5, #1
 8042e8e:	42b5      	cmp	r5, r6
 8042e90:	463a      	mov	r2, r7
 8042e92:	4474      	add	r4, lr
 8042e94:	4441      	add	r1, r8
 8042e96:	d001      	beq.n	8042e9c <conv2d_add_3to1+0xac>
 8042e98:	4467      	add	r7, ip
 8042e9a:	e7e9      	b.n	8042e70 <conv2d_add_3to1+0x80>
		for (j = 0; j < d[1]; ++j)
 8042e9c:	f8dd 9004 	ldr.w	r9, [sp, #4]
 8042ea0:	9a02      	ldr	r2, [sp, #8]
 8042ea2:	f109 0901 	add.w	r9, r9, #1
 8042ea6:	454a      	cmp	r2, r9
 8042ea8:	44b2      	add	sl, r6
 8042eaa:	d1d3      	bne.n	8042e54 <conv2d_add_3to1+0x64>
 8042eac:	e9dd 1704 	ldrd	r1, r7, [sp, #16]
 8042eb0:	e9dd 4506 	ldrd	r4, r5, [sp, #24]
	for (i = 0; i < d[0]; ++i)
 8042eb4:	9b02      	ldr	r3, [sp, #8]
 8042eb6:	3101      	adds	r1, #1
 8042eb8:	42b9      	cmp	r1, r7
 8042eba:	441c      	add	r4, r3
 8042ebc:	d1ae      	bne.n	8042e1c <conv2d_add_3to1+0x2c>
			}
}
 8042ebe:	b009      	add	sp, #36	@ 0x24
 8042ec0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		for (j = 0; j < d[1]; ++j)
 8042ec4:	9a02      	ldr	r2, [sp, #8]
 8042ec6:	f109 0901 	add.w	r9, r9, #1
 8042eca:	4591      	cmp	r9, r2
 8042ecc:	44b2      	add	sl, r6
 8042ece:	d1ba      	bne.n	8042e46 <conv2d_add_3to1+0x56>
 8042ed0:	e7f0      	b.n	8042eb4 <conv2d_add_3to1+0xc4>
 8042ed2:	bf00      	nop

08042ed4 <kad_op_max2d>:
	free(t); free(q1); free(w1); free(x_padded);
	return 0;
}

int kad_op_max2d(kad_node_t *p, int action)
{
 8042ed4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	conv_conf_t *aux = (conv_conf_t*)p->ptr;
	kad_node_t *q = p->child[0];
 8042ed8:	6b82      	ldr	r2, [r0, #56]	@ 0x38
	if (action == KAD_SYNC_DIM) {
 8042eda:	2904      	cmp	r1, #4
{
 8042edc:	4683      	mov	fp, r0
	conv_conf_t *aux = (conv_conf_t*)p->ptr;
 8042ede:	f8d0 c030 	ldr.w	ip, [r0, #48]	@ 0x30
	kad_node_t *q = p->child[0];
 8042ee2:	f8d2 8000 	ldr.w	r8, [r2]
{
 8042ee6:	b08f      	sub	sp, #60	@ 0x3c
	if (action == KAD_SYNC_DIM) {
 8042ee8:	d028      	beq.n	8042f3c <kad_op_max2d+0x68>
		if (q->n_d != 4) return -1;
		p->n_d = 4;
		p->d[0] = q->d[0], p->d[1] = q->d[1], p->d[2] = conv_out_size(q->d[2], &aux[0]), p->d[3] = conv_out_size(q->d[3], &aux[1]);
	} else if (action == KAD_ALLOC) {
 8042eea:	2901      	cmp	r1, #1
 8042eec:	d008      	beq.n	8042f00 <kad_op_max2d+0x2c>
		p->gtmp = realloc(p->gtmp, kad_len(p) * sizeof(int));
	} else if (action == KAD_FORWARD) {
 8042eee:	2902      	cmp	r1, #2
 8042ef0:	f000 8081 	beq.w	8042ff6 <kad_op_max2d+0x122>
							if (p->x[u + j] < q->x[v])
								p->x[u + j] = q->x[v], f[u + j] = v;
				} /* ~k */
			} /* ~i */
		}
	} else if (action == KAD_BACKWARD) {
 8042ef4:	2903      	cmp	r1, #3
 8042ef6:	d050      	beq.n	8042f9a <kad_op_max2d+0xc6>
		int i, len, *f = (int*)p->gtmp;
		len = kad_len(p);
		for (i = 0; i < len; ++i) q->g[f[i]] += p->g[i];
	}
	return 0;
 8042ef8:	2000      	movs	r0, #0
}
 8042efa:	b00f      	add	sp, #60	@ 0x3c
 8042efc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	for (i = 0; i < p->n_d; ++i) n *= p->d[i];
 8042f00:	7802      	ldrb	r2, [r0, #0]
		p->gtmp = realloc(p->gtmp, kad_len(p) * sizeof(int));
 8042f02:	6b40      	ldr	r0, [r0, #52]	@ 0x34
 8042f04:	2a00      	cmp	r2, #0
 8042f06:	f000 814a 	beq.w	804319e <kad_op_max2d+0x2ca>
 8042f0a:	2a01      	cmp	r2, #1
 8042f0c:	f8db 1010 	ldr.w	r1, [fp, #16]
 8042f10:	d00e      	beq.n	8042f30 <kad_op_max2d+0x5c>
 8042f12:	f8db 3014 	ldr.w	r3, [fp, #20]
 8042f16:	2a02      	cmp	r2, #2
 8042f18:	fb03 f101 	mul.w	r1, r3, r1
 8042f1c:	d008      	beq.n	8042f30 <kad_op_max2d+0x5c>
 8042f1e:	f8db 3018 	ldr.w	r3, [fp, #24]
 8042f22:	2a03      	cmp	r2, #3
 8042f24:	fb03 f101 	mul.w	r1, r3, r1
 8042f28:	bf1c      	itt	ne
 8042f2a:	f8db 201c 	ldrne.w	r2, [fp, #28]
 8042f2e:	4351      	mulne	r1, r2
 8042f30:	0089      	lsls	r1, r1, #2
 8042f32:	f008 fd7d 	bl	804ba30 <realloc>
 8042f36:	f8cb 0034 	str.w	r0, [fp, #52]	@ 0x34
 8042f3a:	e7dd      	b.n	8042ef8 <kad_op_max2d+0x24>
		if (q->n_d != 4) return -1;
 8042f3c:	f898 3000 	ldrb.w	r3, [r8]
 8042f40:	2b04      	cmp	r3, #4
 8042f42:	f040 812e 	bne.w	80431a2 <kad_op_max2d+0x2ce>
		p->n_d = 4;
 8042f46:	7003      	strb	r3, [r0, #0]
		p->d[0] = q->d[0], p->d[1] = q->d[1], p->d[2] = conv_out_size(q->d[2], &aux[0]), p->d[3] = conv_out_size(q->d[3], &aux[1]);
 8042f48:	e9d8 2304 	ldrd	r2, r3, [r8, #16]
 8042f4c:	e9c0 2304 	strd	r2, r3, [r0, #16]
 8042f50:	f8dc 1000 	ldr.w	r1, [ip]
 8042f54:	f8d8 2018 	ldr.w	r2, [r8, #24]
 8042f58:	f8d8 301c 	ldr.w	r3, [r8, #28]
 8042f5c:	1a52      	subs	r2, r2, r1
 8042f5e:	f8dc 1008 	ldr.w	r1, [ip, #8]
 8042f62:	f8dc 001c 	ldr.w	r0, [ip, #28]
 8042f66:	440a      	add	r2, r1
 8042f68:	f8dc 100c 	ldr.w	r1, [ip, #12]
 8042f6c:	440a      	add	r2, r1
 8042f6e:	f8dc 1004 	ldr.w	r1, [ip, #4]
 8042f72:	fb92 f2f1 	sdiv	r2, r2, r1
 8042f76:	f8dc 1010 	ldr.w	r1, [ip, #16]
 8042f7a:	3201      	adds	r2, #1
 8042f7c:	1a5b      	subs	r3, r3, r1
 8042f7e:	f8dc 1018 	ldr.w	r1, [ip, #24]
 8042f82:	440b      	add	r3, r1
 8042f84:	f8dc 1014 	ldr.w	r1, [ip, #20]
 8042f88:	4403      	add	r3, r0
 8042f8a:	fb93 f3f1 	sdiv	r3, r3, r1
 8042f8e:	3301      	adds	r3, #1
 8042f90:	f8cb 2018 	str.w	r2, [fp, #24]
 8042f94:	f8cb 301c 	str.w	r3, [fp, #28]
 8042f98:	e7ae      	b.n	8042ef8 <kad_op_max2d+0x24>
 8042f9a:	7801      	ldrb	r1, [r0, #0]
		int i, len, *f = (int*)p->gtmp;
 8042f9c:	6b42      	ldr	r2, [r0, #52]	@ 0x34
 8042f9e:	2900      	cmp	r1, #0
 8042fa0:	f000 80fb 	beq.w	804319a <kad_op_max2d+0x2c6>
 8042fa4:	2901      	cmp	r1, #1
 8042fa6:	6903      	ldr	r3, [r0, #16]
 8042fa8:	d00d      	beq.n	8042fc6 <kad_op_max2d+0xf2>
 8042faa:	6940      	ldr	r0, [r0, #20]
 8042fac:	2902      	cmp	r1, #2
 8042fae:	fb00 f303 	mul.w	r3, r0, r3
 8042fb2:	d008      	beq.n	8042fc6 <kad_op_max2d+0xf2>
 8042fb4:	f8db 0018 	ldr.w	r0, [fp, #24]
 8042fb8:	2903      	cmp	r1, #3
 8042fba:	fb00 f303 	mul.w	r3, r0, r3
 8042fbe:	bf1c      	itt	ne
 8042fc0:	f8db 101c 	ldrne.w	r1, [fp, #28]
 8042fc4:	434b      	mulne	r3, r1
		for (i = 0; i < len; ++i) q->g[f[i]] += p->g[i];
 8042fc6:	2b00      	cmp	r3, #0
 8042fc8:	dd96      	ble.n	8042ef8 <kad_op_max2d+0x24>
 8042fca:	2000      	movs	r0, #0
 8042fcc:	f8d8 502c 	ldr.w	r5, [r8, #44]	@ 0x2c
 8042fd0:	f8db 402c 	ldr.w	r4, [fp, #44]	@ 0x2c
 8042fd4:	3a04      	subs	r2, #4
 8042fd6:	f852 1f04 	ldr.w	r1, [r2, #4]!
 8042fda:	ecb4 7a01 	vldmia	r4!, {s14}
 8042fde:	eb05 0181 	add.w	r1, r5, r1, lsl #2
 8042fe2:	edd1 7a00 	vldr	s15, [r1]
 8042fe6:	ee77 7a87 	vadd.f32	s15, s15, s14
 8042fea:	3001      	adds	r0, #1
 8042fec:	4283      	cmp	r3, r0
 8042fee:	edc1 7a00 	vstr	s15, [r1]
 8042ff2:	dcf0      	bgt.n	8042fd6 <kad_op_max2d+0x102>
 8042ff4:	e780      	b.n	8042ef8 <kad_op_max2d+0x24>
 8042ff6:	7801      	ldrb	r1, [r0, #0]
		int *f = (int*)p->gtmp;
 8042ff8:	6b47      	ldr	r7, [r0, #52]	@ 0x34
 8042ffa:	2900      	cmp	r1, #0
 8042ffc:	f000 80e1 	beq.w	80431c2 <kad_op_max2d+0x2ee>
 8043000:	2901      	cmp	r1, #1
 8043002:	6903      	ldr	r3, [r0, #16]
 8043004:	f000 80d9 	beq.w	80431ba <kad_op_max2d+0x2e6>
 8043008:	6944      	ldr	r4, [r0, #20]
 804300a:	2902      	cmp	r1, #2
 804300c:	fb04 f203 	mul.w	r2, r4, r3
 8043010:	f000 80ca 	beq.w	80431a8 <kad_op_max2d+0x2d4>
 8043014:	6980      	ldr	r0, [r0, #24]
 8043016:	2903      	cmp	r1, #3
 8043018:	fb00 f202 	mul.w	r2, r0, r2
 804301c:	f000 80c9 	beq.w	80431b2 <kad_op_max2d+0x2de>
 8043020:	f8db 001c 	ldr.w	r0, [fp, #28]
 8043024:	fb00 f202 	mul.w	r2, r0, r2
		for (i = 0; i < len; ++i) p->x[i] = -FLT_MAX;
 8043028:	2a00      	cmp	r2, #0
 804302a:	dd13      	ble.n	8043054 <kad_op_max2d+0x180>
 804302c:	2300      	movs	r3, #0
 804302e:	f46f 0400 	mvn.w	r4, #8388608	@ 0x800000
 8043032:	f8db 0028 	ldr.w	r0, [fp, #40]	@ 0x28
 8043036:	3301      	adds	r3, #1
 8043038:	429a      	cmp	r2, r3
 804303a:	f840 4b04 	str.w	r4, [r0], #4
 804303e:	dcfa      	bgt.n	8043036 <kad_op_max2d+0x162>
		for (i = 0; i < p->n_d - 2; ++i) rest *= p->d[i];
 8043040:	1e8a      	subs	r2, r1, #2
 8043042:	2a00      	cmp	r2, #0
 8043044:	f340 80b3 	ble.w	80431ae <kad_op_max2d+0x2da>
 8043048:	2a02      	cmp	r2, #2
 804304a:	f8db 3010 	ldr.w	r3, [fp, #16]
 804304e:	d103      	bne.n	8043058 <kad_op_max2d+0x184>
 8043050:	f8db 4014 	ldr.w	r4, [fp, #20]
 8043054:	fb04 f303 	mul.w	r3, r4, r3
		for (t = 0; t < rest; ++t) {
 8043058:	2b00      	cmp	r3, #0
 804305a:	f77f af4d 	ble.w	8042ef8 <kad_op_max2d+0x24>
 804305e:	eb0b 0281 	add.w	r2, fp, r1, lsl #2
			int i, j, k, l, p_row = p->d[p->n_d - 2], p_col = p->d[p->n_d - 1];
 8043062:	e9d2 0a02 	ldrd	r0, sl, [r2, #8]
 8043066:	2800      	cmp	r0, #0
 8043068:	ea4f 0181 	mov.w	r1, r1, lsl #2
 804306c:	f77f af44 	ble.w	8042ef8 <kad_op_max2d+0x24>
 8043070:	2400      	movs	r4, #0
 8043072:	f8dc 9000 	ldr.w	r9, [ip]
 8043076:	eb08 0201 	add.w	r2, r8, r1
 804307a:	fb0a fe00 	mul.w	lr, sl, r0
		for (t = 0; t < rest; ++t) {
 804307e:	4619      	mov	r1, r3
 8043080:	9008      	str	r0, [sp, #32]
 8043082:	4623      	mov	r3, r4
 8043084:	4648      	mov	r0, r9
 8043086:	ea4f 068a 	mov.w	r6, sl, lsl #2
 804308a:	9202      	str	r2, [sp, #8]
 804308c:	9405      	str	r4, [sp, #20]
 804308e:	f8cd 8004 	str.w	r8, [sp, #4]
 8043092:	9609      	str	r6, [sp, #36]	@ 0x24
			for (i = 0; i < p_row; ++i) {
 8043094:	f04f 0900 	mov.w	r9, #0
				for (k = 0; k < aux[0].kernel_size; ++k) {
 8043098:	2800      	cmp	r0, #0
 804309a:	461c      	mov	r4, r3
 804309c:	46c8      	mov	r8, r9
 804309e:	e9cd e70a 	strd	lr, r7, [sp, #40]	@ 0x28
 80430a2:	e9cd 130c 	strd	r1, r3, [sp, #48]	@ 0x30
 80430a6:	eb07 0683 	add.w	r6, r7, r3, lsl #2
 80430aa:	dd6a      	ble.n	8043182 <kad_op_max2d+0x2ae>
 80430ac:	ea4f 0984 	mov.w	r9, r4, lsl #2
 80430b0:	e9cd 9406 	strd	r9, r4, [sp, #24]
 80430b4:	2300      	movs	r3, #0
 80430b6:	46c1      	mov	r9, r8
 80430b8:	e002      	b.n	80430c0 <kad_op_max2d+0x1ec>
 80430ba:	3301      	adds	r3, #1
 80430bc:	4283      	cmp	r3, r0
 80430be:	da55      	bge.n	804316c <kad_op_max2d+0x298>
					int v, v0, v_end, ii = i * aux[0].stride + k - aux[0].pad[0];
 80430c0:	f8dc 2004 	ldr.w	r2, [ip, #4]
 80430c4:	f8dc 1008 	ldr.w	r1, [ip, #8]
 80430c8:	fb02 3209 	mla	r2, r2, r9, r3
					if (ii < 0 || ii >= q->d[p->n_d - 2]) continue;
 80430cc:	1a52      	subs	r2, r2, r1
 80430ce:	d4f4      	bmi.n	80430ba <kad_op_max2d+0x1e6>
 80430d0:	9c02      	ldr	r4, [sp, #8]
 80430d2:	68a1      	ldr	r1, [r4, #8]
 80430d4:	4291      	cmp	r1, r2
 80430d6:	ddf0      	ble.n	80430ba <kad_op_max2d+0x1e6>
					v0 = (t * q->d[p->n_d - 2] + ii) * q->d[p->n_d - 1];
 80430d8:	9d05      	ldr	r5, [sp, #20]
 80430da:	f8d4 800c 	ldr.w	r8, [r4, #12]
 80430de:	fb05 2201 	mla	r2, r5, r1, r2
 80430e2:	fb08 fe02 	mul.w	lr, r8, r2
					for (l = 0; l < aux[1].kernel_size; ++l)
 80430e6:	f8dc 4010 	ldr.w	r4, [ip, #16]
					v_end = v0 + q->d[p->n_d - 1];
 80430ea:	eb08 050e 	add.w	r5, r8, lr
					for (l = 0; l < aux[1].kernel_size; ++l)
 80430ee:	2c00      	cmp	r4, #0
 80430f0:	dde3      	ble.n	80430ba <kad_op_max2d+0x1e6>
 80430f2:	2700      	movs	r7, #0
 80430f4:	e9cd 9303 	strd	r9, r3, [sp, #12]
 80430f8:	f8dd 9018 	ldr.w	r9, [sp, #24]
						for (j = 0, v = v0 + (l > aux[1].pad[0]? l - aux[1].pad[0] : 0); j < p_col && v < v_end; ++j, v += aux[1].stride)
 80430fc:	f8dc 2018 	ldr.w	r2, [ip, #24]
 8043100:	42ba      	cmp	r2, r7
 8043102:	bfb3      	iteet	lt
 8043104:	1aba      	sublt	r2, r7, r2
					v0 = (t * q->d[p->n_d - 2] + ii) * q->d[p->n_d - 1];
 8043106:	4673      	movge	r3, lr
						for (j = 0, v = v0 + (l > aux[1].pad[0]? l - aux[1].pad[0] : 0); j < p_col && v < v_end; ++j, v += aux[1].stride)
 8043108:	2200      	movge	r2, #0
 804310a:	eb0e 0302 	addlt.w	r3, lr, r2
 804310e:	f1ba 0f00 	cmp.w	sl, #0
 8043112:	dd21      	ble.n	8043158 <kad_op_max2d+0x284>
 8043114:	4590      	cmp	r8, r2
 8043116:	dd1f      	ble.n	8043158 <kad_op_max2d+0x284>
 8043118:	f8db 1028 	ldr.w	r1, [fp, #40]	@ 0x28
							if (p->x[u + j] < q->x[v])
 804311c:	9801      	ldr	r0, [sp, #4]
						for (j = 0, v = v0 + (l > aux[1].pad[0]? l - aux[1].pad[0] : 0); j < p_col && v < v_end; ++j, v += aux[1].stride)
 804311e:	2200      	movs	r2, #0
							if (p->x[u + j] < q->x[v])
 8043120:	6a84      	ldr	r4, [r0, #40]	@ 0x28
 8043122:	4449      	add	r1, r9
 8043124:	e001      	b.n	804312a <kad_op_max2d+0x256>
						for (j = 0, v = v0 + (l > aux[1].pad[0]? l - aux[1].pad[0] : 0); j < p_col && v < v_end; ++j, v += aux[1].stride)
 8043126:	429d      	cmp	r5, r3
 8043128:	dd14      	ble.n	8043154 <kad_op_max2d+0x280>
							if (p->x[u + j] < q->x[v])
 804312a:	eb04 0083 	add.w	r0, r4, r3, lsl #2
 804312e:	edd0 7a00 	vldr	s15, [r0]
 8043132:	ecb1 7a01 	vldmia	r1!, {s14}
 8043136:	eeb4 7ae7 	vcmpe.f32	s14, s15
 804313a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
								p->x[u + j] = q->x[v], f[u + j] = v;
 804313e:	bf44      	itt	mi
 8043140:	ed41 7a01 	vstrmi	s15, [r1, #-4]
 8043144:	f846 3022 	strmi.w	r3, [r6, r2, lsl #2]
						for (j = 0, v = v0 + (l > aux[1].pad[0]? l - aux[1].pad[0] : 0); j < p_col && v < v_end; ++j, v += aux[1].stride)
 8043148:	f8dc 0014 	ldr.w	r0, [ip, #20]
 804314c:	3201      	adds	r2, #1
 804314e:	4592      	cmp	sl, r2
 8043150:	4403      	add	r3, r0
 8043152:	d1e8      	bne.n	8043126 <kad_op_max2d+0x252>
 8043154:	f8dc 4010 	ldr.w	r4, [ip, #16]
					for (l = 0; l < aux[1].kernel_size; ++l)
 8043158:	3701      	adds	r7, #1
 804315a:	42bc      	cmp	r4, r7
 804315c:	dcce      	bgt.n	80430fc <kad_op_max2d+0x228>
 804315e:	e9dd 9303 	ldrd	r9, r3, [sp, #12]
				for (k = 0; k < aux[0].kernel_size; ++k) {
 8043162:	f8dc 0000 	ldr.w	r0, [ip]
 8043166:	3301      	adds	r3, #1
 8043168:	4283      	cmp	r3, r0
 804316a:	dba9      	blt.n	80430c0 <kad_op_max2d+0x1ec>
			for (i = 0; i < p_row; ++i) {
 804316c:	9b08      	ldr	r3, [sp, #32]
 804316e:	f109 0801 	add.w	r8, r9, #1
 8043172:	4543      	cmp	r3, r8
 8043174:	9c07      	ldr	r4, [sp, #28]
 8043176:	d004      	beq.n	8043182 <kad_op_max2d+0x2ae>
 8043178:	9b09      	ldr	r3, [sp, #36]	@ 0x24
				for (k = 0; k < aux[0].kernel_size; ++k) {
 804317a:	2800      	cmp	r0, #0
 804317c:	4454      	add	r4, sl
 804317e:	441e      	add	r6, r3
 8043180:	dc94      	bgt.n	80430ac <kad_op_max2d+0x1d8>
		for (t = 0; t < rest; ++t) {
 8043182:	e9dd 130c 	ldrd	r1, r3, [sp, #48]	@ 0x30
 8043186:	e9dd e70a 	ldrd	lr, r7, [sp, #40]	@ 0x28
 804318a:	9a05      	ldr	r2, [sp, #20]
 804318c:	4473      	add	r3, lr
 804318e:	3201      	adds	r2, #1
 8043190:	428a      	cmp	r2, r1
 8043192:	9205      	str	r2, [sp, #20]
 8043194:	f6ff af7e 	blt.w	8043094 <kad_op_max2d+0x1c0>
 8043198:	e6ae      	b.n	8042ef8 <kad_op_max2d+0x24>
	int n = 1, i;
 804319a:	2301      	movs	r3, #1
 804319c:	e715      	b.n	8042fca <kad_op_max2d+0xf6>
	for (i = 0; i < p->n_d; ++i) n *= p->d[i];
 804319e:	2104      	movs	r1, #4
 80431a0:	e6c7      	b.n	8042f32 <kad_op_max2d+0x5e>
		if (q->n_d != 4) return -1;
 80431a2:	f04f 30ff 	mov.w	r0, #4294967295
 80431a6:	e6a8      	b.n	8042efa <kad_op_max2d+0x26>
		for (i = 0; i < len; ++i) p->x[i] = -FLT_MAX;
 80431a8:	2a00      	cmp	r2, #0
 80431aa:	f73f af3f 	bgt.w	804302c <kad_op_max2d+0x158>
		int rest = 1, len, t, i;
 80431ae:	2301      	movs	r3, #1
 80431b0:	e755      	b.n	804305e <kad_op_max2d+0x18a>
		for (i = 0; i < len; ++i) p->x[i] = -FLT_MAX;
 80431b2:	2a00      	cmp	r2, #0
 80431b4:	f73f af3a 	bgt.w	804302c <kad_op_max2d+0x158>
 80431b8:	e74e      	b.n	8043058 <kad_op_max2d+0x184>
 80431ba:	2b00      	cmp	r3, #0
 80431bc:	ddf7      	ble.n	80431ae <kad_op_max2d+0x2da>
 80431be:	461a      	mov	r2, r3
 80431c0:	e734      	b.n	804302c <kad_op_max2d+0x158>
	int n = 1, i;
 80431c2:	2201      	movs	r2, #1
 80431c4:	e732      	b.n	804302c <kad_op_max2d+0x158>
 80431c6:	bf00      	nop

080431c8 <kad_op_max1d>:
	free(t); free(q1); free(w1); free(x_padded);
	return 0;
}

int kad_op_max1d(kad_node_t *p, int action)
{
 80431c8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	conv_conf_t *aux = (conv_conf_t*)p->ptr;
	kad_node_t *q = p->child[0];
 80431cc:	6b83      	ldr	r3, [r0, #56]	@ 0x38
	if (action == KAD_SYNC_DIM) {
 80431ce:	2904      	cmp	r1, #4
{
 80431d0:	4605      	mov	r5, r0
	kad_node_t *q = p->child[0];
 80431d2:	f8d3 8000 	ldr.w	r8, [r3]
	conv_conf_t *aux = (conv_conf_t*)p->ptr;
 80431d6:	6b00      	ldr	r0, [r0, #48]	@ 0x30
{
 80431d8:	b087      	sub	sp, #28
	if (action == KAD_SYNC_DIM) {
 80431da:	d022      	beq.n	8043222 <kad_op_max1d+0x5a>
		if (q->n_d != 3) return -1;
		p->n_d = 3;
		p->d[0] = q->d[0], p->d[1] = q->d[1], p->d[2] = conv_out_size(q->d[2], aux);
	} else if (action == KAD_ALLOC) {
 80431dc:	2901      	cmp	r1, #1
 80431de:	d007      	beq.n	80431f0 <kad_op_max1d+0x28>
		p->gtmp = realloc(p->gtmp, kad_len(p) * sizeof(int));
	} else if (action == KAD_FORWARD) {
 80431e0:	2902      	cmp	r1, #2
 80431e2:	d061      	beq.n	80432a8 <kad_op_max1d+0xe0>
			for (l = 0; l < aux->kernel_size; ++l)
				for (j = 0, v = v0 + (l > aux->pad[0]? l - aux->pad[0] : 0); j < p_width && v < v_end; ++j, v += aux->stride)
					if (p->x[u + j] < q->x[v])
						p->x[u + j] = q->x[v], f[u + j] = v;
		}
	} else if (action == KAD_BACKWARD) {
 80431e4:	2903      	cmp	r1, #3
 80431e6:	d034      	beq.n	8043252 <kad_op_max1d+0x8a>
		int i, len, *f = (int*)p->gtmp;
		len = kad_len(p);
		for (i = 0; i < len; ++i) q->g[f[i]] += p->g[i];
	}
	return 0;
 80431e8:	2000      	movs	r0, #0
}
 80431ea:	b007      	add	sp, #28
 80431ec:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	for (i = 0; i < p->n_d; ++i) n *= p->d[i];
 80431f0:	782a      	ldrb	r2, [r5, #0]
		p->gtmp = realloc(p->gtmp, kad_len(p) * sizeof(int));
 80431f2:	6b68      	ldr	r0, [r5, #52]	@ 0x34
 80431f4:	2a00      	cmp	r2, #0
 80431f6:	f000 80ea 	beq.w	80433ce <kad_op_max1d+0x206>
 80431fa:	2a01      	cmp	r2, #1
 80431fc:	6929      	ldr	r1, [r5, #16]
 80431fe:	d00b      	beq.n	8043218 <kad_op_max1d+0x50>
 8043200:	696b      	ldr	r3, [r5, #20]
 8043202:	2a02      	cmp	r2, #2
 8043204:	fb03 f101 	mul.w	r1, r3, r1
 8043208:	d006      	beq.n	8043218 <kad_op_max1d+0x50>
 804320a:	69ab      	ldr	r3, [r5, #24]
 804320c:	2a03      	cmp	r2, #3
 804320e:	fb03 f101 	mul.w	r1, r3, r1
 8043212:	bf1c      	itt	ne
 8043214:	69ea      	ldrne	r2, [r5, #28]
 8043216:	4351      	mulne	r1, r2
 8043218:	0089      	lsls	r1, r1, #2
 804321a:	f008 fc09 	bl	804ba30 <realloc>
 804321e:	6368      	str	r0, [r5, #52]	@ 0x34
 8043220:	e7e2      	b.n	80431e8 <kad_op_max1d+0x20>
		if (q->n_d != 3) return -1;
 8043222:	f898 3000 	ldrb.w	r3, [r8]
 8043226:	2b03      	cmp	r3, #3
 8043228:	f040 80e8 	bne.w	80433fc <kad_op_max1d+0x234>
		p->n_d = 3;
 804322c:	702b      	strb	r3, [r5, #0]
		p->d[0] = q->d[0], p->d[1] = q->d[1], p->d[2] = conv_out_size(q->d[2], aux);
 804322e:	e9d8 2304 	ldrd	r2, r3, [r8, #16]
 8043232:	e9c5 2304 	strd	r2, r3, [r5, #16]
 8043236:	6801      	ldr	r1, [r0, #0]
 8043238:	f8d8 3018 	ldr.w	r3, [r8, #24]
 804323c:	6882      	ldr	r2, [r0, #8]
 804323e:	1a5b      	subs	r3, r3, r1
 8043240:	68c1      	ldr	r1, [r0, #12]
 8043242:	4413      	add	r3, r2
 8043244:	6842      	ldr	r2, [r0, #4]
 8043246:	440b      	add	r3, r1
 8043248:	fb93 f3f2 	sdiv	r3, r3, r2
 804324c:	3301      	adds	r3, #1
 804324e:	61ab      	str	r3, [r5, #24]
 8043250:	e7ca      	b.n	80431e8 <kad_op_max1d+0x20>
 8043252:	782b      	ldrb	r3, [r5, #0]
		int i, len, *f = (int*)p->gtmp;
 8043254:	6b69      	ldr	r1, [r5, #52]	@ 0x34
 8043256:	2b00      	cmp	r3, #0
 8043258:	f000 80cc 	beq.w	80433f4 <kad_op_max1d+0x22c>
 804325c:	2b01      	cmp	r3, #1
 804325e:	692c      	ldr	r4, [r5, #16]
 8043260:	d00b      	beq.n	804327a <kad_op_max1d+0xb2>
 8043262:	696a      	ldr	r2, [r5, #20]
 8043264:	2b02      	cmp	r3, #2
 8043266:	fb02 f404 	mul.w	r4, r2, r4
 804326a:	d006      	beq.n	804327a <kad_op_max1d+0xb2>
 804326c:	69aa      	ldr	r2, [r5, #24]
 804326e:	2b03      	cmp	r3, #3
 8043270:	fb02 f404 	mul.w	r4, r2, r4
 8043274:	bf1c      	itt	ne
 8043276:	69eb      	ldrne	r3, [r5, #28]
 8043278:	435c      	mulne	r4, r3
		for (i = 0; i < len; ++i) q->g[f[i]] += p->g[i];
 804327a:	2c00      	cmp	r4, #0
 804327c:	ddb4      	ble.n	80431e8 <kad_op_max1d+0x20>
 804327e:	2200      	movs	r2, #0
 8043280:	f8d8 602c 	ldr.w	r6, [r8, #44]	@ 0x2c
 8043284:	6ae8      	ldr	r0, [r5, #44]	@ 0x2c
 8043286:	3904      	subs	r1, #4
 8043288:	f851 3f04 	ldr.w	r3, [r1, #4]!
 804328c:	ecb0 7a01 	vldmia	r0!, {s14}
 8043290:	eb06 0383 	add.w	r3, r6, r3, lsl #2
 8043294:	edd3 7a00 	vldr	s15, [r3]
 8043298:	ee77 7a87 	vadd.f32	s15, s15, s14
 804329c:	3201      	adds	r2, #1
 804329e:	4294      	cmp	r4, r2
 80432a0:	edc3 7a00 	vstr	s15, [r3]
 80432a4:	dcf0      	bgt.n	8043288 <kad_op_max1d+0xc0>
 80432a6:	e79f      	b.n	80431e8 <kad_op_max1d+0x20>
 80432a8:	782f      	ldrb	r7, [r5, #0]
		int *f = (int*)p->gtmp;
 80432aa:	6b6e      	ldr	r6, [r5, #52]	@ 0x34
 80432ac:	2f00      	cmp	r7, #0
 80432ae:	f000 8096 	beq.w	80433de <kad_op_max1d+0x216>
 80432b2:	2f01      	cmp	r7, #1
 80432b4:	692a      	ldr	r2, [r5, #16]
 80432b6:	f000 808e 	beq.w	80433d6 <kad_op_max1d+0x20e>
 80432ba:	f8d5 c014 	ldr.w	ip, [r5, #20]
 80432be:	2f02      	cmp	r7, #2
 80432c0:	fb0c f302 	mul.w	r3, ip, r2
 80432c4:	461c      	mov	r4, r3
 80432c6:	f000 8090 	beq.w	80433ea <kad_op_max1d+0x222>
 80432ca:	f8d5 e018 	ldr.w	lr, [r5, #24]
 80432ce:	2f03      	cmp	r7, #3
 80432d0:	fb0e f403 	mul.w	r4, lr, r3
 80432d4:	f000 8085 	beq.w	80433e2 <kad_op_max1d+0x21a>
 80432d8:	69ea      	ldr	r2, [r5, #28]
 80432da:	fb02 f404 	mul.w	r4, r2, r4
		for (i = 0; i < len; ++i) p->x[i] = -FLT_MAX;
 80432de:	2c00      	cmp	r4, #0
 80432e0:	f340 808f 	ble.w	8043402 <kad_op_max1d+0x23a>
 80432e4:	2300      	movs	r3, #0
 80432e6:	f46f 0100 	mvn.w	r1, #8388608	@ 0x800000
 80432ea:	6aaa      	ldr	r2, [r5, #40]	@ 0x28
 80432ec:	3301      	adds	r3, #1
 80432ee:	429c      	cmp	r4, r3
 80432f0:	f842 1b04 	str.w	r1, [r2], #4
 80432f4:	dcfa      	bgt.n	80432ec <kad_op_max1d+0x124>
		for (i = 0; i < p->n_d - 1; ++i) rest *= p->d[i];
 80432f6:	1e79      	subs	r1, r7, #1
 80432f8:	2900      	cmp	r1, #0
 80432fa:	dd6a      	ble.n	80433d2 <kad_op_max1d+0x20a>
 80432fc:	2901      	cmp	r1, #1
 80432fe:	692a      	ldr	r2, [r5, #16]
 8043300:	d00a      	beq.n	8043318 <kad_op_max1d+0x150>
 8043302:	f8d5 c014 	ldr.w	ip, [r5, #20]
 8043306:	2903      	cmp	r1, #3
 8043308:	fb0c f202 	mul.w	r2, ip, r2
 804330c:	d174      	bne.n	80433f8 <kad_op_max1d+0x230>
 804330e:	f8d5 e018 	ldr.w	lr, [r5, #24]
 8043312:	2103      	movs	r1, #3
 8043314:	fb0e f202 	mul.w	r2, lr, r2
		for (t = 0; t < rest; ++t) {
 8043318:	2a00      	cmp	r2, #0
 804331a:	f77f af65 	ble.w	80431e8 <kad_op_max1d+0x20>
			for (l = 0; l < aux->kernel_size; ++l)
 804331e:	2300      	movs	r3, #0
			int j, l, p_width = p->d[p->n_d - 1];
 8043320:	3104      	adds	r1, #4
 8043322:	f855 c021 	ldr.w	ip, [r5, r1, lsl #2]
			int u = t * p_width, v, v0 = t * q->d[p->n_d - 1], v_end = v0 + q->d[p->n_d - 1];
 8043326:	f858 9021 	ldr.w	r9, [r8, r1, lsl #2]
 804332a:	ea4f 048c 	mov.w	r4, ip, lsl #2
 804332e:	9404      	str	r4, [sp, #16]
 8043330:	ea4f 0449 	mov.w	r4, r9, lsl #1
 8043334:	9405      	str	r4, [sp, #20]
			for (l = 0; l < aux->kernel_size; ++l)
 8043336:	46ce      	mov	lr, r9
		for (t = 0; t < rest; ++t) {
 8043338:	461c      	mov	r4, r3
			for (l = 0; l < aux->kernel_size; ++l)
 804333a:	6801      	ldr	r1, [r0, #0]
		for (t = 0; t < rest; ++t) {
 804333c:	f8cd 8000 	str.w	r8, [sp]
 8043340:	9203      	str	r2, [sp, #12]
			for (l = 0; l < aux->kernel_size; ++l)
 8043342:	2900      	cmp	r1, #0
 8043344:	ebae 0809 	sub.w	r8, lr, r9
 8043348:	f77f af4e 	ble.w	80431e8 <kad_op_max1d+0x20>
 804334c:	2700      	movs	r7, #0
 804334e:	e9cd 3401 	strd	r3, r4, [sp, #4]
 8043352:	ea4f 0a84 	mov.w	sl, r4, lsl #2
				for (j = 0, v = v0 + (l > aux->pad[0]? l - aux->pad[0] : 0); j < p_width && v < v_end; ++j, v += aux->stride)
 8043356:	6882      	ldr	r2, [r0, #8]
 8043358:	42ba      	cmp	r2, r7
 804335a:	bfb3      	iteet	lt
 804335c:	1aba      	sublt	r2, r7, r2
			int u = t * p_width, v, v0 = t * q->d[p->n_d - 1], v_end = v0 + q->d[p->n_d - 1];
 804335e:	4643      	movge	r3, r8
				for (j = 0, v = v0 + (l > aux->pad[0]? l - aux->pad[0] : 0); j < p_width && v < v_end; ++j, v += aux->stride)
 8043360:	2200      	movge	r2, #0
 8043362:	eb08 0302 	addlt.w	r3, r8, r2
 8043366:	f1bc 0f00 	cmp.w	ip, #0
 804336a:	dd1f      	ble.n	80433ac <kad_op_max1d+0x1e4>
 804336c:	4591      	cmp	r9, r2
 804336e:	dd1d      	ble.n	80433ac <kad_op_max1d+0x1e4>
 8043370:	6aa9      	ldr	r1, [r5, #40]	@ 0x28
					if (p->x[u + j] < q->x[v])
 8043372:	9c00      	ldr	r4, [sp, #0]
				for (j = 0, v = v0 + (l > aux->pad[0]? l - aux->pad[0] : 0); j < p_width && v < v_end; ++j, v += aux->stride)
 8043374:	2200      	movs	r2, #0
					if (p->x[u + j] < q->x[v])
 8043376:	f8d4 b028 	ldr.w	fp, [r4, #40]	@ 0x28
 804337a:	4451      	add	r1, sl
 804337c:	e001      	b.n	8043382 <kad_op_max1d+0x1ba>
				for (j = 0, v = v0 + (l > aux->pad[0]? l - aux->pad[0] : 0); j < p_width && v < v_end; ++j, v += aux->stride)
 804337e:	4573      	cmp	r3, lr
 8043380:	da13      	bge.n	80433aa <kad_op_max1d+0x1e2>
					if (p->x[u + j] < q->x[v])
 8043382:	eb0b 0483 	add.w	r4, fp, r3, lsl #2
 8043386:	edd4 7a00 	vldr	s15, [r4]
 804338a:	ecb1 7a01 	vldmia	r1!, {s14}
 804338e:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8043392:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
						p->x[u + j] = q->x[v], f[u + j] = v;
 8043396:	bf44      	itt	mi
 8043398:	ed41 7a01 	vstrmi	s15, [r1, #-4]
 804339c:	f846 3022 	strmi.w	r3, [r6, r2, lsl #2]
				for (j = 0, v = v0 + (l > aux->pad[0]? l - aux->pad[0] : 0); j < p_width && v < v_end; ++j, v += aux->stride)
 80433a0:	6844      	ldr	r4, [r0, #4]
 80433a2:	3201      	adds	r2, #1
 80433a4:	4594      	cmp	ip, r2
 80433a6:	4423      	add	r3, r4
 80433a8:	d1e9      	bne.n	804337e <kad_op_max1d+0x1b6>
 80433aa:	6801      	ldr	r1, [r0, #0]
			for (l = 0; l < aux->kernel_size; ++l)
 80433ac:	3701      	adds	r7, #1
 80433ae:	42b9      	cmp	r1, r7
 80433b0:	dcd1      	bgt.n	8043356 <kad_op_max1d+0x18e>
 80433b2:	e9dd 3401 	ldrd	r3, r4, [sp, #4]
		for (t = 0; t < rest; ++t) {
 80433b6:	9a03      	ldr	r2, [sp, #12]
 80433b8:	3301      	adds	r3, #1
 80433ba:	4293      	cmp	r3, r2
 80433bc:	f6bf af14 	bge.w	80431e8 <kad_op_max1d+0x20>
 80433c0:	9a05      	ldr	r2, [sp, #20]
 80433c2:	4464      	add	r4, ip
 80433c4:	eb02 0e08 	add.w	lr, r2, r8
 80433c8:	9a04      	ldr	r2, [sp, #16]
 80433ca:	4416      	add	r6, r2
 80433cc:	e7b9      	b.n	8043342 <kad_op_max1d+0x17a>
 80433ce:	2104      	movs	r1, #4
 80433d0:	e723      	b.n	804321a <kad_op_max1d+0x52>
		int rest = 1, len, t, i;
 80433d2:	2201      	movs	r2, #1
 80433d4:	e7a3      	b.n	804331e <kad_op_max1d+0x156>
		for (i = 0; i < len; ++i) p->x[i] = -FLT_MAX;
 80433d6:	2a00      	cmp	r2, #0
 80433d8:	dd15      	ble.n	8043406 <kad_op_max1d+0x23e>
 80433da:	4614      	mov	r4, r2
 80433dc:	e782      	b.n	80432e4 <kad_op_max1d+0x11c>
	int n = 1, i;
 80433de:	2401      	movs	r4, #1
 80433e0:	e780      	b.n	80432e4 <kad_op_max1d+0x11c>
 80433e2:	2c00      	cmp	r4, #0
 80433e4:	f73f af7e 	bgt.w	80432e4 <kad_op_max1d+0x11c>
 80433e8:	e78d      	b.n	8043306 <kad_op_max1d+0x13e>
 80433ea:	2b00      	cmp	r3, #0
 80433ec:	f73f af7a 	bgt.w	80432e4 <kad_op_max1d+0x11c>
		for (i = 0; i < p->n_d - 1; ++i) rest *= p->d[i];
 80433f0:	2101      	movs	r1, #1
 80433f2:	e791      	b.n	8043318 <kad_op_max1d+0x150>
 80433f4:	2401      	movs	r4, #1
 80433f6:	e742      	b.n	804327e <kad_op_max1d+0xb6>
 80433f8:	2102      	movs	r1, #2
 80433fa:	e78d      	b.n	8043318 <kad_op_max1d+0x150>
		if (q->n_d != 3) return -1;
 80433fc:	f04f 30ff 	mov.w	r0, #4294967295
 8043400:	e6f3      	b.n	80431ea <kad_op_max1d+0x22>
		for (i = 0; i < p->n_d - 1; ++i) rest *= p->d[i];
 8043402:	461a      	mov	r2, r3
 8043404:	e785      	b.n	8043312 <kad_op_max1d+0x14a>
		int rest = 1, len, t, i;
 8043406:	463a      	mov	r2, r7
		for (i = 0; i < p->n_d - 1; ++i) rest *= p->d[i];
 8043408:	2100      	movs	r1, #0
 804340a:	e788      	b.n	804331e <kad_op_max1d+0x156>

0804340c <kad_op_avg1d>:

int kad_op_avg1d(kad_node_t *p, int action)
{
 804340c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	conv_conf_t *aux = (conv_conf_t*)p->ptr;
	kad_node_t *q = p->child[0];
 8043410:	6b83      	ldr	r3, [r0, #56]	@ 0x38
	conv_conf_t *aux = (conv_conf_t*)p->ptr;
 8043412:	6b02      	ldr	r2, [r0, #48]	@ 0x30
	kad_node_t *q = p->child[0];
 8043414:	681b      	ldr	r3, [r3, #0]
{
 8043416:	b093      	sub	sp, #76	@ 0x4c
	if (action == KAD_SYNC_DIM) {
 8043418:	2904      	cmp	r1, #4
{
 804341a:	4681      	mov	r9, r0
	conv_conf_t *aux = (conv_conf_t*)p->ptr;
 804341c:	9202      	str	r2, [sp, #8]
	kad_node_t *q = p->child[0];
 804341e:	9301      	str	r3, [sp, #4]
	if (action == KAD_SYNC_DIM) {
 8043420:	d028      	beq.n	8043474 <kad_op_avg1d+0x68>
		if (q->n_d != 3) return -1;
		p->n_d = 3;
		p->d[0] = q->d[0], p->d[1] = q->d[1], p->d[2] = conv_out_size(q->d[2], aux);
	} else if (action == KAD_ALLOC) {
 8043422:	2901      	cmp	r1, #1
 8043424:	d008      	beq.n	8043438 <kad_op_avg1d+0x2c>
		p->gtmp = realloc(p->gtmp, kad_len(p) * sizeof(int));
	} else if (action == KAD_FORWARD) {
 8043426:	2902      	cmp	r1, #2
 8043428:	f000 8188 	beq.w	804373c <kad_op_avg1d+0x330>
			for (l = 0; l < aux->kernel_size; ++l)
				for (j = 0, v = v0 + (l > aux->pad[0]? l - aux->pad[0] : 0); j < p_width && v < v_end; ++j, v += aux->stride)
					p->x[u + j] += q->x[v], ++f[u + j];
		}
		for (i = 0; i < len; ++i) p->x[i] /= f[i];
	} else if (action == KAD_BACKWARD) {
 804342c:	2903      	cmp	r1, #3
 804342e:	d03a      	beq.n	80434a6 <kad_op_avg1d+0x9a>
			for (l = 0; l < aux->kernel_size; ++l)
				for (j = 0, v = v0 + (l > aux->pad[0]? l - aux->pad[0] : 0); j < p_width && v < v_end; ++j, v += aux->stride)
					q->g[v] += p->g[u + j] / f[u + j];
		}
	}
	return 0;
 8043430:	2000      	movs	r0, #0
}
 8043432:	b013      	add	sp, #76	@ 0x4c
 8043434:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	for (i = 0; i < p->n_d; ++i) n *= p->d[i];
 8043438:	7802      	ldrb	r2, [r0, #0]
		p->gtmp = realloc(p->gtmp, kad_len(p) * sizeof(int));
 804343a:	6b40      	ldr	r0, [r0, #52]	@ 0x34
 804343c:	2a00      	cmp	r2, #0
 804343e:	f000 8249 	beq.w	80438d4 <kad_op_avg1d+0x4c8>
 8043442:	2a01      	cmp	r2, #1
 8043444:	f8d9 1010 	ldr.w	r1, [r9, #16]
 8043448:	d00e      	beq.n	8043468 <kad_op_avg1d+0x5c>
 804344a:	f8d9 3014 	ldr.w	r3, [r9, #20]
 804344e:	2a02      	cmp	r2, #2
 8043450:	fb03 f101 	mul.w	r1, r3, r1
 8043454:	d008      	beq.n	8043468 <kad_op_avg1d+0x5c>
 8043456:	f8d9 3018 	ldr.w	r3, [r9, #24]
 804345a:	2a03      	cmp	r2, #3
 804345c:	fb03 f101 	mul.w	r1, r3, r1
 8043460:	bf1c      	itt	ne
 8043462:	f8d9 201c 	ldrne.w	r2, [r9, #28]
 8043466:	4351      	mulne	r1, r2
 8043468:	0089      	lsls	r1, r1, #2
 804346a:	f008 fae1 	bl	804ba30 <realloc>
 804346e:	f8c9 0034 	str.w	r0, [r9, #52]	@ 0x34
 8043472:	e7dd      	b.n	8043430 <kad_op_avg1d+0x24>
		if (q->n_d != 3) return -1;
 8043474:	4619      	mov	r1, r3
 8043476:	781b      	ldrb	r3, [r3, #0]
 8043478:	2b03      	cmp	r3, #3
 804347a:	f040 8246 	bne.w	804390a <kad_op_avg1d+0x4fe>
		p->n_d = 3;
 804347e:	7003      	strb	r3, [r0, #0]
		p->d[0] = q->d[0], p->d[1] = q->d[1], p->d[2] = conv_out_size(q->d[2], aux);
 8043480:	e9d1 2304 	ldrd	r2, r3, [r1, #16]
 8043484:	e9c0 2304 	strd	r2, r3, [r0, #16]
 8043488:	9802      	ldr	r0, [sp, #8]
 804348a:	698b      	ldr	r3, [r1, #24]
 804348c:	6801      	ldr	r1, [r0, #0]
 804348e:	6882      	ldr	r2, [r0, #8]
 8043490:	1a5b      	subs	r3, r3, r1
 8043492:	68c1      	ldr	r1, [r0, #12]
 8043494:	4413      	add	r3, r2
 8043496:	6842      	ldr	r2, [r0, #4]
 8043498:	440b      	add	r3, r1
 804349a:	fb93 f3f2 	sdiv	r3, r3, r2
 804349e:	3301      	adds	r3, #1
 80434a0:	f8c9 3018 	str.w	r3, [r9, #24]
 80434a4:	e7c4      	b.n	8043430 <kad_op_avg1d+0x24>
		for (i = 0; i < p->n_d - 1; ++i) rest *= p->d[i];
 80434a6:	7803      	ldrb	r3, [r0, #0]
 80434a8:	3b01      	subs	r3, #1
 80434aa:	2b00      	cmp	r3, #0
 80434ac:	f340 822a 	ble.w	8043904 <kad_op_avg1d+0x4f8>
 80434b0:	2b01      	cmp	r3, #1
 80434b2:	f8d0 c010 	ldr.w	ip, [r0, #16]
 80434b6:	d00c      	beq.n	80434d2 <kad_op_avg1d+0xc6>
 80434b8:	6942      	ldr	r2, [r0, #20]
 80434ba:	2b02      	cmp	r3, #2
 80434bc:	fb02 fc0c 	mul.w	ip, r2, ip
 80434c0:	d007      	beq.n	80434d2 <kad_op_avg1d+0xc6>
 80434c2:	6982      	ldr	r2, [r0, #24]
 80434c4:	2b03      	cmp	r3, #3
 80434c6:	fb02 fc0c 	mul.w	ip, r2, ip
 80434ca:	bf1c      	itt	ne
 80434cc:	69c2      	ldrne	r2, [r0, #28]
 80434ce:	fb02 fc0c 	mulne.w	ip, r2, ip
		for (t = 0; t < rest; ++t) {
 80434d2:	f1bc 0f00 	cmp.w	ip, #0
 80434d6:	ddab      	ble.n	8043430 <kad_op_avg1d+0x24>
			for (l = 0; l < aux->kernel_size; ++l)
 80434d8:	9902      	ldr	r1, [sp, #8]
			int u = t * p_width, v, v0 = t * q->d[p->n_d - 1], v_end = v0 + q->d[p->n_d - 1];
 80434da:	9801      	ldr	r0, [sp, #4]
			for (l = 0; l < aux->kernel_size; ++l)
 80434dc:	680a      	ldr	r2, [r1, #0]
			int j, l, p_width = p->d[p->n_d - 1];
 80434de:	3304      	adds	r3, #4
 80434e0:	2a00      	cmp	r2, #0
 80434e2:	f859 b023 	ldr.w	fp, [r9, r3, lsl #2]
			int u = t * p_width, v, v0 = t * q->d[p->n_d - 1], v_end = v0 + q->d[p->n_d - 1];
 80434e6:	f850 8023 	ldr.w	r8, [r0, r3, lsl #2]
			for (l = 0; l < aux->kernel_size; ++l)
 80434ea:	9210      	str	r2, [sp, #64]	@ 0x40
 80434ec:	4613      	mov	r3, r2
 80434ee:	dd9f      	ble.n	8043430 <kad_op_avg1d+0x24>
				for (j = 0, v = v0 + (l > aux->pad[0]? l - aux->pad[0] : 0); j < p_width && v < v_end; ++j, v += aux->stride)
 80434f0:	f8d1 e008 	ldr.w	lr, [r1, #8]
 80434f4:	3b01      	subs	r3, #1
 80434f6:	4573      	cmp	r3, lr
 80434f8:	bfa8      	it	ge
 80434fa:	4673      	movge	r3, lr
		for (t = 0; t < rest; ++t) {
 80434fc:	4676      	mov	r6, lr
				for (j = 0, v = v0 + (l > aux->pad[0]? l - aux->pad[0] : 0); j < p_width && v < v_end; ++j, v += aux->stride)
 80434fe:	2200      	movs	r2, #0
 8043500:	930a      	str	r3, [sp, #40]	@ 0x28
		int *f = (int*)p->gtmp;
 8043502:	f8d9 3034 	ldr.w	r3, [r9, #52]	@ 0x34
 8043506:	2e00      	cmp	r6, #0
 8043508:	f1a3 0304 	sub.w	r3, r3, #4
 804350c:	9311      	str	r3, [sp, #68]	@ 0x44
 804350e:	f1cb 0300 	rsb	r3, fp, #0
 8043512:	9305      	str	r3, [sp, #20]
				for (j = 0, v = v0 + (l > aux->pad[0]? l - aux->pad[0] : 0); j < p_width && v < v_end; ++j, v += aux->stride)
 8043514:	465f      	mov	r7, fp
 8043516:	46c2      	mov	sl, r8
		for (t = 0; t < rest; ++t) {
 8043518:	4613      	mov	r3, r2
			int u = t * p_width, v, v0 = t * q->d[p->n_d - 1], v_end = v0 + q->d[p->n_d - 1];
 804351a:	f04f 0e00 	mov.w	lr, #0
				for (j = 0, v = v0 + (l > aux->pad[0]? l - aux->pad[0] : 0); j < p_width && v < v_end; ++j, v += aux->stride)
 804351e:	9209      	str	r2, [sp, #36]	@ 0x24
		for (t = 0; t < rest; ++t) {
 8043520:	f8cd 9010 	str.w	r9, [sp, #16]
			for (l = 0; l < aux->kernel_size; ++l)
 8043524:	da60      	bge.n	80435e8 <kad_op_avg1d+0x1dc>
 8043526:	0091      	lsls	r1, r2, #2
 8043528:	9103      	str	r1, [sp, #12]
 804352a:	9909      	ldr	r1, [sp, #36]	@ 0x24
 804352c:	ebae 0406 	sub.w	r4, lr, r6
 8043530:	440c      	add	r4, r1
 8043532:	eb04 000b 	add.w	r0, r4, fp
 8043536:	900c      	str	r0, [sp, #48]	@ 0x30
 8043538:	9d11      	ldr	r5, [sp, #68]	@ 0x44
 804353a:	9803      	ldr	r0, [sp, #12]
 804353c:	e9cd 6c07 	strd	r6, ip, [sp, #28]
 8043540:	4405      	add	r5, r0
 8043542:	980c      	ldr	r0, [sp, #48]	@ 0x30
 8043544:	e9cd 270c 	strd	r2, r7, [sp, #48]	@ 0x30
 8043548:	f8dd e040 	ldr.w	lr, [sp, #64]	@ 0x40
 804354c:	9506      	str	r5, [sp, #24]
 804354e:	eba6 0901 	sub.w	r9, r6, r1
 8043552:	930b      	str	r3, [sp, #44]	@ 0x2c
				for (j = 0, v = v0 + (l > aux->pad[0]? l - aux->pad[0] : 0); j < p_width && v < v_end; ++j, v += aux->stride)
 8043554:	f1bb 0f00 	cmp.w	fp, #0
 8043558:	4623      	mov	r3, r4
 804355a:	dd27      	ble.n	80435ac <kad_op_avg1d+0x1a0>
 804355c:	9a05      	ldr	r2, [sp, #20]
 804355e:	1882      	adds	r2, r0, r2
 8043560:	4590      	cmp	r8, r2
 8043562:	dd23      	ble.n	80435ac <kad_op_avg1d+0x1a0>
 8043564:	9a02      	ldr	r2, [sp, #8]
					q->g[v] += p->g[u + j] / f[u + j];
 8043566:	9904      	ldr	r1, [sp, #16]
				for (j = 0, v = v0 + (l > aux->pad[0]? l - aux->pad[0] : 0); j < p_width && v < v_end; ++j, v += aux->stride)
 8043568:	6856      	ldr	r6, [r2, #4]
					q->g[v] += p->g[u + j] / f[u + j];
 804356a:	9a01      	ldr	r2, [sp, #4]
 804356c:	6ac9      	ldr	r1, [r1, #44]	@ 0x2c
 804356e:	6ad2      	ldr	r2, [r2, #44]	@ 0x2c
 8043570:	9d03      	ldr	r5, [sp, #12]
 8043572:	2e01      	cmp	r6, #1
 8043574:	eb02 0284 	add.w	r2, r2, r4, lsl #2
 8043578:	4429      	add	r1, r5
 804357a:	f040 8081 	bne.w	8043680 <kad_op_avg1d+0x274>
				for (j = 0, v = v0 + (l > aux->pad[0]? l - aux->pad[0] : 0); j < p_width && v < v_end; ++j, v += aux->stride)
 804357e:	9d06      	ldr	r5, [sp, #24]
 8043580:	e001      	b.n	8043586 <kad_op_avg1d+0x17a>
 8043582:	4553      	cmp	r3, sl
 8043584:	da12      	bge.n	80435ac <kad_op_avg1d+0x1a0>
					q->g[v] += p->g[u + j] / f[u + j];
 8043586:	ed95 7a01 	vldr	s14, [r5, #4]
 804358a:	ecb1 6a01 	vldmia	r1!, {s12}
 804358e:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 8043592:	edd2 6a00 	vldr	s13, [r2]
 8043596:	eec6 7a07 	vdiv.f32	s15, s12, s14
 804359a:	ee77 7aa6 	vadd.f32	s15, s15, s13
				for (j = 0, v = v0 + (l > aux->pad[0]? l - aux->pad[0] : 0); j < p_width && v < v_end; ++j, v += aux->stride)
 804359e:	3301      	adds	r3, #1
 80435a0:	4283      	cmp	r3, r0
					q->g[v] += p->g[u + j] / f[u + j];
 80435a2:	f105 0504 	add.w	r5, r5, #4
 80435a6:	ece2 7a01 	vstmia	r2!, {s15}
				for (j = 0, v = v0 + (l > aux->pad[0]? l - aux->pad[0] : 0); j < p_width && v < v_end; ++j, v += aux->stride)
 80435aa:	d1ea      	bne.n	8043582 <kad_op_avg1d+0x176>
			for (l = 0; l < aux->kernel_size; ++l)
 80435ac:	3401      	adds	r4, #1
 80435ae:	eb09 0304 	add.w	r3, r9, r4
 80435b2:	459e      	cmp	lr, r3
 80435b4:	f100 0001 	add.w	r0, r0, #1
 80435b8:	dccc      	bgt.n	8043554 <kad_op_avg1d+0x148>
 80435ba:	e9dd 6c07 	ldrd	r6, ip, [sp, #28]
 80435be:	e9dd 320b 	ldrd	r3, r2, [sp, #44]	@ 0x2c
 80435c2:	9f0d      	ldr	r7, [sp, #52]	@ 0x34
		for (t = 0; t < rest; ++t) {
 80435c4:	9909      	ldr	r1, [sp, #36]	@ 0x24
 80435c6:	3301      	adds	r3, #1
 80435c8:	4441      	add	r1, r8
 80435ca:	9109      	str	r1, [sp, #36]	@ 0x24
 80435cc:	9905      	ldr	r1, [sp, #20]
 80435ce:	459c      	cmp	ip, r3
 80435d0:	eba1 0108 	sub.w	r1, r1, r8
 80435d4:	9105      	str	r1, [sp, #20]
 80435d6:	445a      	add	r2, fp
 80435d8:	44c2      	add	sl, r8
 80435da:	4447      	add	r7, r8
 80435dc:	f77f af28 	ble.w	8043430 <kad_op_avg1d+0x24>
			for (l = 0; l < aux->kernel_size; ++l)
 80435e0:	2e00      	cmp	r6, #0
			int u = t * p_width, v, v0 = t * q->d[p->n_d - 1], v_end = v0 + q->d[p->n_d - 1];
 80435e2:	f04f 0e00 	mov.w	lr, #0
 80435e6:	db9e      	blt.n	8043526 <kad_op_avg1d+0x11a>
 80435e8:	9909      	ldr	r1, [sp, #36]	@ 0x24
 80435ea:	0089      	lsls	r1, r1, #2
 80435ec:	910c      	str	r1, [sp, #48]	@ 0x30
 80435ee:	0091      	lsls	r1, r2, #2
 80435f0:	9103      	str	r1, [sp, #12]
 80435f2:	9911      	ldr	r1, [sp, #68]	@ 0x44
 80435f4:	eb01 0182 	add.w	r1, r1, r2, lsl #2
 80435f8:	910b      	str	r1, [sp, #44]	@ 0x2c
				for (j = 0, v = v0 + (l > aux->pad[0]? l - aux->pad[0] : 0); j < p_width && v < v_end; ++j, v += aux->stride)
 80435fa:	f1bb 0f00 	cmp.w	fp, #0
 80435fe:	f340 8097 	ble.w	8043730 <kad_op_avg1d+0x324>
 8043602:	4634      	mov	r4, r6
 8043604:	4618      	mov	r0, r3
 8043606:	4611      	mov	r1, r2
 8043608:	f1b8 0f00 	cmp.w	r8, #0
 804360c:	dd2b      	ble.n	8043666 <kad_op_avg1d+0x25a>
 804360e:	46f1      	mov	r9, lr
 8043610:	9b02      	ldr	r3, [sp, #8]
 8043612:	9a04      	ldr	r2, [sp, #16]
 8043614:	685d      	ldr	r5, [r3, #4]
 8043616:	9b01      	ldr	r3, [sp, #4]
 8043618:	6ad2      	ldr	r2, [r2, #44]	@ 0x2c
 804361a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 804361c:	9108      	str	r1, [sp, #32]
 804361e:	e9cd 2306 	strd	r2, r3, [sp, #24]
 8043622:	2d01      	cmp	r5, #1
 8043624:	d149      	bne.n	80436ba <kad_op_avg1d+0x2ae>
 8043626:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
 804362a:	9d0c      	ldr	r5, [sp, #48]	@ 0x30
 804362c:	46ce      	mov	lr, r9
 804362e:	442b      	add	r3, r5
 8043630:	9d03      	ldr	r5, [sp, #12]
 8043632:	9908      	ldr	r1, [sp, #32]
 8043634:	442a      	add	r2, r5
 8043636:	9e0b      	ldr	r6, [sp, #44]	@ 0x2c
 8043638:	9d09      	ldr	r5, [sp, #36]	@ 0x24
 804363a:	e001      	b.n	8043640 <kad_op_avg1d+0x234>
 804363c:	4555      	cmp	r5, sl
 804363e:	da12      	bge.n	8043666 <kad_op_avg1d+0x25a>
					q->g[v] += p->g[u + j] / f[u + j];
 8043640:	ed96 7a01 	vldr	s14, [r6, #4]
 8043644:	ecb2 6a01 	vldmia	r2!, {s12}
 8043648:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 804364c:	edd3 6a00 	vldr	s13, [r3]
 8043650:	eec6 7a07 	vdiv.f32	s15, s12, s14
 8043654:	ee77 7aa6 	vadd.f32	s15, s15, s13
				for (j = 0, v = v0 + (l > aux->pad[0]? l - aux->pad[0] : 0); j < p_width && v < v_end; ++j, v += aux->stride)
 8043658:	3501      	adds	r5, #1
 804365a:	42bd      	cmp	r5, r7
					q->g[v] += p->g[u + j] / f[u + j];
 804365c:	f106 0604 	add.w	r6, r6, #4
 8043660:	ece3 7a01 	vstmia	r3!, {s15}
				for (j = 0, v = v0 + (l > aux->pad[0]? l - aux->pad[0] : 0); j < p_width && v < v_end; ++j, v += aux->stride)
 8043664:	d1ea      	bne.n	804363c <kad_op_avg1d+0x230>
			for (l = 0; l < aux->kernel_size; ++l)
 8043666:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 8043668:	f10e 0e01 	add.w	lr, lr, #1
 804366c:	4573      	cmp	r3, lr
 804366e:	dacb      	bge.n	8043608 <kad_op_avg1d+0x1fc>
 8043670:	4626      	mov	r6, r4
 8043672:	4603      	mov	r3, r0
 8043674:	460a      	mov	r2, r1
 8043676:	9910      	ldr	r1, [sp, #64]	@ 0x40
 8043678:	4571      	cmp	r1, lr
 804367a:	f73f af56 	bgt.w	804352a <kad_op_avg1d+0x11e>
 804367e:	e7a1      	b.n	80435c4 <kad_op_avg1d+0x1b8>
				for (j = 0, v = v0 + (l > aux->pad[0]? l - aux->pad[0] : 0); j < p_width && v < v_end; ++j, v += aux->stride)
 8043680:	2500      	movs	r5, #0
 8043682:	9f06      	ldr	r7, [sp, #24]
 8043684:	ea4f 0c86 	mov.w	ip, r6, lsl #2
 8043688:	e001      	b.n	804368e <kad_op_avg1d+0x282>
 804368a:	4553      	cmp	r3, sl
 804368c:	da8e      	bge.n	80435ac <kad_op_avg1d+0x1a0>
					q->g[v] += p->g[u + j] / f[u + j];
 804368e:	ed97 7a01 	vldr	s14, [r7, #4]
 8043692:	ecb1 6a01 	vldmia	r1!, {s12}
 8043696:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 804369a:	edd2 7a00 	vldr	s15, [r2]
 804369e:	eec6 6a07 	vdiv.f32	s13, s12, s14
 80436a2:	ee77 7aa6 	vadd.f32	s15, s15, s13
				for (j = 0, v = v0 + (l > aux->pad[0]? l - aux->pad[0] : 0); j < p_width && v < v_end; ++j, v += aux->stride)
 80436a6:	3501      	adds	r5, #1
 80436a8:	45ab      	cmp	fp, r5
					q->g[v] += p->g[u + j] / f[u + j];
 80436aa:	edc2 7a00 	vstr	s15, [r2]
 80436ae:	f107 0704 	add.w	r7, r7, #4
				for (j = 0, v = v0 + (l > aux->pad[0]? l - aux->pad[0] : 0); j < p_width && v < v_end; ++j, v += aux->stride)
 80436b2:	4433      	add	r3, r6
 80436b4:	4462      	add	r2, ip
 80436b6:	d1e8      	bne.n	804368a <kad_op_avg1d+0x27e>
 80436b8:	e778      	b.n	80435ac <kad_op_avg1d+0x1a0>
 80436ba:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 80436bc:	9a0c      	ldr	r2, [sp, #48]	@ 0x30
 80436be:	930e      	str	r3, [sp, #56]	@ 0x38
 80436c0:	2300      	movs	r3, #0
 80436c2:	930d      	str	r3, [sp, #52]	@ 0x34
 80436c4:	9b07      	ldr	r3, [sp, #28]
 80436c6:	9903      	ldr	r1, [sp, #12]
 80436c8:	4413      	add	r3, r2
 80436ca:	9a06      	ldr	r2, [sp, #24]
 80436cc:	f8cd 803c 	str.w	r8, [sp, #60]	@ 0x3c
 80436d0:	eb02 0e01 	add.w	lr, r2, r1
 80436d4:	9e09      	ldr	r6, [sp, #36]	@ 0x24
 80436d6:	2200      	movs	r2, #0
 80436d8:	990e      	ldr	r1, [sp, #56]	@ 0x38
 80436da:	ea4f 0885 	mov.w	r8, r5, lsl #2
 80436de:	e001      	b.n	80436e4 <kad_op_avg1d+0x2d8>
 80436e0:	4556      	cmp	r6, sl
 80436e2:	da20      	bge.n	8043726 <kad_op_avg1d+0x31a>
					q->g[v] += p->g[u + j] / f[u + j];
 80436e4:	ed91 7a01 	vldr	s14, [r1, #4]
 80436e8:	ecbe 6a01 	vldmia	lr!, {s12}
 80436ec:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 80436f0:	edd3 7a00 	vldr	s15, [r3]
 80436f4:	eec6 6a07 	vdiv.f32	s13, s12, s14
 80436f8:	ee77 7aa6 	vadd.f32	s15, s15, s13
				for (j = 0, v = v0 + (l > aux->pad[0]? l - aux->pad[0] : 0); j < p_width && v < v_end; ++j, v += aux->stride)
 80436fc:	3201      	adds	r2, #1
 80436fe:	4593      	cmp	fp, r2
					q->g[v] += p->g[u + j] / f[u + j];
 8043700:	edc3 7a00 	vstr	s15, [r3]
 8043704:	f101 0104 	add.w	r1, r1, #4
				for (j = 0, v = v0 + (l > aux->pad[0]? l - aux->pad[0] : 0); j < p_width && v < v_end; ++j, v += aux->stride)
 8043708:	442e      	add	r6, r5
 804370a:	4443      	add	r3, r8
 804370c:	d1e8      	bne.n	80436e0 <kad_op_avg1d+0x2d4>
			for (l = 0; l < aux->kernel_size; ++l)
 804370e:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 8043710:	f109 0901 	add.w	r9, r9, #1
 8043714:	454b      	cmp	r3, r9
 8043716:	f8dd 803c 	ldr.w	r8, [sp, #60]	@ 0x3c
 804371a:	da82      	bge.n	8043622 <kad_op_avg1d+0x216>
 804371c:	4626      	mov	r6, r4
 804371e:	4603      	mov	r3, r0
 8043720:	46ce      	mov	lr, r9
 8043722:	9a08      	ldr	r2, [sp, #32]
 8043724:	e7a7      	b.n	8043676 <kad_op_avg1d+0x26a>
 8043726:	46ce      	mov	lr, r9
 8043728:	f8dd 803c 	ldr.w	r8, [sp, #60]	@ 0x3c
 804372c:	9908      	ldr	r1, [sp, #32]
 804372e:	e79a      	b.n	8043666 <kad_op_avg1d+0x25a>
 8043730:	990a      	ldr	r1, [sp, #40]	@ 0x28
 8043732:	f10e 0e01 	add.w	lr, lr, #1
 8043736:	458e      	cmp	lr, r1
 8043738:	dc9d      	bgt.n	8043676 <kad_op_avg1d+0x26a>
 804373a:	e75e      	b.n	80435fa <kad_op_avg1d+0x1ee>
 804373c:	7805      	ldrb	r5, [r0, #0]
		int *f = (int*)p->gtmp;
 804373e:	f8d0 a034 	ldr.w	sl, [r0, #52]	@ 0x34
 8043742:	2d00      	cmp	r5, #0
 8043744:	f000 80cf 	beq.w	80438e6 <kad_op_avg1d+0x4da>
 8043748:	6904      	ldr	r4, [r0, #16]
 804374a:	2d01      	cmp	r5, #1
 804374c:	4620      	mov	r0, r4
 804374e:	f000 80c5 	beq.w	80438dc <kad_op_avg1d+0x4d0>
 8043752:	f8d9 3014 	ldr.w	r3, [r9, #20]
 8043756:	2d02      	cmp	r5, #2
 8043758:	fb03 f404 	mul.w	r4, r3, r4
 804375c:	f000 80cc 	beq.w	80438f8 <kad_op_avg1d+0x4ec>
 8043760:	f8d9 2018 	ldr.w	r2, [r9, #24]
 8043764:	2d03      	cmp	r5, #3
 8043766:	fb02 f404 	mul.w	r4, r2, r4
 804376a:	f000 80c0 	beq.w	80438ee <kad_op_avg1d+0x4e2>
 804376e:	f8d9 101c 	ldr.w	r1, [r9, #28]
 8043772:	fb01 f404 	mul.w	r4, r1, r4
		for (i = 0; i < len; ++i) p->x[i] = 0.0f, f[i] = 0;
 8043776:	2c00      	cmp	r4, #0
 8043778:	f340 80d6 	ble.w	8043928 <kad_op_avg1d+0x51c>
 804377c:	2c00      	cmp	r4, #0
 804377e:	ea4f 0684 	mov.w	r6, r4, lsl #2
 8043782:	bfd8      	it	le
 8043784:	2604      	movle	r6, #4
 8043786:	f8d9 0028 	ldr.w	r0, [r9, #40]	@ 0x28
 804378a:	eb0a 0306 	add.w	r3, sl, r6
 804378e:	4298      	cmp	r0, r3
 8043790:	d207      	bcs.n	80437a2 <kad_op_avg1d+0x396>
 8043792:	1983      	adds	r3, r0, r6
 8043794:	459a      	cmp	sl, r3
 8043796:	bf34      	ite	cc
 8043798:	2300      	movcc	r3, #0
 804379a:	2301      	movcs	r3, #1
 804379c:	2b00      	cmp	r3, #0
 804379e:	f000 80b7 	beq.w	8043910 <kad_op_avg1d+0x504>
 80437a2:	4632      	mov	r2, r6
 80437a4:	2100      	movs	r1, #0
 80437a6:	f008 fb45 	bl	804be34 <memset>
 80437aa:	4632      	mov	r2, r6
 80437ac:	2100      	movs	r1, #0
 80437ae:	4650      	mov	r0, sl
 80437b0:	f008 fb40 	bl	804be34 <memset>
		for (i = 0; i < p->n_d - 1; ++i) rest *= p->d[i];
 80437b4:	1e69      	subs	r1, r5, #1
 80437b6:	2900      	cmp	r1, #0
 80437b8:	f340 808e 	ble.w	80438d8 <kad_op_avg1d+0x4cc>
 80437bc:	2901      	cmp	r1, #1
 80437be:	f8d9 5010 	ldr.w	r5, [r9, #16]
 80437c2:	d00a      	beq.n	80437da <kad_op_avg1d+0x3ce>
 80437c4:	f8d9 3014 	ldr.w	r3, [r9, #20]
 80437c8:	2903      	cmp	r1, #3
 80437ca:	fb03 f505 	mul.w	r5, r3, r5
 80437ce:	f040 808c 	bne.w	80438ea <kad_op_avg1d+0x4de>
 80437d2:	f8d9 2018 	ldr.w	r2, [r9, #24]
 80437d6:	fb02 f505 	mul.w	r5, r2, r5
		for (t = 0; t < rest; ++t) {
 80437da:	2d00      	cmp	r5, #0
 80437dc:	dd62      	ble.n	80438a4 <kad_op_avg1d+0x498>
			int u = t * p_width, v, v0 = t * q->d[p->n_d - 1], v_end = v0 + q->d[p->n_d - 1];
 80437de:	9a01      	ldr	r2, [sp, #4]
			int j, l, p_width = p->d[p->n_d - 1];
 80437e0:	3104      	adds	r1, #4
			int u = t * p_width, v, v0 = t * q->d[p->n_d - 1], v_end = v0 + q->d[p->n_d - 1];
 80437e2:	f852 8021 	ldr.w	r8, [r2, r1, lsl #2]
			for (l = 0; l < aux->kernel_size; ++l)
 80437e6:	2300      	movs	r3, #0
 80437e8:	4647      	mov	r7, r8
 80437ea:	9a02      	ldr	r2, [sp, #8]
			int j, l, p_width = p->d[p->n_d - 1];
 80437ec:	f859 6021 	ldr.w	r6, [r9, r1, lsl #2]
			for (l = 0; l < aux->kernel_size; ++l)
 80437f0:	6811      	ldr	r1, [r2, #0]
 80437f2:	ea4f 0048 	mov.w	r0, r8, lsl #1
 80437f6:	f1aa 0204 	sub.w	r2, sl, #4
 80437fa:	2900      	cmp	r1, #0
 80437fc:	9007      	str	r0, [sp, #28]
		for (t = 0; t < rest; ++t) {
 80437fe:	9506      	str	r5, [sp, #24]
 8043800:	4618      	mov	r0, r3
 8043802:	e9cd 4a08 	strd	r4, sl, [sp, #32]
 8043806:	9d02      	ldr	r5, [sp, #8]
 8043808:	9205      	str	r2, [sp, #20]
			int u = t * p_width, v, v0 = t * q->d[p->n_d - 1], v_end = v0 + q->d[p->n_d - 1];
 804380a:	eba7 0e08 	sub.w	lr, r7, r8
			for (l = 0; l < aux->kernel_size; ++l)
 804380e:	dd47      	ble.n	80438a0 <kad_op_avg1d+0x494>
 8043810:	f04f 0c00 	mov.w	ip, #0
 8043814:	9a05      	ldr	r2, [sp, #20]
 8043816:	ea4f 0a83 	mov.w	sl, r3, lsl #2
 804381a:	eb02 0283 	add.w	r2, r2, r3, lsl #2
 804381e:	e9cd 2302 	strd	r2, r3, [sp, #8]
 8043822:	9004      	str	r0, [sp, #16]
				for (j = 0, v = v0 + (l > aux->pad[0]? l - aux->pad[0] : 0); j < p_width && v < v_end; ++j, v += aux->stride)
 8043824:	68aa      	ldr	r2, [r5, #8]
 8043826:	4562      	cmp	r2, ip
 8043828:	bfb3      	iteet	lt
 804382a:	ebac 0202 	sublt.w	r2, ip, r2
			int u = t * p_width, v, v0 = t * q->d[p->n_d - 1], v_end = v0 + q->d[p->n_d - 1];
 804382e:	4673      	movge	r3, lr
				for (j = 0, v = v0 + (l > aux->pad[0]? l - aux->pad[0] : 0); j < p_width && v < v_end; ++j, v += aux->stride)
 8043830:	2200      	movge	r2, #0
 8043832:	eb0e 0302 	addlt.w	r3, lr, r2
 8043836:	2e00      	cmp	r6, #0
 8043838:	dd20      	ble.n	804387c <kad_op_avg1d+0x470>
 804383a:	4590      	cmp	r8, r2
 804383c:	dd1e      	ble.n	804387c <kad_op_avg1d+0x470>
 804383e:	f8d9 2028 	ldr.w	r2, [r9, #40]	@ 0x28
					p->x[u + j] += q->x[v], ++f[u + j];
 8043842:	9c01      	ldr	r4, [sp, #4]
				for (j = 0, v = v0 + (l > aux->pad[0]? l - aux->pad[0] : 0); j < p_width && v < v_end; ++j, v += aux->stride)
 8043844:	2100      	movs	r1, #0
					p->x[u + j] += q->x[v], ++f[u + j];
 8043846:	9802      	ldr	r0, [sp, #8]
 8043848:	f8d4 b028 	ldr.w	fp, [r4, #40]	@ 0x28
 804384c:	4452      	add	r2, sl
 804384e:	e001      	b.n	8043854 <kad_op_avg1d+0x448>
				for (j = 0, v = v0 + (l > aux->pad[0]? l - aux->pad[0] : 0); j < p_width && v < v_end; ++j, v += aux->stride)
 8043850:	42bb      	cmp	r3, r7
 8043852:	da12      	bge.n	804387a <kad_op_avg1d+0x46e>
					p->x[u + j] += q->x[v], ++f[u + j];
 8043854:	eb0b 0483 	add.w	r4, fp, r3, lsl #2
 8043858:	edd4 7a00 	vldr	s15, [r4]
 804385c:	ed92 7a00 	vldr	s14, [r2]
 8043860:	ee77 7a87 	vadd.f32	s15, s15, s14
 8043864:	f850 4f04 	ldr.w	r4, [r0, #4]!
 8043868:	ece2 7a01 	vstmia	r2!, {s15}
 804386c:	3401      	adds	r4, #1
 804386e:	6004      	str	r4, [r0, #0]
				for (j = 0, v = v0 + (l > aux->pad[0]? l - aux->pad[0] : 0); j < p_width && v < v_end; ++j, v += aux->stride)
 8043870:	686c      	ldr	r4, [r5, #4]
 8043872:	3101      	adds	r1, #1
 8043874:	428e      	cmp	r6, r1
 8043876:	4423      	add	r3, r4
 8043878:	d1ea      	bne.n	8043850 <kad_op_avg1d+0x444>
 804387a:	6829      	ldr	r1, [r5, #0]
			for (l = 0; l < aux->kernel_size; ++l)
 804387c:	f10c 0c01 	add.w	ip, ip, #1
 8043880:	4561      	cmp	r1, ip
 8043882:	dccf      	bgt.n	8043824 <kad_op_avg1d+0x418>
 8043884:	e9dd 3003 	ldrd	r3, r0, [sp, #12]
		for (t = 0; t < rest; ++t) {
 8043888:	9a06      	ldr	r2, [sp, #24]
 804388a:	3001      	adds	r0, #1
 804388c:	4290      	cmp	r0, r2
 804388e:	da07      	bge.n	80438a0 <kad_op_avg1d+0x494>
 8043890:	9a07      	ldr	r2, [sp, #28]
			for (l = 0; l < aux->kernel_size; ++l)
 8043892:	2900      	cmp	r1, #0
 8043894:	eb02 070e 	add.w	r7, r2, lr
			int u = t * p_width, v, v0 = t * q->d[p->n_d - 1], v_end = v0 + q->d[p->n_d - 1];
 8043898:	4433      	add	r3, r6
 804389a:	eba7 0e08 	sub.w	lr, r7, r8
			for (l = 0; l < aux->kernel_size; ++l)
 804389e:	dcb7      	bgt.n	8043810 <kad_op_avg1d+0x404>
 80438a0:	e9dd 4a08 	ldrd	r4, sl, [sp, #32]
		for (i = 0; i < len; ++i) p->x[i] /= f[i];
 80438a4:	2c00      	cmp	r4, #0
 80438a6:	f77f adc3 	ble.w	8043430 <kad_op_avg1d+0x24>
 80438aa:	f8d9 3028 	ldr.w	r3, [r9, #40]	@ 0x28
 80438ae:	f1aa 0a04 	sub.w	sl, sl, #4
 80438b2:	eb03 0984 	add.w	r9, r3, r4, lsl #2
 80438b6:	edda 7a01 	vldr	s15, [sl, #4]
 80438ba:	edd3 6a00 	vldr	s13, [r3]
 80438be:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 80438c2:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 80438c6:	eca3 7a01 	vstmia	r3!, {s14}
 80438ca:	454b      	cmp	r3, r9
 80438cc:	f10a 0a04 	add.w	sl, sl, #4
 80438d0:	d1f1      	bne.n	80438b6 <kad_op_avg1d+0x4aa>
 80438d2:	e5ad      	b.n	8043430 <kad_op_avg1d+0x24>
 80438d4:	2104      	movs	r1, #4
 80438d6:	e5c8      	b.n	804346a <kad_op_avg1d+0x5e>
		int rest = 1, len, t, i;
 80438d8:	2501      	movs	r5, #1
 80438da:	e780      	b.n	80437de <kad_op_avg1d+0x3d2>
		for (i = 0; i < len; ++i) p->x[i] = 0.0f, f[i] = 0;
 80438dc:	2c00      	cmp	r4, #0
 80438de:	f73f af4d 	bgt.w	804377c <kad_op_avg1d+0x370>
		for (i = 0; i < p->n_d - 1; ++i) rest *= p->d[i];
 80438e2:	2100      	movs	r1, #0
 80438e4:	e77b      	b.n	80437de <kad_op_avg1d+0x3d2>
	int n = 1, i;
 80438e6:	2401      	movs	r4, #1
 80438e8:	e748      	b.n	804377c <kad_op_avg1d+0x370>
 80438ea:	2102      	movs	r1, #2
 80438ec:	e775      	b.n	80437da <kad_op_avg1d+0x3ce>
		for (i = 0; i < len; ++i) p->x[i] = 0.0f, f[i] = 0;
 80438ee:	2c00      	cmp	r4, #0
 80438f0:	f73f af44 	bgt.w	804377c <kad_op_avg1d+0x370>
		for (i = 0; i < p->n_d - 1; ++i) rest *= p->d[i];
 80438f4:	4605      	mov	r5, r0
 80438f6:	e767      	b.n	80437c8 <kad_op_avg1d+0x3bc>
		for (i = 0; i < len; ++i) p->x[i] = 0.0f, f[i] = 0;
 80438f8:	2c00      	cmp	r4, #0
 80438fa:	f73f af3f 	bgt.w	804377c <kad_op_avg1d+0x370>
		for (i = 0; i < p->n_d - 1; ++i) rest *= p->d[i];
 80438fe:	4605      	mov	r5, r0
 8043900:	2101      	movs	r1, #1
 8043902:	e76a      	b.n	80437da <kad_op_avg1d+0x3ce>
		int rest = 1, t, i;
 8043904:	f04f 0c01 	mov.w	ip, #1
 8043908:	e5e6      	b.n	80434d8 <kad_op_avg1d+0xcc>
		if (q->n_d != 3) return -1;
 804390a:	f04f 30ff 	mov.w	r0, #4294967295
 804390e:	e590      	b.n	8043432 <kad_op_avg1d+0x26>
		for (i = 0; i < len; ++i) p->x[i] = 0.0f, f[i] = 0;
 8043910:	2600      	movs	r6, #0
 8043912:	4619      	mov	r1, r3
 8043914:	f1aa 0204 	sub.w	r2, sl, #4
 8043918:	3301      	adds	r3, #1
 804391a:	429c      	cmp	r4, r3
 804391c:	f840 6b04 	str.w	r6, [r0], #4
 8043920:	f842 1f04 	str.w	r1, [r2, #4]!
 8043924:	dcf8      	bgt.n	8043918 <kad_op_avg1d+0x50c>
 8043926:	e745      	b.n	80437b4 <kad_op_avg1d+0x3a8>
		for (i = 0; i < p->n_d - 1; ++i) rest *= p->d[i];
 8043928:	1e69      	subs	r1, r5, #1
 804392a:	fb03 f500 	mul.w	r5, r3, r0
 804392e:	e752      	b.n	80437d6 <kad_op_avg1d+0x3ca>

08043930 <kad_op_reduce_sum>:
{
 8043930:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	kad_node_t *q = p->child[0];
 8043934:	6b82      	ldr	r2, [r0, #56]	@ 0x38
	assert(p->ptr);
 8043936:	6b03      	ldr	r3, [r0, #48]	@ 0x30
	kad_node_t *q = p->child[0];
 8043938:	f8d2 9000 	ldr.w	r9, [r2]
{
 804393c:	b083      	sub	sp, #12
	assert(p->ptr);
 804393e:	2b00      	cmp	r3, #0
 8043940:	f000 8158 	beq.w	8043bf4 <kad_op_reduce_sum+0x2c4>
	axis = *(int32_t*)p->ptr;
 8043944:	681d      	ldr	r5, [r3, #0]
	if (axis < 0 || axis >= q->n_d) return -1;
 8043946:	2d00      	cmp	r5, #0
 8043948:	f2c0 8145 	blt.w	8043bd6 <kad_op_reduce_sum+0x2a6>
 804394c:	f899 3000 	ldrb.w	r3, [r9]
 8043950:	42ab      	cmp	r3, r5
 8043952:	f340 8140 	ble.w	8043bd6 <kad_op_reduce_sum+0x2a6>
	for (i = 0, d0 = 1; i < axis; ++i) d0 *= q->d[i];
 8043956:	4680      	mov	r8, r0
 8043958:	2d00      	cmp	r5, #0
 804395a:	f000 80ca 	beq.w	8043af2 <kad_op_reduce_sum+0x1c2>
 804395e:	2d01      	cmp	r5, #1
 8043960:	f8d9 6010 	ldr.w	r6, [r9, #16]
 8043964:	d00f      	beq.n	8043986 <kad_op_reduce_sum+0x56>
 8043966:	f8d9 2014 	ldr.w	r2, [r9, #20]
 804396a:	2d02      	cmp	r5, #2
 804396c:	fb02 f606 	mul.w	r6, r2, r6
 8043970:	d009      	beq.n	8043986 <kad_op_reduce_sum+0x56>
 8043972:	f8d9 2018 	ldr.w	r2, [r9, #24]
 8043976:	2d03      	cmp	r5, #3
 8043978:	fb02 f606 	mul.w	r6, r2, r6
 804397c:	d003      	beq.n	8043986 <kad_op_reduce_sum+0x56>
 804397e:	f8d9 201c 	ldr.w	r2, [r9, #28]
 8043982:	fb02 f606 	mul.w	r6, r2, r6
	for (i = axis + 1, d1 = 1; i < q->n_d; ++i) d1 *= q->d[i];
 8043986:	1c6a      	adds	r2, r5, #1
 8043988:	4293      	cmp	r3, r2
 804398a:	f340 8091 	ble.w	8043ab0 <kad_op_reduce_sum+0x180>
 804398e:	1caa      	adds	r2, r5, #2
 8043990:	eb09 0085 	add.w	r0, r9, r5, lsl #2
 8043994:	4293      	cmp	r3, r2
 8043996:	6944      	ldr	r4, [r0, #20]
 8043998:	dd08      	ble.n	80439ac <kad_op_reduce_sum+0x7c>
 804399a:	6982      	ldr	r2, [r0, #24]
 804399c:	fb02 f404 	mul.w	r4, r2, r4
 80439a0:	1cea      	adds	r2, r5, #3
 80439a2:	4293      	cmp	r3, r2
 80439a4:	dd02      	ble.n	80439ac <kad_op_reduce_sum+0x7c>
 80439a6:	69c2      	ldr	r2, [r0, #28]
 80439a8:	fb02 f404 	mul.w	r4, r2, r4
	if (action == KAD_SYNC_DIM) {
 80439ac:	2904      	cmp	r1, #4
 80439ae:	d060      	beq.n	8043a72 <kad_op_reduce_sum+0x142>
	} else if (action == KAD_FORWARD) {
 80439b0:	2902      	cmp	r1, #2
 80439b2:	d006      	beq.n	80439c2 <kad_op_reduce_sum+0x92>
	} else if (action == KAD_BACKWARD && kad_is_back(q)) {
 80439b4:	2903      	cmp	r1, #3
 80439b6:	f000 809e 	beq.w	8043af6 <kad_op_reduce_sum+0x1c6>
	return 0;
 80439ba:	2000      	movs	r0, #0
}
 80439bc:	b003      	add	sp, #12
 80439be:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	for (i = 0; i < p->n_d; ++i) n *= p->d[i];
 80439c2:	f898 2000 	ldrb.w	r2, [r8]
		memset(p->x, 0, kad_len(p) * sizeof(float));
 80439c6:	f8d8 0028 	ldr.w	r0, [r8, #40]	@ 0x28
 80439ca:	2a00      	cmp	r2, #0
 80439cc:	f000 80fd 	beq.w	8043bca <kad_op_reduce_sum+0x29a>
 80439d0:	2a01      	cmp	r2, #1
 80439d2:	f8d8 3010 	ldr.w	r3, [r8, #16]
 80439d6:	d00e      	beq.n	80439f6 <kad_op_reduce_sum+0xc6>
 80439d8:	f8d8 1014 	ldr.w	r1, [r8, #20]
 80439dc:	2a02      	cmp	r2, #2
 80439de:	fb01 f303 	mul.w	r3, r1, r3
 80439e2:	d008      	beq.n	80439f6 <kad_op_reduce_sum+0xc6>
 80439e4:	f8d8 1018 	ldr.w	r1, [r8, #24]
 80439e8:	2a03      	cmp	r2, #3
 80439ea:	fb01 f303 	mul.w	r3, r1, r3
 80439ee:	bf1c      	itt	ne
 80439f0:	f8d8 201c 	ldrne.w	r2, [r8, #28]
 80439f4:	4353      	mulne	r3, r2
 80439f6:	009a      	lsls	r2, r3, #2
 80439f8:	2100      	movs	r1, #0
 80439fa:	f008 fa1b 	bl	804be34 <memset>
		for (i = 0; i < d0; ++i)
 80439fe:	2e00      	cmp	r6, #0
 8043a00:	dddb      	ble.n	80439ba <kad_op_reduce_sum+0x8a>
			for (j = 0; j < q->d[axis]; ++j)
 8043a02:	3504      	adds	r5, #4
 8043a04:	f859 e025 	ldr.w	lr, [r9, r5, lsl #2]
 8043a08:	f1be 0f00 	cmp.w	lr, #0
 8043a0c:	ddd5      	ble.n	80439ba <kad_op_reduce_sum+0x8a>
 8043a0e:	2c00      	cmp	r4, #0
 8043a10:	ddd3      	ble.n	80439ba <kad_op_reduce_sum+0x8a>
					p->x[i * d1 + k] += q->x[(i * q->d[axis] + j) * d1 + k];
 8043a12:	2300      	movs	r3, #0
 8043a14:	00a2      	lsls	r2, r4, #2
 8043a16:	4692      	mov	sl, r2
 8043a18:	f8d8 b028 	ldr.w	fp, [r8, #40]	@ 0x28
 8043a1c:	f8d9 7028 	ldr.w	r7, [r9, #40]	@ 0x28
 8043a20:	9201      	str	r2, [sp, #4]
 8043a22:	4699      	mov	r9, r3
		for (i = 0; i < d0; ++i)
 8043a24:	4698      	mov	r8, r3
 8043a26:	4632      	mov	r2, r6
			for (j = 0; j < q->d[axis]; ++j)
 8043a28:	2600      	movs	r6, #0
 8043a2a:	fb04 f509 	mul.w	r5, r4, r9
 8043a2e:	eb0b 0c83 	add.w	ip, fp, r3, lsl #2
 8043a32:	eb0b 000a 	add.w	r0, fp, sl
 8043a36:	f8cd b000 	str.w	fp, [sp]
 8043a3a:	4661      	mov	r1, ip
 8043a3c:	eb07 0b85 	add.w	fp, r7, r5, lsl #2
					p->x[i * d1 + k] += q->x[(i * q->d[axis] + j) * d1 + k];
 8043a40:	edd1 7a00 	vldr	s15, [r1]
 8043a44:	ecbb 7a01 	vldmia	fp!, {s14}
 8043a48:	ee77 7a87 	vadd.f32	s15, s15, s14
 8043a4c:	ece1 7a01 	vstmia	r1!, {s15}
				for (k = 0; k < d1; ++k)
 8043a50:	4281      	cmp	r1, r0
 8043a52:	d1f5      	bne.n	8043a40 <kad_op_reduce_sum+0x110>
			for (j = 0; j < q->d[axis]; ++j)
 8043a54:	3601      	adds	r6, #1
 8043a56:	4576      	cmp	r6, lr
 8043a58:	4425      	add	r5, r4
 8043a5a:	d1ee      	bne.n	8043a3a <kad_op_reduce_sum+0x10a>
		for (i = 0; i < d0; ++i)
 8043a5c:	9901      	ldr	r1, [sp, #4]
 8043a5e:	f108 0801 	add.w	r8, r8, #1
 8043a62:	4590      	cmp	r8, r2
 8043a64:	f8dd b000 	ldr.w	fp, [sp]
 8043a68:	44f1      	add	r9, lr
 8043a6a:	4423      	add	r3, r4
 8043a6c:	448a      	add	sl, r1
 8043a6e:	d1db      	bne.n	8043a28 <kad_op_reduce_sum+0xf8>
 8043a70:	e7a3      	b.n	80439ba <kad_op_reduce_sum+0x8a>
		p->n_d = q->n_d - 1;
 8043a72:	3b01      	subs	r3, #1
 8043a74:	f888 3000 	strb.w	r3, [r8]
		for (i = j = 0; i < q->n_d; ++i)
 8043a78:	f899 3000 	ldrb.w	r3, [r9]
 8043a7c:	2b00      	cmp	r3, #0
 8043a7e:	d09c      	beq.n	80439ba <kad_op_reduce_sum+0x8a>
			if (i != axis) p->d[j++] = q->d[i];
 8043a80:	b1c5      	cbz	r5, 8043ab4 <kad_op_reduce_sum+0x184>
 8043a82:	f8d9 2010 	ldr.w	r2, [r9, #16]
		for (i = j = 0; i < q->n_d; ++i)
 8043a86:	2b01      	cmp	r3, #1
			if (i != axis) p->d[j++] = q->d[i];
 8043a88:	f8c8 2010 	str.w	r2, [r8, #16]
		for (i = j = 0; i < q->n_d; ++i)
 8043a8c:	d095      	beq.n	80439ba <kad_op_reduce_sum+0x8a>
			if (i != axis) p->d[j++] = q->d[i];
 8043a8e:	2d01      	cmp	r5, #1
 8043a90:	d16e      	bne.n	8043b70 <kad_op_reduce_sum+0x240>
		for (i = j = 0; i < q->n_d; ++i)
 8043a92:	2b02      	cmp	r3, #2
 8043a94:	d091      	beq.n	80439ba <kad_op_reduce_sum+0x8a>
			if (i != axis) p->d[j++] = q->d[i];
 8043a96:	f8d9 2018 	ldr.w	r2, [r9, #24]
		for (i = j = 0; i < q->n_d; ++i)
 8043a9a:	2b03      	cmp	r3, #3
			if (i != axis) p->d[j++] = q->d[i];
 8043a9c:	f8c8 2014 	str.w	r2, [r8, #20]
		for (i = j = 0; i < q->n_d; ++i)
 8043aa0:	d08b      	beq.n	80439ba <kad_op_reduce_sum+0x8a>
			if (i != axis) p->d[j++] = q->d[i];
 8043aa2:	f8d9 201c 	ldr.w	r2, [r9, #28]
		for (i = j = 0; i < q->n_d; ++i)
 8043aa6:	2b04      	cmp	r3, #4
			if (i != axis) p->d[j++] = q->d[i];
 8043aa8:	f8c8 2018 	str.w	r2, [r8, #24]
		for (i = j = 0; i < q->n_d; ++i)
 8043aac:	d173      	bne.n	8043b96 <kad_op_reduce_sum+0x266>
 8043aae:	e784      	b.n	80439ba <kad_op_reduce_sum+0x8a>
	for (i = axis + 1, d1 = 1; i < q->n_d; ++i) d1 *= q->d[i];
 8043ab0:	2401      	movs	r4, #1
 8043ab2:	e77b      	b.n	80439ac <kad_op_reduce_sum+0x7c>
		for (i = j = 0; i < q->n_d; ++i)
 8043ab4:	2b01      	cmp	r3, #1
 8043ab6:	d080      	beq.n	80439ba <kad_op_reduce_sum+0x8a>
			if (i != axis) p->d[j++] = q->d[i];
 8043ab8:	f8d9 2014 	ldr.w	r2, [r9, #20]
		for (i = j = 0; i < q->n_d; ++i)
 8043abc:	2b02      	cmp	r3, #2
			if (i != axis) p->d[j++] = q->d[i];
 8043abe:	f8c8 2010 	str.w	r2, [r8, #16]
		for (i = j = 0; i < q->n_d; ++i)
 8043ac2:	f43f af7a 	beq.w	80439ba <kad_op_reduce_sum+0x8a>
			if (i != axis) p->d[j++] = q->d[i];
 8043ac6:	f8d9 2018 	ldr.w	r2, [r9, #24]
		for (i = j = 0; i < q->n_d; ++i)
 8043aca:	2b03      	cmp	r3, #3
			if (i != axis) p->d[j++] = q->d[i];
 8043acc:	f8c8 2014 	str.w	r2, [r8, #20]
 8043ad0:	bf18      	it	ne
 8043ad2:	2202      	movne	r2, #2
		for (i = j = 0; i < q->n_d; ++i)
 8043ad4:	f43f af71 	beq.w	80439ba <kad_op_reduce_sum+0x8a>
			if (i != axis) p->d[j++] = q->d[i];
 8043ad8:	f8d9 001c 	ldr.w	r0, [r9, #28]
 8043adc:	1d11      	adds	r1, r2, #4
		for (i = j = 0; i < q->n_d; ++i)
 8043ade:	2b04      	cmp	r3, #4
			if (i != axis) p->d[j++] = q->d[i];
 8043ae0:	f848 0021 	str.w	r0, [r8, r1, lsl #2]
 8043ae4:	f102 0201 	add.w	r2, r2, #1
		for (i = j = 0; i < q->n_d; ++i)
 8043ae8:	f77f af67 	ble.w	80439ba <kad_op_reduce_sum+0x8a>
			if (i != axis) p->d[j++] = q->d[i];
 8043aec:	2d04      	cmp	r5, #4
 8043aee:	d059      	beq.n	8043ba4 <kad_op_reduce_sum+0x274>
 8043af0:	e052      	b.n	8043b98 <kad_op_reduce_sum+0x268>
	for (i = 0, d0 = 1; i < axis; ++i) d0 *= q->d[i];
 8043af2:	2601      	movs	r6, #1
 8043af4:	e747      	b.n	8043986 <kad_op_reduce_sum+0x56>
	} else if (action == KAD_BACKWARD && kad_is_back(q)) {
 8043af6:	f899 3001 	ldrb.w	r3, [r9, #1]
 8043afa:	07db      	lsls	r3, r3, #31
 8043afc:	f57f af5d 	bpl.w	80439ba <kad_op_reduce_sum+0x8a>
		for (i = 0; i < d0; ++i)
 8043b00:	2e00      	cmp	r6, #0
 8043b02:	f77f af5a 	ble.w	80439ba <kad_op_reduce_sum+0x8a>
			for (j = 0; j < q->d[axis]; ++j)
 8043b06:	3504      	adds	r5, #4
 8043b08:	f859 7025 	ldr.w	r7, [r9, r5, lsl #2]
 8043b0c:	2f00      	cmp	r7, #0
 8043b0e:	f77f af54 	ble.w	80439ba <kad_op_reduce_sum+0x8a>
 8043b12:	2c00      	cmp	r4, #0
 8043b14:	f77f af51 	ble.w	80439ba <kad_op_reduce_sum+0x8a>
					q->g[(i * q->d[axis] + j) * d1 + k] += p->g[i * d1 + k];
 8043b18:	2300      	movs	r3, #0
 8043b1a:	f8d9 e02c 	ldr.w	lr, [r9, #44]	@ 0x2c
		for (i = 0; i < d0; ++i)
 8043b1e:	461a      	mov	r2, r3
					q->g[(i * q->d[axis] + j) * d1 + k] += p->g[i * d1 + k];
 8043b20:	4699      	mov	r9, r3
 8043b22:	f8d8 a02c 	ldr.w	sl, [r8, #44]	@ 0x2c
 8043b26:	eb0e 0884 	add.w	r8, lr, r4, lsl #2
 8043b2a:	f8cd a000 	str.w	sl, [sp]
			for (j = 0; j < q->d[axis]; ++j)
 8043b2e:	f04f 0a00 	mov.w	sl, #0
 8043b32:	fb04 fc09 	mul.w	ip, r4, r9
 8043b36:	9900      	ldr	r1, [sp, #0]
 8043b38:	eb01 0b83 	add.w	fp, r1, r3, lsl #2
		for (i = 0; i < d0; ++i)
 8043b3c:	4658      	mov	r0, fp
 8043b3e:	eb0e 018c 	add.w	r1, lr, ip, lsl #2
 8043b42:	eb08 058c 	add.w	r5, r8, ip, lsl #2
					q->g[(i * q->d[axis] + j) * d1 + k] += p->g[i * d1 + k];
 8043b46:	edd1 7a00 	vldr	s15, [r1]
 8043b4a:	ecb0 7a01 	vldmia	r0!, {s14}
 8043b4e:	ee77 7a87 	vadd.f32	s15, s15, s14
 8043b52:	ece1 7a01 	vstmia	r1!, {s15}
				for (k = 0; k < d1; ++k)
 8043b56:	428d      	cmp	r5, r1
 8043b58:	d1f5      	bne.n	8043b46 <kad_op_reduce_sum+0x216>
			for (j = 0; j < q->d[axis]; ++j)
 8043b5a:	f10a 0a01 	add.w	sl, sl, #1
 8043b5e:	45ba      	cmp	sl, r7
 8043b60:	44a4      	add	ip, r4
 8043b62:	d1eb      	bne.n	8043b3c <kad_op_reduce_sum+0x20c>
		for (i = 0; i < d0; ++i)
 8043b64:	3201      	adds	r2, #1
 8043b66:	42b2      	cmp	r2, r6
 8043b68:	44b9      	add	r9, r7
 8043b6a:	4423      	add	r3, r4
 8043b6c:	d1df      	bne.n	8043b2e <kad_op_reduce_sum+0x1fe>
 8043b6e:	e724      	b.n	80439ba <kad_op_reduce_sum+0x8a>
			if (i != axis) p->d[j++] = q->d[i];
 8043b70:	f8d9 2014 	ldr.w	r2, [r9, #20]
		for (i = j = 0; i < q->n_d; ++i)
 8043b74:	2b02      	cmp	r3, #2
			if (i != axis) p->d[j++] = q->d[i];
 8043b76:	f8c8 2014 	str.w	r2, [r8, #20]
		for (i = j = 0; i < q->n_d; ++i)
 8043b7a:	f43f af1e 	beq.w	80439ba <kad_op_reduce_sum+0x8a>
			if (i != axis) p->d[j++] = q->d[i];
 8043b7e:	2d02      	cmp	r5, #2
 8043b80:	d12c      	bne.n	8043bdc <kad_op_reduce_sum+0x2ac>
		for (i = j = 0; i < q->n_d; ++i)
 8043b82:	2b03      	cmp	r3, #3
 8043b84:	f43f af19 	beq.w	80439ba <kad_op_reduce_sum+0x8a>
			if (i != axis) p->d[j++] = q->d[i];
 8043b88:	f8d9 201c 	ldr.w	r2, [r9, #28]
		for (i = j = 0; i < q->n_d; ++i)
 8043b8c:	2b04      	cmp	r3, #4
			if (i != axis) p->d[j++] = q->d[i];
 8043b8e:	f8c8 2018 	str.w	r2, [r8, #24]
		for (i = j = 0; i < q->n_d; ++i)
 8043b92:	f43f af12 	beq.w	80439ba <kad_op_reduce_sum+0x8a>
			if (i != axis) p->d[j++] = q->d[i];
 8043b96:	2203      	movs	r2, #3
 8043b98:	f8d9 0020 	ldr.w	r0, [r9, #32]
 8043b9c:	1d11      	adds	r1, r2, #4
 8043b9e:	f848 0021 	str.w	r0, [r8, r1, lsl #2]
 8043ba2:	3201      	adds	r2, #1
		for (i = j = 0; i < q->n_d; ++i)
 8043ba4:	2b05      	cmp	r3, #5
 8043ba6:	f77f af08 	ble.w	80439ba <kad_op_reduce_sum+0x8a>
 8043baa:	2105      	movs	r1, #5
			if (i != axis) p->d[j++] = q->d[i];
 8043bac:	42a9      	cmp	r1, r5
 8043bae:	d00e      	beq.n	8043bce <kad_op_reduce_sum+0x29e>
 8043bb0:	f109 0010 	add.w	r0, r9, #16
 8043bb4:	f850 4021 	ldr.w	r4, [r0, r1, lsl #2]
		for (i = j = 0; i < q->n_d; ++i)
 8043bb8:	3101      	adds	r1, #1
			if (i != axis) p->d[j++] = q->d[i];
 8043bba:	1d10      	adds	r0, r2, #4
		for (i = j = 0; i < q->n_d; ++i)
 8043bbc:	4299      	cmp	r1, r3
			if (i != axis) p->d[j++] = q->d[i];
 8043bbe:	f848 4020 	str.w	r4, [r8, r0, lsl #2]
 8043bc2:	f102 0201 	add.w	r2, r2, #1
		for (i = j = 0; i < q->n_d; ++i)
 8043bc6:	dbf1      	blt.n	8043bac <kad_op_reduce_sum+0x27c>
 8043bc8:	e6f7      	b.n	80439ba <kad_op_reduce_sum+0x8a>
 8043bca:	2204      	movs	r2, #4
 8043bcc:	e714      	b.n	80439f8 <kad_op_reduce_sum+0xc8>
 8043bce:	3101      	adds	r1, #1
 8043bd0:	4299      	cmp	r1, r3
 8043bd2:	dbeb      	blt.n	8043bac <kad_op_reduce_sum+0x27c>
 8043bd4:	e6f1      	b.n	80439ba <kad_op_reduce_sum+0x8a>
	if (axis < 0 || axis >= q->n_d) return -1;
 8043bd6:	f04f 30ff 	mov.w	r0, #4294967295
 8043bda:	e6ef      	b.n	80439bc <kad_op_reduce_sum+0x8c>
			if (i != axis) p->d[j++] = q->d[i];
 8043bdc:	f8d9 2018 	ldr.w	r2, [r9, #24]
		for (i = j = 0; i < q->n_d; ++i)
 8043be0:	2b03      	cmp	r3, #3
			if (i != axis) p->d[j++] = q->d[i];
 8043be2:	f8c8 2018 	str.w	r2, [r8, #24]
		for (i = j = 0; i < q->n_d; ++i)
 8043be6:	f43f aee8 	beq.w	80439ba <kad_op_reduce_sum+0x8a>
			if (i != axis) p->d[j++] = q->d[i];
 8043bea:	2d03      	cmp	r5, #3
 8043bec:	d109      	bne.n	8043c02 <kad_op_reduce_sum+0x2d2>
		for (i = j = 0; i < q->n_d; ++i)
 8043bee:	2b04      	cmp	r3, #4
 8043bf0:	d1d1      	bne.n	8043b96 <kad_op_reduce_sum+0x266>
 8043bf2:	e6e2      	b.n	80439ba <kad_op_reduce_sum+0x8a>
	assert(p->ptr);
 8043bf4:	f240 41e3 	movw	r1, #1251	@ 0x4e3
 8043bf8:	4b03      	ldr	r3, [pc, #12]	@ (8043c08 <kad_op_reduce_sum+0x2d8>)
 8043bfa:	4a04      	ldr	r2, [pc, #16]	@ (8043c0c <kad_op_reduce_sum+0x2dc>)
 8043bfc:	4804      	ldr	r0, [pc, #16]	@ (8043c10 <kad_op_reduce_sum+0x2e0>)
 8043bfe:	f007 fdf1 	bl	804b7e4 <__assert_func>
			if (i != axis) p->d[j++] = q->d[i];
 8043c02:	2203      	movs	r2, #3
 8043c04:	e768      	b.n	8043ad8 <kad_op_reduce_sum+0x1a8>
 8043c06:	bf00      	nop
 8043c08:	0804e3d4 	.word	0x0804e3d4
 8043c0c:	0804e590 	.word	0x0804e590
 8043c10:	0804e3dc 	.word	0x0804e3dc

08043c14 <kad_op_reduce_mean>:
{
 8043c14:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8043c18:	ed2d 8b02 	vpush	{d8}
	kad_node_t *q = p->child[0];
 8043c1c:	6b82      	ldr	r2, [r0, #56]	@ 0x38
	assert(p->ptr);
 8043c1e:	6b03      	ldr	r3, [r0, #48]	@ 0x30
	kad_node_t *q = p->child[0];
 8043c20:	f8d2 8000 	ldr.w	r8, [r2]
{
 8043c24:	b083      	sub	sp, #12
	assert(p->ptr);
 8043c26:	2b00      	cmp	r3, #0
 8043c28:	f000 8160 	beq.w	8043eec <kad_op_reduce_mean+0x2d8>
	axis = *(int32_t*)p->ptr;
 8043c2c:	681b      	ldr	r3, [r3, #0]
	if (axis < 0 || axis >= q->n_d) return -1;
 8043c2e:	2b00      	cmp	r3, #0
 8043c30:	f2c0 814e 	blt.w	8043ed0 <kad_op_reduce_mean+0x2bc>
 8043c34:	f898 2000 	ldrb.w	r2, [r8]
 8043c38:	429a      	cmp	r2, r3
 8043c3a:	f340 8149 	ble.w	8043ed0 <kad_op_reduce_mean+0x2bc>
	for (i = 0, d0 = 1; i < axis; ++i) d0 *= q->d[i];
 8043c3e:	4605      	mov	r5, r0
 8043c40:	2b00      	cmp	r3, #0
 8043c42:	f000 80cb 	beq.w	8043ddc <kad_op_reduce_mean+0x1c8>
 8043c46:	2b01      	cmp	r3, #1
 8043c48:	f8d8 6010 	ldr.w	r6, [r8, #16]
 8043c4c:	d00f      	beq.n	8043c6e <kad_op_reduce_mean+0x5a>
 8043c4e:	f8d8 0014 	ldr.w	r0, [r8, #20]
 8043c52:	2b02      	cmp	r3, #2
 8043c54:	fb00 f606 	mul.w	r6, r0, r6
 8043c58:	d009      	beq.n	8043c6e <kad_op_reduce_mean+0x5a>
 8043c5a:	f8d8 0018 	ldr.w	r0, [r8, #24]
 8043c5e:	2b03      	cmp	r3, #3
 8043c60:	fb00 f606 	mul.w	r6, r0, r6
 8043c64:	d003      	beq.n	8043c6e <kad_op_reduce_mean+0x5a>
 8043c66:	f8d8 001c 	ldr.w	r0, [r8, #28]
 8043c6a:	fb00 f606 	mul.w	r6, r0, r6
	for (i = axis + 1, d1 = 1; i < q->n_d; ++i) d1 *= q->d[i];
 8043c6e:	f103 0c01 	add.w	ip, r3, #1
 8043c72:	4562      	cmp	r2, ip
 8043c74:	f340 8092 	ble.w	8043d9c <kad_op_reduce_mean+0x188>
 8043c78:	1c98      	adds	r0, r3, #2
 8043c7a:	eb08 0783 	add.w	r7, r8, r3, lsl #2
 8043c7e:	4282      	cmp	r2, r0
 8043c80:	697c      	ldr	r4, [r7, #20]
 8043c82:	dd08      	ble.n	8043c96 <kad_op_reduce_mean+0x82>
 8043c84:	69b8      	ldr	r0, [r7, #24]
 8043c86:	fb00 f404 	mul.w	r4, r0, r4
 8043c8a:	1cd8      	adds	r0, r3, #3
 8043c8c:	4282      	cmp	r2, r0
 8043c8e:	dd02      	ble.n	8043c96 <kad_op_reduce_mean+0x82>
 8043c90:	69f8      	ldr	r0, [r7, #28]
 8043c92:	fb00 f404 	mul.w	r4, r0, r4
	if (action == KAD_SYNC_DIM) {
 8043c96:	2904      	cmp	r1, #4
 8043c98:	d065      	beq.n	8043d66 <kad_op_reduce_mean+0x152>
	} else if (action == KAD_FORWARD) {
 8043c9a:	2902      	cmp	r1, #2
 8043c9c:	d008      	beq.n	8043cb0 <kad_op_reduce_mean+0x9c>
	} else if (action == KAD_BACKWARD && kad_is_back(q)) {
 8043c9e:	2903      	cmp	r1, #3
 8043ca0:	f000 809e 	beq.w	8043de0 <kad_op_reduce_mean+0x1cc>
	return 0;
 8043ca4:	2000      	movs	r0, #0
}
 8043ca6:	b003      	add	sp, #12
 8043ca8:	ecbd 8b02 	vpop	{d8}
 8043cac:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8043cb0:	7829      	ldrb	r1, [r5, #0]
 8043cb2:	eb08 0783 	add.w	r7, r8, r3, lsl #2
		float t = 1.0f / q->d[axis];
 8043cb6:	ed97 8a04 	vldr	s16, [r7, #16]
		memset(p->x, 0, kad_len(p) * sizeof(float));
 8043cba:	6aa8      	ldr	r0, [r5, #40]	@ 0x28
 8043cbc:	2900      	cmp	r1, #0
 8043cbe:	f000 8101 	beq.w	8043ec4 <kad_op_reduce_mean+0x2b0>
 8043cc2:	2901      	cmp	r1, #1
 8043cc4:	692a      	ldr	r2, [r5, #16]
 8043cc6:	d00b      	beq.n	8043ce0 <kad_op_reduce_mean+0xcc>
 8043cc8:	696b      	ldr	r3, [r5, #20]
 8043cca:	2902      	cmp	r1, #2
 8043ccc:	fb03 f202 	mul.w	r2, r3, r2
 8043cd0:	d006      	beq.n	8043ce0 <kad_op_reduce_mean+0xcc>
 8043cd2:	69ab      	ldr	r3, [r5, #24]
 8043cd4:	2903      	cmp	r1, #3
 8043cd6:	fb03 f202 	mul.w	r2, r3, r2
 8043cda:	bf1c      	itt	ne
 8043cdc:	69eb      	ldrne	r3, [r5, #28]
 8043cde:	435a      	mulne	r2, r3
 8043ce0:	0092      	lsls	r2, r2, #2
 8043ce2:	2100      	movs	r1, #0
 8043ce4:	f008 f8a6 	bl	804be34 <memset>
		for (i = 0; i < d0; ++i)
 8043ce8:	2e00      	cmp	r6, #0
 8043cea:	dddb      	ble.n	8043ca4 <kad_op_reduce_mean+0x90>
			for (j = 0; j < q->d[axis]; ++j)
 8043cec:	f8d7 e010 	ldr.w	lr, [r7, #16]
 8043cf0:	f1be 0f00 	cmp.w	lr, #0
 8043cf4:	ddd6      	ble.n	8043ca4 <kad_op_reduce_mean+0x90>
 8043cf6:	2c00      	cmp	r4, #0
 8043cf8:	ddd4      	ble.n	8043ca4 <kad_op_reduce_mean+0x90>
					p->x[i * d1 + k] += t * q->x[(i * q->d[axis] + j) * d1 + k];
 8043cfa:	2300      	movs	r3, #0
		float t = 1.0f / q->d[axis];
 8043cfc:	eef8 7ac8 	vcvt.f32.s32	s15, s16
 8043d00:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 8043d04:	00a2      	lsls	r2, r4, #2
					p->x[i * d1 + k] += t * q->x[(i * q->d[axis] + j) * d1 + k];
 8043d06:	4692      	mov	sl, r2
 8043d08:	f8d8 7028 	ldr.w	r7, [r8, #40]	@ 0x28
 8043d0c:	9201      	str	r2, [sp, #4]
		float t = 1.0f / q->d[axis];
 8043d0e:	eec7 6a27 	vdiv.f32	s13, s14, s15
					p->x[i * d1 + k] += t * q->x[(i * q->d[axis] + j) * d1 + k];
 8043d12:	4699      	mov	r9, r3
		for (i = 0; i < d0; ++i)
 8043d14:	4698      	mov	r8, r3
 8043d16:	4632      	mov	r2, r6
					p->x[i * d1 + k] += t * q->x[(i * q->d[axis] + j) * d1 + k];
 8043d18:	f8d5 b028 	ldr.w	fp, [r5, #40]	@ 0x28
			for (j = 0; j < q->d[axis]; ++j)
 8043d1c:	2600      	movs	r6, #0
 8043d1e:	fb04 f509 	mul.w	r5, r4, r9
 8043d22:	eb0b 0c83 	add.w	ip, fp, r3, lsl #2
 8043d26:	eb0b 000a 	add.w	r0, fp, sl
 8043d2a:	f8cd b000 	str.w	fp, [sp]
 8043d2e:	4661      	mov	r1, ip
 8043d30:	eb07 0b85 	add.w	fp, r7, r5, lsl #2
					p->x[i * d1 + k] += t * q->x[(i * q->d[axis] + j) * d1 + k];
 8043d34:	edd1 7a00 	vldr	s15, [r1]
 8043d38:	ecbb 7a01 	vldmia	fp!, {s14}
 8043d3c:	eee7 7a26 	vfma.f32	s15, s14, s13
 8043d40:	ece1 7a01 	vstmia	r1!, {s15}
				for (k = 0; k < d1; ++k)
 8043d44:	4281      	cmp	r1, r0
 8043d46:	d1f5      	bne.n	8043d34 <kad_op_reduce_mean+0x120>
			for (j = 0; j < q->d[axis]; ++j)
 8043d48:	3601      	adds	r6, #1
 8043d4a:	4576      	cmp	r6, lr
 8043d4c:	4425      	add	r5, r4
 8043d4e:	d1ee      	bne.n	8043d2e <kad_op_reduce_mean+0x11a>
		for (i = 0; i < d0; ++i)
 8043d50:	9901      	ldr	r1, [sp, #4]
 8043d52:	f108 0801 	add.w	r8, r8, #1
 8043d56:	4590      	cmp	r8, r2
 8043d58:	f8dd b000 	ldr.w	fp, [sp]
 8043d5c:	44f1      	add	r9, lr
 8043d5e:	4423      	add	r3, r4
 8043d60:	448a      	add	sl, r1
 8043d62:	d1db      	bne.n	8043d1c <kad_op_reduce_mean+0x108>
 8043d64:	e79e      	b.n	8043ca4 <kad_op_reduce_mean+0x90>
		p->n_d = q->n_d - 1;
 8043d66:	3a01      	subs	r2, #1
 8043d68:	702a      	strb	r2, [r5, #0]
		for (i = j = 0; i < q->n_d; ++i)
 8043d6a:	f898 2000 	ldrb.w	r2, [r8]
 8043d6e:	2a00      	cmp	r2, #0
 8043d70:	d098      	beq.n	8043ca4 <kad_op_reduce_mean+0x90>
			if (i != axis) p->d[j++] = q->d[i];
 8043d72:	b1ab      	cbz	r3, 8043da0 <kad_op_reduce_mean+0x18c>
 8043d74:	f8d8 1010 	ldr.w	r1, [r8, #16]
		for (i = j = 0; i < q->n_d; ++i)
 8043d78:	2a01      	cmp	r2, #1
			if (i != axis) p->d[j++] = q->d[i];
 8043d7a:	6129      	str	r1, [r5, #16]
		for (i = j = 0; i < q->n_d; ++i)
 8043d7c:	d092      	beq.n	8043ca4 <kad_op_reduce_mean+0x90>
			if (i != axis) p->d[j++] = q->d[i];
 8043d7e:	2b01      	cmp	r3, #1
 8043d80:	d175      	bne.n	8043e6e <kad_op_reduce_mean+0x25a>
		for (i = j = 0; i < q->n_d; ++i)
 8043d82:	2a02      	cmp	r2, #2
 8043d84:	d08e      	beq.n	8043ca4 <kad_op_reduce_mean+0x90>
			if (i != axis) p->d[j++] = q->d[i];
 8043d86:	f8d8 1018 	ldr.w	r1, [r8, #24]
		for (i = j = 0; i < q->n_d; ++i)
 8043d8a:	2a03      	cmp	r2, #3
			if (i != axis) p->d[j++] = q->d[i];
 8043d8c:	6169      	str	r1, [r5, #20]
		for (i = j = 0; i < q->n_d; ++i)
 8043d8e:	d089      	beq.n	8043ca4 <kad_op_reduce_mean+0x90>
			if (i != axis) p->d[j++] = q->d[i];
 8043d90:	f8d8 101c 	ldr.w	r1, [r8, #28]
		for (i = j = 0; i < q->n_d; ++i)
 8043d94:	2a04      	cmp	r2, #4
			if (i != axis) p->d[j++] = q->d[i];
 8043d96:	61a9      	str	r1, [r5, #24]
		for (i = j = 0; i < q->n_d; ++i)
 8043d98:	d17a      	bne.n	8043e90 <kad_op_reduce_mean+0x27c>
 8043d9a:	e783      	b.n	8043ca4 <kad_op_reduce_mean+0x90>
	for (i = axis + 1, d1 = 1; i < q->n_d; ++i) d1 *= q->d[i];
 8043d9c:	2401      	movs	r4, #1
 8043d9e:	e77a      	b.n	8043c96 <kad_op_reduce_mean+0x82>
		for (i = j = 0; i < q->n_d; ++i)
 8043da0:	2a01      	cmp	r2, #1
 8043da2:	f43f af7f 	beq.w	8043ca4 <kad_op_reduce_mean+0x90>
			if (i != axis) p->d[j++] = q->d[i];
 8043da6:	f8d8 1014 	ldr.w	r1, [r8, #20]
		for (i = j = 0; i < q->n_d; ++i)
 8043daa:	2a02      	cmp	r2, #2
			if (i != axis) p->d[j++] = q->d[i];
 8043dac:	6129      	str	r1, [r5, #16]
		for (i = j = 0; i < q->n_d; ++i)
 8043dae:	f43f af79 	beq.w	8043ca4 <kad_op_reduce_mean+0x90>
			if (i != axis) p->d[j++] = q->d[i];
 8043db2:	f8d8 1018 	ldr.w	r1, [r8, #24]
		for (i = j = 0; i < q->n_d; ++i)
 8043db6:	2a03      	cmp	r2, #3
			if (i != axis) p->d[j++] = q->d[i];
 8043db8:	6169      	str	r1, [r5, #20]
 8043dba:	bf18      	it	ne
 8043dbc:	2102      	movne	r1, #2
		for (i = j = 0; i < q->n_d; ++i)
 8043dbe:	f43f af71 	beq.w	8043ca4 <kad_op_reduce_mean+0x90>
			if (i != axis) p->d[j++] = q->d[i];
 8043dc2:	f8d8 401c 	ldr.w	r4, [r8, #28]
 8043dc6:	1d08      	adds	r0, r1, #4
		for (i = j = 0; i < q->n_d; ++i)
 8043dc8:	2a04      	cmp	r2, #4
			if (i != axis) p->d[j++] = q->d[i];
 8043dca:	f845 4020 	str.w	r4, [r5, r0, lsl #2]
 8043dce:	f101 0101 	add.w	r1, r1, #1
		for (i = j = 0; i < q->n_d; ++i)
 8043dd2:	f77f af67 	ble.w	8043ca4 <kad_op_reduce_mean+0x90>
			if (i != axis) p->d[j++] = q->d[i];
 8043dd6:	2b04      	cmp	r3, #4
 8043dd8:	d061      	beq.n	8043e9e <kad_op_reduce_mean+0x28a>
 8043dda:	e05a      	b.n	8043e92 <kad_op_reduce_mean+0x27e>
	for (i = 0, d0 = 1; i < axis; ++i) d0 *= q->d[i];
 8043ddc:	2601      	movs	r6, #1
 8043dde:	e746      	b.n	8043c6e <kad_op_reduce_mean+0x5a>
	} else if (action == KAD_BACKWARD && kad_is_back(q)) {
 8043de0:	f898 2001 	ldrb.w	r2, [r8, #1]
 8043de4:	07d2      	lsls	r2, r2, #31
 8043de6:	f57f af5d 	bpl.w	8043ca4 <kad_op_reduce_mean+0x90>
		float t = 1.0f / q->d[axis];
 8043dea:	3304      	adds	r3, #4
		for (i = 0; i < d0; ++i)
 8043dec:	2e00      	cmp	r6, #0
		float t = 1.0f / q->d[axis];
 8043dee:	f858 7023 	ldr.w	r7, [r8, r3, lsl #2]
		for (i = 0; i < d0; ++i)
 8043df2:	f77f af57 	ble.w	8043ca4 <kad_op_reduce_mean+0x90>
 8043df6:	2f00      	cmp	r7, #0
 8043df8:	f77f af54 	ble.w	8043ca4 <kad_op_reduce_mean+0x90>
 8043dfc:	2c00      	cmp	r4, #0
 8043dfe:	f77f af51 	ble.w	8043ca4 <kad_op_reduce_mean+0x90>
		float t = 1.0f / q->d[axis];
 8043e02:	ee07 7a90 	vmov	s15, r7
					q->g[(i * q->d[axis] + j) * d1 + k] += t * p->g[i * d1 + k];
 8043e06:	2300      	movs	r3, #0
		float t = 1.0f / q->d[axis];
 8043e08:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8043e0c:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
					q->g[(i * q->d[axis] + j) * d1 + k] += t * p->g[i * d1 + k];
 8043e10:	f8d5 a02c 	ldr.w	sl, [r5, #44]	@ 0x2c
		float t = 1.0f / q->d[axis];
 8043e14:	eec7 6a27 	vdiv.f32	s13, s14, s15
					q->g[(i * q->d[axis] + j) * d1 + k] += t * p->g[i * d1 + k];
 8043e18:	4699      	mov	r9, r3
		for (i = 0; i < d0; ++i)
 8043e1a:	461a      	mov	r2, r3
 8043e1c:	4651      	mov	r1, sl
					q->g[(i * q->d[axis] + j) * d1 + k] += t * p->g[i * d1 + k];
 8043e1e:	f8d8 e02c 	ldr.w	lr, [r8, #44]	@ 0x2c
 8043e22:	eb0e 0884 	add.w	r8, lr, r4, lsl #2
			for (j = 0; j < q->d[axis]; ++j)
 8043e26:	f04f 0a00 	mov.w	sl, #0
 8043e2a:	fb04 fc09 	mul.w	ip, r4, r9
 8043e2e:	eb01 0b83 	add.w	fp, r1, r3, lsl #2
 8043e32:	f8cd 9000 	str.w	r9, [sp]
		for (i = 0; i < d0; ++i)
 8043e36:	465d      	mov	r5, fp
 8043e38:	eb0e 008c 	add.w	r0, lr, ip, lsl #2
 8043e3c:	eb08 098c 	add.w	r9, r8, ip, lsl #2
					q->g[(i * q->d[axis] + j) * d1 + k] += t * p->g[i * d1 + k];
 8043e40:	edd0 7a00 	vldr	s15, [r0]
 8043e44:	ecb5 7a01 	vldmia	r5!, {s14}
 8043e48:	eee7 7a26 	vfma.f32	s15, s14, s13
 8043e4c:	ece0 7a01 	vstmia	r0!, {s15}
				for (k = 0; k < d1; ++k)
 8043e50:	4581      	cmp	r9, r0
 8043e52:	d1f5      	bne.n	8043e40 <kad_op_reduce_mean+0x22c>
			for (j = 0; j < q->d[axis]; ++j)
 8043e54:	f10a 0a01 	add.w	sl, sl, #1
 8043e58:	4557      	cmp	r7, sl
 8043e5a:	44a4      	add	ip, r4
 8043e5c:	d1eb      	bne.n	8043e36 <kad_op_reduce_mean+0x222>
		for (i = 0; i < d0; ++i)
 8043e5e:	f8dd 9000 	ldr.w	r9, [sp]
 8043e62:	3201      	adds	r2, #1
 8043e64:	42b2      	cmp	r2, r6
 8043e66:	44b9      	add	r9, r7
 8043e68:	4423      	add	r3, r4
 8043e6a:	d1dc      	bne.n	8043e26 <kad_op_reduce_mean+0x212>
 8043e6c:	e71a      	b.n	8043ca4 <kad_op_reduce_mean+0x90>
			if (i != axis) p->d[j++] = q->d[i];
 8043e6e:	f8d8 1014 	ldr.w	r1, [r8, #20]
		for (i = j = 0; i < q->n_d; ++i)
 8043e72:	2a02      	cmp	r2, #2
			if (i != axis) p->d[j++] = q->d[i];
 8043e74:	6169      	str	r1, [r5, #20]
		for (i = j = 0; i < q->n_d; ++i)
 8043e76:	f43f af15 	beq.w	8043ca4 <kad_op_reduce_mean+0x90>
			if (i != axis) p->d[j++] = q->d[i];
 8043e7a:	2b02      	cmp	r3, #2
 8043e7c:	d12b      	bne.n	8043ed6 <kad_op_reduce_mean+0x2c2>
		for (i = j = 0; i < q->n_d; ++i)
 8043e7e:	2a03      	cmp	r2, #3
 8043e80:	f43f af10 	beq.w	8043ca4 <kad_op_reduce_mean+0x90>
			if (i != axis) p->d[j++] = q->d[i];
 8043e84:	f8d8 101c 	ldr.w	r1, [r8, #28]
		for (i = j = 0; i < q->n_d; ++i)
 8043e88:	2a04      	cmp	r2, #4
			if (i != axis) p->d[j++] = q->d[i];
 8043e8a:	61a9      	str	r1, [r5, #24]
		for (i = j = 0; i < q->n_d; ++i)
 8043e8c:	f43f af0a 	beq.w	8043ca4 <kad_op_reduce_mean+0x90>
			if (i != axis) p->d[j++] = q->d[i];
 8043e90:	2103      	movs	r1, #3
 8043e92:	f8d8 4020 	ldr.w	r4, [r8, #32]
 8043e96:	1d08      	adds	r0, r1, #4
 8043e98:	f845 4020 	str.w	r4, [r5, r0, lsl #2]
 8043e9c:	3101      	adds	r1, #1
		for (i = j = 0; i < q->n_d; ++i)
 8043e9e:	2a05      	cmp	r2, #5
 8043ea0:	f77f af00 	ble.w	8043ca4 <kad_op_reduce_mean+0x90>
 8043ea4:	2005      	movs	r0, #5
			if (i != axis) p->d[j++] = q->d[i];
 8043ea6:	4283      	cmp	r3, r0
 8043ea8:	d00e      	beq.n	8043ec8 <kad_op_reduce_mean+0x2b4>
 8043eaa:	f108 0410 	add.w	r4, r8, #16
 8043eae:	f854 6020 	ldr.w	r6, [r4, r0, lsl #2]
		for (i = j = 0; i < q->n_d; ++i)
 8043eb2:	3001      	adds	r0, #1
			if (i != axis) p->d[j++] = q->d[i];
 8043eb4:	1d0c      	adds	r4, r1, #4
		for (i = j = 0; i < q->n_d; ++i)
 8043eb6:	4290      	cmp	r0, r2
			if (i != axis) p->d[j++] = q->d[i];
 8043eb8:	f845 6024 	str.w	r6, [r5, r4, lsl #2]
 8043ebc:	f101 0101 	add.w	r1, r1, #1
		for (i = j = 0; i < q->n_d; ++i)
 8043ec0:	dbf1      	blt.n	8043ea6 <kad_op_reduce_mean+0x292>
 8043ec2:	e6ef      	b.n	8043ca4 <kad_op_reduce_mean+0x90>
 8043ec4:	2204      	movs	r2, #4
 8043ec6:	e70c      	b.n	8043ce2 <kad_op_reduce_mean+0xce>
 8043ec8:	4594      	cmp	ip, r2
 8043eca:	4660      	mov	r0, ip
 8043ecc:	dbeb      	blt.n	8043ea6 <kad_op_reduce_mean+0x292>
 8043ece:	e6e9      	b.n	8043ca4 <kad_op_reduce_mean+0x90>
	if (axis < 0 || axis >= q->n_d) return -1;
 8043ed0:	f04f 30ff 	mov.w	r0, #4294967295
 8043ed4:	e6e7      	b.n	8043ca6 <kad_op_reduce_mean+0x92>
			if (i != axis) p->d[j++] = q->d[i];
 8043ed6:	f8d8 1018 	ldr.w	r1, [r8, #24]
		for (i = j = 0; i < q->n_d; ++i)
 8043eda:	2a03      	cmp	r2, #3
			if (i != axis) p->d[j++] = q->d[i];
 8043edc:	61a9      	str	r1, [r5, #24]
		for (i = j = 0; i < q->n_d; ++i)
 8043ede:	f43f aee1 	beq.w	8043ca4 <kad_op_reduce_mean+0x90>
			if (i != axis) p->d[j++] = q->d[i];
 8043ee2:	2b03      	cmp	r3, #3
 8043ee4:	d109      	bne.n	8043efa <kad_op_reduce_mean+0x2e6>
		for (i = j = 0; i < q->n_d; ++i)
 8043ee6:	2a04      	cmp	r2, #4
 8043ee8:	d1d2      	bne.n	8043e90 <kad_op_reduce_mean+0x27c>
 8043eea:	e6db      	b.n	8043ca4 <kad_op_reduce_mean+0x90>
	assert(p->ptr);
 8043eec:	f44f 61a0 	mov.w	r1, #1280	@ 0x500
 8043ef0:	4b03      	ldr	r3, [pc, #12]	@ (8043f00 <kad_op_reduce_mean+0x2ec>)
 8043ef2:	4a04      	ldr	r2, [pc, #16]	@ (8043f04 <kad_op_reduce_mean+0x2f0>)
 8043ef4:	4804      	ldr	r0, [pc, #16]	@ (8043f08 <kad_op_reduce_mean+0x2f4>)
 8043ef6:	f007 fc75 	bl	804b7e4 <__assert_func>
			if (i != axis) p->d[j++] = q->d[i];
 8043efa:	2103      	movs	r1, #3
 8043efc:	e761      	b.n	8043dc2 <kad_op_reduce_mean+0x1ae>
 8043efe:	bf00      	nop
 8043f00:	0804e3d4 	.word	0x0804e3d4
 8043f04:	0804e57c 	.word	0x0804e57c
 8043f08:	0804e3dc 	.word	0x0804e3dc

08043f0c <kad_op_square>:
{
 8043f0c:	b538      	push	{r3, r4, r5, lr}
	kad_node_t *q = p->child[0];
 8043f0e:	6b83      	ldr	r3, [r0, #56]	@ 0x38
 8043f10:	681c      	ldr	r4, [r3, #0]
 8043f12:	7825      	ldrb	r5, [r4, #0]
 8043f14:	b305      	cbz	r5, 8043f58 <kad_op_square+0x4c>
 8043f16:	2d01      	cmp	r5, #1
 8043f18:	6923      	ldr	r3, [r4, #16]
 8043f1a:	d00c      	beq.n	8043f36 <kad_op_square+0x2a>
 8043f1c:	6962      	ldr	r2, [r4, #20]
 8043f1e:	2d02      	cmp	r5, #2
 8043f20:	fb02 f303 	mul.w	r3, r2, r3
 8043f24:	d007      	beq.n	8043f36 <kad_op_square+0x2a>
 8043f26:	69a2      	ldr	r2, [r4, #24]
 8043f28:	2d03      	cmp	r5, #3
 8043f2a:	fb02 f303 	mul.w	r3, r2, r3
 8043f2e:	d002      	beq.n	8043f36 <kad_op_square+0x2a>
 8043f30:	69e2      	ldr	r2, [r4, #28]
 8043f32:	fb02 f303 	mul.w	r3, r2, r3
	if (action == KAD_SYNC_DIM) {
 8043f36:	2904      	cmp	r1, #4
 8043f38:	d005      	beq.n	8043f46 <kad_op_square+0x3a>
	} else if (action == KAD_FORWARD) {
 8043f3a:	2902      	cmp	r1, #2
 8043f3c:	d017      	beq.n	8043f6e <kad_op_square+0x62>
	} else if (action == KAD_BACKWARD && kad_is_back(q)) {
 8043f3e:	2903      	cmp	r1, #3
 8043f40:	d027      	beq.n	8043f92 <kad_op_square+0x86>
}
 8043f42:	2000      	movs	r0, #0
 8043f44:	bd38      	pop	{r3, r4, r5, pc}
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 8043f46:	00aa      	lsls	r2, r5, #2
 8043f48:	f104 0110 	add.w	r1, r4, #16
	dst->n_d = src->n_d;
 8043f4c:	f800 5b10 	strb.w	r5, [r0], #16
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 8043f50:	f008 f86d 	bl	804c02e <memcpy>
}
 8043f54:	2000      	movs	r0, #0
 8043f56:	bd38      	pop	{r3, r4, r5, pc}
	if (action == KAD_SYNC_DIM) {
 8043f58:	2904      	cmp	r1, #4
 8043f5a:	d018      	beq.n	8043f8e <kad_op_square+0x82>
	} else if (action == KAD_FORWARD) {
 8043f5c:	2902      	cmp	r1, #2
 8043f5e:	d031      	beq.n	8043fc4 <kad_op_square+0xb8>
	} else if (action == KAD_BACKWARD && kad_is_back(q)) {
 8043f60:	2903      	cmp	r1, #3
 8043f62:	d1ee      	bne.n	8043f42 <kad_op_square+0x36>
 8043f64:	7863      	ldrb	r3, [r4, #1]
 8043f66:	07d9      	lsls	r1, r3, #31
 8043f68:	d5eb      	bpl.n	8043f42 <kad_op_square+0x36>
	int n = 1, i;
 8043f6a:	2301      	movs	r3, #1
 8043f6c:	e016      	b.n	8043f9c <kad_op_square+0x90>
		for (i = 0; i < n; ++i)
 8043f6e:	2b00      	cmp	r3, #0
 8043f70:	dde7      	ble.n	8043f42 <kad_op_square+0x36>
 8043f72:	2200      	movs	r2, #0
 8043f74:	6aa4      	ldr	r4, [r4, #40]	@ 0x28
 8043f76:	6a81      	ldr	r1, [r0, #40]	@ 0x28
			p->x[i] = q->x[i] * q->x[i];
 8043f78:	ecf4 7a01 	vldmia	r4!, {s15}
 8043f7c:	ee67 7aa7 	vmul.f32	s15, s15, s15
		for (i = 0; i < n; ++i)
 8043f80:	3201      	adds	r2, #1
 8043f82:	429a      	cmp	r2, r3
			p->x[i] = q->x[i] * q->x[i];
 8043f84:	ece1 7a01 	vstmia	r1!, {s15}
		for (i = 0; i < n; ++i)
 8043f88:	dbf6      	blt.n	8043f78 <kad_op_square+0x6c>
}
 8043f8a:	2000      	movs	r0, #0
 8043f8c:	bd38      	pop	{r3, r4, r5, pc}
	dst->n_d = src->n_d;
 8043f8e:	7005      	strb	r5, [r0, #0]
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 8043f90:	e7d7      	b.n	8043f42 <kad_op_square+0x36>
	} else if (action == KAD_BACKWARD && kad_is_back(q)) {
 8043f92:	7862      	ldrb	r2, [r4, #1]
 8043f94:	07d2      	lsls	r2, r2, #31
 8043f96:	d5d4      	bpl.n	8043f42 <kad_op_square+0x36>
		for (i = 0; i < n; ++i)
 8043f98:	2b00      	cmp	r3, #0
 8043f9a:	ddd2      	ble.n	8043f42 <kad_op_square+0x36>
 8043f9c:	6ae2      	ldr	r2, [r4, #44]	@ 0x2c
 8043f9e:	6ac0      	ldr	r0, [r0, #44]	@ 0x2c
 8043fa0:	6aa1      	ldr	r1, [r4, #40]	@ 0x28
 8043fa2:	eb02 0383 	add.w	r3, r2, r3, lsl #2
			q->g[i] += p->g[i] * (q->x[i] + q->x[i]);
 8043fa6:	ecf1 7a01 	vldmia	r1!, {s15}
 8043faa:	ed92 7a00 	vldr	s14, [r2]
 8043fae:	ecf0 6a01 	vldmia	r0!, {s13}
 8043fb2:	ee77 7aa7 	vadd.f32	s15, s15, s15
 8043fb6:	eea6 7aa7 	vfma.f32	s14, s13, s15
 8043fba:	eca2 7a01 	vstmia	r2!, {s14}
		for (i = 0; i < n; ++i)
 8043fbe:	4293      	cmp	r3, r2
 8043fc0:	d1f1      	bne.n	8043fa6 <kad_op_square+0x9a>
 8043fc2:	e7be      	b.n	8043f42 <kad_op_square+0x36>
 8043fc4:	2301      	movs	r3, #1
 8043fc6:	e7d4      	b.n	8043f72 <kad_op_square+0x66>

08043fc8 <kad_op_relu>:
{
 8043fc8:	b570      	push	{r4, r5, r6, lr}
	kad_node_t *q = p->child[0];
 8043fca:	6b83      	ldr	r3, [r0, #56]	@ 0x38
 8043fcc:	681c      	ldr	r4, [r3, #0]
	for (i = 0; i < p->n_d; ++i) n *= p->d[i];
 8043fce:	7825      	ldrb	r5, [r4, #0]
 8043fd0:	b305      	cbz	r5, 8044014 <kad_op_relu+0x4c>
 8043fd2:	2d01      	cmp	r5, #1
 8043fd4:	6923      	ldr	r3, [r4, #16]
 8043fd6:	d00c      	beq.n	8043ff2 <kad_op_relu+0x2a>
 8043fd8:	6962      	ldr	r2, [r4, #20]
 8043fda:	2d02      	cmp	r5, #2
 8043fdc:	fb02 f303 	mul.w	r3, r2, r3
 8043fe0:	d007      	beq.n	8043ff2 <kad_op_relu+0x2a>
 8043fe2:	69a2      	ldr	r2, [r4, #24]
 8043fe4:	2d03      	cmp	r5, #3
 8043fe6:	fb02 f303 	mul.w	r3, r2, r3
 8043fea:	d002      	beq.n	8043ff2 <kad_op_relu+0x2a>
 8043fec:	69e2      	ldr	r2, [r4, #28]
 8043fee:	fb02 f303 	mul.w	r3, r2, r3
	if (action == KAD_SYNC_DIM) {
 8043ff2:	2904      	cmp	r1, #4
 8043ff4:	d005      	beq.n	8044002 <kad_op_relu+0x3a>
	} else if (action == KAD_FORWARD) {
 8043ff6:	2902      	cmp	r1, #2
 8043ff8:	d017      	beq.n	804402a <kad_op_relu+0x62>
	} else if (action == KAD_BACKWARD && kad_is_back(q)) {
 8043ffa:	2903      	cmp	r1, #3
 8043ffc:	d02e      	beq.n	804405c <kad_op_relu+0x94>
}
 8043ffe:	2000      	movs	r0, #0
 8044000:	bd70      	pop	{r4, r5, r6, pc}
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 8044002:	00aa      	lsls	r2, r5, #2
 8044004:	f104 0110 	add.w	r1, r4, #16
	dst->n_d = src->n_d;
 8044008:	f800 5b10 	strb.w	r5, [r0], #16
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 804400c:	f008 f80f 	bl	804c02e <memcpy>
}
 8044010:	2000      	movs	r0, #0
 8044012:	bd70      	pop	{r4, r5, r6, pc}
	if (action == KAD_SYNC_DIM) {
 8044014:	2904      	cmp	r1, #4
 8044016:	d01f      	beq.n	8044058 <kad_op_relu+0x90>
	} else if (action == KAD_FORWARD) {
 8044018:	2902      	cmp	r1, #2
 804401a:	d041      	beq.n	80440a0 <kad_op_relu+0xd8>
	} else if (action == KAD_BACKWARD && kad_is_back(q)) {
 804401c:	2903      	cmp	r1, #3
 804401e:	d1ee      	bne.n	8043ffe <kad_op_relu+0x36>
 8044020:	7863      	ldrb	r3, [r4, #1]
 8044022:	07d9      	lsls	r1, r3, #31
 8044024:	d5eb      	bpl.n	8043ffe <kad_op_relu+0x36>
	int n = 1, i;
 8044026:	2301      	movs	r3, #1
 8044028:	e01d      	b.n	8044066 <kad_op_relu+0x9e>
		for (i = 0; i < n; ++i)
 804402a:	2b00      	cmp	r3, #0
 804402c:	dde7      	ble.n	8043ffe <kad_op_relu+0x36>
 804402e:	2200      	movs	r2, #0
			p->x[i] = q->x[i] > 0.0f? q->x[i] : 0.0f;
 8044030:	ed9f 7a1c 	vldr	s14, [pc, #112]	@ 80440a4 <kad_op_relu+0xdc>
 8044034:	6aa4      	ldr	r4, [r4, #40]	@ 0x28
 8044036:	6a81      	ldr	r1, [r0, #40]	@ 0x28
 8044038:	ecf4 7a01 	vldmia	r4!, {s15}
 804403c:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8044040:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8044044:	bfd8      	it	le
 8044046:	eef0 7a47 	vmovle.f32	s15, s14
		for (i = 0; i < n; ++i)
 804404a:	3201      	adds	r2, #1
 804404c:	429a      	cmp	r2, r3
			p->x[i] = q->x[i] > 0.0f? q->x[i] : 0.0f;
 804404e:	ece1 7a01 	vstmia	r1!, {s15}
		for (i = 0; i < n; ++i)
 8044052:	dbf1      	blt.n	8044038 <kad_op_relu+0x70>
}
 8044054:	2000      	movs	r0, #0
 8044056:	bd70      	pop	{r4, r5, r6, pc}
	dst->n_d = src->n_d;
 8044058:	7005      	strb	r5, [r0, #0]
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 804405a:	e7d0      	b.n	8043ffe <kad_op_relu+0x36>
	} else if (action == KAD_BACKWARD && kad_is_back(q)) {
 804405c:	7862      	ldrb	r2, [r4, #1]
 804405e:	07d2      	lsls	r2, r2, #31
 8044060:	d5cd      	bpl.n	8043ffe <kad_op_relu+0x36>
		for (i = 0; i < n; ++i)
 8044062:	2b00      	cmp	r3, #0
 8044064:	ddcb      	ble.n	8043ffe <kad_op_relu+0x36>
			if (q->x[i] > 0.0f)
 8044066:	2200      	movs	r2, #0
 8044068:	6aa1      	ldr	r1, [r4, #40]	@ 0x28
 804406a:	eb01 0383 	add.w	r3, r1, r3, lsl #2
 804406e:	ecf1 7a01 	vldmia	r1!, {s15}
 8044072:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8044076:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 804407a:	dd0c      	ble.n	8044096 <kad_op_relu+0xce>
				q->g[i] += p->g[i];
 804407c:	6ae5      	ldr	r5, [r4, #44]	@ 0x2c
 804407e:	6ac6      	ldr	r6, [r0, #44]	@ 0x2c
 8044080:	4415      	add	r5, r2
 8044082:	eb06 0c02 	add.w	ip, r6, r2
 8044086:	edd5 7a00 	vldr	s15, [r5]
 804408a:	ed9c 7a00 	vldr	s14, [ip]
 804408e:	ee77 7a87 	vadd.f32	s15, s15, s14
 8044092:	edc5 7a00 	vstr	s15, [r5]
		for (i = 0; i < n; ++i)
 8044096:	4299      	cmp	r1, r3
 8044098:	f102 0204 	add.w	r2, r2, #4
 804409c:	d1e7      	bne.n	804406e <kad_op_relu+0xa6>
 804409e:	e7ae      	b.n	8043ffe <kad_op_relu+0x36>
 80440a0:	2301      	movs	r3, #1
 80440a2:	e7c4      	b.n	804402e <kad_op_relu+0x66>
 80440a4:	00000000 	.word	0x00000000

080440a8 <kad_op_max>:
{
 80440a8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80440ac:	4605      	mov	r5, r0
	kad_node_t *q = p->child[0];
 80440ae:	6b80      	ldr	r0, [r0, #56]	@ 0x38
 80440b0:	6806      	ldr	r6, [r0, #0]
	for (i = 0; i < p->n_d; ++i) n *= p->d[i];
 80440b2:	f896 8000 	ldrb.w	r8, [r6]
 80440b6:	f1b8 0f00 	cmp.w	r8, #0
 80440ba:	d048      	beq.n	804414e <kad_op_max+0xa6>
 80440bc:	f1b8 0f01 	cmp.w	r8, #1
 80440c0:	6934      	ldr	r4, [r6, #16]
 80440c2:	d00e      	beq.n	80440e2 <kad_op_max+0x3a>
 80440c4:	6973      	ldr	r3, [r6, #20]
 80440c6:	f1b8 0f02 	cmp.w	r8, #2
 80440ca:	fb03 f404 	mul.w	r4, r3, r4
 80440ce:	d008      	beq.n	80440e2 <kad_op_max+0x3a>
 80440d0:	69b3      	ldr	r3, [r6, #24]
 80440d2:	f1b8 0f03 	cmp.w	r8, #3
 80440d6:	fb03 f404 	mul.w	r4, r3, r4
 80440da:	d002      	beq.n	80440e2 <kad_op_max+0x3a>
 80440dc:	69f3      	ldr	r3, [r6, #28]
 80440de:	fb03 f404 	mul.w	r4, r3, r4
	if (action == KAD_SYNC_DIM) {
 80440e2:	2904      	cmp	r1, #4
 80440e4:	d007      	beq.n	80440f6 <kad_op_max+0x4e>
	} else if (action == KAD_FORWARD) {
 80440e6:	2902      	cmp	r1, #2
 80440e8:	d03a      	beq.n	8044160 <kad_op_max+0xb8>
	} else if (action == KAD_BACKWARD) {
 80440ea:	2903      	cmp	r1, #3
 80440ec:	f000 8086 	beq.w	80441fc <kad_op_max+0x154>
	return 0;
 80440f0:	2000      	movs	r0, #0
}
 80440f2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		for (i = 1; i < p->n_child; ++i)
 80440f6:	686f      	ldr	r7, [r5, #4]
 80440f8:	2f01      	cmp	r7, #1
 80440fa:	f340 809b 	ble.w	8044234 <kad_op_max+0x18c>
 80440fe:	4686      	mov	lr, r0
 8044100:	f04f 0c01 	mov.w	ip, #1
 8044104:	e015      	b.n	8044132 <kad_op_max+0x8a>
 8044106:	2a01      	cmp	r2, #1
 8044108:	690b      	ldr	r3, [r1, #16]
 804410a:	d00c      	beq.n	8044126 <kad_op_max+0x7e>
 804410c:	6948      	ldr	r0, [r1, #20]
 804410e:	2a02      	cmp	r2, #2
 8044110:	fb00 f303 	mul.w	r3, r0, r3
 8044114:	d007      	beq.n	8044126 <kad_op_max+0x7e>
 8044116:	6988      	ldr	r0, [r1, #24]
 8044118:	2a03      	cmp	r2, #3
 804411a:	fb00 f303 	mul.w	r3, r0, r3
 804411e:	d002      	beq.n	8044126 <kad_op_max+0x7e>
 8044120:	69ca      	ldr	r2, [r1, #28]
 8044122:	fb02 f303 	mul.w	r3, r2, r3
			if (kad_len(p->child[i]) != n) return -1;
 8044126:	429c      	cmp	r4, r3
		for (i = 1; i < p->n_child; ++i)
 8044128:	f10c 0c01 	add.w	ip, ip, #1
			if (kad_len(p->child[i]) != n) return -1;
 804412c:	d10b      	bne.n	8044146 <kad_op_max+0x9e>
		for (i = 1; i < p->n_child; ++i)
 804412e:	45bc      	cmp	ip, r7
 8044130:	da54      	bge.n	80441dc <kad_op_max+0x134>
			if (kad_len(p->child[i]) != n) return -1;
 8044132:	f85e 1f04 	ldr.w	r1, [lr, #4]!
 8044136:	780a      	ldrb	r2, [r1, #0]
 8044138:	2a00      	cmp	r2, #0
 804413a:	d1e4      	bne.n	8044106 <kad_op_max+0x5e>
	int n = 1, i;
 804413c:	2301      	movs	r3, #1
 804413e:	429c      	cmp	r4, r3
		for (i = 1; i < p->n_child; ++i)
 8044140:	f10c 0c01 	add.w	ip, ip, #1
			if (kad_len(p->child[i]) != n) return -1;
 8044144:	d0f3      	beq.n	804412e <kad_op_max+0x86>
 8044146:	f04f 30ff 	mov.w	r0, #4294967295
}
 804414a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (action == KAD_SYNC_DIM) {
 804414e:	2904      	cmp	r1, #4
 8044150:	d03a      	beq.n	80441c8 <kad_op_max+0x120>
	} else if (action == KAD_FORWARD) {
 8044152:	2902      	cmp	r1, #2
 8044154:	d079      	beq.n	804424a <kad_op_max+0x1a2>
	} else if (action == KAD_BACKWARD) {
 8044156:	2903      	cmp	r1, #3
 8044158:	d1ca      	bne.n	80440f0 <kad_op_max+0x48>
 804415a:	2401      	movs	r4, #1
		int *max_j = (int*)p->gtmp;
 804415c:	6b6e      	ldr	r6, [r5, #52]	@ 0x34
		for (i = 0; i < n; ++i)
 804415e:	e051      	b.n	8044204 <kad_op_max+0x15c>
		int j, *max_j = (int*)p->gtmp;
 8044160:	6b6f      	ldr	r7, [r5, #52]	@ 0x34
		memset(max_j, 0, n * sizeof(int));
 8044162:	ea4f 0884 	mov.w	r8, r4, lsl #2
 8044166:	2100      	movs	r1, #0
 8044168:	4642      	mov	r2, r8
 804416a:	4638      	mov	r0, r7
 804416c:	f007 fe62 	bl	804be34 <memset>
		memcpy(p->x, q->x, n * sizeof(float));
 8044170:	4642      	mov	r2, r8
 8044172:	6ab1      	ldr	r1, [r6, #40]	@ 0x28
 8044174:	6aa8      	ldr	r0, [r5, #40]	@ 0x28
 8044176:	f007 ff5a 	bl	804c02e <memcpy>
		for (j = 1; j < p->n_child; ++j)
 804417a:	686b      	ldr	r3, [r5, #4]
 804417c:	2b01      	cmp	r3, #1
 804417e:	ddb7      	ble.n	80440f0 <kad_op_max+0x48>
 8044180:	2c00      	cmp	r4, #0
			for (i = 0, q = p->child[j]; i < n; ++i)
 8044182:	6baa      	ldr	r2, [r5, #56]	@ 0x38
 8044184:	ddb4      	ble.n	80440f0 <kad_op_max+0x48>
		for (j = 1; j < p->n_child; ++j)
 8044186:	2401      	movs	r4, #1
 8044188:	6aae      	ldr	r6, [r5, #40]	@ 0x28
 804418a:	1f15      	subs	r5, r2, #4
 804418c:	eb05 0583 	add.w	r5, r5, r3, lsl #2
			for (i = 0, q = p->child[j]; i < n; ++i)
 8044190:	4638      	mov	r0, r7
				if (q->x[i] > p->x[i]) p->x[i] = q->x[i], max_j[i] = j;
 8044192:	4631      	mov	r1, r6
 8044194:	f852 3f04 	ldr.w	r3, [r2, #4]!
 8044198:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 804419a:	eb08 0c03 	add.w	ip, r8, r3
 804419e:	ecf3 7a01 	vldmia	r3!, {s15}
 80441a2:	ecb1 7a01 	vldmia	r1!, {s14}
 80441a6:	eef4 7ac7 	vcmpe.f32	s15, s14
 80441aa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80441ae:	bfc4      	itt	gt
 80441b0:	ed41 7a01 	vstrgt	s15, [r1, #-4]
 80441b4:	6004      	strgt	r4, [r0, #0]
			for (i = 0, q = p->child[j]; i < n; ++i)
 80441b6:	4563      	cmp	r3, ip
 80441b8:	f100 0004 	add.w	r0, r0, #4
 80441bc:	d1ef      	bne.n	804419e <kad_op_max+0xf6>
		for (j = 1; j < p->n_child; ++j)
 80441be:	4295      	cmp	r5, r2
 80441c0:	f104 0401 	add.w	r4, r4, #1
 80441c4:	d1e4      	bne.n	8044190 <kad_op_max+0xe8>
 80441c6:	e793      	b.n	80440f0 <kad_op_max+0x48>
		for (i = 1; i < p->n_child; ++i)
 80441c8:	686f      	ldr	r7, [r5, #4]
 80441ca:	2f01      	cmp	r7, #1
 80441cc:	bfc8      	it	gt
 80441ce:	2401      	movgt	r4, #1
 80441d0:	dc95      	bgt.n	80440fe <kad_op_max+0x56>
	dst->n_d = src->n_d;
 80441d2:	460e      	mov	r6, r1
 80441d4:	2001      	movs	r0, #1
 80441d6:	f885 8000 	strb.w	r8, [r5]
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 80441da:	e006      	b.n	80441ea <kad_op_max+0x142>
	dst->n_d = src->n_d;
 80441dc:	f885 8000 	strb.w	r8, [r5]
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 80441e0:	f1b8 0f00 	cmp.w	r8, #0
 80441e4:	d128      	bne.n	8044238 <kad_op_max+0x190>
		max_j = (int*)calloc(n, sizeof(int));
 80441e6:	4620      	mov	r0, r4
		heapSize += n*sizeof(int);
 80441e8:	00a6      	lsls	r6, r4, #2
		max_j = (int*)calloc(n, sizeof(int));
 80441ea:	2104      	movs	r1, #4
 80441ec:	f007 fb18 	bl	804b820 <calloc>
		heapSize += n*sizeof(int);
 80441f0:	4a1d      	ldr	r2, [pc, #116]	@ (8044268 <kad_op_max+0x1c0>)
		p->gtmp = max_j;
 80441f2:	6368      	str	r0, [r5, #52]	@ 0x34
		heapSize += n*sizeof(int);
 80441f4:	6813      	ldr	r3, [r2, #0]
 80441f6:	4433      	add	r3, r6
 80441f8:	6013      	str	r3, [r2, #0]
		p->gtmp = max_j;
 80441fa:	e779      	b.n	80440f0 <kad_op_max+0x48>
		for (i = 0; i < n; ++i)
 80441fc:	2c00      	cmp	r4, #0
		int *max_j = (int*)p->gtmp;
 80441fe:	6b6e      	ldr	r6, [r5, #52]	@ 0x34
		for (i = 0; i < n; ++i)
 8044200:	f77f af76 	ble.w	80440f0 <kad_op_max+0x48>
 8044204:	1f32      	subs	r2, r6, #4
 8044206:	6ae9      	ldr	r1, [r5, #44]	@ 0x2c
 8044208:	eb02 0484 	add.w	r4, r2, r4, lsl #2
 804420c:	f1c6 0604 	rsb	r6, r6, #4
			p->child[max_j[i]]->g[i] += p->g[i];
 8044210:	18b5      	adds	r5, r6, r2
 8044212:	f852 3f04 	ldr.w	r3, [r2, #4]!
 8044216:	ecb1 7a01 	vldmia	r1!, {s14}
 804421a:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
		for (i = 0; i < n; ++i)
 804421e:	4294      	cmp	r4, r2
			p->child[max_j[i]]->g[i] += p->g[i];
 8044220:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8044222:	442b      	add	r3, r5
 8044224:	edd3 7a00 	vldr	s15, [r3]
 8044228:	ee77 7a87 	vadd.f32	s15, s15, s14
 804422c:	edc3 7a00 	vstr	s15, [r3]
		for (i = 0; i < n; ++i)
 8044230:	d1ee      	bne.n	8044210 <kad_op_max+0x168>
 8044232:	e75d      	b.n	80440f0 <kad_op_max+0x48>
	dst->n_d = src->n_d;
 8044234:	f885 8000 	strb.w	r8, [r5]
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 8044238:	ea4f 0288 	mov.w	r2, r8, lsl #2
 804423c:	f106 0110 	add.w	r1, r6, #16
 8044240:	f105 0010 	add.w	r0, r5, #16
 8044244:	f007 fef3 	bl	804c02e <memcpy>
 8044248:	e7cd      	b.n	80441e6 <kad_op_max+0x13e>
		int j, *max_j = (int*)p->gtmp;
 804424a:	6b6f      	ldr	r7, [r5, #52]	@ 0x34
		memset(max_j, 0, n * sizeof(int));
 804424c:	f8c7 8000 	str.w	r8, [r7]
		memcpy(p->x, q->x, n * sizeof(float));
 8044250:	6ab2      	ldr	r2, [r6, #40]	@ 0x28
 8044252:	6aab      	ldr	r3, [r5, #40]	@ 0x28
 8044254:	6812      	ldr	r2, [r2, #0]
 8044256:	601a      	str	r2, [r3, #0]
		for (j = 1; j < p->n_child; ++j)
 8044258:	686b      	ldr	r3, [r5, #4]
 804425a:	2b01      	cmp	r3, #1
 804425c:	f77f af48 	ble.w	80440f0 <kad_op_max+0x48>
		memset(max_j, 0, n * sizeof(int));
 8044260:	f04f 0804 	mov.w	r8, #4
			for (i = 0, q = p->child[j]; i < n; ++i)
 8044264:	6baa      	ldr	r2, [r5, #56]	@ 0x38
 8044266:	e78e      	b.n	8044186 <kad_op_max+0xde>
 8044268:	20018acc 	.word	0x20018acc

0804426c <kad_op_mul>:
{
 804426c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	q[0] = p->child[0], n0 = kad_len(q[0]);
 8044270:	6b83      	ldr	r3, [r0, #56]	@ 0x38
{
 8044272:	4680      	mov	r8, r0
	q[0] = p->child[0], n0 = kad_len(q[0]);
 8044274:	681e      	ldr	r6, [r3, #0]
{
 8044276:	b083      	sub	sp, #12
	for (i = 0; i < p->n_d; ++i) n *= p->d[i];
 8044278:	7832      	ldrb	r2, [r6, #0]
 804427a:	2a00      	cmp	r2, #0
 804427c:	d079      	beq.n	8044372 <kad_op_mul+0x106>
 804427e:	2a01      	cmp	r2, #1
 8044280:	6935      	ldr	r5, [r6, #16]
 8044282:	d00c      	beq.n	804429e <kad_op_mul+0x32>
 8044284:	6970      	ldr	r0, [r6, #20]
 8044286:	2a02      	cmp	r2, #2
 8044288:	fb00 f505 	mul.w	r5, r0, r5
 804428c:	d007      	beq.n	804429e <kad_op_mul+0x32>
 804428e:	69b0      	ldr	r0, [r6, #24]
 8044290:	2a03      	cmp	r2, #3
 8044292:	fb00 f505 	mul.w	r5, r0, r5
 8044296:	d002      	beq.n	804429e <kad_op_mul+0x32>
 8044298:	69f0      	ldr	r0, [r6, #28]
 804429a:	fb00 f505 	mul.w	r5, r0, r5
	q[1] = p->child[1], n1 = kad_len(q[1]);
 804429e:	685f      	ldr	r7, [r3, #4]
 80442a0:	783b      	ldrb	r3, [r7, #0]
 80442a2:	2b00      	cmp	r3, #0
 80442a4:	d061      	beq.n	804436a <kad_op_mul+0xfe>
 80442a6:	2b01      	cmp	r3, #1
 80442a8:	693c      	ldr	r4, [r7, #16]
 80442aa:	d00c      	beq.n	80442c6 <kad_op_mul+0x5a>
 80442ac:	6978      	ldr	r0, [r7, #20]
 80442ae:	2b02      	cmp	r3, #2
 80442b0:	fb00 f404 	mul.w	r4, r0, r4
 80442b4:	d007      	beq.n	80442c6 <kad_op_mul+0x5a>
 80442b6:	69b8      	ldr	r0, [r7, #24]
 80442b8:	2b03      	cmp	r3, #3
 80442ba:	fb00 f404 	mul.w	r4, r0, r4
 80442be:	d002      	beq.n	80442c6 <kad_op_mul+0x5a>
 80442c0:	69fb      	ldr	r3, [r7, #28]
 80442c2:	fb03 f404 	mul.w	r4, r3, r4
	if (action == KAD_SYNC_DIM) {
 80442c6:	2904      	cmp	r1, #4
 80442c8:	d03d      	beq.n	8044346 <kad_op_mul+0xda>
	} else if (action == KAD_FORWARD) {
 80442ca:	2902      	cmp	r1, #2
 80442cc:	d005      	beq.n	80442da <kad_op_mul+0x6e>
	} else if (action == KAD_BACKWARD) {
 80442ce:	2903      	cmp	r1, #3
 80442d0:	d051      	beq.n	8044376 <kad_op_mul+0x10a>
	return 0;
 80442d2:	2000      	movs	r0, #0
}
 80442d4:	b003      	add	sp, #12
 80442d6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		assert(n0 >= n1);
 80442da:	42a5      	cmp	r5, r4
 80442dc:	f2c0 80b8 	blt.w	8044450 <kad_op_mul+0x1e4>
		memset(p->x, 0, n0 * sizeof(float));
 80442e0:	2100      	movs	r1, #0
 80442e2:	f8d8 0028 	ldr.w	r0, [r8, #40]	@ 0x28
 80442e6:	00aa      	lsls	r2, r5, #2
 80442e8:	f007 fda4 	bl	804be34 <memset>
		if (q[0]->x != 0 && q[1]->x != 0)
 80442ec:	f8d6 e028 	ldr.w	lr, [r6, #40]	@ 0x28
 80442f0:	f1be 0f00 	cmp.w	lr, #0
 80442f4:	d0ed      	beq.n	80442d2 <kad_op_mul+0x66>
 80442f6:	f8d7 9028 	ldr.w	r9, [r7, #40]	@ 0x28
 80442fa:	f1b9 0f00 	cmp.w	r9, #0
 80442fe:	d0e8      	beq.n	80442d2 <kad_op_mul+0x66>
			for (i = 0; i < n0; i += n1) /* TODO: optimize when n1==1 */
 8044300:	2d00      	cmp	r5, #0
 8044302:	dde6      	ble.n	80442d2 <kad_op_mul+0x66>
 8044304:	2c00      	cmp	r4, #0
				kad_vec_mul_sum(n1, p->x + i, q[0]->x + i, q[1]->x);
 8044306:	f8d8 8028 	ldr.w	r8, [r8, #40]	@ 0x28
 804430a:	dde2      	ble.n	80442d2 <kad_op_mul+0x66>
 804430c:	2600      	movs	r6, #0
			for (i = 0; i < n0; i += n1) /* TODO: optimize when n1==1 */
 804430e:	4637      	mov	r7, r6
 8044310:	ea4f 0c84 	mov.w	ip, r4, lsl #2
 8044314:	eb08 0084 	add.w	r0, r8, r4, lsl #2
	for (i = 0; i < n; ++i) a[i] += b[i] * c[i];
 8044318:	4649      	mov	r1, r9
 804431a:	eb08 0306 	add.w	r3, r8, r6
 804431e:	eb0e 0206 	add.w	r2, lr, r6
 8044322:	edd3 7a00 	vldr	s15, [r3]
 8044326:	ecf2 6a01 	vldmia	r2!, {s13}
 804432a:	ecb1 7a01 	vldmia	r1!, {s14}
 804432e:	eee6 7a87 	vfma.f32	s15, s13, s14
 8044332:	ece3 7a01 	vstmia	r3!, {s15}
 8044336:	4298      	cmp	r0, r3
 8044338:	d1f3      	bne.n	8044322 <kad_op_mul+0xb6>
			for (i = 0; i < n0; i += n1) /* TODO: optimize when n1==1 */
 804433a:	4427      	add	r7, r4
 804433c:	42bd      	cmp	r5, r7
 804433e:	4466      	add	r6, ip
 8044340:	4460      	add	r0, ip
 8044342:	dce9      	bgt.n	8044318 <kad_op_mul+0xac>
 8044344:	e7c5      	b.n	80442d2 <kad_op_mul+0x66>
		if (n0 % n1 != 0) return -1;
 8044346:	fb95 f3f4 	sdiv	r3, r5, r4
 804434a:	fb04 5313 	mls	r3, r4, r3, r5
 804434e:	2b00      	cmp	r3, #0
 8044350:	d17b      	bne.n	804444a <kad_op_mul+0x1de>
	dst->n_d = src->n_d;
 8044352:	f888 2000 	strb.w	r2, [r8]
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 8044356:	2a00      	cmp	r2, #0
 8044358:	d0bb      	beq.n	80442d2 <kad_op_mul+0x66>
 804435a:	0092      	lsls	r2, r2, #2
 804435c:	f106 0110 	add.w	r1, r6, #16
 8044360:	f108 0010 	add.w	r0, r8, #16
 8044364:	f007 fe63 	bl	804c02e <memcpy>
 8044368:	e7b3      	b.n	80442d2 <kad_op_mul+0x66>
	if (action == KAD_SYNC_DIM) {
 804436a:	2904      	cmp	r1, #4
 804436c:	d0f1      	beq.n	8044352 <kad_op_mul+0xe6>
	int n = 1, i;
 804436e:	2401      	movs	r4, #1
 8044370:	e7ab      	b.n	80442ca <kad_op_mul+0x5e>
 8044372:	2501      	movs	r5, #1
 8044374:	e793      	b.n	804429e <kad_op_mul+0x32>
		if (kad_is_back(q[0]) && q[1]->x)
 8044376:	7872      	ldrb	r2, [r6, #1]
 8044378:	787b      	ldrb	r3, [r7, #1]
 804437a:	07d2      	lsls	r2, r2, #31
 804437c:	f003 0301 	and.w	r3, r3, #1
 8044380:	d534      	bpl.n	80443ec <kad_op_mul+0x180>
 8044382:	f8d7 a028 	ldr.w	sl, [r7, #40]	@ 0x28
 8044386:	f1ba 0f00 	cmp.w	sl, #0
 804438a:	d02f      	beq.n	80443ec <kad_op_mul+0x180>
			for (i = 0; i < n0; i += n1)
 804438c:	2d00      	cmp	r5, #0
 804438e:	dda0      	ble.n	80442d2 <kad_op_mul+0x66>
 8044390:	2c00      	cmp	r4, #0
				kad_vec_mul_sum(n1, q[0]->g + i, p->g + i, q[1]->x);
 8044392:	f8d8 802c 	ldr.w	r8, [r8, #44]	@ 0x2c
 8044396:	f8d6 b02c 	ldr.w	fp, [r6, #44]	@ 0x2c
 804439a:	dd1e      	ble.n	80443da <kad_op_mul+0x16e>
 804439c:	f04f 0c00 	mov.w	ip, #0
			for (i = 0; i < n0; i += n1)
 80443a0:	46e6      	mov	lr, ip
 80443a2:	ea4f 0984 	mov.w	r9, r4, lsl #2
 80443a6:	eb0b 0084 	add.w	r0, fp, r4, lsl #2
 80443aa:	9601      	str	r6, [sp, #4]
	for (i = 0; i < n; ++i) a[i] += b[i] * c[i];
 80443ac:	4656      	mov	r6, sl
 80443ae:	eb0b 020c 	add.w	r2, fp, ip
 80443b2:	eb08 010c 	add.w	r1, r8, ip
 80443b6:	edd2 7a00 	vldr	s15, [r2]
 80443ba:	ecf1 6a01 	vldmia	r1!, {s13}
 80443be:	ecb6 7a01 	vldmia	r6!, {s14}
 80443c2:	eee6 7a87 	vfma.f32	s15, s13, s14
 80443c6:	ece2 7a01 	vstmia	r2!, {s15}
 80443ca:	4290      	cmp	r0, r2
 80443cc:	d1f3      	bne.n	80443b6 <kad_op_mul+0x14a>
			for (i = 0; i < n0; i += n1)
 80443ce:	44a6      	add	lr, r4
 80443d0:	4575      	cmp	r5, lr
 80443d2:	44cc      	add	ip, r9
 80443d4:	4448      	add	r0, r9
 80443d6:	dce9      	bgt.n	80443ac <kad_op_mul+0x140>
 80443d8:	9e01      	ldr	r6, [sp, #4]
		if (kad_is_back(q[1]) && q[0]->x)
 80443da:	2b00      	cmp	r3, #0
 80443dc:	f43f af79 	beq.w	80442d2 <kad_op_mul+0x66>
 80443e0:	f8d6 c028 	ldr.w	ip, [r6, #40]	@ 0x28
 80443e4:	f1bc 0f00 	cmp.w	ip, #0
 80443e8:	d10e      	bne.n	8044408 <kad_op_mul+0x19c>
 80443ea:	e772      	b.n	80442d2 <kad_op_mul+0x66>
 80443ec:	2b00      	cmp	r3, #0
 80443ee:	f43f af70 	beq.w	80442d2 <kad_op_mul+0x66>
 80443f2:	f8d6 c028 	ldr.w	ip, [r6, #40]	@ 0x28
 80443f6:	f1bc 0f00 	cmp.w	ip, #0
 80443fa:	f43f af6a 	beq.w	80442d2 <kad_op_mul+0x66>
			for (i = 0; i < n0; i += n1)
 80443fe:	2d00      	cmp	r5, #0
 8044400:	f77f af67 	ble.w	80442d2 <kad_op_mul+0x66>
 8044404:	f8d8 802c 	ldr.w	r8, [r8, #44]	@ 0x2c
 8044408:	2c00      	cmp	r4, #0
				kad_vec_mul_sum(n1, q[1]->g, p->g + i, q[0]->x + i);
 804440a:	f8d7 e02c 	ldr.w	lr, [r7, #44]	@ 0x2c
 804440e:	f77f af60 	ble.w	80442d2 <kad_op_mul+0x66>
 8044412:	2600      	movs	r6, #0
			for (i = 0; i < n0; i += n1)
 8044414:	4637      	mov	r7, r6
 8044416:	ea4f 0984 	mov.w	r9, r4, lsl #2
 804441a:	eb0e 0084 	add.w	r0, lr, r4, lsl #2
 804441e:	4673      	mov	r3, lr
 8044420:	eb08 0106 	add.w	r1, r8, r6
 8044424:	eb0c 0206 	add.w	r2, ip, r6
	for (i = 0; i < n; ++i) a[i] += b[i] * c[i];
 8044428:	edd3 7a00 	vldr	s15, [r3]
 804442c:	ecf1 6a01 	vldmia	r1!, {s13}
 8044430:	ecb2 7a01 	vldmia	r2!, {s14}
 8044434:	eee6 7a87 	vfma.f32	s15, s13, s14
 8044438:	ece3 7a01 	vstmia	r3!, {s15}
 804443c:	4298      	cmp	r0, r3
 804443e:	d1f3      	bne.n	8044428 <kad_op_mul+0x1bc>
			for (i = 0; i < n0; i += n1)
 8044440:	4427      	add	r7, r4
 8044442:	42bd      	cmp	r5, r7
 8044444:	444e      	add	r6, r9
 8044446:	dcea      	bgt.n	804441e <kad_op_mul+0x1b2>
 8044448:	e743      	b.n	80442d2 <kad_op_mul+0x66>
		if (n0 % n1 != 0) return -1;
 804444a:	f04f 30ff 	mov.w	r0, #4294967295
 804444e:	e741      	b.n	80442d4 <kad_op_mul+0x68>
		assert(n0 >= n1);
 8044450:	f240 4159 	movw	r1, #1113	@ 0x459
 8044454:	4b02      	ldr	r3, [pc, #8]	@ (8044460 <kad_op_mul+0x1f4>)
 8044456:	4a03      	ldr	r2, [pc, #12]	@ (8044464 <kad_op_mul+0x1f8>)
 8044458:	4803      	ldr	r0, [pc, #12]	@ (8044468 <kad_op_mul+0x1fc>)
 804445a:	f007 f9c3 	bl	804b7e4 <__assert_func>
 804445e:	bf00      	nop
 8044460:	0804e3fc 	.word	0x0804e3fc
 8044464:	0804e5a4 	.word	0x0804e5a4
 8044468:	0804e3dc 	.word	0x0804e3dc

0804446c <kad_op_add>:
{
 804446c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	q[0] = p->child[0], n0 = kad_len(q[0]);
 8044470:	6b83      	ldr	r3, [r0, #56]	@ 0x38
{
 8044472:	4680      	mov	r8, r0
	q[0] = p->child[0], n0 = kad_len(q[0]);
 8044474:	6818      	ldr	r0, [r3, #0]
	for (i = 0; i < p->n_d; ++i) n *= p->d[i];
 8044476:	7802      	ldrb	r2, [r0, #0]
 8044478:	2a00      	cmp	r2, #0
 804447a:	d06d      	beq.n	8044558 <kad_op_add+0xec>
 804447c:	2a01      	cmp	r2, #1
 804447e:	6905      	ldr	r5, [r0, #16]
 8044480:	d00c      	beq.n	804449c <kad_op_add+0x30>
 8044482:	6944      	ldr	r4, [r0, #20]
 8044484:	2a02      	cmp	r2, #2
 8044486:	fb04 f505 	mul.w	r5, r4, r5
 804448a:	d007      	beq.n	804449c <kad_op_add+0x30>
 804448c:	6984      	ldr	r4, [r0, #24]
 804448e:	2a03      	cmp	r2, #3
 8044490:	fb04 f505 	mul.w	r5, r4, r5
 8044494:	d002      	beq.n	804449c <kad_op_add+0x30>
 8044496:	69c4      	ldr	r4, [r0, #28]
 8044498:	fb04 f505 	mul.w	r5, r4, r5
	q[1] = p->child[1], n1 = kad_len(q[1]);
 804449c:	685f      	ldr	r7, [r3, #4]
 804449e:	783b      	ldrb	r3, [r7, #0]
 80444a0:	2b00      	cmp	r3, #0
 80444a2:	d055      	beq.n	8044550 <kad_op_add+0xe4>
 80444a4:	2b01      	cmp	r3, #1
 80444a6:	693c      	ldr	r4, [r7, #16]
 80444a8:	d00c      	beq.n	80444c4 <kad_op_add+0x58>
 80444aa:	697e      	ldr	r6, [r7, #20]
 80444ac:	2b02      	cmp	r3, #2
 80444ae:	fb06 f404 	mul.w	r4, r6, r4
 80444b2:	d007      	beq.n	80444c4 <kad_op_add+0x58>
 80444b4:	69be      	ldr	r6, [r7, #24]
 80444b6:	2b03      	cmp	r3, #3
 80444b8:	fb06 f404 	mul.w	r4, r6, r4
 80444bc:	d002      	beq.n	80444c4 <kad_op_add+0x58>
 80444be:	69fb      	ldr	r3, [r7, #28]
 80444c0:	fb03 f404 	mul.w	r4, r3, r4
	if (action == KAD_SYNC_DIM) {
 80444c4:	2904      	cmp	r1, #4
 80444c6:	d031      	beq.n	804452c <kad_op_add+0xc0>
	} else if (action == KAD_FORWARD) {
 80444c8:	2902      	cmp	r1, #2
 80444ca:	d004      	beq.n	80444d6 <kad_op_add+0x6a>
	} else if (action == KAD_BACKWARD) {
 80444cc:	2903      	cmp	r1, #3
 80444ce:	d045      	beq.n	804455c <kad_op_add+0xf0>
	return 0;
 80444d0:	2000      	movs	r0, #0
}
 80444d2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		assert(n0 >= n1);
 80444d6:	42ac      	cmp	r4, r5
 80444d8:	dc7a      	bgt.n	80445d0 <kad_op_add+0x164>
		memcpy(p->x, q[0]->x, n0 * sizeof(float));
 80444da:	6a81      	ldr	r1, [r0, #40]	@ 0x28
 80444dc:	00aa      	lsls	r2, r5, #2
 80444de:	f8d8 0028 	ldr.w	r0, [r8, #40]	@ 0x28
 80444e2:	f007 fda4 	bl	804c02e <memcpy>
		for (i = 0; i < n0; i += n1)
 80444e6:	2d00      	cmp	r5, #0
 80444e8:	ddf2      	ble.n	80444d0 <kad_op_add+0x64>
 80444ea:	2c00      	cmp	r4, #0
			kad_saxpy(n1, 1.0f, q[1]->x, p->x + i);
 80444ec:	6abf      	ldr	r7, [r7, #40]	@ 0x28
 80444ee:	f8d8 1028 	ldr.w	r1, [r8, #40]	@ 0x28
 80444f2:	dded      	ble.n	80444d0 <kad_op_add+0x64>
		for (i = 0; i < n0; i += n1)
 80444f4:	2000      	movs	r0, #0
 80444f6:	ebc4 7e44 	rsb	lr, r4, r4, lsl #29
 80444fa:	00a6      	lsls	r6, r4, #2
 80444fc:	eb01 0184 	add.w	r1, r1, r4, lsl #2
 8044500:	ea4f 0ece 	mov.w	lr, lr, lsl #3
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 8044504:	eba1 0c06 	sub.w	ip, r1, r6
 8044508:	463a      	mov	r2, r7
		for (i = 0; i < n0; i += n1)
 804450a:	4663      	mov	r3, ip
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 804450c:	edd3 7a00 	vldr	s15, [r3]
 8044510:	ecb2 7a01 	vldmia	r2!, {s14}
 8044514:	ee77 7a87 	vadd.f32	s15, s15, s14
 8044518:	ece3 7a01 	vstmia	r3!, {s15}
 804451c:	428b      	cmp	r3, r1
 804451e:	d1f5      	bne.n	804450c <kad_op_add+0xa0>
		for (i = 0; i < n0; i += n1)
 8044520:	4420      	add	r0, r4
 8044522:	42a8      	cmp	r0, r5
 8044524:	ebac 010e 	sub.w	r1, ip, lr
 8044528:	dbec      	blt.n	8044504 <kad_op_add+0x98>
 804452a:	e7d1      	b.n	80444d0 <kad_op_add+0x64>
		if (n0 % n1 != 0) return -1;
 804452c:	fb95 f3f4 	sdiv	r3, r5, r4
 8044530:	fb04 5313 	mls	r3, r4, r3, r5
 8044534:	2b00      	cmp	r3, #0
 8044536:	d148      	bne.n	80445ca <kad_op_add+0x15e>
	dst->n_d = src->n_d;
 8044538:	f888 2000 	strb.w	r2, [r8]
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 804453c:	2a00      	cmp	r2, #0
 804453e:	d0c7      	beq.n	80444d0 <kad_op_add+0x64>
 8044540:	f100 0110 	add.w	r1, r0, #16
 8044544:	0092      	lsls	r2, r2, #2
 8044546:	f108 0010 	add.w	r0, r8, #16
 804454a:	f007 fd70 	bl	804c02e <memcpy>
 804454e:	e7bf      	b.n	80444d0 <kad_op_add+0x64>
	if (action == KAD_SYNC_DIM) {
 8044550:	2904      	cmp	r1, #4
 8044552:	d0f1      	beq.n	8044538 <kad_op_add+0xcc>
	int n = 1, i;
 8044554:	2401      	movs	r4, #1
 8044556:	e7b7      	b.n	80444c8 <kad_op_add+0x5c>
 8044558:	2501      	movs	r5, #1
 804455a:	e79f      	b.n	804449c <kad_op_add+0x30>
		if (kad_is_back(q[0])) kad_saxpy(n0, 1.0f, p->g, q[0]->g);
 804455c:	7843      	ldrb	r3, [r0, #1]
 804455e:	07d9      	lsls	r1, r3, #31
 8044560:	d52b      	bpl.n	80445ba <kad_op_add+0x14e>
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 8044562:	2d00      	cmp	r5, #0
		if (kad_is_back(q[0])) kad_saxpy(n0, 1.0f, p->g, q[0]->g);
 8044564:	f8d8 602c 	ldr.w	r6, [r8, #44]	@ 0x2c
 8044568:	6ac3      	ldr	r3, [r0, #44]	@ 0x2c
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 804456a:	ddb1      	ble.n	80444d0 <kad_op_add+0x64>
 804456c:	4632      	mov	r2, r6
 804456e:	eb03 0185 	add.w	r1, r3, r5, lsl #2
 8044572:	edd3 7a00 	vldr	s15, [r3]
 8044576:	ecb2 7a01 	vldmia	r2!, {s14}
 804457a:	ee77 7a87 	vadd.f32	s15, s15, s14
 804457e:	ece3 7a01 	vstmia	r3!, {s15}
 8044582:	4299      	cmp	r1, r3
 8044584:	d1f5      	bne.n	8044572 <kad_op_add+0x106>
		if (kad_is_back(q[1]))
 8044586:	787b      	ldrb	r3, [r7, #1]
 8044588:	07db      	lsls	r3, r3, #31
 804458a:	d5a1      	bpl.n	80444d0 <kad_op_add+0x64>
 804458c:	2c00      	cmp	r4, #0
				kad_saxpy(n1, 1.0f, p->g + i, q[1]->g);
 804458e:	6aff      	ldr	r7, [r7, #44]	@ 0x2c
 8044590:	dd9e      	ble.n	80444d0 <kad_op_add+0x64>
			for (i = 0; i < n0; i += n1)
 8044592:	2000      	movs	r0, #0
 8044594:	eb07 0184 	add.w	r1, r7, r4, lsl #2
 8044598:	463b      	mov	r3, r7
 804459a:	eb06 0280 	add.w	r2, r6, r0, lsl #2
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 804459e:	edd3 7a00 	vldr	s15, [r3]
 80445a2:	ecb2 7a01 	vldmia	r2!, {s14}
 80445a6:	ee77 7a87 	vadd.f32	s15, s15, s14
 80445aa:	ece3 7a01 	vstmia	r3!, {s15}
 80445ae:	4299      	cmp	r1, r3
 80445b0:	d1f5      	bne.n	804459e <kad_op_add+0x132>
			for (i = 0; i < n0; i += n1)
 80445b2:	4420      	add	r0, r4
 80445b4:	42a8      	cmp	r0, r5
 80445b6:	dbef      	blt.n	8044598 <kad_op_add+0x12c>
 80445b8:	e78a      	b.n	80444d0 <kad_op_add+0x64>
		if (kad_is_back(q[1]))
 80445ba:	787b      	ldrb	r3, [r7, #1]
 80445bc:	07da      	lsls	r2, r3, #31
 80445be:	d587      	bpl.n	80444d0 <kad_op_add+0x64>
			for (i = 0; i < n0; i += n1)
 80445c0:	2d00      	cmp	r5, #0
 80445c2:	dd85      	ble.n	80444d0 <kad_op_add+0x64>
 80445c4:	f8d8 602c 	ldr.w	r6, [r8, #44]	@ 0x2c
 80445c8:	e7e0      	b.n	804458c <kad_op_add+0x120>
		if (n0 % n1 != 0) return -1;
 80445ca:	f04f 30ff 	mov.w	r0, #4294967295
 80445ce:	e780      	b.n	80444d2 <kad_op_add+0x66>
		assert(n0 >= n1);
 80445d0:	f240 4129 	movw	r1, #1065	@ 0x429
 80445d4:	4b02      	ldr	r3, [pc, #8]	@ (80445e0 <kad_op_add+0x174>)
 80445d6:	4a03      	ldr	r2, [pc, #12]	@ (80445e4 <kad_op_add+0x178>)
 80445d8:	4803      	ldr	r0, [pc, #12]	@ (80445e8 <kad_op_add+0x17c>)
 80445da:	f007 f903 	bl	804b7e4 <__assert_func>
 80445de:	bf00      	nop
 80445e0:	0804e3fc 	.word	0x0804e3fc
 80445e4:	0804e5bc 	.word	0x0804e5bc
 80445e8:	0804e3dc 	.word	0x0804e3dc

080445ec <kad_op_sub>:
{
 80445ec:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	q[0] = p->child[0], n0 = kad_len(q[0]);
 80445f0:	6b83      	ldr	r3, [r0, #56]	@ 0x38
{
 80445f2:	4680      	mov	r8, r0
	q[0] = p->child[0], n0 = kad_len(q[0]);
 80445f4:	6818      	ldr	r0, [r3, #0]
	for (i = 0; i < p->n_d; ++i) n *= p->d[i];
 80445f6:	7802      	ldrb	r2, [r0, #0]
 80445f8:	2a00      	cmp	r2, #0
 80445fa:	d06d      	beq.n	80446d8 <kad_op_sub+0xec>
 80445fc:	2a01      	cmp	r2, #1
 80445fe:	6905      	ldr	r5, [r0, #16]
 8044600:	d00c      	beq.n	804461c <kad_op_sub+0x30>
 8044602:	6944      	ldr	r4, [r0, #20]
 8044604:	2a02      	cmp	r2, #2
 8044606:	fb04 f505 	mul.w	r5, r4, r5
 804460a:	d007      	beq.n	804461c <kad_op_sub+0x30>
 804460c:	6984      	ldr	r4, [r0, #24]
 804460e:	2a03      	cmp	r2, #3
 8044610:	fb04 f505 	mul.w	r5, r4, r5
 8044614:	d002      	beq.n	804461c <kad_op_sub+0x30>
 8044616:	69c4      	ldr	r4, [r0, #28]
 8044618:	fb04 f505 	mul.w	r5, r4, r5
	q[1] = p->child[1], n1 = kad_len(q[1]);
 804461c:	685f      	ldr	r7, [r3, #4]
 804461e:	783b      	ldrb	r3, [r7, #0]
 8044620:	2b00      	cmp	r3, #0
 8044622:	d055      	beq.n	80446d0 <kad_op_sub+0xe4>
 8044624:	2b01      	cmp	r3, #1
 8044626:	693c      	ldr	r4, [r7, #16]
 8044628:	d00c      	beq.n	8044644 <kad_op_sub+0x58>
 804462a:	697e      	ldr	r6, [r7, #20]
 804462c:	2b02      	cmp	r3, #2
 804462e:	fb06 f404 	mul.w	r4, r6, r4
 8044632:	d007      	beq.n	8044644 <kad_op_sub+0x58>
 8044634:	69be      	ldr	r6, [r7, #24]
 8044636:	2b03      	cmp	r3, #3
 8044638:	fb06 f404 	mul.w	r4, r6, r4
 804463c:	d002      	beq.n	8044644 <kad_op_sub+0x58>
 804463e:	69fb      	ldr	r3, [r7, #28]
 8044640:	fb03 f404 	mul.w	r4, r3, r4
	if (action == KAD_SYNC_DIM) {
 8044644:	2904      	cmp	r1, #4
 8044646:	d031      	beq.n	80446ac <kad_op_sub+0xc0>
	} else if (action == KAD_FORWARD) {
 8044648:	2902      	cmp	r1, #2
 804464a:	d004      	beq.n	8044656 <kad_op_sub+0x6a>
	} else if (action == KAD_BACKWARD) {
 804464c:	2903      	cmp	r1, #3
 804464e:	d045      	beq.n	80446dc <kad_op_sub+0xf0>
	return 0;
 8044650:	2000      	movs	r0, #0
}
 8044652:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		assert(n0 >= n1);
 8044656:	42ac      	cmp	r4, r5
 8044658:	dc7a      	bgt.n	8044750 <kad_op_sub+0x164>
		memcpy(p->x, q[0]->x, n0 * sizeof(float));
 804465a:	6a81      	ldr	r1, [r0, #40]	@ 0x28
 804465c:	00aa      	lsls	r2, r5, #2
 804465e:	f8d8 0028 	ldr.w	r0, [r8, #40]	@ 0x28
 8044662:	f007 fce4 	bl	804c02e <memcpy>
		for (i = 0; i < n0; i += n1)
 8044666:	2d00      	cmp	r5, #0
 8044668:	ddf2      	ble.n	8044650 <kad_op_sub+0x64>
 804466a:	2c00      	cmp	r4, #0
			kad_saxpy(n1, -1.0f, q[1]->x, p->x + i);
 804466c:	6abf      	ldr	r7, [r7, #40]	@ 0x28
 804466e:	f8d8 1028 	ldr.w	r1, [r8, #40]	@ 0x28
 8044672:	dded      	ble.n	8044650 <kad_op_sub+0x64>
		for (i = 0; i < n0; i += n1)
 8044674:	2000      	movs	r0, #0
 8044676:	ebc4 7e44 	rsb	lr, r4, r4, lsl #29
 804467a:	00a6      	lsls	r6, r4, #2
 804467c:	eb01 0184 	add.w	r1, r1, r4, lsl #2
 8044680:	ea4f 0ece 	mov.w	lr, lr, lsl #3
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 8044684:	eba1 0c06 	sub.w	ip, r1, r6
 8044688:	463a      	mov	r2, r7
		for (i = 0; i < n0; i += n1)
 804468a:	4663      	mov	r3, ip
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 804468c:	edd3 7a00 	vldr	s15, [r3]
 8044690:	ecb2 7a01 	vldmia	r2!, {s14}
 8044694:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8044698:	ece3 7a01 	vstmia	r3!, {s15}
 804469c:	428b      	cmp	r3, r1
 804469e:	d1f5      	bne.n	804468c <kad_op_sub+0xa0>
		for (i = 0; i < n0; i += n1)
 80446a0:	4420      	add	r0, r4
 80446a2:	42a8      	cmp	r0, r5
 80446a4:	ebac 010e 	sub.w	r1, ip, lr
 80446a8:	dbec      	blt.n	8044684 <kad_op_sub+0x98>
 80446aa:	e7d1      	b.n	8044650 <kad_op_sub+0x64>
		if (n0 % n1 != 0) return -1;
 80446ac:	fb95 f3f4 	sdiv	r3, r5, r4
 80446b0:	fb04 5313 	mls	r3, r4, r3, r5
 80446b4:	2b00      	cmp	r3, #0
 80446b6:	d148      	bne.n	804474a <kad_op_sub+0x15e>
	dst->n_d = src->n_d;
 80446b8:	f888 2000 	strb.w	r2, [r8]
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 80446bc:	2a00      	cmp	r2, #0
 80446be:	d0c7      	beq.n	8044650 <kad_op_sub+0x64>
 80446c0:	f100 0110 	add.w	r1, r0, #16
 80446c4:	0092      	lsls	r2, r2, #2
 80446c6:	f108 0010 	add.w	r0, r8, #16
 80446ca:	f007 fcb0 	bl	804c02e <memcpy>
 80446ce:	e7bf      	b.n	8044650 <kad_op_sub+0x64>
	if (action == KAD_SYNC_DIM) {
 80446d0:	2904      	cmp	r1, #4
 80446d2:	d0f1      	beq.n	80446b8 <kad_op_sub+0xcc>
	int n = 1, i;
 80446d4:	2401      	movs	r4, #1
 80446d6:	e7b7      	b.n	8044648 <kad_op_sub+0x5c>
 80446d8:	2501      	movs	r5, #1
 80446da:	e79f      	b.n	804461c <kad_op_sub+0x30>
		if (kad_is_back(q[0])) kad_saxpy(n0, 1.0f, p->g, q[0]->g);
 80446dc:	7843      	ldrb	r3, [r0, #1]
 80446de:	07d9      	lsls	r1, r3, #31
 80446e0:	d52b      	bpl.n	804473a <kad_op_sub+0x14e>
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 80446e2:	2d00      	cmp	r5, #0
		if (kad_is_back(q[0])) kad_saxpy(n0, 1.0f, p->g, q[0]->g);
 80446e4:	f8d8 602c 	ldr.w	r6, [r8, #44]	@ 0x2c
 80446e8:	6ac3      	ldr	r3, [r0, #44]	@ 0x2c
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 80446ea:	ddb1      	ble.n	8044650 <kad_op_sub+0x64>
 80446ec:	4632      	mov	r2, r6
 80446ee:	eb03 0185 	add.w	r1, r3, r5, lsl #2
 80446f2:	edd3 7a00 	vldr	s15, [r3]
 80446f6:	ecb2 7a01 	vldmia	r2!, {s14}
 80446fa:	ee77 7a87 	vadd.f32	s15, s15, s14
 80446fe:	ece3 7a01 	vstmia	r3!, {s15}
 8044702:	4299      	cmp	r1, r3
 8044704:	d1f5      	bne.n	80446f2 <kad_op_sub+0x106>
		if (kad_is_back(q[1]))
 8044706:	787b      	ldrb	r3, [r7, #1]
 8044708:	07db      	lsls	r3, r3, #31
 804470a:	d5a1      	bpl.n	8044650 <kad_op_sub+0x64>
 804470c:	2c00      	cmp	r4, #0
				kad_saxpy(n1, -1.0f, p->g + i, q[1]->g);
 804470e:	6aff      	ldr	r7, [r7, #44]	@ 0x2c
 8044710:	dd9e      	ble.n	8044650 <kad_op_sub+0x64>
			for (i = 0; i < n0; i += n1)
 8044712:	2000      	movs	r0, #0
 8044714:	eb07 0184 	add.w	r1, r7, r4, lsl #2
 8044718:	463b      	mov	r3, r7
 804471a:	eb06 0280 	add.w	r2, r6, r0, lsl #2
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 804471e:	edd3 7a00 	vldr	s15, [r3]
 8044722:	ecb2 7a01 	vldmia	r2!, {s14}
 8044726:	ee77 7ac7 	vsub.f32	s15, s15, s14
 804472a:	ece3 7a01 	vstmia	r3!, {s15}
 804472e:	4299      	cmp	r1, r3
 8044730:	d1f5      	bne.n	804471e <kad_op_sub+0x132>
			for (i = 0; i < n0; i += n1)
 8044732:	4420      	add	r0, r4
 8044734:	42a8      	cmp	r0, r5
 8044736:	dbef      	blt.n	8044718 <kad_op_sub+0x12c>
 8044738:	e78a      	b.n	8044650 <kad_op_sub+0x64>
		if (kad_is_back(q[1]))
 804473a:	787b      	ldrb	r3, [r7, #1]
 804473c:	07da      	lsls	r2, r3, #31
 804473e:	d587      	bpl.n	8044650 <kad_op_sub+0x64>
			for (i = 0; i < n0; i += n1)
 8044740:	2d00      	cmp	r5, #0
 8044742:	dd85      	ble.n	8044650 <kad_op_sub+0x64>
 8044744:	f8d8 602c 	ldr.w	r6, [r8, #44]	@ 0x2c
 8044748:	e7e0      	b.n	804470c <kad_op_sub+0x120>
		if (n0 % n1 != 0) return -1;
 804474a:	f04f 30ff 	mov.w	r0, #4294967295
 804474e:	e780      	b.n	8044652 <kad_op_sub+0x66>
		assert(n0 >= n1);
 8044750:	f240 4141 	movw	r1, #1089	@ 0x441
 8044754:	4b02      	ldr	r3, [pc, #8]	@ (8044760 <kad_op_sub+0x174>)
 8044756:	4a03      	ldr	r2, [pc, #12]	@ (8044764 <kad_op_sub+0x178>)
 8044758:	4803      	ldr	r0, [pc, #12]	@ (8044768 <kad_op_sub+0x17c>)
 804475a:	f007 f843 	bl	804b7e4 <__assert_func>
 804475e:	bf00      	nop
 8044760:	0804e3fc 	.word	0x0804e3fc
 8044764:	0804e5b0 	.word	0x0804e5b0
 8044768:	0804e3dc 	.word	0x0804e3dc

0804476c <kad_op_1minus>:
{
 804476c:	b538      	push	{r3, r4, r5, lr}
	kad_node_t *q = p->child[0];
 804476e:	6b83      	ldr	r3, [r0, #56]	@ 0x38
 8044770:	681c      	ldr	r4, [r3, #0]
	for (i = 0; i < p->n_d; ++i) n *= p->d[i];
 8044772:	7825      	ldrb	r5, [r4, #0]
 8044774:	b305      	cbz	r5, 80447b8 <kad_op_1minus+0x4c>
 8044776:	2d01      	cmp	r5, #1
 8044778:	6923      	ldr	r3, [r4, #16]
 804477a:	d00c      	beq.n	8044796 <kad_op_1minus+0x2a>
 804477c:	6962      	ldr	r2, [r4, #20]
 804477e:	2d02      	cmp	r5, #2
 8044780:	fb02 f303 	mul.w	r3, r2, r3
 8044784:	d007      	beq.n	8044796 <kad_op_1minus+0x2a>
 8044786:	69a2      	ldr	r2, [r4, #24]
 8044788:	2d03      	cmp	r5, #3
 804478a:	fb02 f303 	mul.w	r3, r2, r3
 804478e:	d002      	beq.n	8044796 <kad_op_1minus+0x2a>
 8044790:	69e2      	ldr	r2, [r4, #28]
 8044792:	fb02 f303 	mul.w	r3, r2, r3
	if (action == KAD_SYNC_DIM) {
 8044796:	2904      	cmp	r1, #4
 8044798:	d005      	beq.n	80447a6 <kad_op_1minus+0x3a>
	} else if (action == KAD_FORWARD) {
 804479a:	2902      	cmp	r1, #2
 804479c:	d013      	beq.n	80447c6 <kad_op_1minus+0x5a>
	} else if (action == KAD_BACKWARD && kad_is_back(q)) {
 804479e:	2903      	cmp	r1, #3
 80447a0:	d025      	beq.n	80447ee <kad_op_1minus+0x82>
}
 80447a2:	2000      	movs	r0, #0
 80447a4:	bd38      	pop	{r3, r4, r5, pc}
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 80447a6:	00aa      	lsls	r2, r5, #2
 80447a8:	f104 0110 	add.w	r1, r4, #16
	dst->n_d = src->n_d;
 80447ac:	f800 5b10 	strb.w	r5, [r0], #16
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 80447b0:	f007 fc3d 	bl	804c02e <memcpy>
}
 80447b4:	2000      	movs	r0, #0
 80447b6:	bd38      	pop	{r3, r4, r5, pc}
	if (action == KAD_SYNC_DIM) {
 80447b8:	2904      	cmp	r1, #4
 80447ba:	d016      	beq.n	80447ea <kad_op_1minus+0x7e>
	} else if (action == KAD_FORWARD) {
 80447bc:	2902      	cmp	r1, #2
	int n = 1, i;
 80447be:	f04f 0301 	mov.w	r3, #1
 80447c2:	d1ec      	bne.n	804479e <kad_op_1minus+0x32>
 80447c4:	e001      	b.n	80447ca <kad_op_1minus+0x5e>
		for (i = 0; i < n; ++i) p->x[i] = 1.0f - q->x[i];
 80447c6:	2b00      	cmp	r3, #0
 80447c8:	ddeb      	ble.n	80447a2 <kad_op_1minus+0x36>
 80447ca:	2200      	movs	r2, #0
 80447cc:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 80447d0:	6aa4      	ldr	r4, [r4, #40]	@ 0x28
 80447d2:	6a81      	ldr	r1, [r0, #40]	@ 0x28
 80447d4:	ecf4 7a01 	vldmia	r4!, {s15}
 80447d8:	ee77 7a67 	vsub.f32	s15, s14, s15
 80447dc:	3201      	adds	r2, #1
 80447de:	429a      	cmp	r2, r3
 80447e0:	ece1 7a01 	vstmia	r1!, {s15}
 80447e4:	dbf6      	blt.n	80447d4 <kad_op_1minus+0x68>
}
 80447e6:	2000      	movs	r0, #0
 80447e8:	bd38      	pop	{r3, r4, r5, pc}
	dst->n_d = src->n_d;
 80447ea:	7005      	strb	r5, [r0, #0]
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 80447ec:	e7d9      	b.n	80447a2 <kad_op_1minus+0x36>
	} else if (action == KAD_BACKWARD && kad_is_back(q)) {
 80447ee:	7862      	ldrb	r2, [r4, #1]
 80447f0:	07d2      	lsls	r2, r2, #31
 80447f2:	d5d6      	bpl.n	80447a2 <kad_op_1minus+0x36>
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 80447f4:	2b00      	cmp	r3, #0
		kad_saxpy(n, -1.0f, p->g, q->g);
 80447f6:	6ac1      	ldr	r1, [r0, #44]	@ 0x2c
 80447f8:	6ae2      	ldr	r2, [r4, #44]	@ 0x2c
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 80447fa:	ddd2      	ble.n	80447a2 <kad_op_1minus+0x36>
 80447fc:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 8044800:	edd2 7a00 	vldr	s15, [r2]
 8044804:	ecb1 7a01 	vldmia	r1!, {s14}
 8044808:	ee77 7ac7 	vsub.f32	s15, s15, s14
 804480c:	ece2 7a01 	vstmia	r2!, {s15}
 8044810:	4293      	cmp	r3, r2
 8044812:	d1f5      	bne.n	8044800 <kad_op_1minus+0x94>
 8044814:	e7c5      	b.n	80447a2 <kad_op_1minus+0x36>
 8044816:	bf00      	nop

08044818 <kad_op_slice>:
{
 8044818:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	kad_node_t *q = p->child[0];
 804481c:	6b83      	ldr	r3, [r0, #56]	@ 0x38
	assert(p->ptr);
 804481e:	f8d0 a030 	ldr.w	sl, [r0, #48]	@ 0x30
	kad_node_t *q = p->child[0];
 8044822:	681d      	ldr	r5, [r3, #0]
	assert(p->ptr);
 8044824:	f1ba 0f00 	cmp.w	sl, #0
 8044828:	f000 80b7 	beq.w	804499a <kad_op_slice+0x182>
	aux = (int32_t*)p->ptr, axis = aux[0], range = aux + 1;
 804482c:	f8da 4000 	ldr.w	r4, [sl]
	if (axis < 0 || axis >= q->n_d) return -1;
 8044830:	2c00      	cmp	r4, #0
 8044832:	f2c0 80af 	blt.w	8044994 <kad_op_slice+0x17c>
 8044836:	782f      	ldrb	r7, [r5, #0]
 8044838:	42a7      	cmp	r7, r4
 804483a:	f340 80ab 	ble.w	8044994 <kad_op_slice+0x17c>
	for (i = 0, d0 = 1; i < axis; ++i) d0 *= q->d[i];
 804483e:	4606      	mov	r6, r0
 8044840:	2c00      	cmp	r4, #0
 8044842:	d06d      	beq.n	8044920 <kad_op_slice+0x108>
 8044844:	2c01      	cmp	r4, #1
 8044846:	f8d5 9010 	ldr.w	r9, [r5, #16]
 804484a:	d00c      	beq.n	8044866 <kad_op_slice+0x4e>
 804484c:	696b      	ldr	r3, [r5, #20]
 804484e:	2c02      	cmp	r4, #2
 8044850:	fb03 f909 	mul.w	r9, r3, r9
 8044854:	d007      	beq.n	8044866 <kad_op_slice+0x4e>
 8044856:	69ab      	ldr	r3, [r5, #24]
 8044858:	2c03      	cmp	r4, #3
 804485a:	fb03 f909 	mul.w	r9, r3, r9
 804485e:	d002      	beq.n	8044866 <kad_op_slice+0x4e>
 8044860:	69eb      	ldr	r3, [r5, #28]
 8044862:	fb03 f909 	mul.w	r9, r3, r9
	for (i = axis + 1, d1 = 1; i < q->n_d; ++i) d1 *= q->d[i];
 8044866:	1c63      	adds	r3, r4, #1
 8044868:	429f      	cmp	r7, r3
 804486a:	dd56      	ble.n	804491a <kad_op_slice+0x102>
 804486c:	1ca3      	adds	r3, r4, #2
 804486e:	eb05 0284 	add.w	r2, r5, r4, lsl #2
 8044872:	429f      	cmp	r7, r3
 8044874:	f8d2 8014 	ldr.w	r8, [r2, #20]
 8044878:	dd08      	ble.n	804488c <kad_op_slice+0x74>
 804487a:	6993      	ldr	r3, [r2, #24]
 804487c:	fb03 f808 	mul.w	r8, r3, r8
 8044880:	1ce3      	adds	r3, r4, #3
 8044882:	429f      	cmp	r7, r3
 8044884:	dd02      	ble.n	804488c <kad_op_slice+0x74>
 8044886:	69d3      	ldr	r3, [r2, #28]
 8044888:	fb03 f808 	mul.w	r8, r3, r8
	if (action == KAD_SYNC_DIM) {
 804488c:	2904      	cmp	r1, #4
 804488e:	d02b      	beq.n	80448e8 <kad_op_slice+0xd0>
	} else if (action == KAD_FORWARD) {
 8044890:	2902      	cmp	r1, #2
 8044892:	d004      	beq.n	804489e <kad_op_slice+0x86>
	} else if (action == KAD_BACKWARD && kad_is_back(q)) {
 8044894:	2903      	cmp	r1, #3
 8044896:	d046      	beq.n	8044926 <kad_op_slice+0x10e>
	return 0;
 8044898:	2000      	movs	r0, #0
}
 804489a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		for (i = 0; i < d0; ++i)
 804489e:	f1b9 0f00 	cmp.w	r9, #0
 80448a2:	ddf9      	ble.n	8044898 <kad_op_slice+0x80>
 80448a4:	2700      	movs	r7, #0
 80448a6:	3404      	adds	r4, #4
			memcpy(&p->x[i * p->d[axis] * d1], &q->x[(i * q->d[axis] + range[0]) * d1], (range[1] - range[0]) * d1 * sizeof(float));
 80448a8:	f856 0024 	ldr.w	r0, [r6, r4, lsl #2]
 80448ac:	f8da 1004 	ldr.w	r1, [sl, #4]
 80448b0:	fb07 f000 	mul.w	r0, r7, r0
 80448b4:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
 80448b8:	f8da 2008 	ldr.w	r2, [sl, #8]
 80448bc:	fb03 1307 	mla	r3, r3, r7, r1
 80448c0:	fb08 f000 	mul.w	r0, r8, r0
 80448c4:	1a52      	subs	r2, r2, r1
 80448c6:	fb08 f303 	mul.w	r3, r8, r3
 80448ca:	6ab1      	ldr	r1, [r6, #40]	@ 0x28
 80448cc:	fb08 f202 	mul.w	r2, r8, r2
 80448d0:	eb01 0080 	add.w	r0, r1, r0, lsl #2
 80448d4:	6aa9      	ldr	r1, [r5, #40]	@ 0x28
		for (i = 0; i < d0; ++i)
 80448d6:	3701      	adds	r7, #1
			memcpy(&p->x[i * p->d[axis] * d1], &q->x[(i * q->d[axis] + range[0]) * d1], (range[1] - range[0]) * d1 * sizeof(float));
 80448d8:	0092      	lsls	r2, r2, #2
 80448da:	eb01 0183 	add.w	r1, r1, r3, lsl #2
 80448de:	f007 fba6 	bl	804c02e <memcpy>
		for (i = 0; i < d0; ++i)
 80448e2:	454f      	cmp	r7, r9
 80448e4:	d1e0      	bne.n	80448a8 <kad_op_slice+0x90>
 80448e6:	e7d7      	b.n	8044898 <kad_op_slice+0x80>
		if (range[0] >= range[1] || range[0] < 0 || range[1] > q->d[axis]) return -1;
 80448e8:	e9da 2301 	ldrd	r2, r3, [sl, #4]
 80448ec:	429a      	cmp	r2, r3
 80448ee:	da51      	bge.n	8044994 <kad_op_slice+0x17c>
 80448f0:	2a00      	cmp	r2, #0
 80448f2:	db4f      	blt.n	8044994 <kad_op_slice+0x17c>
 80448f4:	3404      	adds	r4, #4
 80448f6:	f855 2024 	ldr.w	r2, [r5, r4, lsl #2]
 80448fa:	4293      	cmp	r3, r2
 80448fc:	dc4a      	bgt.n	8044994 <kad_op_slice+0x17c>
	dst->n_d = src->n_d;
 80448fe:	4630      	mov	r0, r6
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 8044900:	00ba      	lsls	r2, r7, #2
 8044902:	f105 0110 	add.w	r1, r5, #16
	dst->n_d = src->n_d;
 8044906:	f800 7b10 	strb.w	r7, [r0], #16
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 804490a:	f007 fb90 	bl	804c02e <memcpy>
		p->d[axis] = range[1] - range[0];
 804490e:	e9da 2301 	ldrd	r2, r3, [sl, #4]
 8044912:	1a9b      	subs	r3, r3, r2
 8044914:	f846 3024 	str.w	r3, [r6, r4, lsl #2]
 8044918:	e7be      	b.n	8044898 <kad_op_slice+0x80>
	for (i = axis + 1, d1 = 1; i < q->n_d; ++i) d1 *= q->d[i];
 804491a:	f04f 0801 	mov.w	r8, #1
 804491e:	e7b5      	b.n	804488c <kad_op_slice+0x74>
	for (i = 0, d0 = 1; i < axis; ++i) d0 *= q->d[i];
 8044920:	f04f 0901 	mov.w	r9, #1
 8044924:	e79f      	b.n	8044866 <kad_op_slice+0x4e>
	} else if (action == KAD_BACKWARD && kad_is_back(q)) {
 8044926:	786b      	ldrb	r3, [r5, #1]
 8044928:	07db      	lsls	r3, r3, #31
 804492a:	d5b5      	bpl.n	8044898 <kad_op_slice+0x80>
		for (i = 0; i < d0; ++i)
 804492c:	f1b9 0f00 	cmp.w	r9, #0
 8044930:	ddb2      	ble.n	8044898 <kad_op_slice+0x80>
			kad_saxpy((range[1] - range[0]) * d1, 1.0f, &p->g[i * p->d[axis] * d1], &q->g[(i * q->d[axis] + range[0]) * d1]);
 8044932:	e9da 2301 	ldrd	r2, r3, [sl, #4]
 8044936:	1a9b      	subs	r3, r3, r2
 8044938:	fb08 f303 	mul.w	r3, r8, r3
 804493c:	3404      	adds	r4, #4
 804493e:	2b00      	cmp	r3, #0
 8044940:	6af7      	ldr	r7, [r6, #44]	@ 0x2c
 8044942:	f856 0024 	ldr.w	r0, [r6, r4, lsl #2]
 8044946:	f855 1024 	ldr.w	r1, [r5, r4, lsl #2]
 804494a:	6aee      	ldr	r6, [r5, #44]	@ 0x2c
 804494c:	dda4      	ble.n	8044898 <kad_op_slice+0x80>
 804494e:	2400      	movs	r4, #0
		for (i = 0; i < d0; ++i)
 8044950:	4625      	mov	r5, r4
 8044952:	fb08 f202 	mul.w	r2, r8, r2
 8044956:	fb08 f101 	mul.w	r1, r8, r1
 804495a:	fb08 fe00 	mul.w	lr, r8, r0
 804495e:	4413      	add	r3, r2
 8044960:	ea4f 0c81 	mov.w	ip, r1, lsl #2
 8044964:	0090      	lsls	r0, r2, #2
 8044966:	ea4f 0e8e 	mov.w	lr, lr, lsl #2
 804496a:	eb06 0183 	add.w	r1, r6, r3, lsl #2
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 804496e:	1833      	adds	r3, r6, r0
 8044970:	193a      	adds	r2, r7, r4
 8044972:	edd3 7a00 	vldr	s15, [r3]
 8044976:	ecb2 7a01 	vldmia	r2!, {s14}
 804497a:	ee77 7a87 	vadd.f32	s15, s15, s14
 804497e:	ece3 7a01 	vstmia	r3!, {s15}
 8044982:	4299      	cmp	r1, r3
 8044984:	d1f5      	bne.n	8044972 <kad_op_slice+0x15a>
		for (i = 0; i < d0; ++i)
 8044986:	3501      	adds	r5, #1
 8044988:	454d      	cmp	r5, r9
 804498a:	4460      	add	r0, ip
 804498c:	4474      	add	r4, lr
 804498e:	4461      	add	r1, ip
 8044990:	d1ed      	bne.n	804496e <kad_op_slice+0x156>
 8044992:	e781      	b.n	8044898 <kad_op_slice+0x80>
	if (axis < 0 || axis >= q->n_d) return -1;
 8044994:	f04f 30ff 	mov.w	r0, #4294967295
 8044998:	e77f      	b.n	804489a <kad_op_slice+0x82>
	assert(p->ptr);
 804499a:	f44f 61ab 	mov.w	r1, #1368	@ 0x558
 804499e:	4b02      	ldr	r3, [pc, #8]	@ (80449a8 <kad_op_slice+0x190>)
 80449a0:	4a02      	ldr	r2, [pc, #8]	@ (80449ac <kad_op_slice+0x194>)
 80449a2:	4803      	ldr	r0, [pc, #12]	@ (80449b0 <kad_op_slice+0x198>)
 80449a4:	f006 ff1e 	bl	804b7e4 <__assert_func>
 80449a8:	0804e3d4 	.word	0x0804e3d4
 80449ac:	0804e55c 	.word	0x0804e55c
 80449b0:	0804e3dc 	.word	0x0804e3dc

080449b4 <kad_op_concat>:
{
 80449b4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80449b8:	4604      	mov	r4, r0
	kad_node_t *q = p->child[0];
 80449ba:	6b80      	ldr	r0, [r0, #56]	@ 0x38
	assert(p->ptr);
 80449bc:	6b22      	ldr	r2, [r4, #48]	@ 0x30
	kad_node_t *q = p->child[0];
 80449be:	6803      	ldr	r3, [r0, #0]
{
 80449c0:	b083      	sub	sp, #12
	assert(p->ptr);
 80449c2:	2a00      	cmp	r2, #0
 80449c4:	f000 817c 	beq.w	8044cc0 <kad_op_concat+0x30c>
	aux = (int32_t*)p->ptr, axis = aux[0];
 80449c8:	6815      	ldr	r5, [r2, #0]
	for (i = 0, d0 = 1; i < axis; ++i) d0 *= q->d[i];
 80449ca:	2d00      	cmp	r5, #0
 80449cc:	f340 8114 	ble.w	8044bf8 <kad_op_concat+0x244>
 80449d0:	2d01      	cmp	r5, #1
 80449d2:	f8d3 c010 	ldr.w	ip, [r3, #16]
 80449d6:	d00c      	beq.n	80449f2 <kad_op_concat+0x3e>
 80449d8:	695a      	ldr	r2, [r3, #20]
 80449da:	2d02      	cmp	r5, #2
 80449dc:	fb02 fc0c 	mul.w	ip, r2, ip
 80449e0:	d007      	beq.n	80449f2 <kad_op_concat+0x3e>
 80449e2:	699a      	ldr	r2, [r3, #24]
 80449e4:	2d03      	cmp	r5, #3
 80449e6:	fb02 fc0c 	mul.w	ip, r2, ip
 80449ea:	d002      	beq.n	80449f2 <kad_op_concat+0x3e>
 80449ec:	69da      	ldr	r2, [r3, #28]
 80449ee:	fb02 fc0c 	mul.w	ip, r2, ip
	for (i = axis + 1, d1 = 1; i < q->n_d; ++i) d1 *= q->d[i];
 80449f2:	781a      	ldrb	r2, [r3, #0]
 80449f4:	1c6e      	adds	r6, r5, #1
 80449f6:	4296      	cmp	r6, r2
 80449f8:	f280 80fc 	bge.w	8044bf4 <kad_op_concat+0x240>
 80449fc:	1caf      	adds	r7, r5, #2
 80449fe:	eb03 0e85 	add.w	lr, r3, r5, lsl #2
 8044a02:	42ba      	cmp	r2, r7
 8044a04:	f8de 6014 	ldr.w	r6, [lr, #20]
 8044a08:	dd11      	ble.n	8044a2e <kad_op_concat+0x7a>
 8044a0a:	f8de 7018 	ldr.w	r7, [lr, #24]
 8044a0e:	fb07 f606 	mul.w	r6, r7, r6
 8044a12:	1cef      	adds	r7, r5, #3
 8044a14:	42ba      	cmp	r2, r7
 8044a16:	dd0a      	ble.n	8044a2e <kad_op_concat+0x7a>
 8044a18:	f8de 701c 	ldr.w	r7, [lr, #28]
 8044a1c:	fb07 f606 	mul.w	r6, r7, r6
 8044a20:	1d2f      	adds	r7, r5, #4
 8044a22:	42ba      	cmp	r2, r7
 8044a24:	dd03      	ble.n	8044a2e <kad_op_concat+0x7a>
 8044a26:	f8de 7020 	ldr.w	r7, [lr, #32]
 8044a2a:	fb07 f606 	mul.w	r6, r7, r6
	if (action == KAD_SYNC_DIM) {
 8044a2e:	2904      	cmp	r1, #4
 8044a30:	d042      	beq.n	8044ab8 <kad_op_concat+0x104>
	} else if (action == KAD_FORWARD) {
 8044a32:	2902      	cmp	r1, #2
 8044a34:	d006      	beq.n	8044a44 <kad_op_concat+0x90>
	} else if (action == KAD_BACKWARD) {
 8044a36:	2903      	cmp	r1, #3
 8044a38:	f000 80e1 	beq.w	8044bfe <kad_op_concat+0x24a>
	return 0;
 8044a3c:	2000      	movs	r0, #0
}
 8044a3e:	b003      	add	sp, #12
 8044a40:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		for (i = 0; i < d0; ++i)
 8044a44:	f1bc 0f00 	cmp.w	ip, #0
 8044a48:	ddf8      	ble.n	8044a3c <kad_op_concat+0x88>
		for (i = 1; i < p->n_child; ++i) {
 8044a4a:	6863      	ldr	r3, [r4, #4]
		for (i = 0; i < d0; ++i)
 8044a4c:	f04f 0900 	mov.w	r9, #0
 8044a50:	461a      	mov	r2, r3
 8044a52:	ea4f 0a85 	mov.w	sl, r5, lsl #2
 8044a56:	f105 0b04 	add.w	fp, r5, #4
 8044a5a:	f8cd c004 	str.w	ip, [sp, #4]
			for (j = k = 0; j < p->n_child; ++j) {
 8044a5e:	2a00      	cmp	r2, #0
 8044a60:	ddec      	ble.n	8044a3c <kad_op_concat+0x88>
 8044a62:	2700      	movs	r7, #0
 8044a64:	463d      	mov	r5, r7
				q = p->child[j];
 8044a66:	6ba1      	ldr	r1, [r4, #56]	@ 0x38
				memcpy(&p->x[(i * p->d[axis] + k) * d1], &q->x[i * q->d[axis] * d1], q->d[axis] * d1 * sizeof(float));
 8044a68:	f854 202b 	ldr.w	r2, [r4, fp, lsl #2]
				q = p->child[j];
 8044a6c:	f851 1025 	ldr.w	r1, [r1, r5, lsl #2]
				memcpy(&p->x[(i * p->d[axis] + k) * d1], &q->x[i * q->d[axis] * d1], q->d[axis] * d1 * sizeof(float));
 8044a70:	fb02 7c09 	mla	ip, r2, r9, r7
 8044a74:	eb01 080a 	add.w	r8, r1, sl
 8044a78:	f8d8 2010 	ldr.w	r2, [r8, #16]
 8044a7c:	6a88      	ldr	r0, [r1, #40]	@ 0x28
 8044a7e:	fb09 f102 	mul.w	r1, r9, r2
 8044a82:	fb06 f101 	mul.w	r1, r6, r1
 8044a86:	fb06 fc0c 	mul.w	ip, r6, ip
 8044a8a:	fb06 f202 	mul.w	r2, r6, r2
 8044a8e:	eb00 0181 	add.w	r1, r0, r1, lsl #2
 8044a92:	6aa0      	ldr	r0, [r4, #40]	@ 0x28
 8044a94:	0092      	lsls	r2, r2, #2
 8044a96:	eb00 008c 	add.w	r0, r0, ip, lsl #2
 8044a9a:	f007 fac8 	bl	804c02e <memcpy>
			for (j = k = 0; j < p->n_child; ++j) {
 8044a9e:	6862      	ldr	r2, [r4, #4]
				k += q->d[axis];
 8044aa0:	f8d8 1010 	ldr.w	r1, [r8, #16]
			for (j = k = 0; j < p->n_child; ++j) {
 8044aa4:	3501      	adds	r5, #1
 8044aa6:	42aa      	cmp	r2, r5
				k += q->d[axis];
 8044aa8:	440f      	add	r7, r1
			for (j = k = 0; j < p->n_child; ++j) {
 8044aaa:	dcdc      	bgt.n	8044a66 <kad_op_concat+0xb2>
		for (i = 0; i < d0; ++i)
 8044aac:	9b01      	ldr	r3, [sp, #4]
 8044aae:	f109 0901 	add.w	r9, r9, #1
 8044ab2:	4599      	cmp	r9, r3
 8044ab4:	d1d3      	bne.n	8044a5e <kad_op_concat+0xaa>
 8044ab6:	e7c1      	b.n	8044a3c <kad_op_concat+0x88>
		for (i = 1; i < p->n_child; ++i) {
 8044ab8:	6866      	ldr	r6, [r4, #4]
 8044aba:	2e01      	cmp	r6, #1
 8044abc:	f340 80ea 	ble.w	8044c94 <kad_op_concat+0x2e0>
 8044ac0:	4684      	mov	ip, r0
 8044ac2:	f04f 0e01 	mov.w	lr, #1
 8044ac6:	46a0      	mov	r8, r4
 8044ac8:	4607      	mov	r7, r0
			if (p->child[i]->n_d != q->n_d) return -1;
 8044aca:	f85c 1f04 	ldr.w	r1, [ip, #4]!
 8044ace:	7808      	ldrb	r0, [r1, #0]
 8044ad0:	4290      	cmp	r0, r2
 8044ad2:	d128      	bne.n	8044b26 <kad_op_concat+0x172>
			for (j = 0; j < q->n_d; ++j)
 8044ad4:	2a00      	cmp	r2, #0
 8044ad6:	d051      	beq.n	8044b7c <kad_op_concat+0x1c8>
				if (j != axis && q->d[j] != p->child[i]->d[j]) return -1;
 8044ad8:	b355      	cbz	r5, 8044b30 <kad_op_concat+0x17c>
 8044ada:	690c      	ldr	r4, [r1, #16]
 8044adc:	6918      	ldr	r0, [r3, #16]
 8044ade:	4284      	cmp	r4, r0
 8044ae0:	d121      	bne.n	8044b26 <kad_op_concat+0x172>
			for (j = 0; j < q->n_d; ++j)
 8044ae2:	2a01      	cmp	r2, #1
 8044ae4:	d04a      	beq.n	8044b7c <kad_op_concat+0x1c8>
				if (j != axis && q->d[j] != p->child[i]->d[j]) return -1;
 8044ae6:	2d01      	cmp	r5, #1
 8044ae8:	d063      	beq.n	8044bb2 <kad_op_concat+0x1fe>
 8044aea:	694c      	ldr	r4, [r1, #20]
 8044aec:	6958      	ldr	r0, [r3, #20]
 8044aee:	4284      	cmp	r4, r0
 8044af0:	d119      	bne.n	8044b26 <kad_op_concat+0x172>
			for (j = 0; j < q->n_d; ++j)
 8044af2:	2a02      	cmp	r2, #2
 8044af4:	d042      	beq.n	8044b7c <kad_op_concat+0x1c8>
				if (j != axis && q->d[j] != p->child[i]->d[j]) return -1;
 8044af6:	2d02      	cmp	r5, #2
 8044af8:	d122      	bne.n	8044b40 <kad_op_concat+0x18c>
			for (j = 0; j < q->n_d; ++j)
 8044afa:	2a03      	cmp	r2, #3
 8044afc:	d03e      	beq.n	8044b7c <kad_op_concat+0x1c8>
				if (j != axis && q->d[j] != p->child[i]->d[j]) return -1;
 8044afe:	69cc      	ldr	r4, [r1, #28]
 8044b00:	69d8      	ldr	r0, [r3, #28]
 8044b02:	4284      	cmp	r4, r0
 8044b04:	d10f      	bne.n	8044b26 <kad_op_concat+0x172>
			for (j = 0; j < q->n_d; ++j)
 8044b06:	2a04      	cmp	r2, #4
 8044b08:	d038      	beq.n	8044b7c <kad_op_concat+0x1c8>
				if (j != axis && q->d[j] != p->child[i]->d[j]) return -1;
 8044b0a:	6a0c      	ldr	r4, [r1, #32]
 8044b0c:	6a18      	ldr	r0, [r3, #32]
 8044b0e:	4284      	cmp	r4, r0
 8044b10:	d109      	bne.n	8044b26 <kad_op_concat+0x172>
			for (j = 0; j < q->n_d; ++j)
 8044b12:	2a05      	cmp	r2, #5
 8044b14:	dd32      	ble.n	8044b7c <kad_op_concat+0x1c8>
				if (j != axis && q->d[j] != p->child[i]->d[j]) return -1;
 8044b16:	2d05      	cmp	r5, #5
 8044b18:	d122      	bne.n	8044b60 <kad_op_concat+0x1ac>
			for (j = 0; j < q->n_d; ++j)
 8044b1a:	2a06      	cmp	r2, #6
 8044b1c:	d02e      	beq.n	8044b7c <kad_op_concat+0x1c8>
				if (j != axis && q->d[j] != p->child[i]->d[j]) return -1;
 8044b1e:	6a8c      	ldr	r4, [r1, #40]	@ 0x28
 8044b20:	6a98      	ldr	r0, [r3, #40]	@ 0x28
 8044b22:	4284      	cmp	r4, r0
 8044b24:	d024      	beq.n	8044b70 <kad_op_concat+0x1bc>
			if (p->child[i]->n_d != q->n_d) return -1;
 8044b26:	f04f 30ff 	mov.w	r0, #4294967295
}
 8044b2a:	b003      	add	sp, #12
 8044b2c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			for (j = 0; j < q->n_d; ++j)
 8044b30:	2a01      	cmp	r2, #1
 8044b32:	d023      	beq.n	8044b7c <kad_op_concat+0x1c8>
				if (j != axis && q->d[j] != p->child[i]->d[j]) return -1;
 8044b34:	694c      	ldr	r4, [r1, #20]
 8044b36:	6958      	ldr	r0, [r3, #20]
 8044b38:	4284      	cmp	r4, r0
 8044b3a:	d1f4      	bne.n	8044b26 <kad_op_concat+0x172>
			for (j = 0; j < q->n_d; ++j)
 8044b3c:	2a02      	cmp	r2, #2
 8044b3e:	d01d      	beq.n	8044b7c <kad_op_concat+0x1c8>
				if (j != axis && q->d[j] != p->child[i]->d[j]) return -1;
 8044b40:	699c      	ldr	r4, [r3, #24]
 8044b42:	6988      	ldr	r0, [r1, #24]
 8044b44:	4284      	cmp	r4, r0
 8044b46:	d1ee      	bne.n	8044b26 <kad_op_concat+0x172>
			for (j = 0; j < q->n_d; ++j)
 8044b48:	2a03      	cmp	r2, #3
 8044b4a:	dd17      	ble.n	8044b7c <kad_op_concat+0x1c8>
				if (j != axis && q->d[j] != p->child[i]->d[j]) return -1;
 8044b4c:	2d03      	cmp	r5, #3
 8044b4e:	d138      	bne.n	8044bc2 <kad_op_concat+0x20e>
			for (j = 0; j < q->n_d; ++j)
 8044b50:	2a04      	cmp	r2, #4
 8044b52:	d013      	beq.n	8044b7c <kad_op_concat+0x1c8>
				if (j != axis && q->d[j] != p->child[i]->d[j]) return -1;
 8044b54:	6a1c      	ldr	r4, [r3, #32]
 8044b56:	6a08      	ldr	r0, [r1, #32]
 8044b58:	4284      	cmp	r4, r0
 8044b5a:	d1e4      	bne.n	8044b26 <kad_op_concat+0x172>
			for (j = 0; j < q->n_d; ++j)
 8044b5c:	2a05      	cmp	r2, #5
 8044b5e:	d00d      	beq.n	8044b7c <kad_op_concat+0x1c8>
				if (j != axis && q->d[j] != p->child[i]->d[j]) return -1;
 8044b60:	6a4c      	ldr	r4, [r1, #36]	@ 0x24
 8044b62:	6a58      	ldr	r0, [r3, #36]	@ 0x24
 8044b64:	4284      	cmp	r4, r0
 8044b66:	d1de      	bne.n	8044b26 <kad_op_concat+0x172>
			for (j = 0; j < q->n_d; ++j)
 8044b68:	2a06      	cmp	r2, #6
 8044b6a:	dd07      	ble.n	8044b7c <kad_op_concat+0x1c8>
				if (j != axis && q->d[j] != p->child[i]->d[j]) return -1;
 8044b6c:	2d06      	cmp	r5, #6
 8044b6e:	d138      	bne.n	8044be2 <kad_op_concat+0x22e>
			for (j = 0; j < q->n_d; ++j)
 8044b70:	2a07      	cmp	r2, #7
 8044b72:	d003      	beq.n	8044b7c <kad_op_concat+0x1c8>
				if (j != axis && q->d[j] != p->child[i]->d[j]) return -1;
 8044b74:	6ac8      	ldr	r0, [r1, #44]	@ 0x2c
 8044b76:	6ad9      	ldr	r1, [r3, #44]	@ 0x2c
 8044b78:	4288      	cmp	r0, r1
 8044b7a:	d1d4      	bne.n	8044b26 <kad_op_concat+0x172>
		for (i = 1; i < p->n_child; ++i) {
 8044b7c:	f10e 0e01 	add.w	lr, lr, #1
 8044b80:	4576      	cmp	r6, lr
 8044b82:	d1a2      	bne.n	8044aca <kad_op_concat+0x116>
	dst->n_d = src->n_d;
 8044b84:	4644      	mov	r4, r8
 8044b86:	4638      	mov	r0, r7
 8044b88:	f888 2000 	strb.w	r2, [r8]
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 8044b8c:	2a00      	cmp	r2, #0
 8044b8e:	f040 808d 	bne.w	8044cac <kad_op_concat+0x2f8>
 8044b92:	eb04 0485 	add.w	r4, r4, r5, lsl #2
 8044b96:	1f01      	subs	r1, r0, #4
			p->d[axis] += p->child[i]->d[axis];
 8044b98:	6923      	ldr	r3, [r4, #16]
 8044b9a:	1d2f      	adds	r7, r5, #4
 8044b9c:	eb01 0186 	add.w	r1, r1, r6, lsl #2
 8044ba0:	f850 2f04 	ldr.w	r2, [r0, #4]!
 8044ba4:	f852 2027 	ldr.w	r2, [r2, r7, lsl #2]
		for (i = 1; i < p->n_child; ++i)
 8044ba8:	4288      	cmp	r0, r1
			p->d[axis] += p->child[i]->d[axis];
 8044baa:	4413      	add	r3, r2
 8044bac:	6123      	str	r3, [r4, #16]
		for (i = 1; i < p->n_child; ++i)
 8044bae:	d1f7      	bne.n	8044ba0 <kad_op_concat+0x1ec>
 8044bb0:	e744      	b.n	8044a3c <kad_op_concat+0x88>
			for (j = 0; j < q->n_d; ++j)
 8044bb2:	2a02      	cmp	r2, #2
 8044bb4:	d0e2      	beq.n	8044b7c <kad_op_concat+0x1c8>
				if (j != axis && q->d[j] != p->child[i]->d[j]) return -1;
 8044bb6:	698c      	ldr	r4, [r1, #24]
 8044bb8:	6998      	ldr	r0, [r3, #24]
 8044bba:	4284      	cmp	r4, r0
 8044bbc:	d1b3      	bne.n	8044b26 <kad_op_concat+0x172>
			for (j = 0; j < q->n_d; ++j)
 8044bbe:	2a03      	cmp	r2, #3
 8044bc0:	d0dc      	beq.n	8044b7c <kad_op_concat+0x1c8>
				if (j != axis && q->d[j] != p->child[i]->d[j]) return -1;
 8044bc2:	69cc      	ldr	r4, [r1, #28]
 8044bc4:	69d8      	ldr	r0, [r3, #28]
 8044bc6:	4284      	cmp	r4, r0
 8044bc8:	d1ad      	bne.n	8044b26 <kad_op_concat+0x172>
			for (j = 0; j < q->n_d; ++j)
 8044bca:	2a04      	cmp	r2, #4
 8044bcc:	ddd6      	ble.n	8044b7c <kad_op_concat+0x1c8>
				if (j != axis && q->d[j] != p->child[i]->d[j]) return -1;
 8044bce:	2d04      	cmp	r5, #4
 8044bd0:	d19b      	bne.n	8044b0a <kad_op_concat+0x156>
			for (j = 0; j < q->n_d; ++j)
 8044bd2:	2a05      	cmp	r2, #5
 8044bd4:	d0d2      	beq.n	8044b7c <kad_op_concat+0x1c8>
				if (j != axis && q->d[j] != p->child[i]->d[j]) return -1;
 8044bd6:	6a5c      	ldr	r4, [r3, #36]	@ 0x24
 8044bd8:	6a48      	ldr	r0, [r1, #36]	@ 0x24
 8044bda:	4284      	cmp	r4, r0
 8044bdc:	d1a3      	bne.n	8044b26 <kad_op_concat+0x172>
			for (j = 0; j < q->n_d; ++j)
 8044bde:	2a06      	cmp	r2, #6
 8044be0:	d0cc      	beq.n	8044b7c <kad_op_concat+0x1c8>
				if (j != axis && q->d[j] != p->child[i]->d[j]) return -1;
 8044be2:	6a8c      	ldr	r4, [r1, #40]	@ 0x28
 8044be4:	6a98      	ldr	r0, [r3, #40]	@ 0x28
 8044be6:	4284      	cmp	r4, r0
 8044be8:	d19d      	bne.n	8044b26 <kad_op_concat+0x172>
			for (j = 0; j < q->n_d; ++j)
 8044bea:	2a07      	cmp	r2, #7
 8044bec:	ddc6      	ble.n	8044b7c <kad_op_concat+0x1c8>
				if (j != axis && q->d[j] != p->child[i]->d[j]) return -1;
 8044bee:	2d07      	cmp	r5, #7
 8044bf0:	d0c4      	beq.n	8044b7c <kad_op_concat+0x1c8>
 8044bf2:	e7bf      	b.n	8044b74 <kad_op_concat+0x1c0>
	for (i = axis + 1, d1 = 1; i < q->n_d; ++i) d1 *= q->d[i];
 8044bf4:	2601      	movs	r6, #1
 8044bf6:	e71a      	b.n	8044a2e <kad_op_concat+0x7a>
	for (i = 0, d0 = 1; i < axis; ++i) d0 *= q->d[i];
 8044bf8:	f04f 0c01 	mov.w	ip, #1
 8044bfc:	e6f9      	b.n	80449f2 <kad_op_concat+0x3e>
		for (i = 0; i < d0; ++i)
 8044bfe:	f1bc 0f00 	cmp.w	ip, #0
 8044c02:	f77f af1b 	ble.w	8044a3c <kad_op_concat+0x88>
			for (j = k = 0; j < p->n_child; ++j) {
 8044c06:	6862      	ldr	r2, [r4, #4]
 8044c08:	2a00      	cmp	r2, #0
 8044c0a:	f77f af17 	ble.w	8044a3c <kad_op_concat+0x88>
 8044c0e:	1f03      	subs	r3, r0, #4
		for (i = 0; i < d0; ++i)
 8044c10:	f04f 0800 	mov.w	r8, #0
 8044c14:	469e      	mov	lr, r3
 8044c16:	eb03 0982 	add.w	r9, r3, r2, lsl #2
				kad_saxpy(q->d[axis] * d1, 1.0f, &p->g[(i * p->d[axis] + k) * d1], &q->g[i * q->d[axis] * d1]);
 8044c1a:	f105 0a04 	add.w	sl, r5, #4
 8044c1e:	f8cd c004 	str.w	ip, [sp, #4]
			for (j = k = 0; j < p->n_child; ++j) {
 8044c22:	4677      	mov	r7, lr
 8044c24:	f04f 0c00 	mov.w	ip, #0
 8044c28:	e001      	b.n	8044c2e <kad_op_concat+0x27a>
 8044c2a:	45b9      	cmp	r9, r7
 8044c2c:	d02c      	beq.n	8044c88 <kad_op_concat+0x2d4>
				q = p->child[j];
 8044c2e:	f857 3f04 	ldr.w	r3, [r7, #4]!
				if (!kad_is_back(q)) continue;
 8044c32:	785a      	ldrb	r2, [r3, #1]
 8044c34:	07d2      	lsls	r2, r2, #31
 8044c36:	d5f8      	bpl.n	8044c2a <kad_op_concat+0x276>
				kad_saxpy(q->d[axis] * d1, 1.0f, &p->g[(i * p->d[axis] + k) * d1], &q->g[i * q->d[axis] * d1]);
 8044c38:	f853 502a 	ldr.w	r5, [r3, sl, lsl #2]
 8044c3c:	f854 202a 	ldr.w	r2, [r4, sl, lsl #2]
 8044c40:	fb08 fb05 	mul.w	fp, r8, r5
 8044c44:	fb02 c008 	mla	r0, r2, r8, ip
 8044c48:	fb06 f105 	mul.w	r1, r6, r5
 8044c4c:	fb06 f000 	mul.w	r0, r6, r0
 8044c50:	fb06 fb0b 	mul.w	fp, r6, fp
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 8044c54:	2900      	cmp	r1, #0
				kad_saxpy(q->d[axis] * d1, 1.0f, &p->g[(i * p->d[axis] + k) * d1], &q->g[i * q->d[axis] * d1]);
 8044c56:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8044c58:	6ae2      	ldr	r2, [r4, #44]	@ 0x2c
 8044c5a:	ea4f 0080 	mov.w	r0, r0, lsl #2
 8044c5e:	ea4f 0b8b 	mov.w	fp, fp, lsl #2
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 8044c62:	dd0e      	ble.n	8044c82 <kad_op_concat+0x2ce>
 8044c64:	eb03 0181 	add.w	r1, r3, r1, lsl #2
 8044c68:	4402      	add	r2, r0
 8044c6a:	445b      	add	r3, fp
 8044c6c:	4459      	add	r1, fp
 8044c6e:	edd3 7a00 	vldr	s15, [r3]
 8044c72:	ecb2 7a01 	vldmia	r2!, {s14}
 8044c76:	ee77 7a87 	vadd.f32	s15, s15, s14
 8044c7a:	ece3 7a01 	vstmia	r3!, {s15}
 8044c7e:	4299      	cmp	r1, r3
 8044c80:	d1f5      	bne.n	8044c6e <kad_op_concat+0x2ba>
			for (j = k = 0; j < p->n_child; ++j) {
 8044c82:	45b9      	cmp	r9, r7
				k += q->d[axis];
 8044c84:	44ac      	add	ip, r5
			for (j = k = 0; j < p->n_child; ++j) {
 8044c86:	d1d2      	bne.n	8044c2e <kad_op_concat+0x27a>
		for (i = 0; i < d0; ++i)
 8044c88:	9b01      	ldr	r3, [sp, #4]
 8044c8a:	f108 0801 	add.w	r8, r8, #1
 8044c8e:	4598      	cmp	r8, r3
 8044c90:	d1c7      	bne.n	8044c22 <kad_op_concat+0x26e>
 8044c92:	e6d3      	b.n	8044a3c <kad_op_concat+0x88>
	dst->n_d = src->n_d;
 8044c94:	7022      	strb	r2, [r4, #0]
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 8044c96:	2a00      	cmp	r2, #0
 8044c98:	f43f aed0 	beq.w	8044a3c <kad_op_concat+0x88>
 8044c9c:	0092      	lsls	r2, r2, #2
 8044c9e:	f103 0110 	add.w	r1, r3, #16
 8044ca2:	f104 0010 	add.w	r0, r4, #16
 8044ca6:	f007 f9c2 	bl	804c02e <memcpy>
		for (i = 1; i < p->n_child; ++i)
 8044caa:	e6c7      	b.n	8044a3c <kad_op_concat+0x88>
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 8044cac:	0092      	lsls	r2, r2, #2
 8044cae:	f103 0110 	add.w	r1, r3, #16
 8044cb2:	f108 0010 	add.w	r0, r8, #16
 8044cb6:	f007 f9ba 	bl	804c02e <memcpy>
		for (i = 1; i < p->n_child; ++i)
 8044cba:	f8d8 0038 	ldr.w	r0, [r8, #56]	@ 0x38
 8044cbe:	e768      	b.n	8044b92 <kad_op_concat+0x1de>
	assert(p->ptr);
 8044cc0:	f240 5171 	movw	r1, #1393	@ 0x571
 8044cc4:	4b02      	ldr	r3, [pc, #8]	@ (8044cd0 <kad_op_concat+0x31c>)
 8044cc6:	4a03      	ldr	r2, [pc, #12]	@ (8044cd4 <kad_op_concat+0x320>)
 8044cc8:	4803      	ldr	r0, [pc, #12]	@ (8044cd8 <kad_op_concat+0x324>)
 8044cca:	f006 fd8b 	bl	804b7e4 <__assert_func>
 8044cce:	bf00      	nop
 8044cd0:	0804e3d4 	.word	0x0804e3d4
 8044cd4:	0804e54c 	.word	0x0804e54c
 8044cd8:	0804e3dc 	.word	0x0804e3dc

08044cdc <kad_op_reshape>:
	kad_node_t *q = p->child[0];
 8044cdc:	6b82      	ldr	r2, [r0, #56]	@ 0x38
	if (action == KAD_SYNC_DIM) {
 8044cde:	2904      	cmp	r1, #4
{
 8044ce0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8044ce4:	4603      	mov	r3, r0
	kad_node_t *q = p->child[0];
 8044ce6:	6815      	ldr	r5, [r2, #0]
	if (action == KAD_SYNC_DIM) {
 8044ce8:	d01f      	beq.n	8044d2a <kad_op_reshape+0x4e>
	} else if (action == KAD_FORWARD) {
 8044cea:	2902      	cmp	r1, #2
 8044cec:	d004      	beq.n	8044cf8 <kad_op_reshape+0x1c>
	} else if (action == KAD_BACKWARD && kad_is_back(q)) {
 8044cee:	2903      	cmp	r1, #3
 8044cf0:	d06f      	beq.n	8044dd2 <kad_op_reshape+0xf6>
	return 0;
 8044cf2:	2000      	movs	r0, #0
}
 8044cf4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	for (i = 0; i < p->n_d; ++i) n *= p->d[i];
 8044cf8:	7804      	ldrb	r4, [r0, #0]
		memcpy(p->x, q->x, kad_len(p) * sizeof(float));
 8044cfa:	6aa9      	ldr	r1, [r5, #40]	@ 0x28
 8044cfc:	6a80      	ldr	r0, [r0, #40]	@ 0x28
 8044cfe:	2c00      	cmp	r4, #0
 8044d00:	f000 8112 	beq.w	8044f28 <kad_op_reshape+0x24c>
 8044d04:	2c01      	cmp	r4, #1
 8044d06:	691a      	ldr	r2, [r3, #16]
 8044d08:	d00b      	beq.n	8044d22 <kad_op_reshape+0x46>
 8044d0a:	695d      	ldr	r5, [r3, #20]
 8044d0c:	2c02      	cmp	r4, #2
 8044d0e:	fb05 f202 	mul.w	r2, r5, r2
 8044d12:	d006      	beq.n	8044d22 <kad_op_reshape+0x46>
 8044d14:	699d      	ldr	r5, [r3, #24]
 8044d16:	2c03      	cmp	r4, #3
 8044d18:	fb05 f202 	mul.w	r2, r5, r2
 8044d1c:	bf1c      	itt	ne
 8044d1e:	69db      	ldrne	r3, [r3, #28]
 8044d20:	435a      	mulne	r2, r3
 8044d22:	0092      	lsls	r2, r2, #2
 8044d24:	f007 f983 	bl	804c02e <memcpy>
 8044d28:	e7e3      	b.n	8044cf2 <kad_op_reshape+0x16>
		if (p->ptr) {
 8044d2a:	6b01      	ldr	r1, [r0, #48]	@ 0x30
 8044d2c:	2900      	cmp	r1, #0
 8044d2e:	d079      	beq.n	8044e24 <kad_op_reshape+0x148>
			p->n_d = p->ptr_size / 4;
 8044d30:	68c2      	ldr	r2, [r0, #12]
 8044d32:	2a00      	cmp	r2, #0
 8044d34:	bfb8      	it	lt
 8044d36:	3203      	addlt	r2, #3
 8044d38:	1092      	asrs	r2, r2, #2
			for (i = 0; i < p->n_d; ++i) p->d[i] = aux[i];
 8044d3a:	f012 0cff 	ands.w	ip, r2, #255	@ 0xff
			p->n_d = p->ptr_size / 4;
 8044d3e:	7002      	strb	r2, [r0, #0]
			for (i = 0; i < p->n_d; ++i) p->d[i] = aux[i];
 8044d40:	f000 80d7 	beq.w	8044ef2 <kad_op_reshape+0x216>
 8044d44:	680c      	ldr	r4, [r1, #0]
 8044d46:	f012 06fe 	ands.w	r6, r2, #254	@ 0xfe
 8044d4a:	6104      	str	r4, [r0, #16]
 8044d4c:	f000 8170 	beq.w	8045030 <kad_op_reshape+0x354>
 8044d50:	6848      	ldr	r0, [r1, #4]
 8044d52:	f1bc 0f02 	cmp.w	ip, #2
 8044d56:	6158      	str	r0, [r3, #20]
 8044d58:	dd70      	ble.n	8044e3c <kad_op_reshape+0x160>
 8044d5a:	688f      	ldr	r7, [r1, #8]
 8044d5c:	f012 0efc 	ands.w	lr, r2, #252	@ 0xfc
 8044d60:	619f      	str	r7, [r3, #24]
 8044d62:	d06b      	beq.n	8044e3c <kad_op_reshape+0x160>
 8044d64:	68c9      	ldr	r1, [r1, #12]
				if (p->d[i] <= 0) ++n_missing;
 8044d66:	2c00      	cmp	r4, #0
			for (i = 0; i < p->n_d; ++i) p->d[i] = aux[i];
 8044d68:	61d9      	str	r1, [r3, #28]
				if (p->d[i] <= 0) ++n_missing;
 8044d6a:	dd69      	ble.n	8044e40 <kad_op_reshape+0x164>
 8044d6c:	2800      	cmp	r0, #0
 8044d6e:	f340 80f1 	ble.w	8044f54 <kad_op_reshape+0x278>
			int i, len = 1, n_missing = 0;
 8044d72:	2700      	movs	r7, #0
				else len *= p->d[i];
 8044d74:	fb04 f000 	mul.w	r0, r4, r0
				if (p->d[i] <= 0) ++n_missing;
 8044d78:	6999      	ldr	r1, [r3, #24]
 8044d7a:	2900      	cmp	r1, #0
 8044d7c:	f340 8131 	ble.w	8044fe2 <kad_op_reshape+0x306>
				else len *= p->d[i];
 8044d80:	fb01 f000 	mul.w	r0, r1, r0
			for (i = 0; i < p->n_d; ++i)
 8044d84:	f1be 0f00 	cmp.w	lr, #0
 8044d88:	d005      	beq.n	8044d96 <kad_op_reshape+0xba>
				if (p->d[i] <= 0) ++n_missing;
 8044d8a:	69d9      	ldr	r1, [r3, #28]
 8044d8c:	2900      	cmp	r1, #0
 8044d8e:	f340 816c 	ble.w	804506a <kad_op_reshape+0x38e>
				else len *= p->d[i];
 8044d92:	fb01 f000 	mul.w	r0, r1, r0
			if (n_missing == 0 && len != kad_len(q)) return -1;
 8044d96:	2f00      	cmp	r7, #0
 8044d98:	f000 80ac 	beq.w	8044ef4 <kad_op_reshape+0x218>
 8044d9c:	4639      	mov	r1, r7
			if (n_missing > 1) { /* attempt to infer missing dimensions except the last one */
 8044d9e:	2901      	cmp	r1, #1
 8044da0:	d059      	beq.n	8044e56 <kad_op_reshape+0x17a>
					if (p->d[i] <= 0 && i < q->n_d) {
 8044da2:	2c00      	cmp	r4, #0
 8044da4:	f340 812a 	ble.w	8044ffc <kad_op_reshape+0x320>
 8044da8:	695c      	ldr	r4, [r3, #20]
 8044daa:	2c00      	cmp	r4, #0
 8044dac:	f340 8133 	ble.w	8045016 <kad_op_reshape+0x33a>
				for (i = 0; i < p->n_d; ++i)
 8044db0:	f1bc 0f02 	cmp.w	ip, #2
 8044db4:	dd0a      	ble.n	8044dcc <kad_op_reshape+0xf0>
					if (p->d[i] <= 0 && i < q->n_d) {
 8044db6:	699c      	ldr	r4, [r3, #24]
 8044db8:	2c00      	cmp	r4, #0
 8044dba:	f340 813d 	ble.w	8045038 <kad_op_reshape+0x35c>
				for (i = 0; i < p->n_d; ++i)
 8044dbe:	f012 0ffc 	tst.w	r2, #252	@ 0xfc
 8044dc2:	d003      	beq.n	8044dcc <kad_op_reshape+0xf0>
					if (p->d[i] <= 0 && i < q->n_d) {
 8044dc4:	69dc      	ldr	r4, [r3, #28]
 8044dc6:	2c00      	cmp	r4, #0
 8044dc8:	f340 8143 	ble.w	8045052 <kad_op_reshape+0x376>
			if (n_missing == 0 && len != kad_len(q)) return -1;
 8044dcc:	f04f 30ff 	mov.w	r0, #4294967295
 8044dd0:	e790      	b.n	8044cf4 <kad_op_reshape+0x18>
	} else if (action == KAD_BACKWARD && kad_is_back(q)) {
 8044dd2:	786a      	ldrb	r2, [r5, #1]
 8044dd4:	07d2      	lsls	r2, r2, #31
 8044dd6:	d58c      	bpl.n	8044cf2 <kad_op_reshape+0x16>
 8044dd8:	7804      	ldrb	r4, [r0, #0]
		kad_saxpy(kad_len(p), 1.0f, p->g, q->g);
 8044dda:	6ac1      	ldr	r1, [r0, #44]	@ 0x2c
 8044ddc:	6aea      	ldr	r2, [r5, #44]	@ 0x2c
 8044dde:	2c00      	cmp	r4, #0
 8044de0:	f000 8161 	beq.w	80450a6 <kad_op_reshape+0x3ca>
 8044de4:	2c01      	cmp	r4, #1
 8044de6:	6900      	ldr	r0, [r0, #16]
 8044de8:	d00b      	beq.n	8044e02 <kad_op_reshape+0x126>
 8044dea:	695d      	ldr	r5, [r3, #20]
 8044dec:	2c02      	cmp	r4, #2
 8044dee:	fb05 f000 	mul.w	r0, r5, r0
 8044df2:	d006      	beq.n	8044e02 <kad_op_reshape+0x126>
 8044df4:	699d      	ldr	r5, [r3, #24]
 8044df6:	2c03      	cmp	r4, #3
 8044df8:	fb05 f000 	mul.w	r0, r5, r0
 8044dfc:	bf1c      	itt	ne
 8044dfe:	69db      	ldrne	r3, [r3, #28]
 8044e00:	4358      	mulne	r0, r3
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 8044e02:	2800      	cmp	r0, #0
 8044e04:	f77f af75 	ble.w	8044cf2 <kad_op_reshape+0x16>
 8044e08:	4613      	mov	r3, r2
 8044e0a:	2200      	movs	r2, #0
 8044e0c:	edd3 7a00 	vldr	s15, [r3]
 8044e10:	ecb1 7a01 	vldmia	r1!, {s14}
 8044e14:	ee77 7a87 	vadd.f32	s15, s15, s14
 8044e18:	3201      	adds	r2, #1
 8044e1a:	4282      	cmp	r2, r0
 8044e1c:	ece3 7a01 	vstmia	r3!, {s15}
 8044e20:	dbf4      	blt.n	8044e0c <kad_op_reshape+0x130>
 8044e22:	e766      	b.n	8044cf2 <kad_op_reshape+0x16>
	dst->n_d = src->n_d;
 8044e24:	782a      	ldrb	r2, [r5, #0]
 8044e26:	7002      	strb	r2, [r0, #0]
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 8044e28:	2a00      	cmp	r2, #0
 8044e2a:	f43f af62 	beq.w	8044cf2 <kad_op_reshape+0x16>
 8044e2e:	0092      	lsls	r2, r2, #2
 8044e30:	f105 0110 	add.w	r1, r5, #16
 8044e34:	3010      	adds	r0, #16
 8044e36:	f007 f8fa 	bl	804c02e <memcpy>
 8044e3a:	e75a      	b.n	8044cf2 <kad_op_reshape+0x16>
				if (p->d[i] <= 0) ++n_missing;
 8044e3c:	2c00      	cmp	r4, #0
 8044e3e:	dc75      	bgt.n	8044f2c <kad_op_reshape+0x250>
 8044e40:	2800      	cmp	r0, #0
 8044e42:	dd78      	ble.n	8044f36 <kad_op_reshape+0x25a>
 8044e44:	2701      	movs	r7, #1
			int i, len = 1, n_missing = 0;
 8044e46:	4639      	mov	r1, r7
			for (i = 0; i < p->n_d; ++i)
 8044e48:	f1bc 0f02 	cmp.w	ip, #2
				else len *= p->d[i];
 8044e4c:	fb01 f000 	mul.w	r0, r1, r0
			for (i = 0; i < p->n_d; ++i)
 8044e50:	dc77      	bgt.n	8044f42 <kad_op_reshape+0x266>
			if (n_missing == 0 && len != kad_len(q)) return -1;
 8044e52:	2f00      	cmp	r7, #0
 8044e54:	d04e      	beq.n	8044ef4 <kad_op_reshape+0x218>
 8044e56:	7829      	ldrb	r1, [r5, #0]
 8044e58:	2900      	cmp	r1, #0
 8044e5a:	f000 8132 	beq.w	80450c2 <kad_op_reshape+0x3e6>
 8044e5e:	2901      	cmp	r1, #1
 8044e60:	692f      	ldr	r7, [r5, #16]
 8044e62:	f000 8122 	beq.w	80450aa <kad_op_reshape+0x3ce>
 8044e66:	f8d5 e014 	ldr.w	lr, [r5, #20]
 8044e6a:	2902      	cmp	r1, #2
 8044e6c:	fb0e f807 	mul.w	r8, lr, r7
 8044e70:	f000 80ff 	beq.w	8045072 <kad_op_reshape+0x396>
 8044e74:	69ac      	ldr	r4, [r5, #24]
 8044e76:	2903      	cmp	r1, #3
 8044e78:	fb04 f808 	mul.w	r8, r4, r8
 8044e7c:	f000 80f9 	beq.w	8045072 <kad_op_reshape+0x396>
 8044e80:	69ec      	ldr	r4, [r5, #28]
 8044e82:	fb04 f408 	mul.w	r4, r4, r8
				if (kad_len(q) % len != 0) return -1;
 8044e86:	fb94 f8f0 	sdiv	r8, r4, r0
 8044e8a:	fb00 4418 	mls	r4, r0, r8, r4
 8044e8e:	2c00      	cmp	r4, #0
 8044e90:	d19c      	bne.n	8044dcc <kad_op_reshape+0xf0>
					if (p->d[i] <= 0) p->d[i] = kad_len(q) / len;
 8044e92:	691c      	ldr	r4, [r3, #16]
 8044e94:	2c00      	cmp	r4, #0
 8044e96:	dd60      	ble.n	8044f5a <kad_op_reshape+0x27e>
				for (i = 0; i < p->n_d; ++i)
 8044e98:	2e00      	cmp	r6, #0
 8044e9a:	f43f af2a 	beq.w	8044cf2 <kad_op_reshape+0x16>
					if (p->d[i] <= 0) p->d[i] = kad_len(q) / len;
 8044e9e:	695c      	ldr	r4, [r3, #20]
 8044ea0:	2c00      	cmp	r4, #0
 8044ea2:	dd71      	ble.n	8044f88 <kad_op_reshape+0x2ac>
				for (i = 0; i < p->n_d; ++i)
 8044ea4:	f1bc 0f02 	cmp.w	ip, #2
 8044ea8:	f77f af23 	ble.w	8044cf2 <kad_op_reshape+0x16>
					if (p->d[i] <= 0) p->d[i] = kad_len(q) / len;
 8044eac:	699c      	ldr	r4, [r3, #24]
 8044eae:	2c00      	cmp	r4, #0
 8044eb0:	f340 810f 	ble.w	80450d2 <kad_op_reshape+0x3f6>
				for (i = 0; i < p->n_d; ++i)
 8044eb4:	f012 0ffc 	tst.w	r2, #252	@ 0xfc
 8044eb8:	f43f af1b 	beq.w	8044cf2 <kad_op_reshape+0x16>
					if (p->d[i] <= 0) p->d[i] = kad_len(q) / len;
 8044ebc:	69da      	ldr	r2, [r3, #28]
 8044ebe:	2a00      	cmp	r2, #0
 8044ec0:	f73f af17 	bgt.w	8044cf2 <kad_op_reshape+0x16>
 8044ec4:	2900      	cmp	r1, #0
 8044ec6:	f000 812b 	beq.w	8045120 <kad_op_reshape+0x444>
 8044eca:	2901      	cmp	r1, #1
 8044ecc:	692a      	ldr	r2, [r5, #16]
 8044ece:	d00c      	beq.n	8044eea <kad_op_reshape+0x20e>
 8044ed0:	696c      	ldr	r4, [r5, #20]
 8044ed2:	2902      	cmp	r1, #2
 8044ed4:	fb04 f202 	mul.w	r2, r4, r2
 8044ed8:	d007      	beq.n	8044eea <kad_op_reshape+0x20e>
 8044eda:	69ac      	ldr	r4, [r5, #24]
 8044edc:	2903      	cmp	r1, #3
 8044ede:	fb04 f202 	mul.w	r2, r4, r2
 8044ee2:	d002      	beq.n	8044eea <kad_op_reshape+0x20e>
 8044ee4:	69e9      	ldr	r1, [r5, #28]
 8044ee6:	fb01 f202 	mul.w	r2, r1, r2
 8044eea:	fb92 f2f0 	sdiv	r2, r2, r0
 8044eee:	61da      	str	r2, [r3, #28]
				for (i = 0; i < p->n_d; ++i)
 8044ef0:	e6ff      	b.n	8044cf2 <kad_op_reshape+0x16>
			int i, len = 1, n_missing = 0;
 8044ef2:	2001      	movs	r0, #1
 8044ef4:	782a      	ldrb	r2, [r5, #0]
 8044ef6:	2a00      	cmp	r2, #0
 8044ef8:	f000 80b9 	beq.w	804506e <kad_op_reshape+0x392>
 8044efc:	2a01      	cmp	r2, #1
 8044efe:	692b      	ldr	r3, [r5, #16]
 8044f00:	d00c      	beq.n	8044f1c <kad_op_reshape+0x240>
 8044f02:	6969      	ldr	r1, [r5, #20]
 8044f04:	2a02      	cmp	r2, #2
 8044f06:	fb01 f303 	mul.w	r3, r1, r3
 8044f0a:	d007      	beq.n	8044f1c <kad_op_reshape+0x240>
 8044f0c:	69a9      	ldr	r1, [r5, #24]
 8044f0e:	2a03      	cmp	r2, #3
 8044f10:	fb01 f303 	mul.w	r3, r1, r3
 8044f14:	d002      	beq.n	8044f1c <kad_op_reshape+0x240>
 8044f16:	69ea      	ldr	r2, [r5, #28]
 8044f18:	fb02 f303 	mul.w	r3, r2, r3
			if (n_missing == 0 && len != kad_len(q)) return -1;
 8044f1c:	1ac0      	subs	r0, r0, r3
 8044f1e:	bf18      	it	ne
 8044f20:	f04f 30ff 	movne.w	r0, #4294967295
}
 8044f24:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8044f28:	2204      	movs	r2, #4
 8044f2a:	e6fb      	b.n	8044d24 <kad_op_reshape+0x48>
				if (p->d[i] <= 0) ++n_missing;
 8044f2c:	2800      	cmp	r0, #0
 8044f2e:	dd0b      	ble.n	8044f48 <kad_op_reshape+0x26c>
				else len *= p->d[i];
 8044f30:	4621      	mov	r1, r4
			int i, len = 1, n_missing = 0;
 8044f32:	2700      	movs	r7, #0
 8044f34:	e788      	b.n	8044e48 <kad_op_reshape+0x16c>
			for (i = 0; i < p->n_d; ++i)
 8044f36:	f1bc 0f02 	cmp.w	ip, #2
 8044f3a:	f340 80cd 	ble.w	80450d8 <kad_op_reshape+0x3fc>
				if (p->d[i] <= 0) ++n_missing;
 8044f3e:	2702      	movs	r7, #2
			int i, len = 1, n_missing = 0;
 8044f40:	2001      	movs	r0, #1
 8044f42:	f002 0efc 	and.w	lr, r2, #252	@ 0xfc
 8044f46:	e717      	b.n	8044d78 <kad_op_reshape+0x9c>
			for (i = 0; i < p->n_d; ++i)
 8044f48:	f1bc 0f02 	cmp.w	ip, #2
 8044f4c:	f340 80df 	ble.w	804510e <kad_op_reshape+0x432>
 8044f50:	f002 0efc 	and.w	lr, r2, #252	@ 0xfc
				else len *= p->d[i];
 8044f54:	4620      	mov	r0, r4
				if (p->d[i] <= 0) ++n_missing;
 8044f56:	2701      	movs	r7, #1
 8044f58:	e70e      	b.n	8044d78 <kad_op_reshape+0x9c>
 8044f5a:	2902      	cmp	r1, #2
 8044f5c:	fb0e fe07 	mul.w	lr, lr, r7
 8044f60:	d007      	beq.n	8044f72 <kad_op_reshape+0x296>
 8044f62:	69ac      	ldr	r4, [r5, #24]
 8044f64:	2903      	cmp	r1, #3
 8044f66:	fb04 fe0e 	mul.w	lr, r4, lr
 8044f6a:	bf1c      	itt	ne
 8044f6c:	69ec      	ldrne	r4, [r5, #28]
 8044f6e:	fb04 fe0e 	mulne.w	lr, r4, lr
 8044f72:	fb9e fef0 	sdiv	lr, lr, r0
					if (p->d[i] <= 0) p->d[i] = kad_len(q) / len;
 8044f76:	f8c3 e010 	str.w	lr, [r3, #16]
				for (i = 0; i < p->n_d; ++i)
 8044f7a:	2e00      	cmp	r6, #0
 8044f7c:	f43f aeb9 	beq.w	8044cf2 <kad_op_reshape+0x16>
					if (p->d[i] <= 0) p->d[i] = kad_len(q) / len;
 8044f80:	695c      	ldr	r4, [r3, #20]
 8044f82:	2c00      	cmp	r4, #0
 8044f84:	dc8e      	bgt.n	8044ea4 <kad_op_reshape+0x1c8>
 8044f86:	692f      	ldr	r7, [r5, #16]
 8044f88:	2901      	cmp	r1, #1
 8044f8a:	463e      	mov	r6, r7
 8044f8c:	d00b      	beq.n	8044fa6 <kad_op_reshape+0x2ca>
 8044f8e:	696e      	ldr	r6, [r5, #20]
 8044f90:	2902      	cmp	r1, #2
 8044f92:	fb07 f606 	mul.w	r6, r7, r6
 8044f96:	d006      	beq.n	8044fa6 <kad_op_reshape+0x2ca>
 8044f98:	69ac      	ldr	r4, [r5, #24]
 8044f9a:	2903      	cmp	r1, #3
 8044f9c:	fb04 f606 	mul.w	r6, r4, r6
 8044fa0:	bf1c      	itt	ne
 8044fa2:	69ec      	ldrne	r4, [r5, #28]
 8044fa4:	4366      	mulne	r6, r4
 8044fa6:	fb96 f6f0 	sdiv	r6, r6, r0
				for (i = 0; i < p->n_d; ++i)
 8044faa:	f1bc 0f02 	cmp.w	ip, #2
					if (p->d[i] <= 0) p->d[i] = kad_len(q) / len;
 8044fae:	615e      	str	r6, [r3, #20]
				for (i = 0; i < p->n_d; ++i)
 8044fb0:	f77f ae9f 	ble.w	8044cf2 <kad_op_reshape+0x16>
					if (p->d[i] <= 0) p->d[i] = kad_len(q) / len;
 8044fb4:	699c      	ldr	r4, [r3, #24]
 8044fb6:	2c00      	cmp	r4, #0
 8044fb8:	f73f af7c 	bgt.w	8044eb4 <kad_op_reshape+0x1d8>
 8044fbc:	2901      	cmp	r1, #1
 8044fbe:	d00c      	beq.n	8044fda <kad_op_reshape+0x2fe>
 8044fc0:	696c      	ldr	r4, [r5, #20]
 8044fc2:	2902      	cmp	r1, #2
 8044fc4:	fb04 f707 	mul.w	r7, r4, r7
 8044fc8:	d007      	beq.n	8044fda <kad_op_reshape+0x2fe>
 8044fca:	69ac      	ldr	r4, [r5, #24]
 8044fcc:	2903      	cmp	r1, #3
 8044fce:	fb04 f707 	mul.w	r7, r4, r7
 8044fd2:	d002      	beq.n	8044fda <kad_op_reshape+0x2fe>
 8044fd4:	69ec      	ldr	r4, [r5, #28]
 8044fd6:	fb04 f707 	mul.w	r7, r4, r7
 8044fda:	fb97 f7f0 	sdiv	r7, r7, r0
 8044fde:	619f      	str	r7, [r3, #24]
 8044fe0:	e768      	b.n	8044eb4 <kad_op_reshape+0x1d8>
				if (p->d[i] <= 0) ++n_missing;
 8044fe2:	1c79      	adds	r1, r7, #1
			for (i = 0; i < p->n_d; ++i)
 8044fe4:	f1be 0f00 	cmp.w	lr, #0
 8044fe8:	f43f aed9 	beq.w	8044d9e <kad_op_reshape+0xc2>
				if (p->d[i] <= 0) ++n_missing;
 8044fec:	f8d3 e01c 	ldr.w	lr, [r3, #28]
 8044ff0:	f1be 0f00 	cmp.w	lr, #0
 8044ff4:	dd45      	ble.n	8045082 <kad_op_reshape+0x3a6>
				else len *= p->d[i];
 8044ff6:	fb0e f000 	mul.w	r0, lr, r0
			if (n_missing == 0 && len != kad_len(q)) return -1;
 8044ffa:	e6d0      	b.n	8044d9e <kad_op_reshape+0xc2>
					if (p->d[i] <= 0 && i < q->n_d) {
 8044ffc:	782c      	ldrb	r4, [r5, #0]
 8044ffe:	2c00      	cmp	r4, #0
 8045000:	f43f aed2 	beq.w	8044da8 <kad_op_reshape+0xcc>
						p->d[i] = q->d[i], len *= p->d[i];
 8045004:	692c      	ldr	r4, [r5, #16]
						if (--n_missing == 1) break;
 8045006:	3901      	subs	r1, #1
 8045008:	2901      	cmp	r1, #1
						p->d[i] = q->d[i], len *= p->d[i];
 804500a:	fb04 f000 	mul.w	r0, r4, r0
 804500e:	611c      	str	r4, [r3, #16]
						if (--n_missing == 1) break;
 8045010:	f47f aeca 	bne.w	8044da8 <kad_op_reshape+0xcc>
 8045014:	e71f      	b.n	8044e56 <kad_op_reshape+0x17a>
					if (p->d[i] <= 0 && i < q->n_d) {
 8045016:	782c      	ldrb	r4, [r5, #0]
 8045018:	2c01      	cmp	r4, #1
 804501a:	f67f aec9 	bls.w	8044db0 <kad_op_reshape+0xd4>
						p->d[i] = q->d[i], len *= p->d[i];
 804501e:	696c      	ldr	r4, [r5, #20]
						if (--n_missing == 1) break;
 8045020:	3901      	subs	r1, #1
 8045022:	2901      	cmp	r1, #1
						p->d[i] = q->d[i], len *= p->d[i];
 8045024:	fb04 f000 	mul.w	r0, r4, r0
 8045028:	615c      	str	r4, [r3, #20]
						if (--n_missing == 1) break;
 804502a:	f47f aec1 	bne.w	8044db0 <kad_op_reshape+0xd4>
 804502e:	e712      	b.n	8044e56 <kad_op_reshape+0x17a>
				if (p->d[i] <= 0) ++n_missing;
 8045030:	2c00      	cmp	r4, #0
 8045032:	dd28      	ble.n	8045086 <kad_op_reshape+0x3aa>
				else len *= p->d[i];
 8045034:	4620      	mov	r0, r4
 8045036:	e75d      	b.n	8044ef4 <kad_op_reshape+0x218>
					if (p->d[i] <= 0 && i < q->n_d) {
 8045038:	782c      	ldrb	r4, [r5, #0]
 804503a:	2c02      	cmp	r4, #2
 804503c:	f67f aebf 	bls.w	8044dbe <kad_op_reshape+0xe2>
						p->d[i] = q->d[i], len *= p->d[i];
 8045040:	69ac      	ldr	r4, [r5, #24]
						if (--n_missing == 1) break;
 8045042:	3901      	subs	r1, #1
 8045044:	2901      	cmp	r1, #1
						p->d[i] = q->d[i], len *= p->d[i];
 8045046:	fb04 f000 	mul.w	r0, r4, r0
 804504a:	619c      	str	r4, [r3, #24]
						if (--n_missing == 1) break;
 804504c:	f47f aeb7 	bne.w	8044dbe <kad_op_reshape+0xe2>
 8045050:	e701      	b.n	8044e56 <kad_op_reshape+0x17a>
					if (p->d[i] <= 0 && i < q->n_d) {
 8045052:	782c      	ldrb	r4, [r5, #0]
 8045054:	2c03      	cmp	r4, #3
 8045056:	f67f aeb9 	bls.w	8044dcc <kad_op_reshape+0xf0>
						p->d[i] = q->d[i], len *= p->d[i];
 804505a:	69ec      	ldr	r4, [r5, #28]
						if (--n_missing == 1) break;
 804505c:	2902      	cmp	r1, #2
						p->d[i] = q->d[i], len *= p->d[i];
 804505e:	bf08      	it	eq
 8045060:	4360      	muleq	r0, r4
 8045062:	61dc      	str	r4, [r3, #28]
						if (--n_missing == 1) break;
 8045064:	f47f aeb2 	bne.w	8044dcc <kad_op_reshape+0xf0>
 8045068:	e6f5      	b.n	8044e56 <kad_op_reshape+0x17a>
				if (p->d[i] <= 0) ++n_missing;
 804506a:	1c79      	adds	r1, r7, #1
			if (n_missing == 0 && len != kad_len(q)) return -1;
 804506c:	e697      	b.n	8044d9e <kad_op_reshape+0xc2>
	int n = 1, i;
 804506e:	2301      	movs	r3, #1
 8045070:	e754      	b.n	8044f1c <kad_op_reshape+0x240>
				if (kad_len(q) % len != 0) return -1;
 8045072:	fb98 f4f0 	sdiv	r4, r8, r0
 8045076:	fb00 8414 	mls	r4, r0, r4, r8
 804507a:	2c00      	cmp	r4, #0
 804507c:	f43f af09 	beq.w	8044e92 <kad_op_reshape+0x1b6>
 8045080:	e6a4      	b.n	8044dcc <kad_op_reshape+0xf0>
				if (p->d[i] <= 0) ++n_missing;
 8045082:	1cb9      	adds	r1, r7, #2
			if (n_missing > 1) { /* attempt to infer missing dimensions except the last one */
 8045084:	e68d      	b.n	8044da2 <kad_op_reshape+0xc6>
	for (i = 0; i < p->n_d; ++i) n *= p->d[i];
 8045086:	7829      	ldrb	r1, [r5, #0]
 8045088:	2001      	movs	r0, #1
 804508a:	2900      	cmp	r1, #0
 804508c:	f47f aee7 	bne.w	8044e5e <kad_op_reshape+0x182>
					if (p->d[i] <= 0) p->d[i] = kad_len(q) / len;
 8045090:	6919      	ldr	r1, [r3, #16]
 8045092:	2900      	cmp	r1, #0
 8045094:	dd23      	ble.n	80450de <kad_op_reshape+0x402>
				for (i = 0; i < p->n_d; ++i)
 8045096:	2e00      	cmp	r6, #0
 8045098:	f43f ae2b 	beq.w	8044cf2 <kad_op_reshape+0x16>
					if (p->d[i] <= 0) p->d[i] = kad_len(q) / len;
 804509c:	6959      	ldr	r1, [r3, #20]
 804509e:	2900      	cmp	r1, #0
 80450a0:	dd37      	ble.n	8045112 <kad_op_reshape+0x436>
 80450a2:	2100      	movs	r1, #0
 80450a4:	e6fe      	b.n	8044ea4 <kad_op_reshape+0x1c8>
	int n = 1, i;
 80450a6:	2001      	movs	r0, #1
 80450a8:	e6ae      	b.n	8044e08 <kad_op_reshape+0x12c>
				if (kad_len(q) % len != 0) return -1;
 80450aa:	fb97 fef0 	sdiv	lr, r7, r0
 80450ae:	fb00 741e 	mls	r4, r0, lr, r7
 80450b2:	2c00      	cmp	r4, #0
 80450b4:	f47f ae8a 	bne.w	8044dcc <kad_op_reshape+0xf0>
					if (p->d[i] <= 0) p->d[i] = kad_len(q) / len;
 80450b8:	691c      	ldr	r4, [r3, #16]
 80450ba:	2c00      	cmp	r4, #0
 80450bc:	f73f aeec 	bgt.w	8044e98 <kad_op_reshape+0x1bc>
 80450c0:	e759      	b.n	8044f76 <kad_op_reshape+0x29a>
				if (kad_len(q) % len != 0) return -1;
 80450c2:	2101      	movs	r1, #1
 80450c4:	fb91 f1f0 	sdiv	r1, r1, r0
 80450c8:	fb00 f101 	mul.w	r1, r0, r1
 80450cc:	2901      	cmp	r1, #1
 80450ce:	d0df      	beq.n	8045090 <kad_op_reshape+0x3b4>
 80450d0:	e67c      	b.n	8044dcc <kad_op_reshape+0xf0>
	for (i = 0; i < p->n_d; ++i) n *= p->d[i];
 80450d2:	b1d1      	cbz	r1, 804510a <kad_op_reshape+0x42e>
 80450d4:	692f      	ldr	r7, [r5, #16]
 80450d6:	e771      	b.n	8044fbc <kad_op_reshape+0x2e0>
				if (p->d[i] <= 0) ++n_missing;
 80450d8:	2102      	movs	r1, #2
			int i, len = 1, n_missing = 0;
 80450da:	2001      	movs	r0, #1
 80450dc:	e661      	b.n	8044da2 <kad_op_reshape+0xc6>
					if (p->d[i] <= 0) p->d[i] = kad_len(q) / len;
 80450de:	1c41      	adds	r1, r0, #1
 80450e0:	2902      	cmp	r1, #2
 80450e2:	bf94      	ite	ls
 80450e4:	4604      	movls	r4, r0
 80450e6:	2400      	movhi	r4, #0
 80450e8:	611c      	str	r4, [r3, #16]
				for (i = 0; i < p->n_d; ++i)
 80450ea:	2e00      	cmp	r6, #0
 80450ec:	f43f ae01 	beq.w	8044cf2 <kad_op_reshape+0x16>
					if (p->d[i] <= 0) p->d[i] = kad_len(q) / len;
 80450f0:	695c      	ldr	r4, [r3, #20]
 80450f2:	2c00      	cmp	r4, #0
 80450f4:	dd0e      	ble.n	8045114 <kad_op_reshape+0x438>
				for (i = 0; i < p->n_d; ++i)
 80450f6:	f1bc 0f02 	cmp.w	ip, #2
 80450fa:	f77f adfa 	ble.w	8044cf2 <kad_op_reshape+0x16>
					if (p->d[i] <= 0) p->d[i] = kad_len(q) / len;
 80450fe:	6999      	ldr	r1, [r3, #24]
 8045100:	2900      	cmp	r1, #0
	int n = 1, i;
 8045102:	f04f 0100 	mov.w	r1, #0
 8045106:	f73f aed5 	bgt.w	8044eb4 <kad_op_reshape+0x1d8>
 804510a:	2701      	movs	r7, #1
 804510c:	e765      	b.n	8044fda <kad_op_reshape+0x2fe>
				else len *= p->d[i];
 804510e:	4620      	mov	r0, r4
 8045110:	e6a1      	b.n	8044e56 <kad_op_reshape+0x17a>
 8045112:	1c41      	adds	r1, r0, #1
					if (p->d[i] <= 0) p->d[i] = kad_len(q) / len;
 8045114:	2902      	cmp	r1, #2
 8045116:	bf94      	ite	ls
 8045118:	4601      	movls	r1, r0
 804511a:	2100      	movhi	r1, #0
 804511c:	6159      	str	r1, [r3, #20]
 804511e:	e7ea      	b.n	80450f6 <kad_op_reshape+0x41a>
 8045120:	2201      	movs	r2, #1
 8045122:	e6e2      	b.n	8044eea <kad_op_reshape+0x20e>

08045124 <kad_op_reverse>:
{
 8045124:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	kad_node_t *q = p->child[0];
 8045128:	6b83      	ldr	r3, [r0, #56]	@ 0x38
	axis = p->ptr? *(int32_t*)p->ptr : 0;
 804512a:	6b02      	ldr	r2, [r0, #48]	@ 0x30
	kad_node_t *q = p->child[0];
 804512c:	f8d3 8000 	ldr.w	r8, [r3]
{
 8045130:	4683      	mov	fp, r0
	assert(axis >= 0 && axis < q->n_d);
 8045132:	f898 5000 	ldrb.w	r5, [r8]
{
 8045136:	b085      	sub	sp, #20
	axis = p->ptr? *(int32_t*)p->ptr : 0;
 8045138:	2a00      	cmp	r2, #0
 804513a:	d041      	beq.n	80451c0 <kad_op_reverse+0x9c>
 804513c:	6812      	ldr	r2, [r2, #0]
	if (axis < 0) axis += q->n_d;
 804513e:	2a00      	cmp	r2, #0
 8045140:	db35      	blt.n	80451ae <kad_op_reverse+0x8a>
	assert(axis >= 0 && axis < q->n_d);
 8045142:	42aa      	cmp	r2, r5
 8045144:	da35      	bge.n	80451b2 <kad_op_reverse+0x8e>
	for (i = axis + 1, d1 = 1; i < q->n_d; ++i) d1 *= q->d[i];
 8045146:	1c50      	adds	r0, r2, #1
	for (i = 0, d0 = 1; i < axis; ++i) d0 *= q->d[i];
 8045148:	2a00      	cmp	r2, #0
 804514a:	d03b      	beq.n	80451c4 <kad_op_reverse+0xa0>
 804514c:	2a01      	cmp	r2, #1
 804514e:	f8d8 3010 	ldr.w	r3, [r8, #16]
 8045152:	d00e      	beq.n	8045172 <kad_op_reverse+0x4e>
 8045154:	f8d8 4014 	ldr.w	r4, [r8, #20]
 8045158:	2a02      	cmp	r2, #2
 804515a:	fb04 f303 	mul.w	r3, r4, r3
 804515e:	d008      	beq.n	8045172 <kad_op_reverse+0x4e>
 8045160:	f8d8 4018 	ldr.w	r4, [r8, #24]
 8045164:	2a03      	cmp	r2, #3
 8045166:	fb04 f303 	mul.w	r3, r4, r3
 804516a:	bf1c      	itt	ne
 804516c:	f8d8 401c 	ldrne.w	r4, [r8, #28]
 8045170:	4363      	mulne	r3, r4
	n = q->d[axis];
 8045172:	3204      	adds	r2, #4
	for (i = axis + 1, d1 = 1; i < q->n_d; ++i) d1 *= q->d[i];
 8045174:	42a8      	cmp	r0, r5
	n = q->d[axis];
 8045176:	f858 a022 	ldr.w	sl, [r8, r2, lsl #2]
	for (i = axis + 1, d1 = 1; i < q->n_d; ++i) d1 *= q->d[i];
 804517a:	da2a      	bge.n	80451d2 <kad_op_reverse+0xae>
 804517c:	1c42      	adds	r2, r0, #1
 804517e:	eb08 0680 	add.w	r6, r8, r0, lsl #2
 8045182:	4295      	cmp	r5, r2
 8045184:	6934      	ldr	r4, [r6, #16]
 8045186:	dd08      	ble.n	804519a <kad_op_reverse+0x76>
 8045188:	6972      	ldr	r2, [r6, #20]
 804518a:	3002      	adds	r0, #2
 804518c:	42a8      	cmp	r0, r5
 804518e:	fb02 f404 	mul.w	r4, r2, r4
 8045192:	da02      	bge.n	804519a <kad_op_reverse+0x76>
 8045194:	69b2      	ldr	r2, [r6, #24]
 8045196:	fb02 f404 	mul.w	r4, r2, r4
	if (action == KAD_SYNC_DIM) {
 804519a:	2904      	cmp	r1, #4
 804519c:	d01d      	beq.n	80451da <kad_op_reverse+0xb6>
	} else if (action == KAD_FORWARD) {
 804519e:	2902      	cmp	r1, #2
 80451a0:	d027      	beq.n	80451f2 <kad_op_reverse+0xce>
	} else if (action == KAD_BACKWARD && kad_is_back(q)) {
 80451a2:	2903      	cmp	r1, #3
 80451a4:	d05c      	beq.n	8045260 <kad_op_reverse+0x13c>
}
 80451a6:	2000      	movs	r0, #0
 80451a8:	b005      	add	sp, #20
 80451aa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	assert(axis >= 0 && axis < q->n_d);
 80451ae:	1952      	adds	r2, r2, r5
 80451b0:	d5c9      	bpl.n	8045146 <kad_op_reverse+0x22>
 80451b2:	f240 51bc 	movw	r1, #1468	@ 0x5bc
 80451b6:	4b4b      	ldr	r3, [pc, #300]	@ (80452e4 <kad_op_reverse+0x1c0>)
 80451b8:	4a4b      	ldr	r2, [pc, #300]	@ (80452e8 <kad_op_reverse+0x1c4>)
 80451ba:	484c      	ldr	r0, [pc, #304]	@ (80452ec <kad_op_reverse+0x1c8>)
 80451bc:	f006 fb12 	bl	804b7e4 <__assert_func>
 80451c0:	2d00      	cmp	r5, #0
 80451c2:	d0f6      	beq.n	80451b2 <kad_op_reverse+0x8e>
	for (i = 0, d0 = 1; i < axis; ++i) d0 *= q->d[i];
 80451c4:	2001      	movs	r0, #1
	n = q->d[axis];
 80451c6:	3204      	adds	r2, #4
	for (i = axis + 1, d1 = 1; i < q->n_d; ++i) d1 *= q->d[i];
 80451c8:	42a8      	cmp	r0, r5
	for (i = 0, d0 = 1; i < axis; ++i) d0 *= q->d[i];
 80451ca:	4603      	mov	r3, r0
	n = q->d[axis];
 80451cc:	f858 a022 	ldr.w	sl, [r8, r2, lsl #2]
	for (i = axis + 1, d1 = 1; i < q->n_d; ++i) d1 *= q->d[i];
 80451d0:	dbd4      	blt.n	804517c <kad_op_reverse+0x58>
	if (action == KAD_SYNC_DIM) {
 80451d2:	2904      	cmp	r1, #4
	for (i = axis + 1, d1 = 1; i < q->n_d; ++i) d1 *= q->d[i];
 80451d4:	f04f 0401 	mov.w	r4, #1
	if (action == KAD_SYNC_DIM) {
 80451d8:	d1e1      	bne.n	804519e <kad_op_reverse+0x7a>
	dst->n_d = src->n_d;
 80451da:	4658      	mov	r0, fp
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 80451dc:	00aa      	lsls	r2, r5, #2
 80451de:	f108 0110 	add.w	r1, r8, #16
	dst->n_d = src->n_d;
 80451e2:	f800 5b10 	strb.w	r5, [r0], #16
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 80451e6:	f006 ff22 	bl	804c02e <memcpy>
}
 80451ea:	2000      	movs	r0, #0
 80451ec:	b005      	add	sp, #20
 80451ee:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		for (i = 0; i < d0; ++i)
 80451f2:	2b00      	cmp	r3, #0
 80451f4:	ddd7      	ble.n	80451a6 <kad_op_reverse+0x82>
 80451f6:	f1ba 0f00 	cmp.w	sl, #0
				memcpy(&p->x[(i * n + n - 1 - j) * d1], &q->x[(i * n + j) * d1], d1 * sizeof(float));
 80451fa:	ea4f 0784 	mov.w	r7, r4, lsl #2
 80451fe:	ddd2      	ble.n	80451a6 <kad_op_reverse+0x82>
 8045200:	2200      	movs	r2, #0
 8045202:	46b9      	mov	r9, r7
 8045204:	9303      	str	r3, [sp, #12]
 8045206:	4617      	mov	r7, r2
 8045208:	4613      	mov	r3, r2
 804520a:	fb04 f10a 	mul.w	r1, r4, sl
 804520e:	1b0c      	subs	r4, r1, r4
 8045210:	0089      	lsls	r1, r1, #2
 8045212:	9101      	str	r1, [sp, #4]
 8045214:	00a1      	lsls	r1, r4, #2
 8045216:	9102      	str	r1, [sp, #8]
			for (j = 0; j < n; ++j)
 8045218:	9300      	str	r3, [sp, #0]
 804521a:	465b      	mov	r3, fp
 804521c:	9a02      	ldr	r2, [sp, #8]
	for (i = axis + 1, d1 = 1; i < q->n_d; ++i) d1 *= q->d[i];
 804521e:	463e      	mov	r6, r7
 8045220:	46bb      	mov	fp, r7
 8045222:	19d4      	adds	r4, r2, r7
			for (j = 0; j < n; ++j)
 8045224:	2500      	movs	r5, #0
 8045226:	461f      	mov	r7, r3
				memcpy(&p->x[(i * n + n - 1 - j) * d1], &q->x[(i * n + j) * d1], d1 * sizeof(float));
 8045228:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 804522a:	f8d8 1028 	ldr.w	r1, [r8, #40]	@ 0x28
 804522e:	4420      	add	r0, r4
 8045230:	4431      	add	r1, r6
 8045232:	464a      	mov	r2, r9
			for (j = 0; j < n; ++j)
 8045234:	3501      	adds	r5, #1
				memcpy(&p->x[(i * n + n - 1 - j) * d1], &q->x[(i * n + j) * d1], d1 * sizeof(float));
 8045236:	f006 fefa 	bl	804c02e <memcpy>
			for (j = 0; j < n; ++j)
 804523a:	45aa      	cmp	sl, r5
 804523c:	eba4 0409 	sub.w	r4, r4, r9
 8045240:	444e      	add	r6, r9
 8045242:	d1f1      	bne.n	8045228 <kad_op_reverse+0x104>
		for (i = 0; i < d0; ++i)
 8045244:	463a      	mov	r2, r7
 8045246:	465f      	mov	r7, fp
 8045248:	4693      	mov	fp, r2
 804524a:	9a01      	ldr	r2, [sp, #4]
 804524c:	9b00      	ldr	r3, [sp, #0]
 804524e:	4417      	add	r7, r2
 8045250:	9a03      	ldr	r2, [sp, #12]
 8045252:	3301      	adds	r3, #1
 8045254:	4293      	cmp	r3, r2
 8045256:	d1df      	bne.n	8045218 <kad_op_reverse+0xf4>
}
 8045258:	2000      	movs	r0, #0
 804525a:	b005      	add	sp, #20
 804525c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	} else if (action == KAD_BACKWARD && kad_is_back(q)) {
 8045260:	f898 2001 	ldrb.w	r2, [r8, #1]
 8045264:	07d2      	lsls	r2, r2, #31
 8045266:	d59e      	bpl.n	80451a6 <kad_op_reverse+0x82>
		for (i = 0; i < d0; ++i)
 8045268:	2b00      	cmp	r3, #0
 804526a:	dd9c      	ble.n	80451a6 <kad_op_reverse+0x82>
 804526c:	f1ba 0f00 	cmp.w	sl, #0
 8045270:	dd99      	ble.n	80451a6 <kad_op_reverse+0x82>
 8045272:	2c00      	cmp	r4, #0
 8045274:	dd97      	ble.n	80451a6 <kad_op_reverse+0x82>
 8045276:	f8d8 702c 	ldr.w	r7, [r8, #44]	@ 0x2c
				kad_saxpy(d1, 1.0f, &p->g[(i * n + n - 1 - j) * d1], &q->g[(i * n + j) * d1]);
 804527a:	f04f 0800 	mov.w	r8, #0
		for (i = 0; i < d0; ++i)
 804527e:	46c1      	mov	r9, r8
 8045280:	fb04 f20a 	mul.w	r2, r4, sl
 8045284:	00a6      	lsls	r6, r4, #2
 8045286:	eb07 0c84 	add.w	ip, r7, r4, lsl #2
 804528a:	1b14      	subs	r4, r2, r4
				kad_saxpy(d1, 1.0f, &p->g[(i * n + n - 1 - j) * d1], &q->g[(i * n + j) * d1]);
 804528c:	f8db e02c 	ldr.w	lr, [fp, #44]	@ 0x2c
 8045290:	ea4f 0b82 	mov.w	fp, r2, lsl #2
 8045294:	00a2      	lsls	r2, r4, #2
 8045296:	9200      	str	r2, [sp, #0]
 8045298:	f8cd b004 	str.w	fp, [sp, #4]
		for (i = 0; i < d0; ++i)
 804529c:	46c3      	mov	fp, r8
			for (j = 0; j < n; ++j)
 804529e:	2500      	movs	r5, #0
 80452a0:	9a00      	ldr	r2, [sp, #0]
 80452a2:	eb0c 0008 	add.w	r0, ip, r8
 80452a6:	eb08 0402 	add.w	r4, r8, r2
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 80452aa:	eb07 020b 	add.w	r2, r7, fp
 80452ae:	eb0e 0104 	add.w	r1, lr, r4
 80452b2:	edd2 7a00 	vldr	s15, [r2]
 80452b6:	ecb1 7a01 	vldmia	r1!, {s14}
 80452ba:	ee77 7a87 	vadd.f32	s15, s15, s14
 80452be:	ece2 7a01 	vstmia	r2!, {s15}
 80452c2:	4290      	cmp	r0, r2
 80452c4:	d1f5      	bne.n	80452b2 <kad_op_reverse+0x18e>
			for (j = 0; j < n; ++j)
 80452c6:	3501      	adds	r5, #1
 80452c8:	45aa      	cmp	sl, r5
 80452ca:	44b3      	add	fp, r6
 80452cc:	eba4 0406 	sub.w	r4, r4, r6
 80452d0:	4430      	add	r0, r6
 80452d2:	d1ea      	bne.n	80452aa <kad_op_reverse+0x186>
		for (i = 0; i < d0; ++i)
 80452d4:	9a01      	ldr	r2, [sp, #4]
 80452d6:	f109 0901 	add.w	r9, r9, #1
 80452da:	4599      	cmp	r9, r3
 80452dc:	4490      	add	r8, r2
 80452de:	d1dd      	bne.n	804529c <kad_op_reverse+0x178>
 80452e0:	e761      	b.n	80451a6 <kad_op_reverse+0x82>
 80452e2:	bf00      	nop
 80452e4:	0804e408 	.word	0x0804e408
 80452e8:	0804e53c 	.word	0x0804e53c
 80452ec:	0804e3dc 	.word	0x0804e3dc

080452f0 <kad_op_avg>:
{
 80452f0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	assert(p->n_child > 0);
 80452f4:	6846      	ldr	r6, [r0, #4]
{
 80452f6:	ed2d 8b02 	vpush	{d8}
	assert(p->n_child > 0);
 80452fa:	2e00      	cmp	r6, #0
 80452fc:	f340 80c4 	ble.w	8045488 <kad_op_avg+0x198>
	q = p->child[0];
 8045300:	6b82      	ldr	r2, [r0, #56]	@ 0x38
 8045302:	4605      	mov	r5, r0
 8045304:	6817      	ldr	r7, [r2, #0]
	for (i = 0; i < p->n_d; ++i) n *= p->d[i];
 8045306:	f897 8000 	ldrb.w	r8, [r7]
 804530a:	f1b8 0f00 	cmp.w	r8, #0
 804530e:	d06c      	beq.n	80453ea <kad_op_avg+0xfa>
 8045310:	f1b8 0f01 	cmp.w	r8, #1
 8045314:	693c      	ldr	r4, [r7, #16]
 8045316:	d00e      	beq.n	8045336 <kad_op_avg+0x46>
 8045318:	697b      	ldr	r3, [r7, #20]
 804531a:	f1b8 0f02 	cmp.w	r8, #2
 804531e:	fb03 f404 	mul.w	r4, r3, r4
 8045322:	d008      	beq.n	8045336 <kad_op_avg+0x46>
 8045324:	69bb      	ldr	r3, [r7, #24]
 8045326:	f1b8 0f03 	cmp.w	r8, #3
 804532a:	fb03 f404 	mul.w	r4, r3, r4
 804532e:	d002      	beq.n	8045336 <kad_op_avg+0x46>
 8045330:	69fb      	ldr	r3, [r7, #28]
 8045332:	fb03 f404 	mul.w	r4, r3, r4
	if (action == KAD_SYNC_DIM) {
 8045336:	2904      	cmp	r1, #4
 8045338:	d010      	beq.n	804535c <kad_op_avg+0x6c>
	tmp = 1.0f / p->n_child;
 804533a:	ee07 6a90 	vmov	s15, r6
 804533e:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 8045342:	eef8 7ae7 	vcvt.f32.s32	s15, s15
	} else if (action == KAD_FORWARD) {
 8045346:	2902      	cmp	r1, #2
	tmp = 1.0f / p->n_child;
 8045348:	ee87 8a27 	vdiv.f32	s16, s14, s15
	} else if (action == KAD_FORWARD) {
 804534c:	d05f      	beq.n	804540e <kad_op_avg+0x11e>
	} else if (action == KAD_BACKWARD) {
 804534e:	2903      	cmp	r1, #3
 8045350:	d02f      	beq.n	80453b2 <kad_op_avg+0xc2>
}
 8045352:	ecbd 8b02 	vpop	{d8}
	return 0;
 8045356:	2000      	movs	r0, #0
}
 8045358:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		for (i = 1; i < p->n_child; ++i)
 804535c:	2e01      	cmp	r6, #1
 804535e:	f000 8090 	beq.w	8045482 <kad_op_avg+0x192>
 8045362:	4694      	mov	ip, r2
 8045364:	f04f 0e01 	mov.w	lr, #1
 8045368:	e015      	b.n	8045396 <kad_op_avg+0xa6>
 804536a:	2801      	cmp	r0, #1
 804536c:	6913      	ldr	r3, [r2, #16]
 804536e:	d00c      	beq.n	804538a <kad_op_avg+0x9a>
 8045370:	6951      	ldr	r1, [r2, #20]
 8045372:	2802      	cmp	r0, #2
 8045374:	fb01 f303 	mul.w	r3, r1, r3
 8045378:	d007      	beq.n	804538a <kad_op_avg+0x9a>
 804537a:	6991      	ldr	r1, [r2, #24]
 804537c:	2803      	cmp	r0, #3
 804537e:	fb01 f303 	mul.w	r3, r1, r3
 8045382:	d002      	beq.n	804538a <kad_op_avg+0x9a>
 8045384:	69d2      	ldr	r2, [r2, #28]
 8045386:	fb02 f303 	mul.w	r3, r2, r3
			if (kad_len(p->child[i]) != n) return -1;
 804538a:	429c      	cmp	r4, r3
 804538c:	d10b      	bne.n	80453a6 <kad_op_avg+0xb6>
		for (i = 1; i < p->n_child; ++i)
 804538e:	f10e 0e01 	add.w	lr, lr, #1
 8045392:	4576      	cmp	r6, lr
 8045394:	dd2d      	ble.n	80453f2 <kad_op_avg+0x102>
			if (kad_len(p->child[i]) != n) return -1;
 8045396:	f85c 2f04 	ldr.w	r2, [ip, #4]!
 804539a:	7810      	ldrb	r0, [r2, #0]
 804539c:	2800      	cmp	r0, #0
 804539e:	d1e4      	bne.n	804536a <kad_op_avg+0x7a>
	int n = 1, i;
 80453a0:	2301      	movs	r3, #1
 80453a2:	429c      	cmp	r4, r3
 80453a4:	d0f3      	beq.n	804538e <kad_op_avg+0x9e>
 80453a6:	f04f 30ff 	mov.w	r0, #4294967295
}
 80453aa:	ecbd 8b02 	vpop	{d8}
 80453ae:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80453b2:	3a04      	subs	r2, #4
 80453b4:	eb02 0686 	add.w	r6, r2, r6, lsl #2
 80453b8:	00a7      	lsls	r7, r4, #2
 80453ba:	e001      	b.n	80453c0 <kad_op_avg+0xd0>
		for (i = 0; i < p->n_child; ++i)
 80453bc:	4296      	cmp	r6, r2
 80453be:	d0c8      	beq.n	8045352 <kad_op_avg+0x62>
			if (kad_is_back(p->child[i]))
 80453c0:	f852 3f04 	ldr.w	r3, [r2, #4]!
 80453c4:	7859      	ldrb	r1, [r3, #1]
 80453c6:	07c9      	lsls	r1, r1, #31
 80453c8:	d5f8      	bpl.n	80453bc <kad_op_avg+0xcc>
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 80453ca:	2c00      	cmp	r4, #0
				kad_saxpy(n, tmp, p->g, p->child[i]->g);
 80453cc:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80453ce:	6ae9      	ldr	r1, [r5, #44]	@ 0x2c
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 80453d0:	ddf4      	ble.n	80453bc <kad_op_avg+0xcc>
 80453d2:	19d8      	adds	r0, r3, r7
 80453d4:	edd3 7a00 	vldr	s15, [r3]
 80453d8:	ecb1 7a01 	vldmia	r1!, {s14}
 80453dc:	eee8 7a07 	vfma.f32	s15, s16, s14
 80453e0:	ece3 7a01 	vstmia	r3!, {s15}
 80453e4:	4298      	cmp	r0, r3
 80453e6:	d1f5      	bne.n	80453d4 <kad_op_avg+0xe4>
 80453e8:	e7e8      	b.n	80453bc <kad_op_avg+0xcc>
	if (action == KAD_SYNC_DIM) {
 80453ea:	2904      	cmp	r1, #4
 80453ec:	d03c      	beq.n	8045468 <kad_op_avg+0x178>
 80453ee:	2401      	movs	r4, #1
 80453f0:	e7a3      	b.n	804533a <kad_op_avg+0x4a>
	dst->n_d = src->n_d;
 80453f2:	f885 8000 	strb.w	r8, [r5]
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 80453f6:	f1b8 0f00 	cmp.w	r8, #0
 80453fa:	d0aa      	beq.n	8045352 <kad_op_avg+0x62>
 80453fc:	ea4f 0288 	mov.w	r2, r8, lsl #2
 8045400:	f107 0110 	add.w	r1, r7, #16
 8045404:	f105 0010 	add.w	r0, r5, #16
 8045408:	f006 fe11 	bl	804c02e <memcpy>
 804540c:	e7a1      	b.n	8045352 <kad_op_avg+0x62>
		memcpy(p->x, q->x, n * sizeof(float));
 804540e:	00a6      	lsls	r6, r4, #2
 8045410:	4632      	mov	r2, r6
 8045412:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
 8045414:	6aa8      	ldr	r0, [r5, #40]	@ 0x28
 8045416:	f006 fe0a 	bl	804c02e <memcpy>
		for (i = 1; i < p->n_child; ++i)
 804541a:	686a      	ldr	r2, [r5, #4]
 804541c:	2a01      	cmp	r2, #1
 804541e:	dd2b      	ble.n	8045478 <kad_op_avg+0x188>
 8045420:	2c00      	cmp	r4, #0
			kad_saxpy(n, 1.0f, p->child[i]->x, p->x);
 8045422:	6bab      	ldr	r3, [r5, #56]	@ 0x38
 8045424:	6aad      	ldr	r5, [r5, #40]	@ 0x28
 8045426:	dd94      	ble.n	8045352 <kad_op_avg+0x62>
 8045428:	461c      	mov	r4, r3
 804542a:	1f1f      	subs	r7, r3, #4
 804542c:	19a8      	adds	r0, r5, r6
 804542e:	eb07 0782 	add.w	r7, r7, r2, lsl #2
 8045432:	462b      	mov	r3, r5
 8045434:	f854 2f04 	ldr.w	r2, [r4, #4]!
 8045438:	6a91      	ldr	r1, [r2, #40]	@ 0x28
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 804543a:	edd3 7a00 	vldr	s15, [r3]
 804543e:	ecb1 7a01 	vldmia	r1!, {s14}
 8045442:	ee77 7a87 	vadd.f32	s15, s15, s14
 8045446:	ece3 7a01 	vstmia	r3!, {s15}
 804544a:	4298      	cmp	r0, r3
 804544c:	d1f5      	bne.n	804543a <kad_op_avg+0x14a>
		for (i = 1; i < p->n_child; ++i)
 804544e:	42a7      	cmp	r7, r4
 8045450:	d1ef      	bne.n	8045432 <kad_op_avg+0x142>
 8045452:	462b      	mov	r3, r5
 8045454:	442e      	add	r6, r5
		for (i = 0; i < n; ++i) p->x[i] *= tmp;
 8045456:	edd3 7a00 	vldr	s15, [r3]
 804545a:	ee67 7a88 	vmul.f32	s15, s15, s16
 804545e:	ece3 7a01 	vstmia	r3!, {s15}
 8045462:	429e      	cmp	r6, r3
 8045464:	d1f7      	bne.n	8045456 <kad_op_avg+0x166>
 8045466:	e774      	b.n	8045352 <kad_op_avg+0x62>
		for (i = 1; i < p->n_child; ++i)
 8045468:	2e01      	cmp	r6, #1
	dst->n_d = src->n_d;
 804546a:	bf08      	it	eq
 804546c:	f880 8000 	strbeq.w	r8, [r0]
		for (i = 1; i < p->n_child; ++i)
 8045470:	f43f af6f 	beq.w	8045352 <kad_op_avg+0x62>
 8045474:	2401      	movs	r4, #1
 8045476:	e774      	b.n	8045362 <kad_op_avg+0x72>
		for (i = 0; i < n; ++i) p->x[i] *= tmp;
 8045478:	2c00      	cmp	r4, #0
 804547a:	f77f af6a 	ble.w	8045352 <kad_op_avg+0x62>
 804547e:	6aad      	ldr	r5, [r5, #40]	@ 0x28
 8045480:	e7e7      	b.n	8045452 <kad_op_avg+0x162>
	dst->n_d = src->n_d;
 8045482:	f885 8000 	strb.w	r8, [r5]
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 8045486:	e7b9      	b.n	80453fc <kad_op_avg+0x10c>
	assert(p->n_child > 0);
 8045488:	f240 61fb 	movw	r1, #1787	@ 0x6fb
 804548c:	4b02      	ldr	r3, [pc, #8]	@ (8045498 <kad_op_avg+0x1a8>)
 804548e:	4a03      	ldr	r2, [pc, #12]	@ (804549c <kad_op_avg+0x1ac>)
 8045490:	4803      	ldr	r0, [pc, #12]	@ (80454a0 <kad_op_avg+0x1b0>)
 8045492:	f006 f9a7 	bl	804b7e4 <__assert_func>
 8045496:	bf00      	nop
 8045498:	0804e424 	.word	0x0804e424
 804549c:	0804e510 	.word	0x0804e510
 80454a0:	0804e3dc 	.word	0x0804e3dc

080454a4 <kad_op_stack>:
{
 80454a4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	assert(p->n_child > 0);
 80454a8:	6847      	ldr	r7, [r0, #4]
 80454aa:	2f00      	cmp	r7, #0
 80454ac:	f340 8096 	ble.w	80455dc <kad_op_stack+0x138>
	q = p->child[0];
 80454b0:	6b83      	ldr	r3, [r0, #56]	@ 0x38
 80454b2:	4605      	mov	r5, r0
 80454b4:	681e      	ldr	r6, [r3, #0]
	for (i = 0; i < p->n_d; ++i) n *= p->d[i];
 80454b6:	f896 e000 	ldrb.w	lr, [r6]
 80454ba:	f1be 0f00 	cmp.w	lr, #0
 80454be:	d057      	beq.n	8045570 <kad_op_stack+0xcc>
 80454c0:	f1be 0f01 	cmp.w	lr, #1
 80454c4:	6930      	ldr	r0, [r6, #16]
 80454c6:	d00e      	beq.n	80454e6 <kad_op_stack+0x42>
 80454c8:	6972      	ldr	r2, [r6, #20]
 80454ca:	f1be 0f02 	cmp.w	lr, #2
 80454ce:	fb02 f000 	mul.w	r0, r2, r0
 80454d2:	d008      	beq.n	80454e6 <kad_op_stack+0x42>
 80454d4:	69b2      	ldr	r2, [r6, #24]
 80454d6:	f1be 0f03 	cmp.w	lr, #3
 80454da:	fb02 f000 	mul.w	r0, r2, r0
 80454de:	d002      	beq.n	80454e6 <kad_op_stack+0x42>
 80454e0:	69f2      	ldr	r2, [r6, #28]
 80454e2:	fb02 f000 	mul.w	r0, r2, r0
	if (action == KAD_SYNC_DIM) {
 80454e6:	2904      	cmp	r1, #4
 80454e8:	d01a      	beq.n	8045520 <kad_op_stack+0x7c>
	} else if (action == KAD_FORWARD) { /* TODO: doesn't work when axis != 0 */
 80454ea:	2902      	cmp	r1, #2
 80454ec:	d004      	beq.n	80454f8 <kad_op_stack+0x54>
	} else if (action == KAD_BACKWARD) {
 80454ee:	2903      	cmp	r1, #3
 80454f0:	d053      	beq.n	804559a <kad_op_stack+0xf6>
	return 0;
 80454f2:	2000      	movs	r0, #0
}
 80454f4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			memcpy(&p->x[i * n], p->child[i]->x, n * sizeof(float));
 80454f8:	2700      	movs	r7, #0
 80454fa:	ea4f 0880 	mov.w	r8, r0, lsl #2
		for (i = 0; i < p->n_child; ++i)
 80454fe:	463c      	mov	r4, r7
 8045500:	e002      	b.n	8045508 <kad_op_stack+0x64>
			memcpy(&p->x[i * n], p->child[i]->x, n * sizeof(float));
 8045502:	6bab      	ldr	r3, [r5, #56]	@ 0x38
 8045504:	f853 6024 	ldr.w	r6, [r3, r4, lsl #2]
 8045508:	6aa8      	ldr	r0, [r5, #40]	@ 0x28
 804550a:	4642      	mov	r2, r8
 804550c:	4438      	add	r0, r7
 804550e:	6ab1      	ldr	r1, [r6, #40]	@ 0x28
 8045510:	f006 fd8d 	bl	804c02e <memcpy>
		for (i = 0; i < p->n_child; ++i)
 8045514:	686b      	ldr	r3, [r5, #4]
 8045516:	3401      	adds	r4, #1
 8045518:	42a3      	cmp	r3, r4
 804551a:	4447      	add	r7, r8
 804551c:	dcf1      	bgt.n	8045502 <kad_op_stack+0x5e>
 804551e:	e7e8      	b.n	80454f2 <kad_op_stack+0x4e>
		for (i = 1; i < p->n_child; ++i)
 8045520:	2f01      	cmp	r7, #1
 8045522:	d027      	beq.n	8045574 <kad_op_stack+0xd0>
 8045524:	4698      	mov	r8, r3
 8045526:	f04f 0c01 	mov.w	ip, #1
 804552a:	e015      	b.n	8045558 <kad_op_stack+0xb4>
 804552c:	2c01      	cmp	r4, #1
 804552e:	6913      	ldr	r3, [r2, #16]
 8045530:	d00c      	beq.n	804554c <kad_op_stack+0xa8>
 8045532:	6951      	ldr	r1, [r2, #20]
 8045534:	2c02      	cmp	r4, #2
 8045536:	fb01 f303 	mul.w	r3, r1, r3
 804553a:	d007      	beq.n	804554c <kad_op_stack+0xa8>
 804553c:	6991      	ldr	r1, [r2, #24]
 804553e:	2c03      	cmp	r4, #3
 8045540:	fb01 f303 	mul.w	r3, r1, r3
 8045544:	d002      	beq.n	804554c <kad_op_stack+0xa8>
 8045546:	69d2      	ldr	r2, [r2, #28]
 8045548:	fb02 f303 	mul.w	r3, r2, r3
			if (kad_len(p->child[i]) != n) return -1;
 804554c:	4298      	cmp	r0, r3
 804554e:	d10b      	bne.n	8045568 <kad_op_stack+0xc4>
		for (i = 1; i < p->n_child; ++i)
 8045550:	f10c 0c01 	add.w	ip, ip, #1
 8045554:	4567      	cmp	r7, ip
 8045556:	d00d      	beq.n	8045574 <kad_op_stack+0xd0>
			if (kad_len(p->child[i]) != n) return -1;
 8045558:	f858 2f04 	ldr.w	r2, [r8, #4]!
 804555c:	7814      	ldrb	r4, [r2, #0]
 804555e:	2c00      	cmp	r4, #0
 8045560:	d1e4      	bne.n	804552c <kad_op_stack+0x88>
	int n = 1, i;
 8045562:	2301      	movs	r3, #1
 8045564:	4298      	cmp	r0, r3
 8045566:	d0f3      	beq.n	8045550 <kad_op_stack+0xac>
 8045568:	f04f 30ff 	mov.w	r0, #4294967295
}
 804556c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8045570:	2001      	movs	r0, #1
 8045572:	e7b8      	b.n	80454e6 <kad_op_stack+0x42>
		p->n_d = q->n_d + 1;
 8045574:	f10e 0e01 	add.w	lr, lr, #1
 8045578:	f885 e000 	strb.w	lr, [r5]
		p->d[axis] = p->n_child;
 804557c:	612f      	str	r7, [r5, #16]
		for (; i < q->n_d; ++i) p->d[i+1] = q->d[i];
 804557e:	7833      	ldrb	r3, [r6, #0]
 8045580:	2b00      	cmp	r3, #0
 8045582:	d0b6      	beq.n	80454f2 <kad_op_stack+0x4e>
 8045584:	6932      	ldr	r2, [r6, #16]
 8045586:	2b01      	cmp	r3, #1
 8045588:	616a      	str	r2, [r5, #20]
 804558a:	d0b2      	beq.n	80454f2 <kad_op_stack+0x4e>
 804558c:	6972      	ldr	r2, [r6, #20]
 804558e:	2b02      	cmp	r3, #2
 8045590:	61aa      	str	r2, [r5, #24]
 8045592:	d0ae      	beq.n	80454f2 <kad_op_stack+0x4e>
 8045594:	69b3      	ldr	r3, [r6, #24]
 8045596:	61eb      	str	r3, [r5, #28]
 8045598:	e7ab      	b.n	80454f2 <kad_op_stack+0x4e>
 804559a:	3b04      	subs	r3, #4
	} else if (action == KAD_BACKWARD) {
 804559c:	2600      	movs	r6, #0
 804559e:	ea4f 0c80 	mov.w	ip, r0, lsl #2
 80455a2:	eb03 0787 	add.w	r7, r3, r7, lsl #2
 80455a6:	e002      	b.n	80455ae <kad_op_stack+0x10a>
		for (i = 0; i < p->n_child; ++i)
 80455a8:	429f      	cmp	r7, r3
 80455aa:	4466      	add	r6, ip
 80455ac:	d0a1      	beq.n	80454f2 <kad_op_stack+0x4e>
			if (kad_is_back(p->child[i]))
 80455ae:	f853 2f04 	ldr.w	r2, [r3, #4]!
 80455b2:	7851      	ldrb	r1, [r2, #1]
 80455b4:	07c9      	lsls	r1, r1, #31
 80455b6:	d5f7      	bpl.n	80455a8 <kad_op_stack+0x104>
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 80455b8:	2800      	cmp	r0, #0
				kad_saxpy(n, 1.0f, &p->g[i * n], p->child[i]->g);
 80455ba:	6ad2      	ldr	r2, [r2, #44]	@ 0x2c
 80455bc:	6ae9      	ldr	r1, [r5, #44]	@ 0x2c
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 80455be:	ddf3      	ble.n	80455a8 <kad_op_stack+0x104>
 80455c0:	4431      	add	r1, r6
 80455c2:	eb02 040c 	add.w	r4, r2, ip
 80455c6:	edd2 7a00 	vldr	s15, [r2]
 80455ca:	ecb1 7a01 	vldmia	r1!, {s14}
 80455ce:	ee77 7a87 	vadd.f32	s15, s15, s14
 80455d2:	ece2 7a01 	vstmia	r2!, {s15}
 80455d6:	42a2      	cmp	r2, r4
 80455d8:	d1f5      	bne.n	80455c6 <kad_op_stack+0x122>
 80455da:	e7e5      	b.n	80455a8 <kad_op_stack+0x104>
	assert(p->n_child > 0);
 80455dc:	f240 7131 	movw	r1, #1841	@ 0x731
 80455e0:	4b02      	ldr	r3, [pc, #8]	@ (80455ec <kad_op_stack+0x148>)
 80455e2:	4a03      	ldr	r2, [pc, #12]	@ (80455f0 <kad_op_stack+0x14c>)
 80455e4:	4803      	ldr	r0, [pc, #12]	@ (80455f4 <kad_op_stack+0x150>)
 80455e6:	f006 f8fd 	bl	804b7e4 <__assert_func>
 80455ea:	bf00      	nop
 80455ec:	0804e424 	.word	0x0804e424
 80455f0:	0804e500 	.word	0x0804e500
 80455f4:	0804e3dc 	.word	0x0804e3dc

080455f8 <kad_op_select>:
{
 80455f8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	which = *(int32_t*)p->ptr;
 80455fa:	6b03      	ldr	r3, [r0, #48]	@ 0x30
	if (which < 0) which += p->n_child;
 80455fc:	6845      	ldr	r5, [r0, #4]
	which = *(int32_t*)p->ptr;
 80455fe:	681b      	ldr	r3, [r3, #0]
	if (which < 0) which += p->n_child;
 8045600:	2b00      	cmp	r3, #0
 8045602:	db31      	blt.n	8045668 <kad_op_select+0x70>
	assert(which >= 0 && which < p->n_child);
 8045604:	42ab      	cmp	r3, r5
 8045606:	da31      	bge.n	804566c <kad_op_select+0x74>
	q = p->child[which];
 8045608:	6b82      	ldr	r2, [r0, #56]	@ 0x38
 804560a:	f852 6023 	ldr.w	r6, [r2, r3, lsl #2]
	for (i = 0; i < p->n_d; ++i) n *= p->d[i];
 804560e:	7833      	ldrb	r3, [r6, #0]
 8045610:	2b00      	cmp	r3, #0
 8045612:	d05d      	beq.n	80456d0 <kad_op_select+0xd8>
 8045614:	2b01      	cmp	r3, #1
 8045616:	6934      	ldr	r4, [r6, #16]
 8045618:	d00c      	beq.n	8045634 <kad_op_select+0x3c>
 804561a:	6977      	ldr	r7, [r6, #20]
 804561c:	2b02      	cmp	r3, #2
 804561e:	fb07 f404 	mul.w	r4, r7, r4
 8045622:	d007      	beq.n	8045634 <kad_op_select+0x3c>
 8045624:	69b7      	ldr	r7, [r6, #24]
 8045626:	2b03      	cmp	r3, #3
 8045628:	fb07 f404 	mul.w	r4, r7, r4
 804562c:	d002      	beq.n	8045634 <kad_op_select+0x3c>
 804562e:	69f7      	ldr	r7, [r6, #28]
 8045630:	fb07 f404 	mul.w	r4, r7, r4
	if (action == KAD_SYNC_DIM) {
 8045634:	2904      	cmp	r1, #4
 8045636:	d020      	beq.n	804567a <kad_op_select+0x82>
	} else if (action == KAD_FORWARD) {
 8045638:	2902      	cmp	r1, #2
 804563a:	d04b      	beq.n	80456d4 <kad_op_select+0xdc>
	} else if (action == KAD_BACKWARD && kad_is_back(q)) {
 804563c:	2903      	cmp	r1, #3
 804563e:	d145      	bne.n	80456cc <kad_op_select+0xd4>
 8045640:	7873      	ldrb	r3, [r6, #1]
 8045642:	07db      	lsls	r3, r3, #31
 8045644:	d542      	bpl.n	80456cc <kad_op_select+0xd4>
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 8045646:	2c00      	cmp	r4, #0
		kad_saxpy(n, 1.0f, p->g, q->g);
 8045648:	6ac2      	ldr	r2, [r0, #44]	@ 0x2c
 804564a:	6af3      	ldr	r3, [r6, #44]	@ 0x2c
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 804564c:	dd3e      	ble.n	80456cc <kad_op_select+0xd4>
 804564e:	eb03 0484 	add.w	r4, r3, r4, lsl #2
 8045652:	edd3 7a00 	vldr	s15, [r3]
 8045656:	ecb2 7a01 	vldmia	r2!, {s14}
 804565a:	ee77 7a87 	vadd.f32	s15, s15, s14
 804565e:	ece3 7a01 	vstmia	r3!, {s15}
 8045662:	42a3      	cmp	r3, r4
 8045664:	d1f5      	bne.n	8045652 <kad_op_select+0x5a>
 8045666:	e031      	b.n	80456cc <kad_op_select+0xd4>
	assert(which >= 0 && which < p->n_child);
 8045668:	195b      	adds	r3, r3, r5
 804566a:	d5cd      	bpl.n	8045608 <kad_op_select+0x10>
 804566c:	f240 714d 	movw	r1, #1869	@ 0x74d
 8045670:	4b20      	ldr	r3, [pc, #128]	@ (80456f4 <kad_op_select+0xfc>)
 8045672:	4a21      	ldr	r2, [pc, #132]	@ (80456f8 <kad_op_select+0x100>)
 8045674:	4821      	ldr	r0, [pc, #132]	@ (80456fc <kad_op_select+0x104>)
 8045676:	f006 f8b5 	bl	804b7e4 <__assert_func>
		for (i = 0; i < p->n_child; ++i)
 804567a:	f04f 0c00 	mov.w	ip, #0
 804567e:	f1a2 0e04 	sub.w	lr, r2, #4
 8045682:	e015      	b.n	80456b0 <kad_op_select+0xb8>
 8045684:	2b01      	cmp	r3, #1
 8045686:	690a      	ldr	r2, [r1, #16]
 8045688:	d00c      	beq.n	80456a4 <kad_op_select+0xac>
 804568a:	694f      	ldr	r7, [r1, #20]
 804568c:	2b02      	cmp	r3, #2
 804568e:	fb07 f202 	mul.w	r2, r7, r2
 8045692:	d007      	beq.n	80456a4 <kad_op_select+0xac>
 8045694:	698f      	ldr	r7, [r1, #24]
 8045696:	2b03      	cmp	r3, #3
 8045698:	fb07 f202 	mul.w	r2, r7, r2
 804569c:	d002      	beq.n	80456a4 <kad_op_select+0xac>
 804569e:	69c9      	ldr	r1, [r1, #28]
 80456a0:	fb01 f202 	mul.w	r2, r1, r2
			if (p->child[i]->n_d != q->n_d || kad_len(p->child[i]) != n)
 80456a4:	42a2      	cmp	r2, r4
 80456a6:	d10d      	bne.n	80456c4 <kad_op_select+0xcc>
		for (i = 0; i < p->n_child; ++i)
 80456a8:	f10c 0c01 	add.w	ip, ip, #1
 80456ac:	45ac      	cmp	ip, r5
 80456ae:	d00b      	beq.n	80456c8 <kad_op_select+0xd0>
			if (p->child[i]->n_d != q->n_d || kad_len(p->child[i]) != n)
 80456b0:	f85e 1f04 	ldr.w	r1, [lr, #4]!
 80456b4:	780a      	ldrb	r2, [r1, #0]
 80456b6:	429a      	cmp	r2, r3
 80456b8:	d104      	bne.n	80456c4 <kad_op_select+0xcc>
 80456ba:	2b00      	cmp	r3, #0
 80456bc:	d1e2      	bne.n	8045684 <kad_op_select+0x8c>
	int n = 1, i;
 80456be:	2201      	movs	r2, #1
 80456c0:	42a2      	cmp	r2, r4
 80456c2:	d0f1      	beq.n	80456a8 <kad_op_select+0xb0>
		if (i < p->n_child) return -1;
 80456c4:	45ac      	cmp	ip, r5
 80456c6:	db12      	blt.n	80456ee <kad_op_select+0xf6>
	dst->n_d = src->n_d;
 80456c8:	7003      	strb	r3, [r0, #0]
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 80456ca:	b94b      	cbnz	r3, 80456e0 <kad_op_select+0xe8>
	return 0;
 80456cc:	2000      	movs	r0, #0
}
 80456ce:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80456d0:	2401      	movs	r4, #1
 80456d2:	e7af      	b.n	8045634 <kad_op_select+0x3c>
		memcpy(p->x, q->x, n * sizeof(float));
 80456d4:	6ab1      	ldr	r1, [r6, #40]	@ 0x28
 80456d6:	00a2      	lsls	r2, r4, #2
 80456d8:	6a80      	ldr	r0, [r0, #40]	@ 0x28
 80456da:	f006 fca8 	bl	804c02e <memcpy>
 80456de:	e7f5      	b.n	80456cc <kad_op_select+0xd4>
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 80456e0:	009a      	lsls	r2, r3, #2
 80456e2:	f106 0110 	add.w	r1, r6, #16
 80456e6:	3010      	adds	r0, #16
 80456e8:	f006 fca1 	bl	804c02e <memcpy>
 80456ec:	e7ee      	b.n	80456cc <kad_op_select+0xd4>
		if (i < p->n_child) return -1;
 80456ee:	f04f 30ff 	mov.w	r0, #4294967295
}
 80456f2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80456f4:	0804e434 	.word	0x0804e434
 80456f8:	0804e4f0 	.word	0x0804e4f0
 80456fc:	0804e3dc 	.word	0x0804e3dc

08045700 <kad_op_ce_bin>:
{
 8045700:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8045704:	ed2d 8b04 	vpush	{d8-d9}
	kad_node_t *y1 = p->child[0]; /* test */
 8045708:	6b82      	ldr	r2, [r0, #56]	@ 0x38
{
 804570a:	4681      	mov	r9, r0
	kad_node_t *y1 = p->child[0]; /* test */
 804570c:	e9d2 8300 	ldrd	r8, r3, [r2]
	for (i = 0; i < p->n_d; ++i) n *= p->d[i];
 8045710:	781a      	ldrb	r2, [r3, #0]
{
 8045712:	b083      	sub	sp, #12
 8045714:	2a00      	cmp	r2, #0
 8045716:	d03c      	beq.n	8045792 <kad_op_ce_bin+0x92>
 8045718:	2a01      	cmp	r2, #1
 804571a:	691e      	ldr	r6, [r3, #16]
 804571c:	d00c      	beq.n	8045738 <kad_op_ce_bin+0x38>
 804571e:	6958      	ldr	r0, [r3, #20]
 8045720:	2a02      	cmp	r2, #2
 8045722:	fb00 f606 	mul.w	r6, r0, r6
 8045726:	d007      	beq.n	8045738 <kad_op_ce_bin+0x38>
 8045728:	6998      	ldr	r0, [r3, #24]
 804572a:	2a03      	cmp	r2, #3
 804572c:	fb00 f606 	mul.w	r6, r0, r6
 8045730:	d002      	beq.n	8045738 <kad_op_ce_bin+0x38>
 8045732:	69da      	ldr	r2, [r3, #28]
 8045734:	fb02 f606 	mul.w	r6, r2, r6
	if (action == KAD_SYNC_DIM) {
 8045738:	2904      	cmp	r1, #4
 804573a:	d00a      	beq.n	8045752 <kad_op_ce_bin+0x52>
	} else if (action == KAD_FORWARD) {
 804573c:	2902      	cmp	r1, #2
 804573e:	d030      	beq.n	80457a2 <kad_op_ce_bin+0xa2>
	} else if (action == KAD_BACKWARD && kad_is_back(y1)) {
 8045740:	2903      	cmp	r1, #3
 8045742:	f000 80b8 	beq.w	80458b6 <kad_op_ce_bin+0x1b6>
	return 0;
 8045746:	2000      	movs	r0, #0
}
 8045748:	b003      	add	sp, #12
 804574a:	ecbd 8b04 	vpop	{d8-d9}
 804574e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8045752:	f898 2000 	ldrb.w	r2, [r8]
 8045756:	2a00      	cmp	r2, #0
 8045758:	f000 810e 	beq.w	8045978 <kad_op_ce_bin+0x278>
 804575c:	2a01      	cmp	r2, #1
 804575e:	f8d8 3010 	ldr.w	r3, [r8, #16]
 8045762:	d00f      	beq.n	8045784 <kad_op_ce_bin+0x84>
 8045764:	f8d8 1014 	ldr.w	r1, [r8, #20]
 8045768:	2a02      	cmp	r2, #2
 804576a:	fb01 f303 	mul.w	r3, r1, r3
 804576e:	d009      	beq.n	8045784 <kad_op_ce_bin+0x84>
 8045770:	f8d8 1018 	ldr.w	r1, [r8, #24]
 8045774:	2a03      	cmp	r2, #3
 8045776:	fb01 f303 	mul.w	r3, r1, r3
 804577a:	d003      	beq.n	8045784 <kad_op_ce_bin+0x84>
 804577c:	f8d8 201c 	ldr.w	r2, [r8, #28]
 8045780:	fb02 f303 	mul.w	r3, r2, r3
		if (n != kad_len(y1)) return -1;
 8045784:	429e      	cmp	r6, r3
 8045786:	f040 80fc 	bne.w	8045982 <kad_op_ce_bin+0x282>
		p->n_d = 0;
 804578a:	2300      	movs	r3, #0
 804578c:	f889 3000 	strb.w	r3, [r9]
 8045790:	e7d9      	b.n	8045746 <kad_op_ce_bin+0x46>
	if (action == KAD_SYNC_DIM) {
 8045792:	2904      	cmp	r1, #4
 8045794:	f000 8088 	beq.w	80458a8 <kad_op_ce_bin+0x1a8>
	} else if (action == KAD_FORWARD) {
 8045798:	2902      	cmp	r1, #2
	int n = 1, i;
 804579a:	f04f 0601 	mov.w	r6, #1
 804579e:	d1cf      	bne.n	8045740 <kad_op_ce_bin+0x40>
 80457a0:	e002      	b.n	80457a8 <kad_op_ce_bin+0xa8>
		for (i = 0; i < n; ++i) {
 80457a2:	2e00      	cmp	r6, #0
 80457a4:	f340 80ea 	ble.w	804597c <kad_op_ce_bin+0x27c>
				cost += y0->x[i] * log(y0->x[i] / (y1->x[i] > tiny? y1->x[i] : tiny));
 80457a8:	eddf 8a77 	vldr	s17, [pc, #476]	@ 8045988 <kad_op_ce_bin+0x288>
			if (1.0f - y0->x[i] > 0.0f)
 80457ac:	eeb7 9a00 	vmov.f32	s18, #112	@ 0x3f800000  1.0
		double cost = 0.0;
 80457b0:	2400      	movs	r4, #0
 80457b2:	2500      	movs	r5, #0
		for (i = 0; i < n; ++i) {
 80457b4:	2700      	movs	r7, #0
 80457b6:	f8d3 b028 	ldr.w	fp, [r3, #40]	@ 0x28
			if (y0->x[i] > 0.0f)
 80457ba:	ecbb 8a01 	vldmia	fp!, {s16}
 80457be:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
 80457c2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80457c6:	ea4f 0a87 	mov.w	sl, r7, lsl #2
		for (i = 0; i < n; ++i) {
 80457ca:	f107 0701 	add.w	r7, r7, #1
			if (y0->x[i] > 0.0f)
 80457ce:	dd28      	ble.n	8045822 <kad_op_ce_bin+0x122>
				cost += y0->x[i] * log(y0->x[i] / (y1->x[i] > tiny? y1->x[i] : tiny));
 80457d0:	ee18 0a10 	vmov	r0, s16
 80457d4:	f7fa fe94 	bl	8040500 <__aeabi_f2d>
 80457d8:	f8d8 3028 	ldr.w	r3, [r8, #40]	@ 0x28
 80457dc:	e9cd 0100 	strd	r0, r1, [sp]
 80457e0:	4453      	add	r3, sl
 80457e2:	edd3 7a00 	vldr	s15, [r3]
 80457e6:	eef4 7ae8 	vcmpe.f32	s15, s17
 80457ea:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80457ee:	fe77 7aa8 	vselgt.f32	s15, s15, s17
 80457f2:	eec8 7a27 	vdiv.f32	s15, s16, s15
 80457f6:	ee17 0a90 	vmov	r0, s15
 80457fa:	f7fa fe81 	bl	8040500 <__aeabi_f2d>
 80457fe:	ec41 0b10 	vmov	d0, r0, r1
 8045802:	f007 fa05 	bl	804cc10 <log>
 8045806:	e9dd 0100 	ldrd	r0, r1, [sp]
 804580a:	ec53 2b10 	vmov	r2, r3, d0
 804580e:	f7fa fecf 	bl	80405b0 <__aeabi_dmul>
 8045812:	4602      	mov	r2, r0
 8045814:	460b      	mov	r3, r1
 8045816:	4620      	mov	r0, r4
 8045818:	4629      	mov	r1, r5
 804581a:	f7fa fd13 	bl	8040244 <__adddf3>
 804581e:	4604      	mov	r4, r0
 8045820:	460d      	mov	r5, r1
			if (1.0f - y0->x[i] > 0.0f)
 8045822:	ee39 8a48 	vsub.f32	s16, s18, s16
 8045826:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
 804582a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 804582e:	dd2a      	ble.n	8045886 <kad_op_ce_bin+0x186>
				cost += (1.0f - y0->x[i]) * log((1.0f - y0->x[i]) / (1.0f - y1->x[i] > tiny? 1.0f - y1->x[i] : tiny));
 8045830:	ee18 0a10 	vmov	r0, s16
 8045834:	f7fa fe64 	bl	8040500 <__aeabi_f2d>
 8045838:	f8d8 3028 	ldr.w	r3, [r8, #40]	@ 0x28
 804583c:	e9cd 0100 	strd	r0, r1, [sp]
 8045840:	4453      	add	r3, sl
 8045842:	edd3 7a00 	vldr	s15, [r3]
 8045846:	ee79 7a67 	vsub.f32	s15, s18, s15
 804584a:	eef4 7ae8 	vcmpe.f32	s15, s17
 804584e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8045852:	fe77 7aa8 	vselgt.f32	s15, s15, s17
 8045856:	eec8 7a27 	vdiv.f32	s15, s16, s15
 804585a:	ee17 0a90 	vmov	r0, s15
 804585e:	f7fa fe4f 	bl	8040500 <__aeabi_f2d>
 8045862:	ec41 0b10 	vmov	d0, r0, r1
 8045866:	f007 f9d3 	bl	804cc10 <log>
 804586a:	e9dd 0100 	ldrd	r0, r1, [sp]
 804586e:	ec53 2b10 	vmov	r2, r3, d0
 8045872:	f7fa fe9d 	bl	80405b0 <__aeabi_dmul>
 8045876:	4602      	mov	r2, r0
 8045878:	460b      	mov	r3, r1
 804587a:	4620      	mov	r0, r4
 804587c:	4629      	mov	r1, r5
 804587e:	f7fa fce1 	bl	8040244 <__adddf3>
 8045882:	4604      	mov	r4, r0
 8045884:	460d      	mov	r5, r1
		for (i = 0; i < n; ++i) {
 8045886:	42b7      	cmp	r7, r6
 8045888:	db97      	blt.n	80457ba <kad_op_ce_bin+0xba>
		p->x[0] = (float)(cost / n);
 804588a:	4630      	mov	r0, r6
 804588c:	f7fa fe26 	bl	80404dc <__aeabi_i2d>
 8045890:	460b      	mov	r3, r1
 8045892:	4602      	mov	r2, r0
 8045894:	4629      	mov	r1, r5
 8045896:	4620      	mov	r0, r4
 8045898:	f7fa ffb4 	bl	8040804 <__aeabi_ddiv>
 804589c:	f7fb f960 	bl	8040b60 <__aeabi_d2f>
 80458a0:	f8d9 3028 	ldr.w	r3, [r9, #40]	@ 0x28
 80458a4:	6018      	str	r0, [r3, #0]
 80458a6:	e74e      	b.n	8045746 <kad_op_ce_bin+0x46>
	for (i = 0; i < p->n_d; ++i) n *= p->d[i];
 80458a8:	f898 2000 	ldrb.w	r2, [r8]
 80458ac:	2a00      	cmp	r2, #0
 80458ae:	f43f af6c 	beq.w	804578a <kad_op_ce_bin+0x8a>
	int n = 1, i;
 80458b2:	2601      	movs	r6, #1
 80458b4:	e752      	b.n	804575c <kad_op_ce_bin+0x5c>
	} else if (action == KAD_BACKWARD && kad_is_back(y1)) {
 80458b6:	f898 2001 	ldrb.w	r2, [r8, #1]
 80458ba:	07d2      	lsls	r2, r2, #31
 80458bc:	f57f af43 	bpl.w	8045746 <kad_op_ce_bin+0x46>
		float t = p->g[0] / n;
 80458c0:	ee07 6a90 	vmov	s15, r6
 80458c4:	f8d9 202c 	ldr.w	r2, [r9, #44]	@ 0x2c
 80458c8:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 80458cc:	ed92 7a00 	vldr	s14, [r2]
		for (i = 0; i < n; ++i) {
 80458d0:	2e00      	cmp	r6, #0
		float t = p->g[0] / n;
 80458d2:	ee87 5a27 	vdiv.f32	s10, s14, s15
		for (i = 0; i < n; ++i) {
 80458d6:	f77f af36 	ble.w	8045746 <kad_op_ce_bin+0x46>
			if (y0->x[i] > 0.0f)
 80458da:	2200      	movs	r2, #0
				y1->g[i] -= t * y0->x[i] / (y1->x[i] > tiny? y1->x[i] : tiny);
 80458dc:	eddf 6a2a 	vldr	s13, [pc, #168]	@ 8045988 <kad_op_ce_bin+0x288>
			if (1.0f - y0->x[i] > 0.0f)
 80458e0:	eef7 5a00 	vmov.f32	s11, #112	@ 0x3f800000  1.0
 80458e4:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80458e6:	eb03 0686 	add.w	r6, r3, r6, lsl #2
			if (y0->x[i] > 0.0f)
 80458ea:	ecf3 7a01 	vldmia	r3!, {s15}
 80458ee:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 80458f2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80458f6:	dd19      	ble.n	804592c <kad_op_ce_bin+0x22c>
				y1->g[i] -= t * y0->x[i] / (y1->x[i] > tiny? y1->x[i] : tiny);
 80458f8:	f8d8 1028 	ldr.w	r1, [r8, #40]	@ 0x28
 80458fc:	ee67 7a85 	vmul.f32	s15, s15, s10
 8045900:	4411      	add	r1, r2
 8045902:	ed91 7a00 	vldr	s14, [r1]
 8045906:	eeb4 7ae6 	vcmpe.f32	s14, s13
 804590a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 804590e:	f8d8 102c 	ldr.w	r1, [r8, #44]	@ 0x2c
 8045912:	fe37 7a26 	vselgt.f32	s14, s14, s13
 8045916:	4411      	add	r1, r2
 8045918:	ed91 6a00 	vldr	s12, [r1]
 804591c:	eec7 4a87 	vdiv.f32	s9, s15, s14
 8045920:	ee76 7a64 	vsub.f32	s15, s12, s9
 8045924:	edc1 7a00 	vstr	s15, [r1]
			if (1.0f - y0->x[i] > 0.0f)
 8045928:	ed53 7a01 	vldr	s15, [r3, #-4]
 804592c:	ee75 7ae7 	vsub.f32	s15, s11, s15
 8045930:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8045934:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8045938:	dd19      	ble.n	804596e <kad_op_ce_bin+0x26e>
				y1->g[i] += t * (1.0f - y0->x[i]) / (1.0f - y1->x[i] > tiny? 1.0f - y1->x[i] : tiny);
 804593a:	f8d8 1028 	ldr.w	r1, [r8, #40]	@ 0x28
 804593e:	ee67 7a85 	vmul.f32	s15, s15, s10
 8045942:	4411      	add	r1, r2
 8045944:	ed91 7a00 	vldr	s14, [r1]
 8045948:	ee35 7ac7 	vsub.f32	s14, s11, s14
 804594c:	eeb4 7ae6 	vcmpe.f32	s14, s13
 8045950:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8045954:	f8d8 102c 	ldr.w	r1, [r8, #44]	@ 0x2c
 8045958:	fe37 7a26 	vselgt.f32	s14, s14, s13
 804595c:	4411      	add	r1, r2
 804595e:	edd1 4a00 	vldr	s9, [r1]
 8045962:	ee87 6a87 	vdiv.f32	s12, s15, s14
 8045966:	ee76 7a24 	vadd.f32	s15, s12, s9
 804596a:	edc1 7a00 	vstr	s15, [r1]
		for (i = 0; i < n; ++i) {
 804596e:	42b3      	cmp	r3, r6
 8045970:	f102 0204 	add.w	r2, r2, #4
 8045974:	d1b9      	bne.n	80458ea <kad_op_ce_bin+0x1ea>
 8045976:	e6e6      	b.n	8045746 <kad_op_ce_bin+0x46>
 8045978:	2301      	movs	r3, #1
 804597a:	e703      	b.n	8045784 <kad_op_ce_bin+0x84>
		double cost = 0.0;
 804597c:	2400      	movs	r4, #0
 804597e:	2500      	movs	r5, #0
 8045980:	e783      	b.n	804588a <kad_op_ce_bin+0x18a>
		if (n != kad_len(y1)) return -1;
 8045982:	f04f 30ff 	mov.w	r0, #4294967295
 8045986:	e6df      	b.n	8045748 <kad_op_ce_bin+0x48>
 8045988:	3089705f 	.word	0x3089705f

0804598c <kad_op_ce_bin_neg>:
{
 804598c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8045990:	ed2d 8b06 	vpush	{d8-d10}
	kad_node_t *y1 = p->child[0]; /* test */
 8045994:	6b82      	ldr	r2, [r0, #56]	@ 0x38
{
 8045996:	4681      	mov	r9, r0
	kad_node_t *y1 = p->child[0]; /* test */
 8045998:	e9d2 8300 	ldrd	r8, r3, [r2]
	for (i = 0; i < p->n_d; ++i) n *= p->d[i];
 804599c:	781a      	ldrb	r2, [r3, #0]
{
 804599e:	b083      	sub	sp, #12
 80459a0:	2a00      	cmp	r2, #0
 80459a2:	d03c      	beq.n	8045a1e <kad_op_ce_bin_neg+0x92>
 80459a4:	2a01      	cmp	r2, #1
 80459a6:	691e      	ldr	r6, [r3, #16]
 80459a8:	d00c      	beq.n	80459c4 <kad_op_ce_bin_neg+0x38>
 80459aa:	6958      	ldr	r0, [r3, #20]
 80459ac:	2a02      	cmp	r2, #2
 80459ae:	fb00 f606 	mul.w	r6, r0, r6
 80459b2:	d007      	beq.n	80459c4 <kad_op_ce_bin_neg+0x38>
 80459b4:	6998      	ldr	r0, [r3, #24]
 80459b6:	2a03      	cmp	r2, #3
 80459b8:	fb00 f606 	mul.w	r6, r0, r6
 80459bc:	d002      	beq.n	80459c4 <kad_op_ce_bin_neg+0x38>
 80459be:	69da      	ldr	r2, [r3, #28]
 80459c0:	fb02 f606 	mul.w	r6, r2, r6
	if (action == KAD_SYNC_DIM) {
 80459c4:	2904      	cmp	r1, #4
 80459c6:	d00a      	beq.n	80459de <kad_op_ce_bin_neg+0x52>
	} else if (action == KAD_FORWARD) {
 80459c8:	2902      	cmp	r1, #2
 80459ca:	d030      	beq.n	8045a2e <kad_op_ce_bin_neg+0xa2>
	} else if (action == KAD_BACKWARD && kad_is_back(y1)) {
 80459cc:	2903      	cmp	r1, #3
 80459ce:	f000 80c2 	beq.w	8045b56 <kad_op_ce_bin_neg+0x1ca>
	return 0;
 80459d2:	2000      	movs	r0, #0
}
 80459d4:	b003      	add	sp, #12
 80459d6:	ecbd 8b06 	vpop	{d8-d10}
 80459da:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80459de:	f898 2000 	ldrb.w	r2, [r8]
 80459e2:	2a00      	cmp	r2, #0
 80459e4:	f000 8122 	beq.w	8045c2c <kad_op_ce_bin_neg+0x2a0>
 80459e8:	2a01      	cmp	r2, #1
 80459ea:	f8d8 3010 	ldr.w	r3, [r8, #16]
 80459ee:	d00f      	beq.n	8045a10 <kad_op_ce_bin_neg+0x84>
 80459f0:	f8d8 1014 	ldr.w	r1, [r8, #20]
 80459f4:	2a02      	cmp	r2, #2
 80459f6:	fb01 f303 	mul.w	r3, r1, r3
 80459fa:	d009      	beq.n	8045a10 <kad_op_ce_bin_neg+0x84>
 80459fc:	f8d8 1018 	ldr.w	r1, [r8, #24]
 8045a00:	2a03      	cmp	r2, #3
 8045a02:	fb01 f303 	mul.w	r3, r1, r3
 8045a06:	d003      	beq.n	8045a10 <kad_op_ce_bin_neg+0x84>
 8045a08:	f8d8 201c 	ldr.w	r2, [r8, #28]
 8045a0c:	fb02 f303 	mul.w	r3, r2, r3
		if (n != kad_len(y1)) return -1;
 8045a10:	429e      	cmp	r6, r3
 8045a12:	f040 8110 	bne.w	8045c36 <kad_op_ce_bin_neg+0x2aa>
		p->n_d = 0;
 8045a16:	2300      	movs	r3, #0
 8045a18:	f889 3000 	strb.w	r3, [r9]
 8045a1c:	e7d9      	b.n	80459d2 <kad_op_ce_bin_neg+0x46>
	if (action == KAD_SYNC_DIM) {
 8045a1e:	2904      	cmp	r1, #4
 8045a20:	f000 8092 	beq.w	8045b48 <kad_op_ce_bin_neg+0x1bc>
	} else if (action == KAD_FORWARD) {
 8045a24:	2902      	cmp	r1, #2
	int n = 1, i;
 8045a26:	f04f 0601 	mov.w	r6, #1
 8045a2a:	d1cf      	bne.n	80459cc <kad_op_ce_bin_neg+0x40>
 8045a2c:	e002      	b.n	8045a34 <kad_op_ce_bin_neg+0xa8>
		for (i = 0; i < n; ++i) {
 8045a2e:	2e00      	cmp	r6, #0
 8045a30:	f340 80fe 	ble.w	8045c30 <kad_op_ce_bin_neg+0x2a4>
			if (1.0f + y0->x[i] > 0.0f)
 8045a34:	eef7 8a00 	vmov.f32	s17, #112	@ 0x3f800000  1.0
				cost += .5f * (1.0f + y0->x[i]) * log((1.0f + y0->x[i]) / (1.0f + y1->x[i] > tiny? 1.0f + y1->x[i] : tiny));
 8045a38:	eeb6 aa00 	vmov.f32	s20, #96	@ 0x3f000000  0.5
 8045a3c:	eddf 9a7f 	vldr	s19, [pc, #508]	@ 8045c3c <kad_op_ce_bin_neg+0x2b0>
		double cost = 0.0;
 8045a40:	2400      	movs	r4, #0
 8045a42:	2500      	movs	r5, #0
		for (i = 0; i < n; ++i) {
 8045a44:	2700      	movs	r7, #0
 8045a46:	f8d3 b028 	ldr.w	fp, [r3, #40]	@ 0x28
			if (1.0f + y0->x[i] > 0.0f)
 8045a4a:	ecbb 8a01 	vldmia	fp!, {s16}
 8045a4e:	ee38 9a28 	vadd.f32	s18, s16, s17
 8045a52:	eeb5 9ac0 	vcmpe.f32	s18, #0.0
 8045a56:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8045a5a:	ea4f 0a87 	mov.w	sl, r7, lsl #2
		for (i = 0; i < n; ++i) {
 8045a5e:	f107 0701 	add.w	r7, r7, #1
			if (1.0f + y0->x[i] > 0.0f)
 8045a62:	dd2c      	ble.n	8045abe <kad_op_ce_bin_neg+0x132>
				cost += .5f * (1.0f + y0->x[i]) * log((1.0f + y0->x[i]) / (1.0f + y1->x[i] > tiny? 1.0f + y1->x[i] : tiny));
 8045a64:	ee69 7a0a 	vmul.f32	s15, s18, s20
 8045a68:	ee17 0a90 	vmov	r0, s15
 8045a6c:	f7fa fd48 	bl	8040500 <__aeabi_f2d>
 8045a70:	f8d8 3028 	ldr.w	r3, [r8, #40]	@ 0x28
 8045a74:	e9cd 0100 	strd	r0, r1, [sp]
 8045a78:	4453      	add	r3, sl
 8045a7a:	edd3 7a00 	vldr	s15, [r3]
 8045a7e:	ee77 7aa8 	vadd.f32	s15, s15, s17
 8045a82:	eef4 7ae9 	vcmpe.f32	s15, s19
 8045a86:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8045a8a:	fe77 7aa9 	vselgt.f32	s15, s15, s19
 8045a8e:	eec9 7a27 	vdiv.f32	s15, s18, s15
 8045a92:	ee17 0a90 	vmov	r0, s15
 8045a96:	f7fa fd33 	bl	8040500 <__aeabi_f2d>
 8045a9a:	ec41 0b10 	vmov	d0, r0, r1
 8045a9e:	f007 f8b7 	bl	804cc10 <log>
 8045aa2:	e9dd 0100 	ldrd	r0, r1, [sp]
 8045aa6:	ec53 2b10 	vmov	r2, r3, d0
 8045aaa:	f7fa fd81 	bl	80405b0 <__aeabi_dmul>
 8045aae:	4602      	mov	r2, r0
 8045ab0:	460b      	mov	r3, r1
 8045ab2:	4620      	mov	r0, r4
 8045ab4:	4629      	mov	r1, r5
 8045ab6:	f7fa fbc5 	bl	8040244 <__adddf3>
 8045aba:	4604      	mov	r4, r0
 8045abc:	460d      	mov	r5, r1
			if (1.0f - y0->x[i] > 0.0f)
 8045abe:	ee38 8ac8 	vsub.f32	s16, s17, s16
 8045ac2:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
 8045ac6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8045aca:	dd2c      	ble.n	8045b26 <kad_op_ce_bin_neg+0x19a>
				cost += .5f * (1.0f - y0->x[i]) * log((1.0f - y0->x[i]) / (1.0f - y1->x[i] > tiny? 1.0f - y1->x[i] : tiny));
 8045acc:	ee68 7a0a 	vmul.f32	s15, s16, s20
 8045ad0:	ee17 0a90 	vmov	r0, s15
 8045ad4:	f7fa fd14 	bl	8040500 <__aeabi_f2d>
 8045ad8:	f8d8 3028 	ldr.w	r3, [r8, #40]	@ 0x28
 8045adc:	e9cd 0100 	strd	r0, r1, [sp]
 8045ae0:	4453      	add	r3, sl
 8045ae2:	edd3 7a00 	vldr	s15, [r3]
 8045ae6:	ee78 7ae7 	vsub.f32	s15, s17, s15
 8045aea:	eef4 7ae9 	vcmpe.f32	s15, s19
 8045aee:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8045af2:	fe77 7aa9 	vselgt.f32	s15, s15, s19
 8045af6:	eec8 7a27 	vdiv.f32	s15, s16, s15
 8045afa:	ee17 0a90 	vmov	r0, s15
 8045afe:	f7fa fcff 	bl	8040500 <__aeabi_f2d>
 8045b02:	ec41 0b10 	vmov	d0, r0, r1
 8045b06:	f007 f883 	bl	804cc10 <log>
 8045b0a:	e9dd 0100 	ldrd	r0, r1, [sp]
 8045b0e:	ec53 2b10 	vmov	r2, r3, d0
 8045b12:	f7fa fd4d 	bl	80405b0 <__aeabi_dmul>
 8045b16:	4602      	mov	r2, r0
 8045b18:	460b      	mov	r3, r1
 8045b1a:	4620      	mov	r0, r4
 8045b1c:	4629      	mov	r1, r5
 8045b1e:	f7fa fb91 	bl	8040244 <__adddf3>
 8045b22:	4604      	mov	r4, r0
 8045b24:	460d      	mov	r5, r1
		for (i = 0; i < n; ++i) {
 8045b26:	42b7      	cmp	r7, r6
 8045b28:	db8f      	blt.n	8045a4a <kad_op_ce_bin_neg+0xbe>
		p->x[0] = (float)(cost / n);
 8045b2a:	4630      	mov	r0, r6
 8045b2c:	f7fa fcd6 	bl	80404dc <__aeabi_i2d>
 8045b30:	460b      	mov	r3, r1
 8045b32:	4602      	mov	r2, r0
 8045b34:	4629      	mov	r1, r5
 8045b36:	4620      	mov	r0, r4
 8045b38:	f7fa fe64 	bl	8040804 <__aeabi_ddiv>
 8045b3c:	f7fb f810 	bl	8040b60 <__aeabi_d2f>
 8045b40:	f8d9 3028 	ldr.w	r3, [r9, #40]	@ 0x28
 8045b44:	6018      	str	r0, [r3, #0]
 8045b46:	e744      	b.n	80459d2 <kad_op_ce_bin_neg+0x46>
	for (i = 0; i < p->n_d; ++i) n *= p->d[i];
 8045b48:	f898 2000 	ldrb.w	r2, [r8]
 8045b4c:	2a00      	cmp	r2, #0
 8045b4e:	f43f af62 	beq.w	8045a16 <kad_op_ce_bin_neg+0x8a>
	int n = 1, i;
 8045b52:	2601      	movs	r6, #1
 8045b54:	e748      	b.n	80459e8 <kad_op_ce_bin_neg+0x5c>
	} else if (action == KAD_BACKWARD && kad_is_back(y1)) {
 8045b56:	f898 2001 	ldrb.w	r2, [r8, #1]
 8045b5a:	07d2      	lsls	r2, r2, #31
 8045b5c:	f57f af39 	bpl.w	80459d2 <kad_op_ce_bin_neg+0x46>
		float t = p->g[0] / n;
 8045b60:	ee07 6a90 	vmov	s15, r6
 8045b64:	f8d9 202c 	ldr.w	r2, [r9, #44]	@ 0x2c
 8045b68:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8045b6c:	ed92 7a00 	vldr	s14, [r2]
		for (i = 0; i < n; ++i) {
 8045b70:	2e00      	cmp	r6, #0
		float t = p->g[0] / n;
 8045b72:	eec7 4a27 	vdiv.f32	s9, s14, s15
		for (i = 0; i < n; ++i) {
 8045b76:	f77f af2c 	ble.w	80459d2 <kad_op_ce_bin_neg+0x46>
			if (1.0f + y0->x[i] > 0.0f)
 8045b7a:	2200      	movs	r2, #0
 8045b7c:	eeb7 6a00 	vmov.f32	s12, #112	@ 0x3f800000  1.0
				y1->g[i] -= .5f * t * (1.0f + y0->x[i]) / (1.0f + y1->x[i] > tiny? 1.0f + y1->x[i] : tiny);
 8045b80:	eeb6 4a00 	vmov.f32	s8, #96	@ 0x3f000000  0.5
 8045b84:	eddf 5a2d 	vldr	s11, [pc, #180]	@ 8045c3c <kad_op_ce_bin_neg+0x2b0>
 8045b88:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8045b8a:	eb03 0686 	add.w	r6, r3, r6, lsl #2
			if (1.0f + y0->x[i] > 0.0f)
 8045b8e:	ecf3 7a01 	vldmia	r3!, {s15}
 8045b92:	ee77 6a86 	vadd.f32	s13, s15, s12
 8045b96:	eef5 6ac0 	vcmpe.f32	s13, #0.0
 8045b9a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8045b9e:	dd1d      	ble.n	8045bdc <kad_op_ce_bin_neg+0x250>
				y1->g[i] -= .5f * t * (1.0f + y0->x[i]) / (1.0f + y1->x[i] > tiny? 1.0f + y1->x[i] : tiny);
 8045ba0:	f8d8 1028 	ldr.w	r1, [r8, #40]	@ 0x28
 8045ba4:	ee24 7a84 	vmul.f32	s14, s9, s8
 8045ba8:	4411      	add	r1, r2
 8045baa:	edd1 7a00 	vldr	s15, [r1]
 8045bae:	ee77 7a86 	vadd.f32	s15, s15, s12
 8045bb2:	eef4 7ae5 	vcmpe.f32	s15, s11
 8045bb6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8045bba:	ee27 7a26 	vmul.f32	s14, s14, s13
 8045bbe:	f8d8 102c 	ldr.w	r1, [r8, #44]	@ 0x2c
 8045bc2:	fe77 7aa5 	vselgt.f32	s15, s15, s11
 8045bc6:	4411      	add	r1, r2
 8045bc8:	ed91 5a00 	vldr	s10, [r1]
 8045bcc:	eec7 6a27 	vdiv.f32	s13, s14, s15
 8045bd0:	ee75 7a66 	vsub.f32	s15, s10, s13
 8045bd4:	edc1 7a00 	vstr	s15, [r1]
			if (1.0f - y0->x[i] > 0.0f)
 8045bd8:	ed53 7a01 	vldr	s15, [r3, #-4]
 8045bdc:	ee76 7a67 	vsub.f32	s15, s12, s15
 8045be0:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8045be4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8045be8:	dd1b      	ble.n	8045c22 <kad_op_ce_bin_neg+0x296>
				y1->g[i] += .5f * t * (1.0f - y0->x[i]) / (1.0f - y1->x[i] > tiny? 1.0f - y1->x[i] : tiny);
 8045bea:	f8d8 1028 	ldr.w	r1, [r8, #40]	@ 0x28
 8045bee:	ee64 6a84 	vmul.f32	s13, s9, s8
 8045bf2:	4411      	add	r1, r2
 8045bf4:	ed91 7a00 	vldr	s14, [r1]
 8045bf8:	ee66 6aa7 	vmul.f32	s13, s13, s15
 8045bfc:	ee76 7a47 	vsub.f32	s15, s12, s14
 8045c00:	eef4 7ae5 	vcmpe.f32	s15, s11
 8045c04:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8045c08:	f8d8 102c 	ldr.w	r1, [r8, #44]	@ 0x2c
 8045c0c:	fe77 7aa5 	vselgt.f32	s15, s15, s11
 8045c10:	4411      	add	r1, r2
 8045c12:	ed91 5a00 	vldr	s10, [r1]
 8045c16:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 8045c1a:	ee77 7a05 	vadd.f32	s15, s14, s10
 8045c1e:	edc1 7a00 	vstr	s15, [r1]
		for (i = 0; i < n; ++i) {
 8045c22:	42b3      	cmp	r3, r6
 8045c24:	f102 0204 	add.w	r2, r2, #4
 8045c28:	d1b1      	bne.n	8045b8e <kad_op_ce_bin_neg+0x202>
 8045c2a:	e6d2      	b.n	80459d2 <kad_op_ce_bin_neg+0x46>
 8045c2c:	2301      	movs	r3, #1
 8045c2e:	e6ef      	b.n	8045a10 <kad_op_ce_bin_neg+0x84>
		double cost = 0.0;
 8045c30:	2400      	movs	r4, #0
 8045c32:	2500      	movs	r5, #0
 8045c34:	e779      	b.n	8045b2a <kad_op_ce_bin_neg+0x19e>
		if (n != kad_len(y1)) return -1;
 8045c36:	f04f 30ff 	mov.w	r0, #4294967295
 8045c3a:	e6cb      	b.n	80459d4 <kad_op_ce_bin_neg+0x48>
 8045c3c:	3089705f 	.word	0x3089705f

08045c40 <kad_op_ce_multi>:
{
 8045c40:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8045c44:	ed2d 8b02 	vpush	{d8}
	kad_node_t *y1 = p->child[0]; /* test */
 8045c48:	6b87      	ldr	r7, [r0, #56]	@ 0x38
{
 8045c4a:	b08b      	sub	sp, #44	@ 0x2c
	kad_node_t *y1 = p->child[0]; /* test */
 8045c4c:	e9d7 5200 	ldrd	r5, r2, [r7]
{
 8045c50:	9002      	str	r0, [sp, #8]
	n1 = y0->d[y0->n_d - 1];
 8045c52:	7810      	ldrb	r0, [r2, #0]
 8045c54:	1cc3      	adds	r3, r0, #3
 8045c56:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
	for (i = 0; i < p->n_d; ++i) n *= p->d[i];
 8045c5a:	2800      	cmp	r0, #0
 8045c5c:	f000 80ea 	beq.w	8045e34 <kad_op_ce_multi+0x1f4>
 8045c60:	2801      	cmp	r0, #1
 8045c62:	6914      	ldr	r4, [r2, #16]
 8045c64:	d00c      	beq.n	8045c80 <kad_op_ce_multi+0x40>
 8045c66:	6956      	ldr	r6, [r2, #20]
 8045c68:	2802      	cmp	r0, #2
 8045c6a:	fb06 f404 	mul.w	r4, r6, r4
 8045c6e:	d007      	beq.n	8045c80 <kad_op_ce_multi+0x40>
 8045c70:	6996      	ldr	r6, [r2, #24]
 8045c72:	2803      	cmp	r0, #3
 8045c74:	fb06 f404 	mul.w	r4, r6, r4
 8045c78:	d002      	beq.n	8045c80 <kad_op_ce_multi+0x40>
 8045c7a:	69d6      	ldr	r6, [r2, #28]
 8045c7c:	fb06 f404 	mul.w	r4, r6, r4
	d0 = kad_len(y0) / n1;
 8045c80:	fb94 fcf3 	sdiv	ip, r4, r3
	if (p->n_child == 3) {
 8045c84:	9c02      	ldr	r4, [sp, #8]
 8045c86:	6864      	ldr	r4, [r4, #4]
 8045c88:	2c03      	cmp	r4, #3
 8045c8a:	d043      	beq.n	8045d14 <kad_op_ce_multi+0xd4>
	if (action == KAD_SYNC_DIM) {
 8045c8c:	2904      	cmp	r1, #4
 8045c8e:	d00d      	beq.n	8045cac <kad_op_ce_multi+0x6c>
	} else if (action == KAD_FORWARD) {
 8045c90:	2902      	cmp	r1, #2
 8045c92:	f000 811f 	beq.w	8045ed4 <kad_op_ce_multi+0x294>
	kad_node_t *c = 0;
 8045c96:	f04f 0900 	mov.w	r9, #0
	} else if (action == KAD_BACKWARD && kad_is_back(y1)) {
 8045c9a:	2903      	cmp	r1, #3
 8045c9c:	f000 80cc 	beq.w	8045e38 <kad_op_ce_multi+0x1f8>
	return 0;
 8045ca0:	2000      	movs	r0, #0
}
 8045ca2:	b00b      	add	sp, #44	@ 0x2c
 8045ca4:	ecbd 8b02 	vpop	{d8}
 8045ca8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8045cac:	7829      	ldrb	r1, [r5, #0]
 8045cae:	2800      	cmp	r0, #0
 8045cb0:	f000 8172 	beq.w	8045f98 <kad_op_ce_multi+0x358>
 8045cb4:	2801      	cmp	r0, #1
 8045cb6:	6914      	ldr	r4, [r2, #16]
 8045cb8:	d00c      	beq.n	8045cd4 <kad_op_ce_multi+0x94>
 8045cba:	6956      	ldr	r6, [r2, #20]
 8045cbc:	2802      	cmp	r0, #2
 8045cbe:	fb06 f404 	mul.w	r4, r6, r4
 8045cc2:	d007      	beq.n	8045cd4 <kad_op_ce_multi+0x94>
 8045cc4:	6996      	ldr	r6, [r2, #24]
 8045cc6:	2803      	cmp	r0, #3
 8045cc8:	fb06 f404 	mul.w	r4, r6, r4
 8045ccc:	d002      	beq.n	8045cd4 <kad_op_ce_multi+0x94>
 8045cce:	69d2      	ldr	r2, [r2, #28]
 8045cd0:	fb02 f404 	mul.w	r4, r2, r4
 8045cd4:	2900      	cmp	r1, #0
 8045cd6:	f000 8164 	beq.w	8045fa2 <kad_op_ce_multi+0x362>
 8045cda:	2901      	cmp	r1, #1
 8045cdc:	692a      	ldr	r2, [r5, #16]
 8045cde:	dd0c      	ble.n	8045cfa <kad_op_ce_multi+0xba>
 8045ce0:	6968      	ldr	r0, [r5, #20]
 8045ce2:	2902      	cmp	r1, #2
 8045ce4:	fb00 f202 	mul.w	r2, r0, r2
 8045ce8:	d007      	beq.n	8045cfa <kad_op_ce_multi+0xba>
 8045cea:	69a8      	ldr	r0, [r5, #24]
 8045cec:	2903      	cmp	r1, #3
 8045cee:	fb00 f202 	mul.w	r2, r0, r2
 8045cf2:	d002      	beq.n	8045cfa <kad_op_ce_multi+0xba>
 8045cf4:	69e8      	ldr	r0, [r5, #28]
 8045cf6:	fb00 f202 	mul.w	r2, r0, r2
		if (kad_len(y0) != kad_len(y1) || y0->d[y0->n_d - 1] != y1->d[y1->n_d - 1]) return -1;
 8045cfa:	4294      	cmp	r4, r2
 8045cfc:	f040 818b 	bne.w	8046016 <kad_op_ce_multi+0x3d6>
 8045d00:	3103      	adds	r1, #3
 8045d02:	f855 2021 	ldr.w	r2, [r5, r1, lsl #2]
 8045d06:	429a      	cmp	r2, r3
 8045d08:	f040 8185 	bne.w	8046016 <kad_op_ce_multi+0x3d6>
		p->n_d = 0;
 8045d0c:	2300      	movs	r3, #0
 8045d0e:	9a02      	ldr	r2, [sp, #8]
 8045d10:	7013      	strb	r3, [r2, #0]
 8045d12:	e7c5      	b.n	8045ca0 <kad_op_ce_multi+0x60>
		c = p->child[2];
 8045d14:	f8d7 9008 	ldr.w	r9, [r7, #8]
		assert(c->n_d == 1 && c->d[0] == n1);
 8045d18:	f899 4000 	ldrb.w	r4, [r9]
 8045d1c:	2c01      	cmp	r4, #1
 8045d1e:	f040 817d 	bne.w	804601c <kad_op_ce_multi+0x3dc>
 8045d22:	f8d9 4010 	ldr.w	r4, [r9, #16]
 8045d26:	429c      	cmp	r4, r3
 8045d28:	f040 8178 	bne.w	804601c <kad_op_ce_multi+0x3dc>
	if (action == KAD_SYNC_DIM) {
 8045d2c:	2904      	cmp	r1, #4
 8045d2e:	d0bd      	beq.n	8045cac <kad_op_ce_multi+0x6c>
	} else if (action == KAD_FORWARD) {
 8045d30:	2902      	cmp	r1, #2
 8045d32:	d1b2      	bne.n	8045c9a <kad_op_ce_multi+0x5a>
			for (j = 0; j < d0; ++j) {
 8045d34:	f1bc 0f00 	cmp.w	ip, #0
 8045d38:	f340 8135 	ble.w	8045fa6 <kad_op_ce_multi+0x366>
				float *x1 = &y1->x[j * n1], *x0 = &y0->x[j * n1];
 8045d3c:	2600      	movs	r6, #0
			for (j = 0; j < d0; ++j) {
 8045d3e:	e9cd c306 	strd	ip, r3, [sp, #24]
						cost += c->x[i] * x0[i] * log(x0[i] / (x1[i] > tiny? x1[i] : tiny));
 8045d42:	eddf 8aba 	vldr	s17, [pc, #744]	@ 804602c <kad_op_ce_multi+0x3ec>
		double cost = 0.0;
 8045d46:	f04f 0a00 	mov.w	sl, #0
 8045d4a:	f04f 0b00 	mov.w	fp, #0
			for (j = 0; j < d0; ++j) {
 8045d4e:	46b4      	mov	ip, r6
 8045d50:	6a91      	ldr	r1, [r2, #40]	@ 0x28
				float *x1 = &y1->x[j * n1], *x0 = &y0->x[j * n1];
 8045d52:	6aaa      	ldr	r2, [r5, #40]	@ 0x28
 8045d54:	009f      	lsls	r7, r3, #2
 8045d56:	9208      	str	r2, [sp, #32]
 8045d58:	eb01 0883 	add.w	r8, r1, r3, lsl #2
 8045d5c:	f1c1 0e00 	rsb	lr, r1, #0
			for (j = 0; j < d0; ++j) {
 8045d60:	9109      	str	r1, [sp, #36]	@ 0x24
				for (i = 0; i < n1; ++i)
 8045d62:	9b07      	ldr	r3, [sp, #28]
 8045d64:	2b00      	cmp	r3, #0
 8045d66:	dd4c      	ble.n	8045e02 <kad_op_ce_multi+0x1c2>
 8045d68:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8045d6a:	e9cd 7604 	strd	r7, r6, [sp, #16]
 8045d6e:	199c      	adds	r4, r3, r6
 8045d70:	9b08      	ldr	r3, [sp, #32]
 8045d72:	f8cd c00c 	str.w	ip, [sp, #12]
 8045d76:	199d      	adds	r5, r3, r6
 8045d78:	f8cd e004 	str.w	lr, [sp, #4]
					if (x0[i] > 0.0f)
 8045d7c:	ed94 8a00 	vldr	s16, [r4]
 8045d80:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
 8045d84:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8045d88:	4622      	mov	r2, r4
 8045d8a:	f104 0404 	add.w	r4, r4, #4
 8045d8e:	dd2e      	ble.n	8045dee <kad_op_ce_multi+0x1ae>
						cost += c->x[i] * x0[i] * log(x0[i] / (x1[i] > tiny? x1[i] : tiny));
 8045d90:	9901      	ldr	r1, [sp, #4]
 8045d92:	f8d9 3028 	ldr.w	r3, [r9, #40]	@ 0x28
 8045d96:	440b      	add	r3, r1
 8045d98:	4413      	add	r3, r2
 8045d9a:	edd3 7a00 	vldr	s15, [r3]
 8045d9e:	ee68 7a27 	vmul.f32	s15, s16, s15
 8045da2:	ee17 0a90 	vmov	r0, s15
 8045da6:	f7fa fbab 	bl	8040500 <__aeabi_f2d>
 8045daa:	edd5 7a00 	vldr	s15, [r5]
 8045dae:	eef4 7ae8 	vcmpe.f32	s15, s17
 8045db2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8045db6:	fe77 7aa8 	vselgt.f32	s15, s15, s17
 8045dba:	eec8 7a27 	vdiv.f32	s15, s16, s15
 8045dbe:	4606      	mov	r6, r0
 8045dc0:	ee17 0a90 	vmov	r0, s15
 8045dc4:	460f      	mov	r7, r1
 8045dc6:	f7fa fb9b 	bl	8040500 <__aeabi_f2d>
 8045dca:	ec41 0b10 	vmov	d0, r0, r1
 8045dce:	f006 ff1f 	bl	804cc10 <log>
 8045dd2:	4630      	mov	r0, r6
 8045dd4:	ec53 2b10 	vmov	r2, r3, d0
 8045dd8:	4639      	mov	r1, r7
 8045dda:	f7fa fbe9 	bl	80405b0 <__aeabi_dmul>
 8045dde:	4602      	mov	r2, r0
 8045de0:	460b      	mov	r3, r1
 8045de2:	4650      	mov	r0, sl
 8045de4:	4659      	mov	r1, fp
 8045de6:	f7fa fa2d 	bl	8040244 <__adddf3>
 8045dea:	4682      	mov	sl, r0
 8045dec:	468b      	mov	fp, r1
				for (i = 0; i < n1; ++i)
 8045dee:	45a0      	cmp	r8, r4
 8045df0:	f105 0504 	add.w	r5, r5, #4
 8045df4:	d1c2      	bne.n	8045d7c <kad_op_ce_multi+0x13c>
 8045df6:	e9dd 7604 	ldrd	r7, r6, [sp, #16]
 8045dfa:	f8dd c00c 	ldr.w	ip, [sp, #12]
 8045dfe:	f8dd e004 	ldr.w	lr, [sp, #4]
			for (j = 0; j < d0; ++j) {
 8045e02:	9b06      	ldr	r3, [sp, #24]
 8045e04:	f10c 0c01 	add.w	ip, ip, #1
 8045e08:	4563      	cmp	r3, ip
 8045e0a:	44b8      	add	r8, r7
 8045e0c:	ebae 0e07 	sub.w	lr, lr, r7
 8045e10:	443e      	add	r6, r7
 8045e12:	d1a6      	bne.n	8045d62 <kad_op_ce_multi+0x122>
 8045e14:	469c      	mov	ip, r3
		p->x[0] = (float)(cost / d0);
 8045e16:	4660      	mov	r0, ip
 8045e18:	f7fa fb60 	bl	80404dc <__aeabi_i2d>
 8045e1c:	460b      	mov	r3, r1
 8045e1e:	4602      	mov	r2, r0
 8045e20:	4659      	mov	r1, fp
 8045e22:	4650      	mov	r0, sl
 8045e24:	f7fa fcee 	bl	8040804 <__aeabi_ddiv>
 8045e28:	f7fa fe9a 	bl	8040b60 <__aeabi_d2f>
 8045e2c:	9b02      	ldr	r3, [sp, #8]
 8045e2e:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8045e30:	6018      	str	r0, [r3, #0]
 8045e32:	e735      	b.n	8045ca0 <kad_op_ce_multi+0x60>
	int n = 1, i;
 8045e34:	2401      	movs	r4, #1
 8045e36:	e723      	b.n	8045c80 <kad_op_ce_multi+0x40>
	} else if (action == KAD_BACKWARD && kad_is_back(y1)) {
 8045e38:	7869      	ldrb	r1, [r5, #1]
 8045e3a:	07c9      	lsls	r1, r1, #31
 8045e3c:	f57f af30 	bpl.w	8045ca0 <kad_op_ce_multi+0x60>
		float t = p->g[0] / d0;
 8045e40:	ee07 ca90 	vmov	s15, ip
 8045e44:	9902      	ldr	r1, [sp, #8]
 8045e46:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8045e4a:	6ac9      	ldr	r1, [r1, #44]	@ 0x2c
 8045e4c:	ed91 7a00 	vldr	s14, [r1]
 8045e50:	ee87 5a27 	vdiv.f32	s10, s14, s15
		if (c == 0) {
 8045e54:	f1b9 0f00 	cmp.w	r9, #0
 8045e58:	f000 80aa 	beq.w	8045fb0 <kad_op_ce_multi+0x370>
			for (j = 0; j < d0; ++j) {
 8045e5c:	f1bc 0f00 	cmp.w	ip, #0
 8045e60:	f77f af1e 	ble.w	8045ca0 <kad_op_ce_multi+0x60>
				float *g = &y1->g[j * n1], *x1 = &y1->x[j * n1], *x0 = &y0->x[j * n1];
 8045e64:	e9d5 8e0a 	ldrd	r8, lr, [r5, #40]	@ 0x28
 8045e68:	2b00      	cmp	r3, #0
 8045e6a:	f8d2 a028 	ldr.w	sl, [r2, #40]	@ 0x28
 8045e6e:	f77f af17 	ble.w	8045ca0 <kad_op_ce_multi+0x60>
					g[i] -= t * c->x[i] * x0[i] / (x1[i] > tiny? x1[i] : tiny);
 8045e72:	2600      	movs	r6, #0
 8045e74:	ed9f 6a6d 	vldr	s12, [pc, #436]	@ 804602c <kad_op_ce_multi+0x3ec>
			for (j = 0; j < d0; ++j) {
 8045e78:	4637      	mov	r7, r6
 8045e7a:	f8d9 b028 	ldr.w	fp, [r9, #40]	@ 0x28
 8045e7e:	eb0e 0583 	add.w	r5, lr, r3, lsl #2
 8045e82:	ea4f 0983 	mov.w	r9, r3, lsl #2
 8045e86:	465c      	mov	r4, fp
 8045e88:	eb0e 0286 	add.w	r2, lr, r6, lsl #2
 8045e8c:	eb0a 0086 	add.w	r0, sl, r6, lsl #2
 8045e90:	eb08 0186 	add.w	r1, r8, r6, lsl #2
					g[i] -= t * c->x[i] * x0[i] / (x1[i] > tiny? x1[i] : tiny);
 8045e94:	ecb1 7a01 	vldmia	r1!, {s14}
 8045e98:	ecf4 7a01 	vldmia	r4!, {s15}
 8045e9c:	eeb4 7ac6 	vcmpe.f32	s14, s12
 8045ea0:	ecf0 5a01 	vldmia	r0!, {s11}
 8045ea4:	ee65 7a27 	vmul.f32	s15, s10, s15
 8045ea8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8045eac:	ee67 7aa5 	vmul.f32	s15, s15, s11
 8045eb0:	fe37 7a06 	vselgt.f32	s14, s14, s12
 8045eb4:	ecf2 6a01 	vldmia	r2!, {s13}
 8045eb8:	eec7 5a87 	vdiv.f32	s11, s15, s14
 8045ebc:	ee76 7ae5 	vsub.f32	s15, s13, s11
				for (i = 0; i < n1; ++i)
 8045ec0:	4295      	cmp	r5, r2
					g[i] -= t * c->x[i] * x0[i] / (x1[i] > tiny? x1[i] : tiny);
 8045ec2:	ed42 7a01 	vstr	s15, [r2, #-4]
				for (i = 0; i < n1; ++i)
 8045ec6:	d1e5      	bne.n	8045e94 <kad_op_ce_multi+0x254>
			for (j = 0; j < d0; ++j) {
 8045ec8:	3701      	adds	r7, #1
 8045eca:	45bc      	cmp	ip, r7
 8045ecc:	444d      	add	r5, r9
 8045ece:	441e      	add	r6, r3
 8045ed0:	d1d9      	bne.n	8045e86 <kad_op_ce_multi+0x246>
 8045ed2:	e6e5      	b.n	8045ca0 <kad_op_ce_multi+0x60>
			for (j = 0; j < d0; ++j) {
 8045ed4:	f1bc 0f00 	cmp.w	ip, #0
 8045ed8:	dd65      	ble.n	8045fa6 <kad_op_ce_multi+0x366>
				float *x1 = &y1->x[j * n1], *x0 = &y0->x[j * n1];
 8045eda:	2400      	movs	r4, #0
 8045edc:	f8d2 9028 	ldr.w	r9, [r2, #40]	@ 0x28
						cost += x0[i] * log(x0[i] / (x1[i] > tiny? x1[i] : tiny));
 8045ee0:	eddf 8a52 	vldr	s17, [pc, #328]	@ 804602c <kad_op_ce_multi+0x3ec>
				float *x1 = &y1->x[j * n1], *x0 = &y0->x[j * n1];
 8045ee4:	6aaa      	ldr	r2, [r5, #40]	@ 0x28
 8045ee6:	eb09 0883 	add.w	r8, r9, r3, lsl #2
			for (j = 0; j < d0; ++j) {
 8045eea:	f8cd 901c 	str.w	r9, [sp, #28]
		double cost = 0.0;
 8045eee:	f04f 0a00 	mov.w	sl, #0
 8045ef2:	f04f 0b00 	mov.w	fp, #0
			for (j = 0; j < d0; ++j) {
 8045ef6:	4625      	mov	r5, r4
 8045ef8:	4699      	mov	r9, r3
				float *x1 = &y1->x[j * n1], *x0 = &y0->x[j * n1];
 8045efa:	9206      	str	r2, [sp, #24]
 8045efc:	009a      	lsls	r2, r3, #2
 8045efe:	9205      	str	r2, [sp, #20]
			for (j = 0; j < d0; ++j) {
 8045f00:	f8cd c010 	str.w	ip, [sp, #16]
				for (i = 0; i < n1; ++i)
 8045f04:	f1b9 0f00 	cmp.w	r9, #0
 8045f08:	dd3e      	ble.n	8045f88 <kad_op_ce_multi+0x348>
 8045f0a:	f8cd 9004 	str.w	r9, [sp, #4]
 8045f0e:	46a9      	mov	r9, r5
 8045f10:	9b07      	ldr	r3, [sp, #28]
 8045f12:	9403      	str	r4, [sp, #12]
 8045f14:	eb03 0684 	add.w	r6, r3, r4, lsl #2
 8045f18:	9b06      	ldr	r3, [sp, #24]
 8045f1a:	eb03 0784 	add.w	r7, r3, r4, lsl #2
					if (x0[i] > 0.0f)
 8045f1e:	ecb6 8a01 	vldmia	r6!, {s16}
 8045f22:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
 8045f26:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8045f2a:	dd25      	ble.n	8045f78 <kad_op_ce_multi+0x338>
						cost += x0[i] * log(x0[i] / (x1[i] > tiny? x1[i] : tiny));
 8045f2c:	ee18 0a10 	vmov	r0, s16
 8045f30:	f7fa fae6 	bl	8040500 <__aeabi_f2d>
 8045f34:	edd7 7a00 	vldr	s15, [r7]
 8045f38:	eef4 7ae8 	vcmpe.f32	s15, s17
 8045f3c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8045f40:	fe77 7aa8 	vselgt.f32	s15, s15, s17
 8045f44:	eec8 7a27 	vdiv.f32	s15, s16, s15
 8045f48:	4604      	mov	r4, r0
 8045f4a:	ee17 0a90 	vmov	r0, s15
 8045f4e:	460d      	mov	r5, r1
 8045f50:	f7fa fad6 	bl	8040500 <__aeabi_f2d>
 8045f54:	ec41 0b10 	vmov	d0, r0, r1
 8045f58:	f006 fe5a 	bl	804cc10 <log>
 8045f5c:	4620      	mov	r0, r4
 8045f5e:	ec53 2b10 	vmov	r2, r3, d0
 8045f62:	4629      	mov	r1, r5
 8045f64:	f7fa fb24 	bl	80405b0 <__aeabi_dmul>
 8045f68:	4602      	mov	r2, r0
 8045f6a:	460b      	mov	r3, r1
 8045f6c:	4650      	mov	r0, sl
 8045f6e:	4659      	mov	r1, fp
 8045f70:	f7fa f968 	bl	8040244 <__adddf3>
 8045f74:	4682      	mov	sl, r0
 8045f76:	468b      	mov	fp, r1
				for (i = 0; i < n1; ++i)
 8045f78:	4546      	cmp	r6, r8
 8045f7a:	f107 0704 	add.w	r7, r7, #4
 8045f7e:	d1ce      	bne.n	8045f1e <kad_op_ce_multi+0x2de>
 8045f80:	464d      	mov	r5, r9
 8045f82:	9c03      	ldr	r4, [sp, #12]
 8045f84:	f8dd 9004 	ldr.w	r9, [sp, #4]
			for (j = 0; j < d0; ++j) {
 8045f88:	9b05      	ldr	r3, [sp, #20]
 8045f8a:	3501      	adds	r5, #1
 8045f8c:	4498      	add	r8, r3
 8045f8e:	9b04      	ldr	r3, [sp, #16]
 8045f90:	444c      	add	r4, r9
 8045f92:	42ab      	cmp	r3, r5
 8045f94:	d1b6      	bne.n	8045f04 <kad_op_ce_multi+0x2c4>
 8045f96:	e73d      	b.n	8045e14 <kad_op_ce_multi+0x1d4>
	for (i = 0; i < p->n_d; ++i) n *= p->d[i];
 8045f98:	2900      	cmp	r1, #0
 8045f9a:	f43f aeb1 	beq.w	8045d00 <kad_op_ce_multi+0xc0>
 8045f9e:	2401      	movs	r4, #1
 8045fa0:	e69b      	b.n	8045cda <kad_op_ce_multi+0x9a>
	int n = 1, i;
 8045fa2:	2201      	movs	r2, #1
 8045fa4:	e6a9      	b.n	8045cfa <kad_op_ce_multi+0xba>
		double cost = 0.0;
 8045fa6:	f04f 0a00 	mov.w	sl, #0
 8045faa:	f04f 0b00 	mov.w	fp, #0
 8045fae:	e732      	b.n	8045e16 <kad_op_ce_multi+0x1d6>
			for (j = 0; j < d0; ++j) {
 8045fb0:	f1bc 0f00 	cmp.w	ip, #0
 8045fb4:	f77f ae74 	ble.w	8045ca0 <kad_op_ce_multi+0x60>
				float *g = &y1->g[j * n1], *x1 = &y1->x[j * n1], *x0 = &y0->x[j * n1];
 8045fb8:	e9d5 760a 	ldrd	r7, r6, [r5, #40]	@ 0x28
 8045fbc:	2b00      	cmp	r3, #0
 8045fbe:	f8d2 e028 	ldr.w	lr, [r2, #40]	@ 0x28
 8045fc2:	f77f ae6d 	ble.w	8045ca0 <kad_op_ce_multi+0x60>
					g[i] -= t * x0[i] / (x1[i] > tiny? x1[i] : tiny);
 8045fc6:	ed9f 6a19 	vldr	s12, [pc, #100]	@ 804602c <kad_op_ce_multi+0x3ec>
			for (j = 0; j < d0; ++j) {
 8045fca:	464c      	mov	r4, r9
 8045fcc:	009d      	lsls	r5, r3, #2
 8045fce:	eb06 0083 	add.w	r0, r6, r3, lsl #2
				for (i = 0; i < n1; ++i)
 8045fd2:	eb06 0309 	add.w	r3, r6, r9
 8045fd6:	eb0e 0109 	add.w	r1, lr, r9
 8045fda:	eb07 0209 	add.w	r2, r7, r9
					g[i] -= t * x0[i] / (x1[i] > tiny? x1[i] : tiny);
 8045fde:	ecf2 7a01 	vldmia	r2!, {s15}
 8045fe2:	eef4 7ac6 	vcmpe.f32	s15, s12
 8045fe6:	ecf1 6a01 	vldmia	r1!, {s13}
 8045fea:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8045fee:	ee65 6a26 	vmul.f32	s13, s10, s13
 8045ff2:	fe77 7a86 	vselgt.f32	s15, s15, s12
 8045ff6:	ecb3 7a01 	vldmia	r3!, {s14}
 8045ffa:	eec6 5aa7 	vdiv.f32	s11, s13, s15
 8045ffe:	ee77 7a65 	vsub.f32	s15, s14, s11
				for (i = 0; i < n1; ++i)
 8046002:	4298      	cmp	r0, r3
					g[i] -= t * x0[i] / (x1[i] > tiny? x1[i] : tiny);
 8046004:	ed43 7a01 	vstr	s15, [r3, #-4]
				for (i = 0; i < n1; ++i)
 8046008:	d1e9      	bne.n	8045fde <kad_op_ce_multi+0x39e>
			for (j = 0; j < d0; ++j) {
 804600a:	3401      	adds	r4, #1
 804600c:	45a4      	cmp	ip, r4
 804600e:	4428      	add	r0, r5
 8046010:	44a9      	add	r9, r5
 8046012:	d1de      	bne.n	8045fd2 <kad_op_ce_multi+0x392>
 8046014:	e644      	b.n	8045ca0 <kad_op_ce_multi+0x60>
		if (kad_len(y0) != kad_len(y1) || y0->d[y0->n_d - 1] != y1->d[y1->n_d - 1]) return -1;
 8046016:	f04f 30ff 	mov.w	r0, #4294967295
 804601a:	e642      	b.n	8045ca2 <kad_op_ce_multi+0x62>
		assert(c->n_d == 1 && c->d[0] == n1);
 804601c:	f240 6133 	movw	r1, #1587	@ 0x633
 8046020:	4b03      	ldr	r3, [pc, #12]	@ (8046030 <kad_op_ce_multi+0x3f0>)
 8046022:	4a04      	ldr	r2, [pc, #16]	@ (8046034 <kad_op_ce_multi+0x3f4>)
 8046024:	4804      	ldr	r0, [pc, #16]	@ (8046038 <kad_op_ce_multi+0x3f8>)
 8046026:	f005 fbdd 	bl	804b7e4 <__assert_func>
 804602a:	bf00      	nop
 804602c:	3089705f 	.word	0x3089705f
 8046030:	0804e458 	.word	0x0804e458
 8046034:	0804e52c 	.word	0x0804e52c
 8046038:	0804e3dc 	.word	0x0804e3dc

0804603c <kad_op_stdnorm>:
{
 804603c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8046040:	ed2d 8b02 	vpush	{d8}
	kad_node_t *q = p->child[0];
 8046044:	6b83      	ldr	r3, [r0, #56]	@ 0x38
{
 8046046:	b091      	sub	sp, #68	@ 0x44
	kad_node_t *q = p->child[0];
 8046048:	681c      	ldr	r4, [r3, #0]
	assert(q->n_d > 0);
 804604a:	7825      	ldrb	r5, [r4, #0]
 804604c:	2d00      	cmp	r5, #0
 804604e:	f000 8198 	beq.w	8046382 <kad_op_stdnorm+0x346>
	n = q->d[q->n_d - 1];
 8046052:	1ceb      	adds	r3, r5, #3
	for (i = 0; i < p->n_d; ++i) n *= p->d[i];
 8046054:	2d01      	cmp	r5, #1
 8046056:	f854 e023 	ldr.w	lr, [r4, r3, lsl #2]
 804605a:	4606      	mov	r6, r0
 804605c:	6923      	ldr	r3, [r4, #16]
 804605e:	d00b      	beq.n	8046078 <kad_op_stdnorm+0x3c>
 8046060:	6962      	ldr	r2, [r4, #20]
 8046062:	2d02      	cmp	r5, #2
 8046064:	fb02 f303 	mul.w	r3, r2, r3
 8046068:	d006      	beq.n	8046078 <kad_op_stdnorm+0x3c>
 804606a:	69a2      	ldr	r2, [r4, #24]
 804606c:	2d03      	cmp	r5, #3
 804606e:	fb02 f303 	mul.w	r3, r2, r3
 8046072:	bf1c      	itt	ne
 8046074:	69e2      	ldrne	r2, [r4, #28]
 8046076:	4353      	mulne	r3, r2
	if (action == KAD_SYNC_DIM) {
 8046078:	2904      	cmp	r1, #4
	m = kad_len(q) / n;
 804607a:	fb93 f3fe 	sdiv	r3, r3, lr
	if (action == KAD_SYNC_DIM) {
 804607e:	f000 808f 	beq.w	80461a0 <kad_op_stdnorm+0x164>
	} else if (action == KAD_ALLOC) {
 8046082:	2901      	cmp	r1, #1
 8046084:	f000 80af 	beq.w	80461e6 <kad_op_stdnorm+0x1aa>
	} else if (action == KAD_FORWARD) {
 8046088:	2902      	cmp	r1, #2
 804608a:	d008      	beq.n	804609e <kad_op_stdnorm+0x62>
	} else if (action == KAD_BACKWARD && kad_is_back(q)) {
 804608c:	2903      	cmp	r1, #3
 804608e:	f000 80b5 	beq.w	80461fc <kad_op_stdnorm+0x1c0>
}
 8046092:	2000      	movs	r0, #0
 8046094:	b011      	add	sp, #68	@ 0x44
 8046096:	ecbd 8b02 	vpop	{d8}
 804609a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		for (j = 0; j < m; ++j) {
 804609e:	2b00      	cmp	r3, #0
		float *si = (float*)p->gtmp;
 80460a0:	6b72      	ldr	r2, [r6, #52]	@ 0x34
		for (j = 0; j < m; ++j) {
 80460a2:	ddf6      	ble.n	8046092 <kad_op_stdnorm+0x56>
 80460a4:	eb02 0383 	add.w	r3, r2, r3, lsl #2
			std_inv = s == 0.0? 1.0f : (float)(1.0 / sqrt(s / n));
 80460a8:	e9cd e308 	strd	lr, r3, [sp, #32]
 80460ac:	6ab1      	ldr	r1, [r6, #40]	@ 0x28
 80460ae:	f8d4 b028 	ldr.w	fp, [r4, #40]	@ 0x28
			for (i = 0, s = 0.0; i < n; ++i) s += qx[i];
 80460b2:	9b08      	ldr	r3, [sp, #32]
 80460b4:	eb01 078e 	add.w	r7, r1, lr, lsl #2
 80460b8:	eb0b 068e 	add.w	r6, fp, lr, lsl #2
 80460bc:	2b00      	cmp	r3, #0
			std_inv = s == 0.0? 1.0f : (float)(1.0 / sqrt(s / n));
 80460be:	460c      	mov	r4, r1
 80460c0:	9704      	str	r7, [sp, #16]
 80460c2:	9602      	str	r6, [sp, #8]
 80460c4:	ea4f 0a8e 	mov.w	sl, lr, lsl #2
 80460c8:	9200      	str	r2, [sp, #0]
			for (i = 0, s = 0.0; i < n; ++i) s += qx[i];
 80460ca:	dd66      	ble.n	804619a <kad_op_stdnorm+0x15e>
 80460cc:	465d      	mov	r5, fp
 80460ce:	f04f 0800 	mov.w	r8, #0
 80460d2:	f04f 0900 	mov.w	r9, #0
 80460d6:	f855 0b04 	ldr.w	r0, [r5], #4
 80460da:	f7fa fa11 	bl	8040500 <__aeabi_f2d>
 80460de:	4602      	mov	r2, r0
 80460e0:	460b      	mov	r3, r1
 80460e2:	4640      	mov	r0, r8
 80460e4:	4649      	mov	r1, r9
 80460e6:	f7fa f8ad 	bl	8040244 <__adddf3>
 80460ea:	42ae      	cmp	r6, r5
 80460ec:	4680      	mov	r8, r0
 80460ee:	4689      	mov	r9, r1
 80460f0:	d1f1      	bne.n	80460d6 <kad_op_stdnorm+0x9a>
			avg = (float)(s / n);
 80460f2:	9808      	ldr	r0, [sp, #32]
 80460f4:	f7fa f9f2 	bl	80404dc <__aeabi_i2d>
 80460f8:	460b      	mov	r3, r1
 80460fa:	4602      	mov	r2, r0
 80460fc:	4649      	mov	r1, r9
 80460fe:	4640      	mov	r0, r8
 8046100:	e9cd 2306 	strd	r2, r3, [sp, #24]
 8046104:	f7fa fb7e 	bl	8040804 <__aeabi_ddiv>
 8046108:	f7fa fd2a 	bl	8040b60 <__aeabi_d2f>
 804610c:	4623      	mov	r3, r4
 804610e:	ee07 0a10 	vmov	s14, r0
			for (i = 0; i < n; ++i) px[i] = qx[i] - avg;
 8046112:	ecfb 7a01 	vldmia	fp!, {s15}
 8046116:	ee77 7ac7 	vsub.f32	s15, s15, s14
 804611a:	455e      	cmp	r6, fp
 804611c:	ece3 7a01 	vstmia	r3!, {s15}
 8046120:	d1f7      	bne.n	8046112 <kad_op_stdnorm+0xd6>
 8046122:	4625      	mov	r5, r4
			for (i = 0, s = 0.0; i < n; ++i) s += px[i] * px[i];
 8046124:	f04f 0800 	mov.w	r8, #0
 8046128:	f04f 0900 	mov.w	r9, #0
 804612c:	ecf5 7a01 	vldmia	r5!, {s15}
 8046130:	ee67 7aa7 	vmul.f32	s15, s15, s15
 8046134:	ee17 0a90 	vmov	r0, s15
 8046138:	f7fa f9e2 	bl	8040500 <__aeabi_f2d>
 804613c:	4602      	mov	r2, r0
 804613e:	460b      	mov	r3, r1
 8046140:	4640      	mov	r0, r8
 8046142:	4649      	mov	r1, r9
 8046144:	f7fa f87e 	bl	8040244 <__adddf3>
 8046148:	42af      	cmp	r7, r5
 804614a:	4680      	mov	r8, r0
 804614c:	4689      	mov	r9, r1
 804614e:	d1ed      	bne.n	804612c <kad_op_stdnorm+0xf0>
			std_inv = s == 0.0? 1.0f : (float)(1.0 / sqrt(s / n));
 8046150:	2200      	movs	r2, #0
 8046152:	2300      	movs	r3, #0
 8046154:	f7fa fc94 	bl	8040a80 <__aeabi_dcmpeq>
 8046158:	b380      	cbz	r0, 80461bc <kad_op_stdnorm+0x180>
 804615a:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
			for (i = 0; i < n; ++i) px[i] *= std_inv;
 804615e:	edd4 7a00 	vldr	s15, [r4]
 8046162:	ee67 7a87 	vmul.f32	s15, s15, s14
 8046166:	ece4 7a01 	vstmia	r4!, {s15}
 804616a:	42bc      	cmp	r4, r7
 804616c:	d1f7      	bne.n	804615e <kad_op_stdnorm+0x122>
			si[j] = std_inv;
 804616e:	9b00      	ldr	r3, [sp, #0]
		for (j = 0; j < m; ++j) {
 8046170:	9a09      	ldr	r2, [sp, #36]	@ 0x24
			si[j] = std_inv;
 8046172:	eca3 7a01 	vstmia	r3!, {s14}
		for (j = 0; j < m; ++j) {
 8046176:	9804      	ldr	r0, [sp, #16]
 8046178:	9902      	ldr	r1, [sp, #8]
 804617a:	429a      	cmp	r2, r3
 804617c:	4604      	mov	r4, r0
 804617e:	468b      	mov	fp, r1
			si[j] = std_inv;
 8046180:	9300      	str	r3, [sp, #0]
		for (j = 0; j < m; ++j) {
 8046182:	4457      	add	r7, sl
 8046184:	4456      	add	r6, sl
 8046186:	d084      	beq.n	8046092 <kad_op_stdnorm+0x56>
 8046188:	4603      	mov	r3, r0
 804618a:	4453      	add	r3, sl
 804618c:	9304      	str	r3, [sp, #16]
 804618e:	460b      	mov	r3, r1
 8046190:	4453      	add	r3, sl
 8046192:	9302      	str	r3, [sp, #8]
			for (i = 0, s = 0.0; i < n; ++i) s += qx[i];
 8046194:	9b08      	ldr	r3, [sp, #32]
 8046196:	2b00      	cmp	r3, #0
 8046198:	dc98      	bgt.n	80460cc <kad_op_stdnorm+0x90>
			std_inv = s == 0.0? 1.0f : (float)(1.0 / sqrt(s / n));
 804619a:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 804619e:	e7e6      	b.n	804616e <kad_op_stdnorm+0x132>
	dst->n_d = src->n_d;
 80461a0:	4630      	mov	r0, r6
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 80461a2:	00aa      	lsls	r2, r5, #2
 80461a4:	f104 0110 	add.w	r1, r4, #16
	dst->n_d = src->n_d;
 80461a8:	f800 5b10 	strb.w	r5, [r0], #16
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 80461ac:	f005 ff3f 	bl	804c02e <memcpy>
}
 80461b0:	2000      	movs	r0, #0
 80461b2:	b011      	add	sp, #68	@ 0x44
 80461b4:	ecbd 8b02 	vpop	{d8}
 80461b8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			std_inv = s == 0.0? 1.0f : (float)(1.0 / sqrt(s / n));
 80461bc:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
 80461c0:	4640      	mov	r0, r8
 80461c2:	4649      	mov	r1, r9
 80461c4:	f7fa fb1e 	bl	8040804 <__aeabi_ddiv>
 80461c8:	ec41 0b10 	vmov	d0, r0, r1
 80461cc:	f006 fd5e 	bl	804cc8c <sqrt>
 80461d0:	2000      	movs	r0, #0
 80461d2:	ec53 2b10 	vmov	r2, r3, d0
 80461d6:	496e      	ldr	r1, [pc, #440]	@ (8046390 <kad_op_stdnorm+0x354>)
 80461d8:	f7fa fb14 	bl	8040804 <__aeabi_ddiv>
 80461dc:	f7fa fcc0 	bl	8040b60 <__aeabi_d2f>
 80461e0:	ee07 0a10 	vmov	s14, r0
 80461e4:	e7bb      	b.n	804615e <kad_op_stdnorm+0x122>
		p->gtmp = realloc(p->gtmp, m * sizeof(float));
 80461e6:	6b70      	ldr	r0, [r6, #52]	@ 0x34
 80461e8:	0099      	lsls	r1, r3, #2
 80461ea:	f005 fc21 	bl	804ba30 <realloc>
 80461ee:	6370      	str	r0, [r6, #52]	@ 0x34
}
 80461f0:	2000      	movs	r0, #0
 80461f2:	b011      	add	sp, #68	@ 0x44
 80461f4:	ecbd 8b02 	vpop	{d8}
 80461f8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	} else if (action == KAD_BACKWARD && kad_is_back(q)) {
 80461fc:	7862      	ldrb	r2, [r4, #1]
 80461fe:	07d2      	lsls	r2, r2, #31
 8046200:	f57f af47 	bpl.w	8046092 <kad_op_stdnorm+0x56>
		for (j = 0; j < m; ++j) {
 8046204:	2b00      	cmp	r3, #0
		float *si = (float*)p->gtmp;
 8046206:	6b72      	ldr	r2, [r6, #52]	@ 0x34
		for (j = 0; j < m; ++j) {
 8046208:	f77f af43 	ble.w	8046092 <kad_op_stdnorm+0x56>
 804620c:	e9d6 150a 	ldrd	r1, r5, [r6, #40]	@ 0x28
 8046210:	9108      	str	r1, [sp, #32]
 8046212:	eb05 018e 	add.w	r1, r5, lr, lsl #2
 8046216:	910b      	str	r1, [sp, #44]	@ 0x2c
 8046218:	9109      	str	r1, [sp, #36]	@ 0x24
			float *pg = &p->g[j * n], *qg = &q->g[j * n], *px = &p->x[j * n], std_inv = si[j];
 804621a:	2100      	movs	r1, #0
 804621c:	eb02 0383 	add.w	r3, r2, r3, lsl #2
			for (i = 0, s = t = 0.0; i < n; ++i)
 8046220:	e9cd e30c 	strd	lr, r3, [sp, #48]	@ 0x30
 8046224:	4613      	mov	r3, r2
 8046226:	f8d4 c02c 	ldr.w	ip, [r4, #44]	@ 0x2c
			float *pg = &p->g[j * n], *qg = &q->g[j * n], *px = &p->x[j * n], std_inv = si[j];
 804622a:	910a      	str	r1, [sp, #40]	@ 0x28
 804622c:	ea4f 018e 	mov.w	r1, lr, lsl #2
 8046230:	9206      	str	r2, [sp, #24]
 8046232:	910e      	str	r1, [sp, #56]	@ 0x38
 8046234:	eb0c 0b8e 	add.w	fp, ip, lr, lsl #2
			for (i = 0, s = t = 0.0; i < n; ++i)
 8046238:	f8cd c03c 	str.w	ip, [sp, #60]	@ 0x3c
			float *pg = &p->g[j * n], *qg = &q->g[j * n], *px = &p->x[j * n], std_inv = si[j];
 804623c:	ecf3 7a01 	vldmia	r3!, {s15}
 8046240:	9306      	str	r3, [sp, #24]
			for (i = 0, s = t = 0.0; i < n; ++i)
 8046242:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
			float *pg = &p->g[j * n], *qg = &q->g[j * n], *px = &p->x[j * n], std_inv = si[j];
 8046244:	edcd 7a02 	vstr	s15, [sp, #8]
			for (i = 0, s = t = 0.0; i < n; ++i)
 8046248:	2b00      	cmp	r3, #0
 804624a:	f340 8084 	ble.w	8046356 <kad_op_stdnorm+0x31a>
 804624e:	f04f 0800 	mov.w	r8, #0
 8046252:	f04f 0900 	mov.w	r9, #0
 8046256:	f8cd b010 	str.w	fp, [sp, #16]
 804625a:	46c2      	mov	sl, r8
 804625c:	46cb      	mov	fp, r9
 804625e:	462c      	mov	r4, r5
 8046260:	462f      	mov	r7, r5
 8046262:	9e08      	ldr	r6, [sp, #32]
 8046264:	9d09      	ldr	r5, [sp, #36]	@ 0x24
				s += pg[i], t += px[i] * pg[i];
 8046266:	ecb4 8a01 	vldmia	r4!, {s16}
 804626a:	ee18 0a10 	vmov	r0, s16
 804626e:	f7fa f947 	bl	8040500 <__aeabi_f2d>
 8046272:	4602      	mov	r2, r0
 8046274:	460b      	mov	r3, r1
 8046276:	4640      	mov	r0, r8
 8046278:	4649      	mov	r1, r9
 804627a:	f7f9 ffe3 	bl	8040244 <__adddf3>
 804627e:	ecf6 7a01 	vldmia	r6!, {s15}
 8046282:	ee68 7a27 	vmul.f32	s15, s16, s15
 8046286:	4680      	mov	r8, r0
 8046288:	ee17 0a90 	vmov	r0, s15
 804628c:	4689      	mov	r9, r1
 804628e:	f7fa f937 	bl	8040500 <__aeabi_f2d>
 8046292:	4602      	mov	r2, r0
 8046294:	460b      	mov	r3, r1
 8046296:	4650      	mov	r0, sl
 8046298:	4659      	mov	r1, fp
 804629a:	f7f9 ffd3 	bl	8040244 <__adddf3>
			for (i = 0, s = t = 0.0; i < n; ++i)
 804629e:	42a5      	cmp	r5, r4
				s += pg[i], t += px[i] * pg[i];
 80462a0:	4682      	mov	sl, r0
 80462a2:	468b      	mov	fp, r1
			for (i = 0, s = t = 0.0; i < n; ++i)
 80462a4:	d1df      	bne.n	8046266 <kad_op_stdnorm+0x22a>
			s /= n, t /= n;
 80462a6:	980c      	ldr	r0, [sp, #48]	@ 0x30
				qg[i] += std_inv * (pg[i] - s - px[i] * t);
 80462a8:	e9cd ab00 	strd	sl, fp, [sp]
			s /= n, t /= n;
 80462ac:	f7fa f916 	bl	80404dc <__aeabi_i2d>
 80462b0:	4602      	mov	r2, r0
 80462b2:	460b      	mov	r3, r1
 80462b4:	4640      	mov	r0, r8
 80462b6:	4649      	mov	r1, r9
 80462b8:	4690      	mov	r8, r2
 80462ba:	4699      	mov	r9, r3
 80462bc:	f7fa faa2 	bl	8040804 <__aeabi_ddiv>
 80462c0:	9e0a      	ldr	r6, [sp, #40]	@ 0x28
 80462c2:	9c0f      	ldr	r4, [sp, #60]	@ 0x3c
				qg[i] += std_inv * (pg[i] - s - px[i] * t);
 80462c4:	463d      	mov	r5, r7
			s /= n, t /= n;
 80462c6:	4434      	add	r4, r6
 80462c8:	460f      	mov	r7, r1
 80462ca:	4606      	mov	r6, r0
 80462cc:	e9dd 0100 	ldrd	r0, r1, [sp]
 80462d0:	4642      	mov	r2, r8
 80462d2:	464b      	mov	r3, r9
 80462d4:	e9cd 6700 	strd	r6, r7, [sp]
 80462d8:	f7fa fa94 	bl	8040804 <__aeabi_ddiv>
 80462dc:	4602      	mov	r2, r0
 80462de:	460b      	mov	r3, r1
				qg[i] += std_inv * (pg[i] - s - px[i] * t);
 80462e0:	9802      	ldr	r0, [sp, #8]
			s /= n, t /= n;
 80462e2:	e9cd 2302 	strd	r2, r3, [sp, #8]
				qg[i] += std_inv * (pg[i] - s - px[i] * t);
 80462e6:	f7fa f90b 	bl	8040500 <__aeabi_f2d>
 80462ea:	f8dd b010 	ldr.w	fp, [sp, #16]
 80462ee:	e9cd 0104 	strd	r0, r1, [sp, #16]
 80462f2:	f8dd a020 	ldr.w	sl, [sp, #32]
 80462f6:	f855 0b04 	ldr.w	r0, [r5], #4
 80462fa:	f7fa f901 	bl	8040500 <__aeabi_f2d>
 80462fe:	e9dd 2300 	ldrd	r2, r3, [sp]
 8046302:	f7f9 ff9d 	bl	8040240 <__aeabi_dsub>
 8046306:	f85a 3b04 	ldr.w	r3, [sl], #4
 804630a:	4606      	mov	r6, r0
 804630c:	4618      	mov	r0, r3
 804630e:	460f      	mov	r7, r1
 8046310:	f7fa f8f6 	bl	8040500 <__aeabi_f2d>
 8046314:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8046318:	f7fa f94a 	bl	80405b0 <__aeabi_dmul>
 804631c:	4602      	mov	r2, r0
 804631e:	460b      	mov	r3, r1
 8046320:	4630      	mov	r0, r6
 8046322:	4639      	mov	r1, r7
 8046324:	f7f9 ff8c 	bl	8040240 <__aeabi_dsub>
 8046328:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 804632c:	f7fa f940 	bl	80405b0 <__aeabi_dmul>
 8046330:	f8d4 8000 	ldr.w	r8, [r4]
 8046334:	4606      	mov	r6, r0
 8046336:	4640      	mov	r0, r8
 8046338:	460f      	mov	r7, r1
 804633a:	f7fa f8e1 	bl	8040500 <__aeabi_f2d>
 804633e:	4602      	mov	r2, r0
 8046340:	460b      	mov	r3, r1
 8046342:	4630      	mov	r0, r6
 8046344:	4639      	mov	r1, r7
 8046346:	f7f9 ff7d 	bl	8040244 <__adddf3>
 804634a:	f7fa fc09 	bl	8040b60 <__aeabi_d2f>
 804634e:	f844 0b04 	str.w	r0, [r4], #4
			for (i = 0; i < n; ++i)
 8046352:	45a3      	cmp	fp, r4
 8046354:	d1cf      	bne.n	80462f6 <kad_op_stdnorm+0x2ba>
		for (j = 0; j < m; ++j) {
 8046356:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
 8046358:	9a08      	ldr	r2, [sp, #32]
 804635a:	990d      	ldr	r1, [sp, #52]	@ 0x34
 804635c:	441a      	add	r2, r3
 804635e:	9208      	str	r2, [sp, #32]
 8046360:	9a0a      	ldr	r2, [sp, #40]	@ 0x28
 8046362:	9806      	ldr	r0, [sp, #24]
 8046364:	441a      	add	r2, r3
 8046366:	920a      	str	r2, [sp, #40]	@ 0x28
 8046368:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 804636a:	4281      	cmp	r1, r0
 804636c:	441a      	add	r2, r3
 804636e:	9209      	str	r2, [sp, #36]	@ 0x24
 8046370:	9a0b      	ldr	r2, [sp, #44]	@ 0x2c
 8046372:	449b      	add	fp, r3
 8046374:	4615      	mov	r5, r2
 8046376:	f43f ae8c 	beq.w	8046092 <kad_op_stdnorm+0x56>
 804637a:	441a      	add	r2, r3
 804637c:	920b      	str	r2, [sp, #44]	@ 0x2c
 804637e:	4603      	mov	r3, r0
 8046380:	e75c      	b.n	804623c <kad_op_stdnorm+0x200>
	assert(q->n_d > 0);
 8046382:	f240 6163 	movw	r1, #1635	@ 0x663
 8046386:	4b03      	ldr	r3, [pc, #12]	@ (8046394 <kad_op_stdnorm+0x358>)
 8046388:	4a03      	ldr	r2, [pc, #12]	@ (8046398 <kad_op_stdnorm+0x35c>)
 804638a:	4804      	ldr	r0, [pc, #16]	@ (804639c <kad_op_stdnorm+0x360>)
 804638c:	f005 fa2a 	bl	804b7e4 <__assert_func>
 8046390:	3ff00000 	.word	0x3ff00000
 8046394:	0804e478 	.word	0x0804e478
 8046398:	0804e51c 	.word	0x0804e51c
 804639c:	0804e3dc 	.word	0x0804e3dc

080463a0 <kad_op_exp>:
{
 80463a0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	kad_node_t *q = p->child[0];
 80463a2:	6b83      	ldr	r3, [r0, #56]	@ 0x38
 80463a4:	681b      	ldr	r3, [r3, #0]
 80463a6:	781d      	ldrb	r5, [r3, #0]
 80463a8:	b305      	cbz	r5, 80463ec <kad_op_exp+0x4c>
 80463aa:	2d01      	cmp	r5, #1
 80463ac:	691c      	ldr	r4, [r3, #16]
 80463ae:	d00c      	beq.n	80463ca <kad_op_exp+0x2a>
 80463b0:	695a      	ldr	r2, [r3, #20]
 80463b2:	2d02      	cmp	r5, #2
 80463b4:	fb02 f404 	mul.w	r4, r2, r4
 80463b8:	d007      	beq.n	80463ca <kad_op_exp+0x2a>
 80463ba:	699a      	ldr	r2, [r3, #24]
 80463bc:	2d03      	cmp	r5, #3
 80463be:	fb02 f404 	mul.w	r4, r2, r4
 80463c2:	d002      	beq.n	80463ca <kad_op_exp+0x2a>
 80463c4:	69da      	ldr	r2, [r3, #28]
 80463c6:	fb02 f404 	mul.w	r4, r2, r4
	if (action == KAD_SYNC_DIM) {
 80463ca:	2904      	cmp	r1, #4
 80463cc:	d005      	beq.n	80463da <kad_op_exp+0x3a>
	} else if (action == KAD_FORWARD) {
 80463ce:	2902      	cmp	r1, #2
 80463d0:	d017      	beq.n	8046402 <kad_op_exp+0x62>
	} else if (action == KAD_BACKWARD && kad_is_back(q)) {
 80463d2:	2903      	cmp	r1, #3
 80463d4:	d027      	beq.n	8046426 <kad_op_exp+0x86>
}
 80463d6:	2000      	movs	r0, #0
 80463d8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 80463da:	00aa      	lsls	r2, r5, #2
 80463dc:	f103 0110 	add.w	r1, r3, #16
	dst->n_d = src->n_d;
 80463e0:	f800 5b10 	strb.w	r5, [r0], #16
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 80463e4:	f005 fe23 	bl	804c02e <memcpy>
}
 80463e8:	2000      	movs	r0, #0
 80463ea:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (action == KAD_SYNC_DIM) {
 80463ec:	2904      	cmp	r1, #4
 80463ee:	d018      	beq.n	8046422 <kad_op_exp+0x82>
	} else if (action == KAD_FORWARD) {
 80463f0:	2902      	cmp	r1, #2
 80463f2:	d02f      	beq.n	8046454 <kad_op_exp+0xb4>
	} else if (action == KAD_BACKWARD && kad_is_back(q)) {
 80463f4:	2903      	cmp	r1, #3
 80463f6:	d1ee      	bne.n	80463d6 <kad_op_exp+0x36>
 80463f8:	785a      	ldrb	r2, [r3, #1]
 80463fa:	07d1      	lsls	r1, r2, #31
 80463fc:	d5eb      	bpl.n	80463d6 <kad_op_exp+0x36>
	int n = 1, i;
 80463fe:	2401      	movs	r4, #1
 8046400:	e016      	b.n	8046430 <kad_op_exp+0x90>
		for (i = 0; i < n; ++i) p->x[i] = expf(q->x[i]);
 8046402:	2c00      	cmp	r4, #0
 8046404:	dde7      	ble.n	80463d6 <kad_op_exp+0x36>
 8046406:	2500      	movs	r5, #0
 8046408:	6a9f      	ldr	r7, [r3, #40]	@ 0x28
 804640a:	6a86      	ldr	r6, [r0, #40]	@ 0x28
 804640c:	ecb7 0a01 	vldmia	r7!, {s0}
 8046410:	f006 fc68 	bl	804cce4 <expf>
 8046414:	3501      	adds	r5, #1
 8046416:	42a5      	cmp	r5, r4
 8046418:	eca6 0a01 	vstmia	r6!, {s0}
 804641c:	dbf6      	blt.n	804640c <kad_op_exp+0x6c>
}
 804641e:	2000      	movs	r0, #0
 8046420:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	dst->n_d = src->n_d;
 8046422:	7005      	strb	r5, [r0, #0]
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 8046424:	e7d7      	b.n	80463d6 <kad_op_exp+0x36>
	} else if (action == KAD_BACKWARD && kad_is_back(q)) {
 8046426:	785a      	ldrb	r2, [r3, #1]
 8046428:	07d2      	lsls	r2, r2, #31
 804642a:	d5d4      	bpl.n	80463d6 <kad_op_exp+0x36>
		for (i = 0; i < n; ++i)
 804642c:	2c00      	cmp	r4, #0
 804642e:	ddd2      	ble.n	80463d6 <kad_op_exp+0x36>
 8046430:	e9d0 210a 	ldrd	r2, r1, [r0, #40]	@ 0x28
 8046434:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8046436:	eb03 0484 	add.w	r4, r3, r4, lsl #2
			q->g[i] += p->g[i] * p->x[i];
 804643a:	edd3 7a00 	vldr	s15, [r3]
 804643e:	ecf1 6a01 	vldmia	r1!, {s13}
 8046442:	ecb2 7a01 	vldmia	r2!, {s14}
 8046446:	eee6 7a87 	vfma.f32	s15, s13, s14
 804644a:	ece3 7a01 	vstmia	r3!, {s15}
		for (i = 0; i < n; ++i)
 804644e:	429c      	cmp	r4, r3
 8046450:	d1f3      	bne.n	804643a <kad_op_exp+0x9a>
 8046452:	e7c0      	b.n	80463d6 <kad_op_exp+0x36>
 8046454:	2401      	movs	r4, #1
 8046456:	e7d6      	b.n	8046406 <kad_op_exp+0x66>

08046458 <kad_op_sigm>:
{
 8046458:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 804645a:	ed2d 8b02 	vpush	{d8}
	kad_node_t *q = p->child[0];
 804645e:	6b83      	ldr	r3, [r0, #56]	@ 0x38
{
 8046460:	4605      	mov	r5, r0
	kad_node_t *q = p->child[0];
 8046462:	681b      	ldr	r3, [r3, #0]
	for (i = 0; i < p->n_d; ++i) n *= p->d[i];
 8046464:	781c      	ldrb	r4, [r3, #0]
 8046466:	b32c      	cbz	r4, 80464b4 <kad_op_sigm+0x5c>
 8046468:	2c01      	cmp	r4, #1
 804646a:	691e      	ldr	r6, [r3, #16]
 804646c:	d00c      	beq.n	8046488 <kad_op_sigm+0x30>
 804646e:	695a      	ldr	r2, [r3, #20]
 8046470:	2c02      	cmp	r4, #2
 8046472:	fb02 f606 	mul.w	r6, r2, r6
 8046476:	d007      	beq.n	8046488 <kad_op_sigm+0x30>
 8046478:	699a      	ldr	r2, [r3, #24]
 804647a:	2c03      	cmp	r4, #3
 804647c:	fb02 f606 	mul.w	r6, r2, r6
 8046480:	d002      	beq.n	8046488 <kad_op_sigm+0x30>
 8046482:	69da      	ldr	r2, [r3, #28]
 8046484:	fb02 f606 	mul.w	r6, r2, r6
	if (action == KAD_SYNC_DIM) {
 8046488:	2904      	cmp	r1, #4
 804648a:	d007      	beq.n	804649c <kad_op_sigm+0x44>
	} else if (action == KAD_FORWARD) {
 804648c:	2902      	cmp	r1, #2
 804648e:	d01c      	beq.n	80464ca <kad_op_sigm+0x72>
	} else if (action == KAD_BACKWARD && kad_is_back(q)) {
 8046490:	2903      	cmp	r1, #3
 8046492:	d038      	beq.n	8046506 <kad_op_sigm+0xae>
}
 8046494:	ecbd 8b02 	vpop	{d8}
 8046498:	2000      	movs	r0, #0
 804649a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	dst->n_d = src->n_d;
 804649c:	4628      	mov	r0, r5
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 804649e:	00a2      	lsls	r2, r4, #2
 80464a0:	f103 0110 	add.w	r1, r3, #16
	dst->n_d = src->n_d;
 80464a4:	f800 4b10 	strb.w	r4, [r0], #16
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 80464a8:	f005 fdc1 	bl	804c02e <memcpy>
}
 80464ac:	ecbd 8b02 	vpop	{d8}
 80464b0:	2000      	movs	r0, #0
 80464b2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (action == KAD_SYNC_DIM) {
 80464b4:	2904      	cmp	r1, #4
 80464b6:	d024      	beq.n	8046502 <kad_op_sigm+0xaa>
	} else if (action == KAD_FORWARD) {
 80464b8:	2902      	cmp	r1, #2
 80464ba:	d041      	beq.n	8046540 <kad_op_sigm+0xe8>
	} else if (action == KAD_BACKWARD && kad_is_back(q)) {
 80464bc:	2903      	cmp	r1, #3
 80464be:	d1e9      	bne.n	8046494 <kad_op_sigm+0x3c>
 80464c0:	785a      	ldrb	r2, [r3, #1]
 80464c2:	07d1      	lsls	r1, r2, #31
 80464c4:	d5e6      	bpl.n	8046494 <kad_op_sigm+0x3c>
	int n = 1, i;
 80464c6:	2601      	movs	r6, #1
 80464c8:	e022      	b.n	8046510 <kad_op_sigm+0xb8>
		for (i = 0; i < n; ++i)
 80464ca:	2e00      	cmp	r6, #0
 80464cc:	dde2      	ble.n	8046494 <kad_op_sigm+0x3c>
 80464ce:	2400      	movs	r4, #0
			p->x[i] = 1.0f / (1.0f + expf(-q->x[i]));
 80464d0:	eeb7 8a00 	vmov.f32	s16, #112	@ 0x3f800000  1.0
 80464d4:	6a9f      	ldr	r7, [r3, #40]	@ 0x28
 80464d6:	ecb7 0a01 	vldmia	r7!, {s0}
 80464da:	eeb1 0a40 	vneg.f32	s0, s0
 80464de:	f006 fc01 	bl	804cce4 <expf>
 80464e2:	ee30 0a08 	vadd.f32	s0, s0, s16
 80464e6:	eec8 7a00 	vdiv.f32	s15, s16, s0
 80464ea:	6aab      	ldr	r3, [r5, #40]	@ 0x28
 80464ec:	eb03 0384 	add.w	r3, r3, r4, lsl #2
		for (i = 0; i < n; ++i)
 80464f0:	3401      	adds	r4, #1
 80464f2:	42b4      	cmp	r4, r6
			p->x[i] = 1.0f / (1.0f + expf(-q->x[i]));
 80464f4:	edc3 7a00 	vstr	s15, [r3]
		for (i = 0; i < n; ++i)
 80464f8:	dbed      	blt.n	80464d6 <kad_op_sigm+0x7e>
}
 80464fa:	ecbd 8b02 	vpop	{d8}
 80464fe:	2000      	movs	r0, #0
 8046500:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	dst->n_d = src->n_d;
 8046502:	7004      	strb	r4, [r0, #0]
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 8046504:	e7c6      	b.n	8046494 <kad_op_sigm+0x3c>
	} else if (action == KAD_BACKWARD && kad_is_back(q)) {
 8046506:	785a      	ldrb	r2, [r3, #1]
 8046508:	07d2      	lsls	r2, r2, #31
 804650a:	d5c3      	bpl.n	8046494 <kad_op_sigm+0x3c>
		for (i = 0; i < n; ++i)
 804650c:	2e00      	cmp	r6, #0
 804650e:	ddc1      	ble.n	8046494 <kad_op_sigm+0x3c>
 8046510:	e9d5 210a 	ldrd	r2, r1, [r5, #40]	@ 0x28
			q->g[i] += p->g[i] * (p->x[i] * (1.0f - p->x[i]));
 8046514:	eef7 5a00 	vmov.f32	s11, #112	@ 0x3f800000  1.0
 8046518:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 804651a:	eb03 0686 	add.w	r6, r3, r6, lsl #2
 804651e:	ecf2 6a01 	vldmia	r2!, {s13}
 8046522:	ee35 7ae6 	vsub.f32	s14, s11, s13
 8046526:	edd3 7a00 	vldr	s15, [r3]
 804652a:	ecb1 6a01 	vldmia	r1!, {s12}
 804652e:	ee27 7a26 	vmul.f32	s14, s14, s13
 8046532:	eee6 7a07 	vfma.f32	s15, s12, s14
 8046536:	ece3 7a01 	vstmia	r3!, {s15}
		for (i = 0; i < n; ++i)
 804653a:	429e      	cmp	r6, r3
 804653c:	d1ef      	bne.n	804651e <kad_op_sigm+0xc6>
 804653e:	e7a9      	b.n	8046494 <kad_op_sigm+0x3c>
 8046540:	2601      	movs	r6, #1
 8046542:	e7c4      	b.n	80464ce <kad_op_sigm+0x76>

08046544 <kad_op_tanh>:
{
 8046544:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8046548:	ed2d 8b04 	vpush	{d8-d9}
	kad_node_t *q = p->child[0];
 804654c:	6b83      	ldr	r3, [r0, #56]	@ 0x38
{
 804654e:	4605      	mov	r5, r0
	kad_node_t *q = p->child[0];
 8046550:	681b      	ldr	r3, [r3, #0]
	for (i = 0; i < p->n_d; ++i) n *= p->d[i];
 8046552:	781c      	ldrb	r4, [r3, #0]
 8046554:	b33c      	cbz	r4, 80465a6 <kad_op_tanh+0x62>
 8046556:	2c01      	cmp	r4, #1
 8046558:	691e      	ldr	r6, [r3, #16]
 804655a:	d00c      	beq.n	8046576 <kad_op_tanh+0x32>
 804655c:	695a      	ldr	r2, [r3, #20]
 804655e:	2c02      	cmp	r4, #2
 8046560:	fb02 f606 	mul.w	r6, r2, r6
 8046564:	d007      	beq.n	8046576 <kad_op_tanh+0x32>
 8046566:	699a      	ldr	r2, [r3, #24]
 8046568:	2c03      	cmp	r4, #3
 804656a:	fb02 f606 	mul.w	r6, r2, r6
 804656e:	d002      	beq.n	8046576 <kad_op_tanh+0x32>
 8046570:	69da      	ldr	r2, [r3, #28]
 8046572:	fb02 f606 	mul.w	r6, r2, r6
	if (action == KAD_SYNC_DIM) {
 8046576:	2904      	cmp	r1, #4
 8046578:	d008      	beq.n	804658c <kad_op_tanh+0x48>
	} else if (action == KAD_FORWARD) {
 804657a:	2902      	cmp	r1, #2
 804657c:	d01e      	beq.n	80465bc <kad_op_tanh+0x78>
	} else if (action == KAD_BACKWARD && kad_is_back(q)) {
 804657e:	2903      	cmp	r1, #3
 8046580:	d048      	beq.n	8046614 <kad_op_tanh+0xd0>
}
 8046582:	ecbd 8b04 	vpop	{d8-d9}
 8046586:	2000      	movs	r0, #0
 8046588:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	dst->n_d = src->n_d;
 804658c:	4628      	mov	r0, r5
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 804658e:	00a2      	lsls	r2, r4, #2
 8046590:	f103 0110 	add.w	r1, r3, #16
	dst->n_d = src->n_d;
 8046594:	f800 4b10 	strb.w	r4, [r0], #16
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 8046598:	f005 fd49 	bl	804c02e <memcpy>
}
 804659c:	ecbd 8b04 	vpop	{d8-d9}
 80465a0:	2000      	movs	r0, #0
 80465a2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (action == KAD_SYNC_DIM) {
 80465a6:	2904      	cmp	r1, #4
 80465a8:	d032      	beq.n	8046610 <kad_op_tanh+0xcc>
	} else if (action == KAD_FORWARD) {
 80465aa:	2902      	cmp	r1, #2
 80465ac:	d04f      	beq.n	804664e <kad_op_tanh+0x10a>
	} else if (action == KAD_BACKWARD && kad_is_back(q)) {
 80465ae:	2903      	cmp	r1, #3
 80465b0:	d1e7      	bne.n	8046582 <kad_op_tanh+0x3e>
 80465b2:	785a      	ldrb	r2, [r3, #1]
 80465b4:	07d1      	lsls	r1, r2, #31
 80465b6:	d5e4      	bpl.n	8046582 <kad_op_tanh+0x3e>
	int n = 1, i;
 80465b8:	2601      	movs	r6, #1
 80465ba:	e030      	b.n	804661e <kad_op_tanh+0xda>
		for (i = 0; i < n; ++i) {
 80465bc:	2e00      	cmp	r6, #0
 80465be:	dde0      	ble.n	8046582 <kad_op_tanh+0x3e>
 80465c0:	2400      	movs	r4, #0
			if (q->x[i] < -20.0f) p->x[i] = -1.0f;
 80465c2:	eebb 8a04 	vmov.f32	s16, #180	@ 0xc1a00000 -20.0
				y = expf(-2.0f * q->x[i]);
 80465c6:	eeb8 9a00 	vmov.f32	s18, #128	@ 0xc0000000 -2.0
				p->x[i] = (1.0f - y) / (1.0f + y);
 80465ca:	eef7 8a00 	vmov.f32	s17, #112	@ 0x3f800000  1.0
 80465ce:	6a9f      	ldr	r7, [r3, #40]	@ 0x28
 80465d0:	e006      	b.n	80465e0 <kad_op_tanh+0x9c>
			if (q->x[i] < -20.0f) p->x[i] = -1.0f;
 80465d2:	6aab      	ldr	r3, [r5, #40]	@ 0x28
 80465d4:	4a1f      	ldr	r2, [pc, #124]	@ (8046654 <kad_op_tanh+0x110>)
 80465d6:	4443      	add	r3, r8
 80465d8:	601a      	str	r2, [r3, #0]
		for (i = 0; i < n; ++i) {
 80465da:	3401      	adds	r4, #1
 80465dc:	42b4      	cmp	r4, r6
 80465de:	dad0      	bge.n	8046582 <kad_op_tanh+0x3e>
			if (q->x[i] < -20.0f) p->x[i] = -1.0f;
 80465e0:	ecb7 0a01 	vldmia	r7!, {s0}
 80465e4:	eeb4 0ac8 	vcmpe.f32	s0, s16
 80465e8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80465ec:	ea4f 0884 	mov.w	r8, r4, lsl #2
 80465f0:	d4ef      	bmi.n	80465d2 <kad_op_tanh+0x8e>
				y = expf(-2.0f * q->x[i]);
 80465f2:	ee20 0a09 	vmul.f32	s0, s0, s18
 80465f6:	f006 fb75 	bl	804cce4 <expf>
				p->x[i] = (1.0f - y) / (1.0f + y);
 80465fa:	ee38 7ac0 	vsub.f32	s14, s17, s0
 80465fe:	ee30 0a28 	vadd.f32	s0, s0, s17
 8046602:	eec7 7a00 	vdiv.f32	s15, s14, s0
 8046606:	6aab      	ldr	r3, [r5, #40]	@ 0x28
 8046608:	4443      	add	r3, r8
 804660a:	edc3 7a00 	vstr	s15, [r3]
 804660e:	e7e4      	b.n	80465da <kad_op_tanh+0x96>
	dst->n_d = src->n_d;
 8046610:	7004      	strb	r4, [r0, #0]
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 8046612:	e7b6      	b.n	8046582 <kad_op_tanh+0x3e>
	} else if (action == KAD_BACKWARD && kad_is_back(q)) {
 8046614:	785a      	ldrb	r2, [r3, #1]
 8046616:	07d2      	lsls	r2, r2, #31
 8046618:	d5b3      	bpl.n	8046582 <kad_op_tanh+0x3e>
		for (i = 0; i < n; ++i)
 804661a:	2e00      	cmp	r6, #0
 804661c:	ddb1      	ble.n	8046582 <kad_op_tanh+0x3e>
 804661e:	e9d5 210a 	ldrd	r2, r1, [r5, #40]	@ 0x28
			q->g[i] += p->g[i] * (1.0f - p->x[i] * p->x[i]);
 8046622:	eef7 5a00 	vmov.f32	s11, #112	@ 0x3f800000  1.0
 8046626:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8046628:	eb03 0686 	add.w	r6, r3, r6, lsl #2
 804662c:	ecb2 7a01 	vldmia	r2!, {s14}
 8046630:	eef0 6a65 	vmov.f32	s13, s11
 8046634:	edd3 7a00 	vldr	s15, [r3]
 8046638:	ecb1 6a01 	vldmia	r1!, {s12}
 804663c:	eee7 6a47 	vfms.f32	s13, s14, s14
 8046640:	eee6 7a26 	vfma.f32	s15, s12, s13
 8046644:	ece3 7a01 	vstmia	r3!, {s15}
		for (i = 0; i < n; ++i)
 8046648:	429e      	cmp	r6, r3
 804664a:	d1ef      	bne.n	804662c <kad_op_tanh+0xe8>
 804664c:	e799      	b.n	8046582 <kad_op_tanh+0x3e>
 804664e:	2601      	movs	r6, #1
 8046650:	e7b6      	b.n	80465c0 <kad_op_tanh+0x7c>
 8046652:	bf00      	nop
 8046654:	bf800000 	.word	0xbf800000

08046658 <kad_op_softmax>:
{
 8046658:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 804665c:	ed2d 8b04 	vpush	{d8-d9}
	kad_node_t *q = p->child[0];
 8046660:	6b83      	ldr	r3, [r0, #56]	@ 0x38
{
 8046662:	b085      	sub	sp, #20
	kad_node_t *q = p->child[0];
 8046664:	681b      	ldr	r3, [r3, #0]
	n1 = q->d[q->n_d - 1];
 8046666:	781c      	ldrb	r4, [r3, #0]
 8046668:	1ce2      	adds	r2, r4, #3
 804666a:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 804666e:	9202      	str	r2, [sp, #8]
	for (i = 0; i < p->n_d; ++i) n *= p->d[i];
 8046670:	2c00      	cmp	r4, #0
 8046672:	d076      	beq.n	8046762 <kad_op_softmax+0x10a>
 8046674:	2c01      	cmp	r4, #1
 8046676:	691d      	ldr	r5, [r3, #16]
 8046678:	d00c      	beq.n	8046694 <kad_op_softmax+0x3c>
 804667a:	695a      	ldr	r2, [r3, #20]
 804667c:	2c02      	cmp	r4, #2
 804667e:	fb02 f505 	mul.w	r5, r2, r5
 8046682:	d007      	beq.n	8046694 <kad_op_softmax+0x3c>
 8046684:	699a      	ldr	r2, [r3, #24]
 8046686:	2c03      	cmp	r4, #3
 8046688:	fb02 f505 	mul.w	r5, r2, r5
 804668c:	d002      	beq.n	8046694 <kad_op_softmax+0x3c>
 804668e:	69da      	ldr	r2, [r3, #28]
 8046690:	fb02 f505 	mul.w	r5, r2, r5
	if (action == KAD_SYNC_DIM) {
 8046694:	2904      	cmp	r1, #4
 8046696:	d057      	beq.n	8046748 <kad_op_softmax+0xf0>
	d0 = kad_len(q) / n1;
 8046698:	9a02      	ldr	r2, [sp, #8]
 804669a:	fb95 f2f2 	sdiv	r2, r5, r2
 804669e:	9203      	str	r2, [sp, #12]
	} else if (action == KAD_FORWARD) {
 80466a0:	2902      	cmp	r1, #2
 80466a2:	d007      	beq.n	80466b4 <kad_op_softmax+0x5c>
	} else if (action == KAD_BACKWARD && kad_is_back(q)) {
 80466a4:	2903      	cmp	r1, #3
 80466a6:	d068      	beq.n	804677a <kad_op_softmax+0x122>
}
 80466a8:	2000      	movs	r0, #0
 80466aa:	b005      	add	sp, #20
 80466ac:	ecbd 8b04 	vpop	{d8-d9}
 80466b0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		for (j = 0; j < d0; ++j) {
 80466b4:	9a03      	ldr	r2, [sp, #12]
 80466b6:	2a00      	cmp	r2, #0
 80466b8:	ddf6      	ble.n	80466a8 <kad_op_softmax+0x50>
 80466ba:	9a02      	ldr	r2, [sp, #8]
 80466bc:	6a81      	ldr	r1, [r0, #40]	@ 0x28
 80466be:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80466c0:	eb01 0982 	add.w	r9, r1, r2, lsl #2
 80466c4:	eb03 0882 	add.w	r8, r3, r2, lsl #2
			for (i = 0, s = 1.0f / s; i < n1; ++i) y[i] *= s;
 80466c8:	eeb7 9a00 	vmov.f32	s18, #112	@ 0x3f800000  1.0
 80466cc:	464c      	mov	r4, r9
 80466ce:	4645      	mov	r5, r8
		for (j = 0; j < d0; ++j) {
 80466d0:	2700      	movs	r7, #0
 80466d2:	9101      	str	r1, [sp, #4]
 80466d4:	0096      	lsls	r6, r2, #2
			for (i = 0, max = -FLT_MAX; i < n1; ++i)
 80466d6:	9a02      	ldr	r2, [sp, #8]
 80466d8:	2a00      	cmp	r2, #0
 80466da:	dd29      	ble.n	8046730 <kad_op_softmax+0xd8>
 80466dc:	ed9f 8a47 	vldr	s16, [pc, #284]	@ 80467fc <kad_op_softmax+0x1a4>
 80466e0:	4619      	mov	r1, r3
				max = max > x[i]? max : x[i];
 80466e2:	ecf1 7a01 	vldmia	r1!, {s15}
 80466e6:	eef4 7ac8 	vcmpe.f32	s15, s16
 80466ea:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80466ee:	bf58      	it	pl
 80466f0:	eeb0 8a67 	vmovpl.f32	s16, s15
			for (i = 0, max = -FLT_MAX; i < n1; ++i)
 80466f4:	428d      	cmp	r5, r1
 80466f6:	d1f4      	bne.n	80466e2 <kad_op_softmax+0x8a>
 80466f8:	469b      	mov	fp, r3
			for (i = 0, s = 0.0f; i < n1; ++i) {
 80466fa:	eddf 8a41 	vldr	s17, [pc, #260]	@ 8046800 <kad_op_softmax+0x1a8>
			for (i = 0, max = -FLT_MAX; i < n1; ++i)
 80466fe:	f8dd a004 	ldr.w	sl, [sp, #4]
				y[i] = expf(x[i] - max);
 8046702:	ecbb 0a01 	vldmia	fp!, {s0}
 8046706:	ee30 0a48 	vsub.f32	s0, s0, s16
 804670a:	f006 faeb 	bl	804cce4 <expf>
			for (i = 0, s = 0.0f; i < n1; ++i) {
 804670e:	45ab      	cmp	fp, r5
				y[i] = expf(x[i] - max);
 8046710:	ecaa 0a01 	vstmia	sl!, {s0}
				s += y[i];
 8046714:	ee78 8a80 	vadd.f32	s17, s17, s0
			for (i = 0, s = 0.0f; i < n1; ++i) {
 8046718:	d1f3      	bne.n	8046702 <kad_op_softmax+0xaa>
			for (i = 0, s = 1.0f / s; i < n1; ++i) y[i] *= s;
 804671a:	ee89 7a28 	vdiv.f32	s14, s18, s17
 804671e:	9b01      	ldr	r3, [sp, #4]
 8046720:	edd3 7a00 	vldr	s15, [r3]
 8046724:	ee67 7a87 	vmul.f32	s15, s15, s14
 8046728:	ece3 7a01 	vstmia	r3!, {s15}
 804672c:	429c      	cmp	r4, r3
 804672e:	d1f7      	bne.n	8046720 <kad_op_softmax+0xc8>
		for (j = 0; j < d0; ++j) {
 8046730:	9a03      	ldr	r2, [sp, #12]
 8046732:	3701      	adds	r7, #1
 8046734:	42ba      	cmp	r2, r7
 8046736:	4643      	mov	r3, r8
 8046738:	f8cd 9004 	str.w	r9, [sp, #4]
 804673c:	4434      	add	r4, r6
 804673e:	4435      	add	r5, r6
 8046740:	d0b2      	beq.n	80466a8 <kad_op_softmax+0x50>
 8046742:	44b1      	add	r9, r6
 8046744:	44b0      	add	r8, r6
 8046746:	e7c6      	b.n	80466d6 <kad_op_softmax+0x7e>
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 8046748:	00a2      	lsls	r2, r4, #2
 804674a:	f103 0110 	add.w	r1, r3, #16
	dst->n_d = src->n_d;
 804674e:	f800 4b10 	strb.w	r4, [r0], #16
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 8046752:	f005 fc6c 	bl	804c02e <memcpy>
}
 8046756:	2000      	movs	r0, #0
 8046758:	b005      	add	sp, #20
 804675a:	ecbd 8b04 	vpop	{d8-d9}
 804675e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (action == KAD_SYNC_DIM) {
 8046762:	2904      	cmp	r1, #4
 8046764:	d007      	beq.n	8046776 <kad_op_softmax+0x11e>
 8046766:	4614      	mov	r4, r2
	d0 = kad_len(q) / n1;
 8046768:	3201      	adds	r2, #1
 804676a:	2a02      	cmp	r2, #2
 804676c:	bf94      	ite	ls
 804676e:	4622      	movls	r2, r4
 8046770:	2200      	movhi	r2, #0
 8046772:	9203      	str	r2, [sp, #12]
 8046774:	e794      	b.n	80466a0 <kad_op_softmax+0x48>
	dst->n_d = src->n_d;
 8046776:	7004      	strb	r4, [r0, #0]
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 8046778:	e796      	b.n	80466a8 <kad_op_softmax+0x50>
	} else if (action == KAD_BACKWARD && kad_is_back(q)) {
 804677a:	785a      	ldrb	r2, [r3, #1]
 804677c:	07d2      	lsls	r2, r2, #31
 804677e:	d593      	bpl.n	80466a8 <kad_op_softmax+0x50>
		for (j = 0; j < d0; ++j) {
 8046780:	9a03      	ldr	r2, [sp, #12]
 8046782:	2a00      	cmp	r2, #0
 8046784:	dd90      	ble.n	80466a8 <kad_op_softmax+0x50>
 8046786:	e9d0 620a 	ldrd	r6, r2, [r0, #40]	@ 0x28
			float s, *g = &p->g[j * n1], *y = &p->x[j * n1], *h = &q->g[j * n1];
 804678a:	f04f 0c00 	mov.w	ip, #0
 804678e:	f8d3 802c 	ldr.w	r8, [r3, #44]	@ 0x2c
 8046792:	9b02      	ldr	r3, [sp, #8]
		for (j = 0; j < d0; ++j) {
 8046794:	4667      	mov	r7, ip
 8046796:	eb02 0e83 	add.w	lr, r2, r3, lsl #2
 804679a:	4670      	mov	r0, lr
 804679c:	009c      	lsls	r4, r3, #2
 804679e:	eb08 0183 	add.w	r1, r8, r3, lsl #2
			for (i = 0, s = 0.0f; i < n1; ++i)
 80467a2:	9b02      	ldr	r3, [sp, #8]
 80467a4:	2b00      	cmp	r3, #0
 80467a6:	dd1c      	ble.n	80467e2 <kad_op_softmax+0x18a>
 80467a8:	eddf 6a15 	vldr	s13, [pc, #84]	@ 8046800 <kad_op_softmax+0x1a8>
 80467ac:	46b1      	mov	r9, r6
 80467ae:	4613      	mov	r3, r2
				s += g[i] * y[i];
 80467b0:	ecb3 7a01 	vldmia	r3!, {s14}
 80467b4:	ecf9 7a01 	vldmia	r9!, {s15}
			for (i = 0, s = 0.0f; i < n1; ++i)
 80467b8:	4283      	cmp	r3, r0
				s += g[i] * y[i];
 80467ba:	eee7 6a27 	vfma.f32	s13, s14, s15
			for (i = 0, s = 0.0f; i < n1; ++i)
 80467be:	d1f7      	bne.n	80467b0 <kad_op_softmax+0x158>
 80467c0:	46b1      	mov	r9, r6
 80467c2:	eb0c 0308 	add.w	r3, ip, r8
				h[i] += y[i] * (g[i] - s);
 80467c6:	ecb2 7a01 	vldmia	r2!, {s14}
 80467ca:	edd3 7a00 	vldr	s15, [r3]
 80467ce:	ecb9 6a01 	vldmia	r9!, {s12}
 80467d2:	ee37 7a66 	vsub.f32	s14, s14, s13
 80467d6:	eee6 7a07 	vfma.f32	s15, s12, s14
 80467da:	ece3 7a01 	vstmia	r3!, {s15}
			for (i = 0; i < n1; ++i)
 80467de:	428b      	cmp	r3, r1
 80467e0:	d1f1      	bne.n	80467c6 <kad_op_softmax+0x16e>
		for (j = 0; j < d0; ++j) {
 80467e2:	9b03      	ldr	r3, [sp, #12]
 80467e4:	3701      	adds	r7, #1
 80467e6:	42bb      	cmp	r3, r7
 80467e8:	4672      	mov	r2, lr
 80467ea:	4426      	add	r6, r4
 80467ec:	44a4      	add	ip, r4
 80467ee:	4421      	add	r1, r4
 80467f0:	4420      	add	r0, r4
 80467f2:	f43f af59 	beq.w	80466a8 <kad_op_softmax+0x50>
 80467f6:	44a6      	add	lr, r4
 80467f8:	e7d3      	b.n	80467a2 <kad_op_softmax+0x14a>
 80467fa:	bf00      	nop
 80467fc:	ff7fffff 	.word	0xff7fffff
 8046800:	00000000 	.word	0x00000000

08046804 <kad_op_log>:
{
 8046804:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	kad_node_t *q = p->child[0];
 8046806:	6b83      	ldr	r3, [r0, #56]	@ 0x38
 8046808:	681b      	ldr	r3, [r3, #0]
 804680a:	781d      	ldrb	r5, [r3, #0]
 804680c:	b305      	cbz	r5, 8046850 <kad_op_log+0x4c>
 804680e:	2d01      	cmp	r5, #1
 8046810:	691c      	ldr	r4, [r3, #16]
 8046812:	d00c      	beq.n	804682e <kad_op_log+0x2a>
 8046814:	695a      	ldr	r2, [r3, #20]
 8046816:	2d02      	cmp	r5, #2
 8046818:	fb02 f404 	mul.w	r4, r2, r4
 804681c:	d007      	beq.n	804682e <kad_op_log+0x2a>
 804681e:	699a      	ldr	r2, [r3, #24]
 8046820:	2d03      	cmp	r5, #3
 8046822:	fb02 f404 	mul.w	r4, r2, r4
 8046826:	d002      	beq.n	804682e <kad_op_log+0x2a>
 8046828:	69da      	ldr	r2, [r3, #28]
 804682a:	fb02 f404 	mul.w	r4, r2, r4
	if (action == KAD_SYNC_DIM) {
 804682e:	2904      	cmp	r1, #4
 8046830:	d005      	beq.n	804683e <kad_op_log+0x3a>
	} else if (action == KAD_FORWARD) {
 8046832:	2902      	cmp	r1, #2
 8046834:	d017      	beq.n	8046866 <kad_op_log+0x62>
	} else if (action == KAD_BACKWARD && kad_is_back(q)) {
 8046836:	2903      	cmp	r1, #3
 8046838:	d027      	beq.n	804688a <kad_op_log+0x86>
}
 804683a:	2000      	movs	r0, #0
 804683c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 804683e:	00aa      	lsls	r2, r5, #2
 8046840:	f103 0110 	add.w	r1, r3, #16
	dst->n_d = src->n_d;
 8046844:	f800 5b10 	strb.w	r5, [r0], #16
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 8046848:	f005 fbf1 	bl	804c02e <memcpy>
}
 804684c:	2000      	movs	r0, #0
 804684e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (action == KAD_SYNC_DIM) {
 8046850:	2904      	cmp	r1, #4
 8046852:	d018      	beq.n	8046886 <kad_op_log+0x82>
	} else if (action == KAD_FORWARD) {
 8046854:	2902      	cmp	r1, #2
 8046856:	d031      	beq.n	80468bc <kad_op_log+0xb8>
	} else if (action == KAD_BACKWARD && kad_is_back(q)) {
 8046858:	2903      	cmp	r1, #3
 804685a:	d1ee      	bne.n	804683a <kad_op_log+0x36>
 804685c:	785a      	ldrb	r2, [r3, #1]
 804685e:	07d1      	lsls	r1, r2, #31
 8046860:	d5eb      	bpl.n	804683a <kad_op_log+0x36>
	int n = 1, i;
 8046862:	2401      	movs	r4, #1
 8046864:	e016      	b.n	8046894 <kad_op_log+0x90>
		for (i = 0; i < n; ++i) p->x[i] = logf(q->x[i]);
 8046866:	2c00      	cmp	r4, #0
 8046868:	dde7      	ble.n	804683a <kad_op_log+0x36>
 804686a:	2500      	movs	r5, #0
 804686c:	6a9f      	ldr	r7, [r3, #40]	@ 0x28
 804686e:	6a86      	ldr	r6, [r0, #40]	@ 0x28
 8046870:	ecb7 0a01 	vldmia	r7!, {s0}
 8046874:	f006 fa6c 	bl	804cd50 <logf>
 8046878:	3501      	adds	r5, #1
 804687a:	42a5      	cmp	r5, r4
 804687c:	eca6 0a01 	vstmia	r6!, {s0}
 8046880:	dbf6      	blt.n	8046870 <kad_op_log+0x6c>
}
 8046882:	2000      	movs	r0, #0
 8046884:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	dst->n_d = src->n_d;
 8046886:	7005      	strb	r5, [r0, #0]
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 8046888:	e7d7      	b.n	804683a <kad_op_log+0x36>
	} else if (action == KAD_BACKWARD && kad_is_back(q)) {
 804688a:	785a      	ldrb	r2, [r3, #1]
 804688c:	07d2      	lsls	r2, r2, #31
 804688e:	d5d4      	bpl.n	804683a <kad_op_log+0x36>
		for (i = 0; i < n; ++i)
 8046890:	2c00      	cmp	r4, #0
 8046892:	ddd2      	ble.n	804683a <kad_op_log+0x36>
 8046894:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 8046896:	6ac1      	ldr	r1, [r0, #44]	@ 0x2c
 8046898:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 804689a:	eb02 0484 	add.w	r4, r2, r4, lsl #2
			q->g[i] += p->g[i] / q->x[i];
 804689e:	ecb1 6a01 	vldmia	r1!, {s12}
 80468a2:	ecf3 6a01 	vldmia	r3!, {s13}
 80468a6:	ed92 7a00 	vldr	s14, [r2]
 80468aa:	eec6 7a26 	vdiv.f32	s15, s12, s13
 80468ae:	ee77 7a87 	vadd.f32	s15, s15, s14
 80468b2:	ece2 7a01 	vstmia	r2!, {s15}
		for (i = 0; i < n; ++i)
 80468b6:	4294      	cmp	r4, r2
 80468b8:	d1f1      	bne.n	804689e <kad_op_log+0x9a>
 80468ba:	e7be      	b.n	804683a <kad_op_log+0x36>
 80468bc:	2401      	movs	r4, #1
 80468be:	e7d4      	b.n	804686a <kad_op_log+0x66>

080468c0 <kad_op_sin>:
{
 80468c0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	kad_node_t *q = p->child[0];
 80468c2:	6b83      	ldr	r3, [r0, #56]	@ 0x38
 80468c4:	681b      	ldr	r3, [r3, #0]
	for (i = 0; i < p->n_d; ++i) n *= p->d[i];
 80468c6:	781d      	ldrb	r5, [r3, #0]
 80468c8:	b305      	cbz	r5, 804690c <kad_op_sin+0x4c>
 80468ca:	2d01      	cmp	r5, #1
 80468cc:	691c      	ldr	r4, [r3, #16]
 80468ce:	d00c      	beq.n	80468ea <kad_op_sin+0x2a>
 80468d0:	695a      	ldr	r2, [r3, #20]
 80468d2:	2d02      	cmp	r5, #2
 80468d4:	fb02 f404 	mul.w	r4, r2, r4
 80468d8:	d007      	beq.n	80468ea <kad_op_sin+0x2a>
 80468da:	699a      	ldr	r2, [r3, #24]
 80468dc:	2d03      	cmp	r5, #3
 80468de:	fb02 f404 	mul.w	r4, r2, r4
 80468e2:	d002      	beq.n	80468ea <kad_op_sin+0x2a>
 80468e4:	69da      	ldr	r2, [r3, #28]
 80468e6:	fb02 f404 	mul.w	r4, r2, r4
	if (action == KAD_SYNC_DIM) {
 80468ea:	2904      	cmp	r1, #4
 80468ec:	d005      	beq.n	80468fa <kad_op_sin+0x3a>
	} else if (action == KAD_FORWARD) {
 80468ee:	2902      	cmp	r1, #2
 80468f0:	d017      	beq.n	8046922 <kad_op_sin+0x62>
	} else if (action == KAD_BACKWARD && kad_is_back(q)) {
 80468f2:	2903      	cmp	r1, #3
 80468f4:	d027      	beq.n	8046946 <kad_op_sin+0x86>
}
 80468f6:	2000      	movs	r0, #0
 80468f8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 80468fa:	00aa      	lsls	r2, r5, #2
 80468fc:	f103 0110 	add.w	r1, r3, #16
	dst->n_d = src->n_d;
 8046900:	f800 5b10 	strb.w	r5, [r0], #16
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 8046904:	f005 fb93 	bl	804c02e <memcpy>
}
 8046908:	2000      	movs	r0, #0
 804690a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (action == KAD_SYNC_DIM) {
 804690c:	2904      	cmp	r1, #4
 804690e:	d018      	beq.n	8046942 <kad_op_sin+0x82>
	} else if (action == KAD_FORWARD) {
 8046910:	2902      	cmp	r1, #2
 8046912:	d031      	beq.n	8046978 <kad_op_sin+0xb8>
	} else if (action == KAD_BACKWARD && kad_is_back(q)) {
 8046914:	2903      	cmp	r1, #3
 8046916:	d1ee      	bne.n	80468f6 <kad_op_sin+0x36>
 8046918:	785a      	ldrb	r2, [r3, #1]
 804691a:	07d1      	lsls	r1, r2, #31
 804691c:	d5eb      	bpl.n	80468f6 <kad_op_sin+0x36>
	int n = 1, i;
 804691e:	2401      	movs	r4, #1
 8046920:	e016      	b.n	8046950 <kad_op_sin+0x90>
		for (i = 0; i < n; ++i) p->x[i] = sinf(q->x[i]);
 8046922:	2c00      	cmp	r4, #0
 8046924:	dde7      	ble.n	80468f6 <kad_op_sin+0x36>
 8046926:	2500      	movs	r5, #0
 8046928:	6a9f      	ldr	r7, [r3, #40]	@ 0x28
 804692a:	6a86      	ldr	r6, [r0, #40]	@ 0x28
 804692c:	ecb7 0a01 	vldmia	r7!, {s0}
 8046930:	f006 fa9e 	bl	804ce70 <sinf>
 8046934:	3501      	adds	r5, #1
 8046936:	42a5      	cmp	r5, r4
 8046938:	eca6 0a01 	vstmia	r6!, {s0}
 804693c:	dbf6      	blt.n	804692c <kad_op_sin+0x6c>
}
 804693e:	2000      	movs	r0, #0
 8046940:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	dst->n_d = src->n_d;
 8046942:	7005      	strb	r5, [r0, #0]
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 8046944:	e7d7      	b.n	80468f6 <kad_op_sin+0x36>
	} else if (action == KAD_BACKWARD && kad_is_back(q)) {
 8046946:	785a      	ldrb	r2, [r3, #1]
 8046948:	07d2      	lsls	r2, r2, #31
 804694a:	d5d4      	bpl.n	80468f6 <kad_op_sin+0x36>
		for (i = 0; i < n; ++i)
 804694c:	2c00      	cmp	r4, #0
 804694e:	ddd2      	ble.n	80468f6 <kad_op_sin+0x36>
 8046950:	6add      	ldr	r5, [r3, #44]	@ 0x2c
 8046952:	6ac7      	ldr	r7, [r0, #44]	@ 0x2c
 8046954:	6a9e      	ldr	r6, [r3, #40]	@ 0x28
 8046956:	eb05 0484 	add.w	r4, r5, r4, lsl #2
			q->g[i] += p->g[i] * cosf(q->x[i]);
 804695a:	ecb6 0a01 	vldmia	r6!, {s0}
 804695e:	f006 fa43 	bl	804cde8 <cosf>
 8046962:	edd5 7a00 	vldr	s15, [r5]
 8046966:	ecb7 7a01 	vldmia	r7!, {s14}
 804696a:	eee7 7a00 	vfma.f32	s15, s14, s0
 804696e:	ece5 7a01 	vstmia	r5!, {s15}
		for (i = 0; i < n; ++i)
 8046972:	42ac      	cmp	r4, r5
 8046974:	d1f1      	bne.n	804695a <kad_op_sin+0x9a>
 8046976:	e7be      	b.n	80468f6 <kad_op_sin+0x36>
 8046978:	2401      	movs	r4, #1
 804697a:	e7d4      	b.n	8046926 <kad_op_sin+0x66>

0804697c <kad_allocate_internal>:
{
 804697c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	for (i = 0; i < n; ++i) {
 8046980:	1e06      	subs	r6, r0, #0
 8046982:	dd65      	ble.n	8046a50 <kad_allocate_internal+0xd4>
 8046984:	1f0d      	subs	r5, r1, #4
 8046986:	462f      	mov	r7, r5
 8046988:	eb05 0c86 	add.w	ip, r5, r6, lsl #2
 804698c:	e001      	b.n	8046992 <kad_allocate_internal+0x16>
 804698e:	4567      	cmp	r7, ip
 8046990:	d019      	beq.n	80469c6 <kad_allocate_internal+0x4a>
		if (v[i]->n_child == 0) continue;
 8046992:	f857 4f04 	ldr.w	r4, [r7, #4]!
 8046996:	6860      	ldr	r0, [r4, #4]
 8046998:	2800      	cmp	r0, #0
 804699a:	d0f8      	beq.n	804698e <kad_allocate_internal+0x12>
		for (j = 0; j < v[i]->n_child; ++j)
 804699c:	dd5a      	ble.n	8046a54 <kad_allocate_internal+0xd8>
 804699e:	6ba2      	ldr	r2, [r4, #56]	@ 0x38
 80469a0:	2300      	movs	r3, #0
 80469a2:	3a04      	subs	r2, #4
 80469a4:	e002      	b.n	80469ac <kad_allocate_internal+0x30>
 80469a6:	3301      	adds	r3, #1
 80469a8:	4298      	cmp	r0, r3
 80469aa:	d053      	beq.n	8046a54 <kad_allocate_internal+0xd8>
			if (kad_is_back(v[i]->child[j]))
 80469ac:	f852 1f04 	ldr.w	r1, [r2, #4]!
 80469b0:	7849      	ldrb	r1, [r1, #1]
 80469b2:	07c9      	lsls	r1, r1, #31
 80469b4:	d5f7      	bpl.n	80469a6 <kad_allocate_internal+0x2a>
		if (j < v[i]->n_child) v[i]->flag |= KAD_VAR;
 80469b6:	4298      	cmp	r0, r3
 80469b8:	dd4c      	ble.n	8046a54 <kad_allocate_internal+0xd8>
 80469ba:	7863      	ldrb	r3, [r4, #1]
	for (i = 0; i < n; ++i) {
 80469bc:	4567      	cmp	r7, ip
		if (j < v[i]->n_child) v[i]->flag |= KAD_VAR;
 80469be:	f043 0301 	orr.w	r3, r3, #1
 80469c2:	7063      	strb	r3, [r4, #1]
	for (i = 0; i < n; ++i) {
 80469c4:	d1e5      	bne.n	8046992 <kad_allocate_internal+0x16>
	for (i = 0; i < n; ++i) {
 80469c6:	2700      	movs	r7, #0
			kad_op_list[p->op](p, KAD_ALLOC);
 80469c8:	f8df 809c 	ldr.w	r8, [pc, #156]	@ 8046a68 <kad_allocate_internal+0xec>
 80469cc:	e002      	b.n	80469d4 <kad_allocate_internal+0x58>
	for (i = 0; i < n; ++i) {
 80469ce:	3701      	adds	r7, #1
 80469d0:	42be      	cmp	r6, r7
 80469d2:	d03d      	beq.n	8046a50 <kad_allocate_internal+0xd4>
		kad_node_t *p = v[i];
 80469d4:	f855 4f04 	ldr.w	r4, [r5, #4]!
		if (p->n_child == 0) continue;
 80469d8:	6863      	ldr	r3, [r4, #4]
 80469da:	2b00      	cmp	r3, #0
 80469dc:	d0f7      	beq.n	80469ce <kad_allocate_internal+0x52>
	for (i = 0; i < p->n_d; ++i) n *= p->d[i];
 80469de:	7823      	ldrb	r3, [r4, #0]
		p->x = (float*)realloc(p->x, kad_len(p) * sizeof(float));
 80469e0:	6aa0      	ldr	r0, [r4, #40]	@ 0x28
 80469e2:	2b00      	cmp	r3, #0
 80469e4:	d03b      	beq.n	8046a5e <kad_allocate_internal+0xe2>
 80469e6:	2b01      	cmp	r3, #1
 80469e8:	6921      	ldr	r1, [r4, #16]
 80469ea:	d00b      	beq.n	8046a04 <kad_allocate_internal+0x88>
 80469ec:	6962      	ldr	r2, [r4, #20]
 80469ee:	2b02      	cmp	r3, #2
 80469f0:	fb02 f101 	mul.w	r1, r2, r1
 80469f4:	d006      	beq.n	8046a04 <kad_allocate_internal+0x88>
 80469f6:	69a2      	ldr	r2, [r4, #24]
 80469f8:	2b03      	cmp	r3, #3
 80469fa:	fb02 f101 	mul.w	r1, r2, r1
 80469fe:	bf1c      	itt	ne
 8046a00:	69e3      	ldrne	r3, [r4, #28]
 8046a02:	4359      	mulne	r1, r3
 8046a04:	0089      	lsls	r1, r1, #2
 8046a06:	f005 f813 	bl	804ba30 <realloc>
		if (kad_is_back(p)) {
 8046a0a:	7863      	ldrb	r3, [r4, #1]
		p->x = (float*)realloc(p->x, kad_len(p) * sizeof(float));
 8046a0c:	62a0      	str	r0, [r4, #40]	@ 0x28
		if (kad_is_back(p)) {
 8046a0e:	07db      	lsls	r3, r3, #31
 8046a10:	d5dd      	bpl.n	80469ce <kad_allocate_internal+0x52>
 8046a12:	7823      	ldrb	r3, [r4, #0]
			p->g = (float*)realloc(p->g, kad_len(p) * sizeof(float));
 8046a14:	6ae0      	ldr	r0, [r4, #44]	@ 0x2c
 8046a16:	b323      	cbz	r3, 8046a62 <kad_allocate_internal+0xe6>
 8046a18:	2b01      	cmp	r3, #1
 8046a1a:	6921      	ldr	r1, [r4, #16]
 8046a1c:	d00b      	beq.n	8046a36 <kad_allocate_internal+0xba>
 8046a1e:	6962      	ldr	r2, [r4, #20]
 8046a20:	2b02      	cmp	r3, #2
 8046a22:	fb02 f101 	mul.w	r1, r2, r1
 8046a26:	d006      	beq.n	8046a36 <kad_allocate_internal+0xba>
 8046a28:	69a2      	ldr	r2, [r4, #24]
 8046a2a:	2b03      	cmp	r3, #3
 8046a2c:	fb02 f101 	mul.w	r1, r2, r1
 8046a30:	bf1c      	itt	ne
 8046a32:	69e3      	ldrne	r3, [r4, #28]
 8046a34:	4359      	mulne	r1, r3
 8046a36:	0089      	lsls	r1, r1, #2
 8046a38:	f004 fffa 	bl	804ba30 <realloc>
			kad_op_list[p->op](p, KAD_ALLOC);
 8046a3c:	8863      	ldrh	r3, [r4, #2]
			p->g = (float*)realloc(p->g, kad_len(p) * sizeof(float));
 8046a3e:	62e0      	str	r0, [r4, #44]	@ 0x2c
			kad_op_list[p->op](p, KAD_ALLOC);
 8046a40:	2101      	movs	r1, #1
 8046a42:	4620      	mov	r0, r4
 8046a44:	f858 3023 	ldr.w	r3, [r8, r3, lsl #2]
	for (i = 0; i < n; ++i) {
 8046a48:	3701      	adds	r7, #1
			kad_op_list[p->op](p, KAD_ALLOC);
 8046a4a:	4798      	blx	r3
	for (i = 0; i < n; ++i) {
 8046a4c:	42be      	cmp	r6, r7
 8046a4e:	d1c1      	bne.n	80469d4 <kad_allocate_internal+0x58>
}
 8046a50:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		else v[i]->flag &= ~KAD_VAR;
 8046a54:	7863      	ldrb	r3, [r4, #1]
 8046a56:	f023 0301 	bic.w	r3, r3, #1
 8046a5a:	7063      	strb	r3, [r4, #1]
 8046a5c:	e797      	b.n	804698e <kad_allocate_internal+0x12>
 8046a5e:	2104      	movs	r1, #4
 8046a60:	e7d1      	b.n	8046a06 <kad_allocate_internal+0x8a>
 8046a62:	2104      	movs	r1, #4
 8046a64:	e7e8      	b.n	8046a38 <kad_allocate_internal+0xbc>
 8046a66:	bf00      	nop
 8046a68:	20018004 	.word	0x20018004

08046a6c <kad_op_dropout>:
{
 8046a6c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8046a70:	ed2d 8b02 	vpush	{d8}
	kad_node_t *q = p->child[0];
 8046a74:	6b83      	ldr	r3, [r0, #56]	@ 0x38
{
 8046a76:	b087      	sub	sp, #28
	kad_node_t *q = p->child[0];
 8046a78:	e9d3 6200 	ldrd	r6, r2, [r3]
	assert(p->child[1]->n_d == 0);
 8046a7c:	7813      	ldrb	r3, [r2, #0]
 8046a7e:	2b00      	cmp	r3, #0
 8046a80:	f040 8171 	bne.w	8046d66 <kad_op_dropout+0x2fa>
 8046a84:	7834      	ldrb	r4, [r6, #0]
 8046a86:	4682      	mov	sl, r0
 8046a88:	2c00      	cmp	r4, #0
 8046a8a:	d060      	beq.n	8046b4e <kad_op_dropout+0xe2>
 8046a8c:	2c01      	cmp	r4, #1
 8046a8e:	f8d6 b010 	ldr.w	fp, [r6, #16]
 8046a92:	d00c      	beq.n	8046aae <kad_op_dropout+0x42>
 8046a94:	6973      	ldr	r3, [r6, #20]
 8046a96:	2c02      	cmp	r4, #2
 8046a98:	fb03 fb0b 	mul.w	fp, r3, fp
 8046a9c:	d007      	beq.n	8046aae <kad_op_dropout+0x42>
 8046a9e:	69b3      	ldr	r3, [r6, #24]
 8046aa0:	2c03      	cmp	r4, #3
 8046aa2:	fb03 fb0b 	mul.w	fp, r3, fp
 8046aa6:	d002      	beq.n	8046aae <kad_op_dropout+0x42>
 8046aa8:	69f3      	ldr	r3, [r6, #28]
 8046aaa:	fb03 fb0b 	mul.w	fp, r3, fp
	if (action == KAD_SYNC_DIM) {
 8046aae:	2904      	cmp	r1, #4
 8046ab0:	d016      	beq.n	8046ae0 <kad_op_dropout+0x74>
	} else if (action == KAD_ALLOC) {
 8046ab2:	2901      	cmp	r1, #1
 8046ab4:	d009      	beq.n	8046aca <kad_op_dropout+0x5e>
	} else if (action == KAD_FORWARD) {
 8046ab6:	2902      	cmp	r1, #2
 8046ab8:	d04f      	beq.n	8046b5a <kad_op_dropout+0xee>
	} else if (action == KAD_BACKWARD && kad_is_back(p->child[0])) {
 8046aba:	2903      	cmp	r1, #3
 8046abc:	d01e      	beq.n	8046afc <kad_op_dropout+0x90>
}
 8046abe:	2000      	movs	r0, #0
 8046ac0:	b007      	add	sp, #28
 8046ac2:	ecbd 8b02 	vpop	{d8}
 8046ac6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (kad_is_back(p->child[0]))
 8046aca:	7873      	ldrb	r3, [r6, #1]
 8046acc:	07dc      	lsls	r4, r3, #31
 8046ace:	d5f6      	bpl.n	8046abe <kad_op_dropout+0x52>
			p->gtmp = realloc(p->gtmp, n);
 8046ad0:	4659      	mov	r1, fp
 8046ad2:	f8da 0034 	ldr.w	r0, [sl, #52]	@ 0x34
 8046ad6:	f004 ffab 	bl	804ba30 <realloc>
 8046ada:	f8ca 0034 	str.w	r0, [sl, #52]	@ 0x34
 8046ade:	e7ee      	b.n	8046abe <kad_op_dropout+0x52>
	dst->n_d = src->n_d;
 8046ae0:	4650      	mov	r0, sl
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 8046ae2:	00a2      	lsls	r2, r4, #2
 8046ae4:	f106 0110 	add.w	r1, r6, #16
	dst->n_d = src->n_d;
 8046ae8:	f800 4b10 	strb.w	r4, [r0], #16
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 8046aec:	f005 fa9f 	bl	804c02e <memcpy>
}
 8046af0:	2000      	movs	r0, #0
 8046af2:	b007      	add	sp, #28
 8046af4:	ecbd 8b02 	vpop	{d8}
 8046af8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	} else if (action == KAD_BACKWARD && kad_is_back(p->child[0])) {
 8046afc:	7873      	ldrb	r3, [r6, #1]
 8046afe:	07d9      	lsls	r1, r3, #31
 8046b00:	d5dd      	bpl.n	8046abe <kad_op_dropout+0x52>
		float r = kad_is_const(q) || kad_is_var(q)? 0.0f : *p->child[1]->x, z = 1.0f / (1.0f - r);
 8046b02:	6871      	ldr	r1, [r6, #4]
 8046b04:	2900      	cmp	r1, #0
 8046b06:	f040 8122 	bne.w	8046d4e <kad_op_dropout+0x2e2>
 8046b0a:	079b      	lsls	r3, r3, #30
 8046b0c:	f000 811f 	beq.w	8046d4e <kad_op_dropout+0x2e2>
 8046b10:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
		for (i = 0; i < n; ++i)
 8046b14:	f1bb 0f00 	cmp.w	fp, #0
		uint8_t *flag = (uint8_t*)p->gtmp;
 8046b18:	f8da 3034 	ldr.w	r3, [sl, #52]	@ 0x34
		for (i = 0; i < n; ++i)
 8046b1c:	ddcf      	ble.n	8046abe <kad_op_dropout+0x52>
 8046b1e:	2200      	movs	r2, #0
 8046b20:	3b01      	subs	r3, #1
 8046b22:	449b      	add	fp, r3
			if (flag[i]) q->g[i] += z * p->g[i];
 8046b24:	f813 1f01 	ldrb.w	r1, [r3, #1]!
 8046b28:	b161      	cbz	r1, 8046b44 <kad_op_dropout+0xd8>
 8046b2a:	6af1      	ldr	r1, [r6, #44]	@ 0x2c
 8046b2c:	f8da 002c 	ldr.w	r0, [sl, #44]	@ 0x2c
 8046b30:	4411      	add	r1, r2
 8046b32:	4410      	add	r0, r2
 8046b34:	edd1 7a00 	vldr	s15, [r1]
 8046b38:	ed90 7a00 	vldr	s14, [r0]
 8046b3c:	eee7 7a26 	vfma.f32	s15, s14, s13
 8046b40:	edc1 7a00 	vstr	s15, [r1]
		for (i = 0; i < n; ++i)
 8046b44:	459b      	cmp	fp, r3
 8046b46:	f102 0204 	add.w	r2, r2, #4
 8046b4a:	d1eb      	bne.n	8046b24 <kad_op_dropout+0xb8>
 8046b4c:	e7b7      	b.n	8046abe <kad_op_dropout+0x52>
	if (action == KAD_SYNC_DIM) {
 8046b4e:	2904      	cmp	r1, #4
 8046b50:	f000 808d 	beq.w	8046c6e <kad_op_dropout+0x202>
	int n = 1, i;
 8046b54:	f04f 0b01 	mov.w	fp, #1
 8046b58:	e7ab      	b.n	8046ab2 <kad_op_dropout+0x46>
		float r = kad_is_const(q) || kad_is_var(q)? 0.0f : *p->child[1]->x, z = 1.0f / (1.0f - r);
 8046b5a:	6873      	ldr	r3, [r6, #4]
 8046b5c:	b91b      	cbnz	r3, 8046b66 <kad_op_dropout+0xfa>
 8046b5e:	7873      	ldrb	r3, [r6, #1]
 8046b60:	0798      	lsls	r0, r3, #30
 8046b62:	f040 8086 	bne.w	8046c72 <kad_op_dropout+0x206>
 8046b66:	6a93      	ldr	r3, [r2, #40]	@ 0x28
 8046b68:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 8046b6c:	6818      	ldr	r0, [r3, #0]
 8046b6e:	ee07 0a10 	vmov	s14, r0
 8046b72:	ee37 7ac7 	vsub.f32	s14, s15, s14
 8046b76:	ee87 8a87 	vdiv.f32	s16, s15, s14
		for (i = 0; i < n; ++i) {
 8046b7a:	f1bb 0f00 	cmp.w	fp, #0
		uint8_t *flag = (uint8_t*)p->gtmp;
 8046b7e:	f8da 7034 	ldr.w	r7, [sl, #52]	@ 0x34
		for (i = 0; i < n; ++i) {
 8046b82:	dd9c      	ble.n	8046abe <kad_op_dropout+0x52>
			int kept = (kad_drand(p->ptr) >= r);
 8046b84:	f7f9 fcbc 	bl	8040500 <__aeabi_f2d>
 8046b88:	e9cd 0102 	strd	r0, r1, [sp, #8]
 8046b8c:	2f00      	cmp	r7, #0
 8046b8e:	d074      	beq.n	8046c7a <kad_op_dropout+0x20e>
 8046b90:	2400      	movs	r4, #0
			p->x[i] = kept? q->x[i] * z : 0.0f;
 8046b92:	eddf 8a78 	vldr	s17, [pc, #480]	@ 8046d74 <kad_op_dropout+0x308>
 8046b96:	eb07 030b 	add.w	r3, r7, fp
 8046b9a:	9300      	str	r3, [sp, #0]
	return u.d - 1.0;
 8046b9c:	9604      	str	r6, [sp, #16]
			int kept = (kad_drand(p->ptr) >= r);
 8046b9e:	f8da 1030 	ldr.w	r1, [sl, #48]	@ 0x30
	u.i = 0x3FFULL << 52 | kad_xoroshiro128plus_next(d? (kad_rng_t*)d : &kad_rng_dat) >> 12;
 8046ba2:	4b75      	ldr	r3, [pc, #468]	@ (8046d78 <kad_op_dropout+0x30c>)
	return u.d - 1.0;
 8046ba4:	2200      	movs	r2, #0
	u.i = 0x3FFULL << 52 | kad_xoroshiro128plus_next(d? (kad_rng_t*)d : &kad_rng_dat) >> 12;
 8046ba6:	2900      	cmp	r1, #0
 8046ba8:	bf08      	it	eq
 8046baa:	4619      	moveq	r1, r3
	const uint64_t s0 = r->s[0];
 8046bac:	f8d1 c000 	ldr.w	ip, [r1]
	const uint64_t result = s0 + s1;
 8046bb0:	68ce      	ldr	r6, [r1, #12]
	const uint64_t s0 = r->s[0];
 8046bb2:	e9d1 0b01 	ldrd	r0, fp, [r1, #4]
	const uint64_t result = s0 + s1;
 8046bb6:	eb1c 050b 	adds.w	r5, ip, fp
 8046bba:	eb40 0e06 	adc.w	lr, r0, r6
	u.i = 0x3FFULL << 52 | kad_xoroshiro128plus_next(d? (kad_rng_t*)d : &kad_rng_dat) >> 12;
 8046bbe:	0b2d      	lsrs	r5, r5, #12
 8046bc0:	ea45 580e 	orr.w	r8, r5, lr, lsl #20
 8046bc4:	ea4f 3e1e 	mov.w	lr, lr, lsr #12
 8046bc8:	f04e 597f 	orr.w	r9, lr, #1069547520	@ 0x3fc00000
	r->s[0] = (s0 << 55 | s0 >> 9) ^ s1 ^ (s1 << 14);
 8046bcc:	ea4f 2e5c 	mov.w	lr, ip, lsr #9
	s1 ^= s0;
 8046bd0:	ea8c 0b0b 	eor.w	fp, ip, fp
	r->s[0] = (s0 << 55 | s0 >> 9) ^ s1 ^ (s1 << 14);
 8046bd4:	ea4e 5ec0 	orr.w	lr, lr, r0, lsl #23
 8046bd8:	ea8e 0e0b 	eor.w	lr, lr, fp
 8046bdc:	ea8e 3e8b 	eor.w	lr, lr, fp, lsl #14
 8046be0:	f8c1 e000 	str.w	lr, [r1]
 8046be4:	ea4f 2e50 	mov.w	lr, r0, lsr #9
	s1 ^= s0;
 8046be8:	ea80 0506 	eor.w	r5, r0, r6
	r->s[0] = (s0 << 55 | s0 >> 9) ^ s1 ^ (s1 << 14);
 8046bec:	ea4e 5ecc 	orr.w	lr, lr, ip, lsl #23
 8046bf0:	ea8e 0e05 	eor.w	lr, lr, r5
 8046bf4:	03ad      	lsls	r5, r5, #14
 8046bf6:	ea45 459b 	orr.w	r5, r5, fp, lsr #18
 8046bfa:	ea8e 0505 	eor.w	r5, lr, r5
 8046bfe:	604d      	str	r5, [r1, #4]
	r->s[1] = s0 << 36 | s0 >> 28;
 8046c00:	ea4f 751c 	mov.w	r5, ip, lsr #28
 8046c04:	ea45 1500 	orr.w	r5, r5, r0, lsl #4
 8046c08:	0f00      	lsrs	r0, r0, #28
 8046c0a:	ea40 100c 	orr.w	r0, r0, ip, lsl #4
	u.i = 0x3FFULL << 52 | kad_xoroshiro128plus_next(d? (kad_rng_t*)d : &kad_rng_dat) >> 12;
 8046c0e:	f449 1940 	orr.w	r9, r9, #3145728	@ 0x300000
	r->s[1] = s0 << 36 | s0 >> 28;
 8046c12:	60c8      	str	r0, [r1, #12]
	return u.d - 1.0;
 8046c14:	4b59      	ldr	r3, [pc, #356]	@ (8046d7c <kad_op_dropout+0x310>)
	r->s[1] = s0 << 36 | s0 >> 28;
 8046c16:	608d      	str	r5, [r1, #8]
	return u.d - 1.0;
 8046c18:	4640      	mov	r0, r8
 8046c1a:	4649      	mov	r1, r9
 8046c1c:	f7f9 fb10 	bl	8040240 <__aeabi_dsub>
			p->x[i] = kept? q->x[i] * z : 0.0f;
 8046c20:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8046c24:	f7f9 ff4a 	bl	8040abc <__aeabi_dcmpge>
 8046c28:	b1a0      	cbz	r0, 8046c54 <kad_op_dropout+0x1e8>
 8046c2a:	9b04      	ldr	r3, [sp, #16]
 8046c2c:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8046c2e:	4423      	add	r3, r4
 8046c30:	edd3 7a00 	vldr	s15, [r3]
 8046c34:	ee67 7a88 	vmul.f32	s15, s15, s16
 8046c38:	f8da 3028 	ldr.w	r3, [sl, #40]	@ 0x28
 8046c3c:	4423      	add	r3, r4
 8046c3e:	edc3 7a00 	vstr	s15, [r3]
			if (flag) flag[i] = kept;
 8046c42:	f04f 0301 	mov.w	r3, #1
 8046c46:	f807 3b01 	strb.w	r3, [r7], #1
		for (i = 0; i < n; ++i) {
 8046c4a:	9b00      	ldr	r3, [sp, #0]
 8046c4c:	3404      	adds	r4, #4
 8046c4e:	429f      	cmp	r7, r3
 8046c50:	d1a5      	bne.n	8046b9e <kad_op_dropout+0x132>
 8046c52:	e734      	b.n	8046abe <kad_op_dropout+0x52>
			p->x[i] = kept? q->x[i] * z : 0.0f;
 8046c54:	f8da 3028 	ldr.w	r3, [sl, #40]	@ 0x28
 8046c58:	4423      	add	r3, r4
 8046c5a:	edc3 8a00 	vstr	s17, [r3]
		for (i = 0; i < n; ++i) {
 8046c5e:	9b00      	ldr	r3, [sp, #0]
			if (flag) flag[i] = kept;
 8046c60:	f807 0b01 	strb.w	r0, [r7], #1
		for (i = 0; i < n; ++i) {
 8046c64:	429f      	cmp	r7, r3
 8046c66:	f104 0404 	add.w	r4, r4, #4
 8046c6a:	d198      	bne.n	8046b9e <kad_op_dropout+0x132>
 8046c6c:	e727      	b.n	8046abe <kad_op_dropout+0x52>
	dst->n_d = src->n_d;
 8046c6e:	7004      	strb	r4, [r0, #0]
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 8046c70:	e725      	b.n	8046abe <kad_op_dropout+0x52>
 8046c72:	eeb7 8a00 	vmov.f32	s16, #112	@ 0x3f800000  1.0
		float r = kad_is_const(q) || kad_is_var(q)? 0.0f : *p->child[1]->x, z = 1.0f / (1.0f - r);
 8046c76:	2000      	movs	r0, #0
 8046c78:	e77f      	b.n	8046b7a <kad_op_dropout+0x10e>
			p->x[i] = kept? q->x[i] * z : 0.0f;
 8046c7a:	f8da 2028 	ldr.w	r2, [sl, #40]	@ 0x28
			int kept = (kad_drand(p->ptr) >= r);
 8046c7e:	f8da 3030 	ldr.w	r3, [sl, #48]	@ 0x30
			p->x[i] = kept? q->x[i] * z : 0.0f;
 8046c82:	9204      	str	r2, [sp, #16]
 8046c84:	4a3c      	ldr	r2, [pc, #240]	@ (8046d78 <kad_op_dropout+0x30c>)
		for (i = 0; i < n; ++i) {
 8046c86:	463c      	mov	r4, r7
 8046c88:	2b00      	cmp	r3, #0
 8046c8a:	bf18      	it	ne
 8046c8c:	461a      	movne	r2, r3
			p->x[i] = kept? q->x[i] * z : 0.0f;
 8046c8e:	eddf 8a39 	vldr	s17, [pc, #228]	@ 8046d74 <kad_op_dropout+0x308>
 8046c92:	e9d2 1300 	ldrd	r1, r3, [r2]
 8046c96:	e9d2 7502 	ldrd	r7, r5, [r2, #8]
 8046c9a:	9205      	str	r2, [sp, #20]
 8046c9c:	e00e      	b.n	8046cbc <kad_op_dropout+0x250>
 8046c9e:	6ab3      	ldr	r3, [r6, #40]	@ 0x28
		for (i = 0; i < n; ++i) {
 8046ca0:	3401      	adds	r4, #1
			p->x[i] = kept? q->x[i] * z : 0.0f;
 8046ca2:	4453      	add	r3, sl
 8046ca4:	edd3 7a00 	vldr	s15, [r3]
 8046ca8:	ee68 7a27 	vmul.f32	s15, s16, s15
 8046cac:	9b04      	ldr	r3, [sp, #16]
		for (i = 0; i < n; ++i) {
 8046cae:	45a3      	cmp	fp, r4
			p->x[i] = kept? q->x[i] * z : 0.0f;
 8046cb0:	449a      	add	sl, r3
 8046cb2:	edca 7a00 	vstr	s15, [sl]
		for (i = 0; i < n; ++i) {
 8046cb6:	d054      	beq.n	8046d62 <kad_op_dropout+0x2f6>
	r->s[0] = (s0 << 55 | s0 >> 9) ^ s1 ^ (s1 << 14);
 8046cb8:	4649      	mov	r1, r9
 8046cba:	4643      	mov	r3, r8
	const uint64_t result = s0 + s1;
 8046cbc:	19c8      	adds	r0, r1, r7
 8046cbe:	eb43 0205 	adc.w	r2, r3, r5
	r->s[0] = (s0 << 55 | s0 >> 9) ^ s1 ^ (s1 << 14);
 8046cc2:	ea4f 2951 	mov.w	r9, r1, lsr #9
 8046cc6:	ea4f 2853 	mov.w	r8, r3, lsr #9
	u.i = 0x3FFULL << 52 | kad_xoroshiro128plus_next(d? (kad_rng_t*)d : &kad_rng_dat) >> 12;
 8046cca:	0b00      	lsrs	r0, r0, #12
	s1 ^= s0;
 8046ccc:	404f      	eors	r7, r1
	u.i = 0x3FFULL << 52 | kad_xoroshiro128plus_next(d? (kad_rng_t*)d : &kad_rng_dat) >> 12;
 8046cce:	ea40 5002 	orr.w	r0, r0, r2, lsl #20
	s1 ^= s0;
 8046cd2:	405d      	eors	r5, r3
	r->s[0] = (s0 << 55 | s0 >> 9) ^ s1 ^ (s1 << 14);
 8046cd4:	ea49 59c3 	orr.w	r9, r9, r3, lsl #23
 8046cd8:	ea48 58c1 	orr.w	r8, r8, r1, lsl #23
	u.i = 0x3FFULL << 52 | kad_xoroshiro128plus_next(d? (kad_rng_t*)d : &kad_rng_dat) >> 12;
 8046cdc:	0b12      	lsrs	r2, r2, #12
	r->s[0] = (s0 << 55 | s0 >> 9) ^ s1 ^ (s1 << 14);
 8046cde:	ea89 0907 	eor.w	r9, r9, r7
 8046ce2:	ea88 0805 	eor.w	r8, r8, r5
	u.i = 0x3FFULL << 52 | kad_xoroshiro128plus_next(d? (kad_rng_t*)d : &kad_rng_dat) >> 12;
 8046ce6:	f042 527f 	orr.w	r2, r2, #1069547520	@ 0x3fc00000
	r->s[0] = (s0 << 55 | s0 >> 9) ^ s1 ^ (s1 << 14);
 8046cea:	03ad      	lsls	r5, r5, #14
 8046cec:	ea45 4597 	orr.w	r5, r5, r7, lsr #18
	u.i = 0x3FFULL << 52 | kad_xoroshiro128plus_next(d? (kad_rng_t*)d : &kad_rng_dat) >> 12;
 8046cf0:	f442 1240 	orr.w	r2, r2, #3145728	@ 0x300000
	r->s[0] = (s0 << 55 | s0 >> 9) ^ s1 ^ (s1 << 14);
 8046cf4:	ea89 3987 	eor.w	r9, r9, r7, lsl #14
	r->s[1] = s0 << 36 | s0 >> 28;
 8046cf8:	0f0f      	lsrs	r7, r1, #28
	u.i = 0x3FFULL << 52 | kad_xoroshiro128plus_next(d? (kad_rng_t*)d : &kad_rng_dat) >> 12;
 8046cfa:	9201      	str	r2, [sp, #4]
 8046cfc:	9000      	str	r0, [sp, #0]
	r->s[1] = s0 << 36 | s0 >> 28;
 8046cfe:	ea47 1703 	orr.w	r7, r7, r3, lsl #4
 8046d02:	0f1b      	lsrs	r3, r3, #28
	return u.d - 1.0;
 8046d04:	2200      	movs	r2, #0
	r->s[0] = (s0 << 55 | s0 >> 9) ^ s1 ^ (s1 << 14);
 8046d06:	ea88 0805 	eor.w	r8, r8, r5
	r->s[1] = s0 << 36 | s0 >> 28;
 8046d0a:	ea43 1501 	orr.w	r5, r3, r1, lsl #4
	return u.d - 1.0;
 8046d0e:	4b1b      	ldr	r3, [pc, #108]	@ (8046d7c <kad_op_dropout+0x310>)
 8046d10:	e9dd 0100 	ldrd	r0, r1, [sp]
 8046d14:	f7f9 fa94 	bl	8040240 <__aeabi_dsub>
 8046d18:	4602      	mov	r2, r0
 8046d1a:	460b      	mov	r3, r1
			p->x[i] = kept? q->x[i] * z : 0.0f;
 8046d1c:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 8046d20:	ea4f 0a84 	mov.w	sl, r4, lsl #2
 8046d24:	f7f9 fec0 	bl	8040aa8 <__aeabi_dcmple>
 8046d28:	2800      	cmp	r0, #0
 8046d2a:	d1b8      	bne.n	8046c9e <kad_op_dropout+0x232>
 8046d2c:	9b04      	ldr	r3, [sp, #16]
		for (i = 0; i < n; ++i) {
 8046d2e:	3401      	adds	r4, #1
			p->x[i] = kept? q->x[i] * z : 0.0f;
 8046d30:	449a      	add	sl, r3
		for (i = 0; i < n; ++i) {
 8046d32:	45a3      	cmp	fp, r4
			p->x[i] = kept? q->x[i] * z : 0.0f;
 8046d34:	edca 8a00 	vstr	s17, [sl]
		for (i = 0; i < n; ++i) {
 8046d38:	d1be      	bne.n	8046cb8 <kad_op_dropout+0x24c>
			p->x[i] = kept? q->x[i] * z : 0.0f;
 8046d3a:	eddf 7a0e 	vldr	s15, [pc, #56]	@ 8046d74 <kad_op_dropout+0x308>
 8046d3e:	9a05      	ldr	r2, [sp, #20]
 8046d40:	e9c2 9800 	strd	r9, r8, [r2]
 8046d44:	e9c2 7502 	strd	r7, r5, [r2, #8]
 8046d48:	edca 7a00 	vstr	s15, [sl]
 8046d4c:	e6b7      	b.n	8046abe <kad_op_dropout+0x52>
		float r = kad_is_const(q) || kad_is_var(q)? 0.0f : *p->child[1]->x, z = 1.0f / (1.0f - r);
 8046d4e:	6a93      	ldr	r3, [r2, #40]	@ 0x28
 8046d50:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 8046d54:	edd3 7a00 	vldr	s15, [r3]
 8046d58:	ee77 7a67 	vsub.f32	s15, s14, s15
 8046d5c:	eec7 6a27 	vdiv.f32	s13, s14, s15
 8046d60:	e6d8      	b.n	8046b14 <kad_op_dropout+0xa8>
 8046d62:	9a05      	ldr	r2, [sp, #20]
 8046d64:	e7ec      	b.n	8046d40 <kad_op_dropout+0x2d4>
	assert(p->child[1]->n_d == 0);
 8046d66:	f44f 61a4 	mov.w	r1, #1312	@ 0x520
 8046d6a:	4b05      	ldr	r3, [pc, #20]	@ (8046d80 <kad_op_dropout+0x314>)
 8046d6c:	4a05      	ldr	r2, [pc, #20]	@ (8046d84 <kad_op_dropout+0x318>)
 8046d6e:	4806      	ldr	r0, [pc, #24]	@ (8046d88 <kad_op_dropout+0x31c>)
 8046d70:	f004 fd38 	bl	804b7e4 <__assert_func>
 8046d74:	00000000 	.word	0x00000000
 8046d78:	20018108 	.word	0x20018108
 8046d7c:	3ff00000 	.word	0x3ff00000
 8046d80:	0804e484 	.word	0x0804e484
 8046d84:	0804e56c 	.word	0x0804e56c
 8046d88:	0804e3dc 	.word	0x0804e3dc

08046d8c <kad_op_cmul>:
{
 8046d8c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8046d90:	4604      	mov	r4, r0
	q[0] = p->child[0], q[1] = p->child[1];
 8046d92:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
{
 8046d94:	4608      	mov	r0, r1
	q[0] = p->child[0], q[1] = p->child[1];
 8046d96:	e9d3 6500 	ldrd	r6, r5, [r3]
	n_col = q[0]->d[q[0]->n_d - 1] > q[1]->d[q[1]->n_d - 1]? q[0]->d[q[0]->n_d - 1] : q[1]->d[q[1]->n_d - 1];
 8046d9a:	782f      	ldrb	r7, [r5, #0]
 8046d9c:	f896 e000 	ldrb.w	lr, [r6]
 8046da0:	1cfa      	adds	r2, r7, #3
 8046da2:	f10e 0303 	add.w	r3, lr, #3
 8046da6:	f855 2022 	ldr.w	r2, [r5, r2, lsl #2]
 8046daa:	f856 3023 	ldr.w	r3, [r6, r3, lsl #2]
{
 8046dae:	b08f      	sub	sp, #60	@ 0x3c
	n_col = q[0]->d[q[0]->n_d - 1] > q[1]->d[q[1]->n_d - 1]? q[0]->d[q[0]->n_d - 1] : q[1]->d[q[1]->n_d - 1];
 8046db0:	429a      	cmp	r2, r3
 8046db2:	bfb8      	it	lt
 8046db4:	461a      	movlt	r2, r3
 8046db6:	1e79      	subs	r1, r7, #1
 8046db8:	4691      	mov	r9, r2
	for (i = q[0]->n_d - 1; i >= 0; --i) if (n_a_col < n_col) n_a_col *= q[0]->d[i];
 8046dba:	f1be 0f00 	cmp.w	lr, #0
 8046dbe:	f000 8196 	beq.w	80470ee <kad_op_cmul+0x362>
	int i, n_a_row, n_b_row, n_col, n_a_col = 1, n_b_col = 1;
 8046dc2:	2201      	movs	r2, #1
 8046dc4:	f10e 33ff 	add.w	r3, lr, #4294967295
	for (i = q[0]->n_d - 1; i >= 0; --i) if (n_a_col < n_col) n_a_col *= q[0]->d[i];
 8046dc8:	f106 0810 	add.w	r8, r6, #16
 8046dcc:	4591      	cmp	r9, r2
 8046dce:	dc63      	bgt.n	8046e98 <kad_op_cmul+0x10c>
	for (i = q[1]->n_d - 1; i >= 0; --i) if (n_b_col < n_col) n_b_col *= q[1]->d[i];
 8046dd0:	1c4b      	adds	r3, r1, #1
 8046dd2:	f000 8198 	beq.w	8047106 <kad_op_cmul+0x37a>
	int i, n_a_row, n_b_row, n_col, n_a_col = 1, n_b_col = 1;
 8046dd6:	f04f 0c01 	mov.w	ip, #1
	for (i = q[1]->n_d - 1; i >= 0; --i) if (n_b_col < n_col) n_b_col *= q[1]->d[i];
 8046dda:	4663      	mov	r3, ip
 8046ddc:	f105 0810 	add.w	r8, r5, #16
 8046de0:	4599      	cmp	r9, r3
 8046de2:	dc35      	bgt.n	8046e50 <kad_op_cmul+0xc4>
	for (i = 0; i < p->n_d; ++i) n *= p->d[i];
 8046de4:	469c      	mov	ip, r3
 8046de6:	f1be 0f00 	cmp.w	lr, #0
 8046dea:	d03d      	beq.n	8046e68 <kad_op_cmul+0xdc>
 8046dec:	f1be 0f01 	cmp.w	lr, #1
 8046df0:	6931      	ldr	r1, [r6, #16]
 8046df2:	dd0e      	ble.n	8046e12 <kad_op_cmul+0x86>
 8046df4:	6973      	ldr	r3, [r6, #20]
 8046df6:	f1be 0f02 	cmp.w	lr, #2
 8046dfa:	fb03 f101 	mul.w	r1, r3, r1
 8046dfe:	d008      	beq.n	8046e12 <kad_op_cmul+0x86>
 8046e00:	69b3      	ldr	r3, [r6, #24]
 8046e02:	f1be 0f03 	cmp.w	lr, #3
 8046e06:	fb03 f101 	mul.w	r1, r3, r1
 8046e0a:	d002      	beq.n	8046e12 <kad_op_cmul+0x86>
 8046e0c:	69f3      	ldr	r3, [r6, #28]
 8046e0e:	fb03 f101 	mul.w	r1, r3, r1
	n_a_row = kad_len(q[0]) / n_a_col, n_b_row = kad_len(q[1]) / n_b_col;
 8046e12:	fb91 f3f2 	sdiv	r3, r1, r2
 8046e16:	9302      	str	r3, [sp, #8]
 8046e18:	b367      	cbz	r7, 8046e74 <kad_op_cmul+0xe8>
 8046e1a:	2f01      	cmp	r7, #1
 8046e1c:	6929      	ldr	r1, [r5, #16]
 8046e1e:	d00b      	beq.n	8046e38 <kad_op_cmul+0xac>
 8046e20:	696b      	ldr	r3, [r5, #20]
 8046e22:	2f02      	cmp	r7, #2
 8046e24:	fb03 f101 	mul.w	r1, r3, r1
 8046e28:	d006      	beq.n	8046e38 <kad_op_cmul+0xac>
 8046e2a:	69ab      	ldr	r3, [r5, #24]
 8046e2c:	2f03      	cmp	r7, #3
 8046e2e:	fb03 f101 	mul.w	r1, r3, r1
 8046e32:	bf1c      	itt	ne
 8046e34:	69ef      	ldrne	r7, [r5, #28]
 8046e36:	4379      	mulne	r1, r7
	if (action == KAD_SYNC_DIM) {
 8046e38:	2804      	cmp	r0, #4
	n_a_row = kad_len(q[0]) / n_a_col, n_b_row = kad_len(q[1]) / n_b_col;
 8046e3a:	fb91 fafc 	sdiv	sl, r1, ip
	if (action == KAD_SYNC_DIM) {
 8046e3e:	d022      	beq.n	8046e86 <kad_op_cmul+0xfa>
	} else if (action == KAD_FORWARD) {
 8046e40:	2802      	cmp	r0, #2
 8046e42:	d07f      	beq.n	8046f44 <kad_op_cmul+0x1b8>
	} else if (action == KAD_BACKWARD) {
 8046e44:	2803      	cmp	r0, #3
 8046e46:	d030      	beq.n	8046eaa <kad_op_cmul+0x11e>
	return 0;
 8046e48:	2000      	movs	r0, #0
}
 8046e4a:	b00f      	add	sp, #60	@ 0x3c
 8046e4c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	for (i = q[1]->n_d - 1; i >= 0; --i) if (n_b_col < n_col) n_b_col *= q[1]->d[i];
 8046e50:	f858 c021 	ldr.w	ip, [r8, r1, lsl #2]
 8046e54:	3901      	subs	r1, #1
 8046e56:	f1b1 3fff 	cmp.w	r1, #4294967295
 8046e5a:	fb0c f303 	mul.w	r3, ip, r3
 8046e5e:	d1bf      	bne.n	8046de0 <kad_op_cmul+0x54>
 8046e60:	469c      	mov	ip, r3
 8046e62:	f1be 0f00 	cmp.w	lr, #0
 8046e66:	d1c1      	bne.n	8046dec <kad_op_cmul+0x60>
	int n = 1, i;
 8046e68:	2101      	movs	r1, #1
	n_a_row = kad_len(q[0]) / n_a_col, n_b_row = kad_len(q[1]) / n_b_col;
 8046e6a:	fb91 f3f2 	sdiv	r3, r1, r2
 8046e6e:	9302      	str	r3, [sp, #8]
	for (i = 0; i < p->n_d; ++i) n *= p->d[i];
 8046e70:	2f00      	cmp	r7, #0
 8046e72:	d1d2      	bne.n	8046e1a <kad_op_cmul+0x8e>
 8046e74:	f10c 0101 	add.w	r1, ip, #1
 8046e78:	2902      	cmp	r1, #2
 8046e7a:	bf94      	ite	ls
 8046e7c:	46e2      	movls	sl, ip
 8046e7e:	f04f 0a00 	movhi.w	sl, #0
	if (action == KAD_SYNC_DIM) {
 8046e82:	2804      	cmp	r0, #4
 8046e84:	d1dc      	bne.n	8046e40 <kad_op_cmul+0xb4>
		if (n_a_col != n_b_col) return -1;
 8046e86:	4594      	cmp	ip, r2
 8046e88:	f040 8140 	bne.w	804710c <kad_op_cmul+0x380>
		p->n_d = 2, p->d[0] = n_a_row, p->d[1] = n_b_row;
 8046e8c:	2302      	movs	r3, #2
 8046e8e:	9a02      	ldr	r2, [sp, #8]
 8046e90:	7023      	strb	r3, [r4, #0]
 8046e92:	e9c4 2a04 	strd	r2, sl, [r4, #16]
 8046e96:	e7d7      	b.n	8046e48 <kad_op_cmul+0xbc>
	for (i = q[0]->n_d - 1; i >= 0; --i) if (n_a_col < n_col) n_a_col *= q[0]->d[i];
 8046e98:	f858 c023 	ldr.w	ip, [r8, r3, lsl #2]
 8046e9c:	3b01      	subs	r3, #1
 8046e9e:	f1b3 3fff 	cmp.w	r3, #4294967295
 8046ea2:	fb0c f202 	mul.w	r2, ip, r2
 8046ea6:	d093      	beq.n	8046dd0 <kad_op_cmul+0x44>
 8046ea8:	e790      	b.n	8046dcc <kad_op_cmul+0x40>
		if (kad_is_back(q[0]) && q[1]->x)
 8046eaa:	7873      	ldrb	r3, [r6, #1]
 8046eac:	07da      	lsls	r2, r3, #31
 8046eae:	f140 80d8 	bpl.w	8047062 <kad_op_cmul+0x2d6>
 8046eb2:	6aab      	ldr	r3, [r5, #40]	@ 0x28
 8046eb4:	9303      	str	r3, [sp, #12]
 8046eb6:	2b00      	cmp	r3, #0
 8046eb8:	f000 80d3 	beq.w	8047062 <kad_op_cmul+0x2d6>
		for (i = 0; i < M; ++i)
 8046ebc:	9b02      	ldr	r3, [sp, #8]
 8046ebe:	2b00      	cmp	r3, #0
 8046ec0:	f340 80cf 	ble.w	8047062 <kad_op_cmul+0x2d6>
 8046ec4:	f1ba 0f00 	cmp.w	sl, #0
 8046ec8:	f340 80cb 	ble.w	8047062 <kad_op_cmul+0x2d6>
 8046ecc:	f1b9 0f00 	cmp.w	r9, #0
 8046ed0:	f340 80c7 	ble.w	8047062 <kad_op_cmul+0x2d6>
			kad_sgemm_simple(0, 0, n_a_row, n_col, n_b_row, p->g, q[1]->x, q[0]->g); /* G_x <- G_y * W */
 8046ed4:	2300      	movs	r3, #0
 8046ed6:	6af7      	ldr	r7, [r6, #44]	@ 0x2c
 8046ed8:	6ae2      	ldr	r2, [r4, #44]	@ 0x2c
 8046eda:	ea4f 018a 	mov.w	r1, sl, lsl #2
 8046ede:	eb07 0089 	add.w	r0, r7, r9, lsl #2
 8046ee2:	9205      	str	r2, [sp, #20]
 8046ee4:	9104      	str	r1, [sp, #16]
 8046ee6:	eb02 088a 	add.w	r8, r2, sl, lsl #2
 8046eea:	4601      	mov	r1, r0
		for (i = 0; i < M; ++i)
 8046eec:	461a      	mov	r2, r3
 8046eee:	ea4f 0b89 	mov.w	fp, r9, lsl #2
 8046ef2:	9701      	str	r7, [sp, #4]
		for (i = 0; i < M; i += x)
 8046ef4:	f04f 0e00 	mov.w	lr, #0
 8046ef8:	9f05      	ldr	r7, [sp, #20]
 8046efa:	e9cd 6506 	strd	r6, r5, [sp, #24]
 8046efe:	eb07 0c83 	add.w	ip, r7, r3, lsl #2
 8046f02:	9f01      	ldr	r7, [sp, #4]
				kad_saxpy_inlined(N, A[i*K+k], &B[k*N], &C[i*N]);
 8046f04:	ecfc 6a01 	vldmia	ip!, {s13}
 8046f08:	463d      	mov	r5, r7
 8046f0a:	9e03      	ldr	r6, [sp, #12]
 8046f0c:	4476      	add	r6, lr
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 8046f0e:	edd5 7a00 	vldr	s15, [r5]
 8046f12:	ecb6 7a01 	vldmia	r6!, {s14}
 8046f16:	eee6 7a87 	vfma.f32	s15, s13, s14
 8046f1a:	ece5 7a01 	vstmia	r5!, {s15}
 8046f1e:	428d      	cmp	r5, r1
 8046f20:	d1f5      	bne.n	8046f0e <kad_op_cmul+0x182>
			for (k = 0; k < K; ++k)
 8046f22:	45c4      	cmp	ip, r8
 8046f24:	44de      	add	lr, fp
 8046f26:	d1ed      	bne.n	8046f04 <kad_op_cmul+0x178>
		for (i = 0; i < M; ++i)
 8046f28:	e9dd 6506 	ldrd	r6, r5, [sp, #24]
 8046f2c:	9f04      	ldr	r7, [sp, #16]
 8046f2e:	3201      	adds	r2, #1
 8046f30:	44b8      	add	r8, r7
 8046f32:	9f02      	ldr	r7, [sp, #8]
 8046f34:	4459      	add	r1, fp
 8046f36:	42ba      	cmp	r2, r7
 8046f38:	4453      	add	r3, sl
 8046f3a:	9001      	str	r0, [sp, #4]
 8046f3c:	f000 8091 	beq.w	8047062 <kad_op_cmul+0x2d6>
 8046f40:	4458      	add	r0, fp
 8046f42:	e7d7      	b.n	8046ef4 <kad_op_cmul+0x168>
		memset(p->x, 0, n_a_row * n_b_row * sizeof(float));
 8046f44:	9f02      	ldr	r7, [sp, #8]
 8046f46:	2100      	movs	r1, #0
 8046f48:	fb07 f20a 	mul.w	r2, r7, sl
 8046f4c:	6aa0      	ldr	r0, [r4, #40]	@ 0x28
 8046f4e:	0092      	lsls	r2, r2, #2
 8046f50:	f004 ff70 	bl	804be34 <memset>
		if (q[0]->x && q[1]->x)
 8046f54:	6ab3      	ldr	r3, [r6, #40]	@ 0x28
 8046f56:	2b00      	cmp	r3, #0
 8046f58:	f43f af76 	beq.w	8046e48 <kad_op_cmul+0xbc>
 8046f5c:	6aad      	ldr	r5, [r5, #40]	@ 0x28
 8046f5e:	2d00      	cmp	r5, #0
 8046f60:	f43f af72 	beq.w	8046e48 <kad_op_cmul+0xbc>
		for (i = 0; i < M; i += x)
 8046f64:	2f00      	cmp	r7, #0
 8046f66:	f77f af6f 	ble.w	8046e48 <kad_op_cmul+0xbc>
 8046f6a:	f1ba 0f00 	cmp.w	sl, #0
					for (jj = j, bjj = B + j * K; jj < je; ++jj, bjj += K)
 8046f6e:	ea4f 0889 	mov.w	r8, r9, lsl #2
 8046f72:	f77f af69 	ble.w	8046e48 <kad_op_cmul+0xbc>
			kad_sgemm_simple(0, 1, n_a_row, n_b_row, n_col, q[0]->x, q[1]->x, p->x); /* Y = X * trans(W) */
 8046f76:	2200      	movs	r2, #0
 8046f78:	ea4f 1c0a 	mov.w	ip, sl, lsl #4
 8046f7c:	4661      	mov	r1, ip
 8046f7e:	9304      	str	r3, [sp, #16]
 8046f80:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
 8046f82:	9205      	str	r2, [sp, #20]
 8046f84:	9307      	str	r3, [sp, #28]
		for (i = 0; i < M; i += x)
 8046f86:	ebc9 1309 	rsb	r3, r9, r9, lsl #4
 8046f8a:	009c      	lsls	r4, r3, #2
 8046f8c:	ea4f 1389 	mov.w	r3, r9, lsl #6
 8046f90:	9308      	str	r3, [sp, #32]
 8046f92:	ea4f 0b8a 	mov.w	fp, sl, lsl #2
 8046f96:	9203      	str	r2, [sp, #12]
			for (j = 0; j < N; j += x) {
 8046f98:	9e02      	ldr	r6, [sp, #8]
 8046f9a:	9b03      	ldr	r3, [sp, #12]
 8046f9c:	4632      	mov	r2, r6
 8046f9e:	f103 0010 	add.w	r0, r3, #16
				int ii, ie = M < i + x? M : i + x;
 8046fa2:	330f      	adds	r3, #15
 8046fa4:	42b3      	cmp	r3, r6
 8046fa6:	bfb8      	it	lt
 8046fa8:	4602      	movlt	r2, r0
 8046faa:	900b      	str	r0, [sp, #44]	@ 0x2c
 8046fac:	46ac      	mov	ip, r5
			for (j = 0; j < N; j += x) {
 8046fae:	2300      	movs	r3, #0
 8046fb0:	4620      	mov	r0, r4
 8046fb2:	4696      	mov	lr, r2
 8046fb4:	9a04      	ldr	r2, [sp, #16]
 8046fb6:	e9cd 5109 	strd	r5, r1, [sp, #36]	@ 0x24
 8046fba:	4442      	add	r2, r8
 8046fbc:	9206      	str	r2, [sp, #24]
				int jj, je = N < j + x? N : j + x;
 8046fbe:	461a      	mov	r2, r3
				for (ii = i; ii < ie; ++ii) { /* loop tiling */
 8046fc0:	9903      	ldr	r1, [sp, #12]
			for (j = 0; j < N; j += x) {
 8046fc2:	3310      	adds	r3, #16
				int jj, je = N < j + x? N : j + x;
 8046fc4:	f102 050f 	add.w	r5, r2, #15
 8046fc8:	4555      	cmp	r5, sl
 8046fca:	bfb4      	ite	lt
 8046fcc:	461c      	movlt	r4, r3
 8046fce:	4654      	movge	r4, sl
				for (ii = i; ii < ie; ++ii) { /* loop tiling */
 8046fd0:	458e      	cmp	lr, r1
 8046fd2:	dd33      	ble.n	804703c <kad_op_cmul+0x2b0>
 8046fd4:	4294      	cmp	r4, r2
 8046fd6:	dd31      	ble.n	804703c <kad_op_cmul+0x2b0>
 8046fd8:	9905      	ldr	r1, [sp, #20]
 8046fda:	1b12      	subs	r2, r2, r4
 8046fdc:	440c      	add	r4, r1
 8046fde:	9907      	ldr	r1, [sp, #28]
					for (jj = j, bjj = B + j * K; jj < je; ++jj, bjj += K)
 8046fe0:	e9cd 3a0c 	strd	r3, sl, [sp, #48]	@ 0x30
 8046fe4:	eb01 0584 	add.w	r5, r1, r4, lsl #2
 8046fe8:	4601      	mov	r1, r0
 8046fea:	9c06      	ldr	r4, [sp, #24]
 8046fec:	0097      	lsls	r7, r2, #2
 8046fee:	e9dd 2603 	ldrd	r2, r6, [sp, #12]
 8046ff2:	46e2      	mov	sl, ip
 8046ff4:	1978      	adds	r0, r7, r5
 8046ff6:	9201      	str	r2, [sp, #4]
	for (i = 0; i < n; ++i) s += x[i] * y[i];
 8046ff8:	f1b9 0f00 	cmp.w	r9, #0
	float s = 0.;
 8046ffc:	eddf 7a45 	vldr	s15, [pc, #276]	@ 8047114 <kad_op_cmul+0x388>
	for (i = 0; i < n; ++i) s += x[i] * y[i];
 8047000:	dd09      	ble.n	8047016 <kad_op_cmul+0x28a>
 8047002:	4652      	mov	r2, sl
 8047004:	4633      	mov	r3, r6
 8047006:	ecf3 6a01 	vldmia	r3!, {s13}
 804700a:	ecb2 7a01 	vldmia	r2!, {s14}
 804700e:	42a3      	cmp	r3, r4
 8047010:	eee6 7a87 	vfma.f32	s15, s13, s14
 8047014:	d1f7      	bne.n	8047006 <kad_op_cmul+0x27a>
						cii[jj] += kad_sdot(K, aii, bjj);
 8047016:	ed90 7a00 	vldr	s14, [r0]
 804701a:	ee77 7a27 	vadd.f32	s15, s14, s15
 804701e:	ece0 7a01 	vstmia	r0!, {s15}
					for (jj = j, bjj = B + j * K; jj < je; ++jj, bjj += K)
 8047022:	4285      	cmp	r5, r0
 8047024:	44c2      	add	sl, r8
 8047026:	d1e7      	bne.n	8046ff8 <kad_op_cmul+0x26c>
				for (ii = i; ii < ie; ++ii) { /* loop tiling */
 8047028:	9a01      	ldr	r2, [sp, #4]
 804702a:	445d      	add	r5, fp
 804702c:	3201      	adds	r2, #1
 804702e:	4572      	cmp	r2, lr
 8047030:	4446      	add	r6, r8
 8047032:	4444      	add	r4, r8
 8047034:	d1dd      	bne.n	8046ff2 <kad_op_cmul+0x266>
 8047036:	e9dd 3a0c 	ldrd	r3, sl, [sp, #48]	@ 0x30
 804703a:	4608      	mov	r0, r1
			for (j = 0; j < N; j += x) {
 804703c:	9a08      	ldr	r2, [sp, #32]
 804703e:	4553      	cmp	r3, sl
 8047040:	4494      	add	ip, r2
 8047042:	dbbc      	blt.n	8046fbe <kad_op_cmul+0x232>
 8047044:	e9dd 5109 	ldrd	r5, r1, [sp, #36]	@ 0x24
 8047048:	4604      	mov	r4, r0
		for (i = 0; i < M; i += x)
 804704a:	9b05      	ldr	r3, [sp, #20]
 804704c:	980b      	ldr	r0, [sp, #44]	@ 0x2c
 804704e:	440b      	add	r3, r1
 8047050:	9a02      	ldr	r2, [sp, #8]
 8047052:	9305      	str	r3, [sp, #20]
 8047054:	9b06      	ldr	r3, [sp, #24]
 8047056:	4290      	cmp	r0, r2
 8047058:	4423      	add	r3, r4
 804705a:	9003      	str	r0, [sp, #12]
 804705c:	9304      	str	r3, [sp, #16]
 804705e:	db9b      	blt.n	8046f98 <kad_op_cmul+0x20c>
 8047060:	e6f2      	b.n	8046e48 <kad_op_cmul+0xbc>
		if (kad_is_back(q[1]) && q[0]->x)
 8047062:	786b      	ldrb	r3, [r5, #1]
 8047064:	07db      	lsls	r3, r3, #31
 8047066:	f57f aeef 	bpl.w	8046e48 <kad_op_cmul+0xbc>
 804706a:	6ab0      	ldr	r0, [r6, #40]	@ 0x28
 804706c:	2800      	cmp	r0, #0
 804706e:	f43f aeeb 	beq.w	8046e48 <kad_op_cmul+0xbc>
		for (k = 0; k < K; ++k)
 8047072:	9b02      	ldr	r3, [sp, #8]
 8047074:	2b00      	cmp	r3, #0
 8047076:	f77f aee7 	ble.w	8046e48 <kad_op_cmul+0xbc>
 804707a:	f1ba 0f00 	cmp.w	sl, #0
 804707e:	f77f aee3 	ble.w	8046e48 <kad_op_cmul+0xbc>
 8047082:	f1b9 0f00 	cmp.w	r9, #0
 8047086:	f77f aedf 	ble.w	8046e48 <kad_op_cmul+0xbc>
			kad_sgemm_simple(1, 0, n_b_row, n_col, n_a_row, p->g, q[0]->x, q[1]->g); /* G_w <- trans(G_y) * X */
 804708a:	2200      	movs	r2, #0
 804708c:	ea4f 038a 	mov.w	r3, sl, lsl #2
 8047090:	f8d4 e02c 	ldr.w	lr, [r4, #44]	@ 0x2c
 8047094:	4619      	mov	r1, r3
		for (k = 0; k < K; ++k)
 8047096:	4614      	mov	r4, r2
 8047098:	6aef      	ldr	r7, [r5, #44]	@ 0x2c
			for (i = 0; i < M; ++i)
 804709a:	ebc9 7649 	rsb	r6, r9, r9, lsl #29
 804709e:	eb07 0789 	add.w	r7, r7, r9, lsl #2
 80470a2:	00f6      	lsls	r6, r6, #3
 80470a4:	ea4f 0989 	mov.w	r9, r9, lsl #2
 80470a8:	eb0e 058a 	add.w	r5, lr, sl, lsl #2
		for (i = 0; i < M; ++i)
 80470ac:	46b8      	mov	r8, r7
 80470ae:	eb0e 0b82 	add.w	fp, lr, r2, lsl #2
 80470b2:	9201      	str	r2, [sp, #4]
				kad_saxpy_inlined(N, A[k*M+i], &B[k*N], &C[i*N]);
 80470b4:	eba8 0209 	sub.w	r2, r8, r9
 80470b8:	ecfb 6a01 	vldmia	fp!, {s13}
 80470bc:	4684      	mov	ip, r0
 80470be:	4613      	mov	r3, r2
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 80470c0:	edd3 7a00 	vldr	s15, [r3]
 80470c4:	ecbc 7a01 	vldmia	ip!, {s14}
 80470c8:	eee6 7a87 	vfma.f32	s15, s13, s14
 80470cc:	ece3 7a01 	vstmia	r3!, {s15}
 80470d0:	4598      	cmp	r8, r3
 80470d2:	d1f5      	bne.n	80470c0 <kad_op_cmul+0x334>
			for (i = 0; i < M; ++i)
 80470d4:	455d      	cmp	r5, fp
 80470d6:	eba2 0806 	sub.w	r8, r2, r6
 80470da:	d1eb      	bne.n	80470b4 <kad_op_cmul+0x328>
		for (k = 0; k < K; ++k)
 80470dc:	9b02      	ldr	r3, [sp, #8]
 80470de:	9a01      	ldr	r2, [sp, #4]
 80470e0:	3401      	adds	r4, #1
 80470e2:	429c      	cmp	r4, r3
 80470e4:	440d      	add	r5, r1
 80470e6:	4448      	add	r0, r9
 80470e8:	4452      	add	r2, sl
 80470ea:	d1df      	bne.n	80470ac <kad_op_cmul+0x320>
 80470ec:	e6ac      	b.n	8046e48 <kad_op_cmul+0xbc>
	for (i = q[1]->n_d - 1; i >= 0; --i) if (n_b_col < n_col) n_b_col *= q[1]->d[i];
 80470ee:	1c4a      	adds	r2, r1, #1
	int i, n_a_row, n_b_row, n_col, n_a_col = 1, n_b_col = 1;
 80470f0:	bf18      	it	ne
 80470f2:	2201      	movne	r2, #1
	for (i = q[1]->n_d - 1; i >= 0; --i) if (n_b_col < n_col) n_b_col *= q[1]->d[i];
 80470f4:	f47f ae6f 	bne.w	8046dd6 <kad_op_cmul+0x4a>
	n_a_row = kad_len(q[0]) / n_a_col, n_b_row = kad_len(q[1]) / n_b_col;
 80470f8:	2301      	movs	r3, #1
	if (action == KAD_SYNC_DIM) {
 80470fa:	2804      	cmp	r0, #4
 80470fc:	469a      	mov	sl, r3
	n_a_row = kad_len(q[0]) / n_a_col, n_b_row = kad_len(q[1]) / n_b_col;
 80470fe:	9302      	str	r3, [sp, #8]
	if (action == KAD_SYNC_DIM) {
 8047100:	f47f ae9e 	bne.w	8046e40 <kad_op_cmul+0xb4>
 8047104:	e6c2      	b.n	8046e8c <kad_op_cmul+0x100>
	int i, n_a_row, n_b_row, n_col, n_a_col = 1, n_b_col = 1;
 8047106:	f04f 0c01 	mov.w	ip, #1
 804710a:	e66f      	b.n	8046dec <kad_op_cmul+0x60>
		if (n_a_col != n_b_col) return -1;
 804710c:	f04f 30ff 	mov.w	r0, #4294967295
 8047110:	e69b      	b.n	8046e4a <kad_op_cmul+0xbe>
 8047112:	bf00      	nop
 8047114:	00000000 	.word	0x00000000

08047118 <kad_op_matmul>:
{
 8047118:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	q[0] = p->child[0];
 804711c:	6b83      	ldr	r3, [r0, #56]	@ 0x38
{
 804711e:	468c      	mov	ip, r1
	q[1] = p->child[1];
 8047120:	e9d3 7600 	ldrd	r7, r6, [r3]
	n_a_row = q[0]->n_d == 1? 1 : q[0]->d[0];
 8047124:	783b      	ldrb	r3, [r7, #0]
{
 8047126:	4605      	mov	r5, r0
	n_a_row = q[0]->n_d == 1? 1 : q[0]->d[0];
 8047128:	2b01      	cmp	r3, #1
 804712a:	693c      	ldr	r4, [r7, #16]
	n_b_row = q[1]->n_d == 1? 1 : q[1]->d[0];
 804712c:	7831      	ldrb	r1, [r6, #0]
{
 804712e:	b093      	sub	sp, #76	@ 0x4c
	n_a_row = q[0]->n_d == 1? 1 : q[0]->d[0];
 8047130:	d042      	beq.n	80471b8 <kad_op_matmul+0xa0>
	n_b_row = q[1]->n_d == 1? 1 : q[1]->d[0];
 8047132:	2901      	cmp	r1, #1
 8047134:	d035      	beq.n	80471a2 <kad_op_matmul+0x8a>
 8047136:	6932      	ldr	r2, [r6, #16]
 8047138:	9202      	str	r2, [sp, #8]
 804713a:	2b00      	cmp	r3, #0
 804713c:	d055      	beq.n	80471ea <kad_op_matmul+0xd2>
 804713e:	697a      	ldr	r2, [r7, #20]
 8047140:	2b02      	cmp	r3, #2
 8047142:	fb04 f202 	mul.w	r2, r4, r2
 8047146:	d007      	beq.n	8047158 <kad_op_matmul+0x40>
 8047148:	69b8      	ldr	r0, [r7, #24]
 804714a:	2b03      	cmp	r3, #3
 804714c:	fb00 f202 	mul.w	r2, r0, r2
 8047150:	d002      	beq.n	8047158 <kad_op_matmul+0x40>
 8047152:	69fb      	ldr	r3, [r7, #28]
 8047154:	fb03 f202 	mul.w	r2, r3, r2
	n_a_col = kad_len(q[0]) / n_a_row;
 8047158:	fb92 fbf4 	sdiv	fp, r2, r4
 804715c:	2900      	cmp	r1, #0
 804715e:	d035      	beq.n	80471cc <kad_op_matmul+0xb4>
 8047160:	2901      	cmp	r1, #1
 8047162:	6933      	ldr	r3, [r6, #16]
 8047164:	d00c      	beq.n	8047180 <kad_op_matmul+0x68>
 8047166:	6972      	ldr	r2, [r6, #20]
 8047168:	2902      	cmp	r1, #2
 804716a:	fb02 f303 	mul.w	r3, r2, r3
 804716e:	d007      	beq.n	8047180 <kad_op_matmul+0x68>
 8047170:	69b2      	ldr	r2, [r6, #24]
 8047172:	2903      	cmp	r1, #3
 8047174:	fb02 f303 	mul.w	r3, r2, r3
 8047178:	d002      	beq.n	8047180 <kad_op_matmul+0x68>
 804717a:	69f2      	ldr	r2, [r6, #28]
 804717c:	fb02 f303 	mul.w	r3, r2, r3
	n_b_col = kad_len(q[1]) / n_b_row;
 8047180:	9a02      	ldr	r2, [sp, #8]
	if (action == KAD_SYNC_DIM) {
 8047182:	f1bc 0f04 	cmp.w	ip, #4
	n_b_col = kad_len(q[1]) / n_b_row;
 8047186:	fb93 f9f2 	sdiv	r9, r3, r2
	if (action == KAD_SYNC_DIM) {
 804718a:	d026      	beq.n	80471da <kad_op_matmul+0xc2>
	} else if (action == KAD_FORWARD) {
 804718c:	f1bc 0f02 	cmp.w	ip, #2
 8047190:	f000 8105 	beq.w	804739e <kad_op_matmul+0x286>
	} else if (action == KAD_BACKWARD) {
 8047194:	f1bc 0f03 	cmp.w	ip, #3
 8047198:	d02e      	beq.n	80471f8 <kad_op_matmul+0xe0>
	return 0;
 804719a:	2000      	movs	r0, #0
}
 804719c:	b013      	add	sp, #76	@ 0x4c
 804719e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	n_b_row = q[1]->n_d == 1? 1 : q[1]->d[0];
 80471a2:	9102      	str	r1, [sp, #8]
 80471a4:	2b00      	cmp	r3, #0
 80471a6:	d1ca      	bne.n	804713e <kad_op_matmul+0x26>
	n_a_col = kad_len(q[0]) / n_a_row;
 80471a8:	1c63      	adds	r3, r4, #1
 80471aa:	2b02      	cmp	r3, #2
 80471ac:	bf94      	ite	ls
 80471ae:	46a3      	movls	fp, r4
 80471b0:	f04f 0b00 	movhi.w	fp, #0
 80471b4:	6933      	ldr	r3, [r6, #16]
 80471b6:	e7e3      	b.n	8047180 <kad_op_matmul+0x68>
	n_b_row = q[1]->n_d == 1? 1 : q[1]->d[0];
 80471b8:	2901      	cmp	r1, #1
 80471ba:	d018      	beq.n	80471ee <kad_op_matmul+0xd6>
 80471bc:	4622      	mov	r2, r4
	n_a_row = q[0]->n_d == 1? 1 : q[0]->d[0];
 80471be:	461c      	mov	r4, r3
	n_b_row = q[1]->n_d == 1? 1 : q[1]->d[0];
 80471c0:	6933      	ldr	r3, [r6, #16]
	n_a_col = kad_len(q[0]) / n_a_row;
 80471c2:	fb92 fbf4 	sdiv	fp, r2, r4
	n_b_row = q[1]->n_d == 1? 1 : q[1]->d[0];
 80471c6:	9302      	str	r3, [sp, #8]
 80471c8:	2900      	cmp	r1, #0
 80471ca:	d1c9      	bne.n	8047160 <kad_op_matmul+0x48>
	int n = 1, i;
 80471cc:	2301      	movs	r3, #1
	n_b_col = kad_len(q[1]) / n_b_row;
 80471ce:	9a02      	ldr	r2, [sp, #8]
	if (action == KAD_SYNC_DIM) {
 80471d0:	f1bc 0f04 	cmp.w	ip, #4
	n_b_col = kad_len(q[1]) / n_b_row;
 80471d4:	fb93 f9f2 	sdiv	r9, r3, r2
	if (action == KAD_SYNC_DIM) {
 80471d8:	d1d8      	bne.n	804718c <kad_op_matmul+0x74>
		if (n_a_col != n_b_row) return -1;
 80471da:	455a      	cmp	r2, fp
 80471dc:	f040 812d 	bne.w	804743a <kad_op_matmul+0x322>
		p->n_d = 2, p->d[0] = n_a_row, p->d[1] = n_b_col;
 80471e0:	2302      	movs	r3, #2
 80471e2:	e9c5 4904 	strd	r4, r9, [r5, #16]
 80471e6:	702b      	strb	r3, [r5, #0]
 80471e8:	e7d7      	b.n	804719a <kad_op_matmul+0x82>
 80471ea:	2201      	movs	r2, #1
 80471ec:	e7b4      	b.n	8047158 <kad_op_matmul+0x40>
	n_a_col = kad_len(q[0]) / n_a_row;
 80471ee:	46a3      	mov	fp, r4
	for (i = 0; i < p->n_d; ++i) n *= p->d[i];
 80471f0:	6933      	ldr	r3, [r6, #16]
	n_a_row = q[0]->n_d == 1? 1 : q[0]->d[0];
 80471f2:	460c      	mov	r4, r1
	n_b_row = q[1]->n_d == 1? 1 : q[1]->d[0];
 80471f4:	9102      	str	r1, [sp, #8]
 80471f6:	e7c3      	b.n	8047180 <kad_op_matmul+0x68>
		if (kad_is_back(q[0]) && q[1]->x)
 80471f8:	787b      	ldrb	r3, [r7, #1]
 80471fa:	07da      	lsls	r2, r3, #31
 80471fc:	f140 808b 	bpl.w	8047316 <kad_op_matmul+0x1fe>
 8047200:	f8d6 c028 	ldr.w	ip, [r6, #40]	@ 0x28
 8047204:	f1bc 0f00 	cmp.w	ip, #0
 8047208:	f000 8085 	beq.w	8047316 <kad_op_matmul+0x1fe>
		for (i = 0; i < M; i += x)
 804720c:	2c00      	cmp	r4, #0
 804720e:	f340 8082 	ble.w	8047316 <kad_op_matmul+0x1fe>
 8047212:	f1bb 0f00 	cmp.w	fp, #0
					for (jj = j, bjj = B + j * K; jj < je; ++jj, bjj += K)
 8047216:	ea4f 0889 	mov.w	r8, r9, lsl #2
 804721a:	dd7c      	ble.n	8047316 <kad_op_matmul+0x1fe>
			kad_sgemm_simple(0, 1, n_a_row, n_a_col, n_b_col, p->g, q[1]->x, q[0]->g); /* G_x <- G_y * trans(W) */
 804721c:	2100      	movs	r1, #0
		for (i = 0; i < M; i += x)
 804721e:	ebc9 1309 	rsb	r3, r9, r9, lsl #4
 8047222:	ea4f 0e83 	mov.w	lr, r3, lsl #2
 8047226:	e9cd 7609 	strd	r7, r6, [sp, #36]	@ 0x24
			kad_sgemm_simple(0, 1, n_a_row, n_a_col, n_b_col, p->g, q[1]->x, q[0]->g); /* G_x <- G_y * trans(W) */
 804722a:	9104      	str	r1, [sp, #16]
		for (i = 0; i < M; i += x)
 804722c:	9103      	str	r1, [sp, #12]
 804722e:	4666      	mov	r6, ip
 8047230:	4671      	mov	r1, lr
			kad_sgemm_simple(0, 1, n_a_row, n_a_col, n_b_col, p->g, q[1]->x, q[0]->g); /* G_x <- G_y * trans(W) */
 8047232:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8047234:	ea4f 120b 	mov.w	r2, fp, lsl #4
 8047238:	9307      	str	r3, [sp, #28]
 804723a:	6aeb      	ldr	r3, [r5, #44]	@ 0x2c
 804723c:	ea4f 0a8b 	mov.w	sl, fp, lsl #2
 8047240:	9305      	str	r3, [sp, #20]
 8047242:	ea4f 1389 	mov.w	r3, r9, lsl #6
 8047246:	9308      	str	r3, [sp, #32]
 8047248:	920b      	str	r2, [sp, #44]	@ 0x2c
			for (j = 0; j < N; j += x) {
 804724a:	9b03      	ldr	r3, [sp, #12]
 804724c:	46b4      	mov	ip, r6
 804724e:	f103 0710 	add.w	r7, r3, #16
				int ii, ie = M < i + x? M : i + x;
 8047252:	330f      	adds	r3, #15
 8047254:	42a3      	cmp	r3, r4
 8047256:	bfb4      	ite	lt
 8047258:	46be      	movlt	lr, r7
 804725a:	46a6      	movge	lr, r4
 804725c:	4608      	mov	r0, r1
 804725e:	2300      	movs	r3, #0
 8047260:	9a05      	ldr	r2, [sp, #20]
 8047262:	e9cd 460c 	strd	r4, r6, [sp, #48]	@ 0x30
 8047266:	e9cd 570e 	strd	r5, r7, [sp, #56]	@ 0x38
 804726a:	4442      	add	r2, r8
 804726c:	9206      	str	r2, [sp, #24]
 804726e:	461a      	mov	r2, r3
				for (ii = i; ii < ie; ++ii) { /* loop tiling */
 8047270:	9903      	ldr	r1, [sp, #12]
 8047272:	3310      	adds	r3, #16
				int jj, je = N < j + x? N : j + x;
 8047274:	f102 050f 	add.w	r5, r2, #15
 8047278:	45ab      	cmp	fp, r5
 804727a:	bfd4      	ite	le
 804727c:	465c      	movle	r4, fp
 804727e:	461c      	movgt	r4, r3
				for (ii = i; ii < ie; ++ii) { /* loop tiling */
 8047280:	458e      	cmp	lr, r1
 8047282:	dd33      	ble.n	80472ec <kad_op_matmul+0x1d4>
 8047284:	4294      	cmp	r4, r2
 8047286:	dd31      	ble.n	80472ec <kad_op_matmul+0x1d4>
 8047288:	9904      	ldr	r1, [sp, #16]
 804728a:	1b12      	subs	r2, r2, r4
 804728c:	440c      	add	r4, r1
 804728e:	9907      	ldr	r1, [sp, #28]
					for (jj = j, bjj = B + j * K; jj < je; ++jj, bjj += K)
 8047290:	e9cd b310 	strd	fp, r3, [sp, #64]	@ 0x40
 8047294:	eb01 0584 	add.w	r5, r1, r4, lsl #2
 8047298:	4601      	mov	r1, r0
 804729a:	e9dd 6405 	ldrd	r6, r4, [sp, #20]
 804729e:	0097      	lsls	r7, r2, #2
 80472a0:	9a03      	ldr	r2, [sp, #12]
 80472a2:	46e3      	mov	fp, ip
 80472a4:	19e8      	adds	r0, r5, r7
 80472a6:	9201      	str	r2, [sp, #4]
	for (i = 0; i < n; ++i) s += x[i] * y[i];
 80472a8:	f1b9 0f00 	cmp.w	r9, #0
	float s = 0.;
 80472ac:	eddf 7a64 	vldr	s15, [pc, #400]	@ 8047440 <kad_op_matmul+0x328>
	for (i = 0; i < n; ++i) s += x[i] * y[i];
 80472b0:	dd09      	ble.n	80472c6 <kad_op_matmul+0x1ae>
 80472b2:	465a      	mov	r2, fp
 80472b4:	4633      	mov	r3, r6
 80472b6:	ecf3 6a01 	vldmia	r3!, {s13}
 80472ba:	ecb2 7a01 	vldmia	r2!, {s14}
 80472be:	42a3      	cmp	r3, r4
 80472c0:	eee6 7a87 	vfma.f32	s15, s13, s14
 80472c4:	d1f7      	bne.n	80472b6 <kad_op_matmul+0x19e>
						cii[jj] += kad_sdot(K, aii, bjj);
 80472c6:	ed90 7a00 	vldr	s14, [r0]
 80472ca:	ee77 7a27 	vadd.f32	s15, s14, s15
 80472ce:	ece0 7a01 	vstmia	r0!, {s15}
					for (jj = j, bjj = B + j * K; jj < je; ++jj, bjj += K)
 80472d2:	4285      	cmp	r5, r0
 80472d4:	44c3      	add	fp, r8
 80472d6:	d1e7      	bne.n	80472a8 <kad_op_matmul+0x190>
				for (ii = i; ii < ie; ++ii) { /* loop tiling */
 80472d8:	9a01      	ldr	r2, [sp, #4]
 80472da:	4455      	add	r5, sl
 80472dc:	3201      	adds	r2, #1
 80472de:	4572      	cmp	r2, lr
 80472e0:	4446      	add	r6, r8
 80472e2:	4444      	add	r4, r8
 80472e4:	d1dd      	bne.n	80472a2 <kad_op_matmul+0x18a>
 80472e6:	e9dd b310 	ldrd	fp, r3, [sp, #64]	@ 0x40
 80472ea:	4608      	mov	r0, r1
			for (j = 0; j < N; j += x) {
 80472ec:	9a08      	ldr	r2, [sp, #32]
 80472ee:	455b      	cmp	r3, fp
 80472f0:	4494      	add	ip, r2
 80472f2:	dbbc      	blt.n	804726e <kad_op_matmul+0x156>
 80472f4:	e9dd 570e 	ldrd	r5, r7, [sp, #56]	@ 0x38
 80472f8:	e9dd 460c 	ldrd	r4, r6, [sp, #48]	@ 0x30
		for (i = 0; i < M; i += x)
 80472fc:	9b04      	ldr	r3, [sp, #16]
 80472fe:	9a0b      	ldr	r2, [sp, #44]	@ 0x2c
 8047300:	42bc      	cmp	r4, r7
 8047302:	4413      	add	r3, r2
 8047304:	9304      	str	r3, [sp, #16]
 8047306:	9b06      	ldr	r3, [sp, #24]
 8047308:	4601      	mov	r1, r0
 804730a:	4403      	add	r3, r0
 804730c:	9703      	str	r7, [sp, #12]
 804730e:	9305      	str	r3, [sp, #20]
 8047310:	dc9b      	bgt.n	804724a <kad_op_matmul+0x132>
 8047312:	e9dd 7609 	ldrd	r7, r6, [sp, #36]	@ 0x24
		if (kad_is_back(q[1]) && q[0]->x)
 8047316:	7873      	ldrb	r3, [r6, #1]
 8047318:	07db      	lsls	r3, r3, #31
 804731a:	f57f af3e 	bpl.w	804719a <kad_op_matmul+0x82>
 804731e:	6abf      	ldr	r7, [r7, #40]	@ 0x28
 8047320:	2f00      	cmp	r7, #0
 8047322:	f43f af3a 	beq.w	804719a <kad_op_matmul+0x82>
		for (k = 0; k < K; ++k)
 8047326:	2c00      	cmp	r4, #0
 8047328:	f77f af37 	ble.w	804719a <kad_op_matmul+0x82>
 804732c:	9902      	ldr	r1, [sp, #8]
 804732e:	2900      	cmp	r1, #0
 8047330:	f77f af33 	ble.w	804719a <kad_op_matmul+0x82>
 8047334:	f1b9 0f00 	cmp.w	r9, #0
 8047338:	f77f af2f 	ble.w	804719a <kad_op_matmul+0x82>
			kad_sgemm_simple(1, 0, n_b_row, n_b_col, n_a_row, q[0]->x, p->g, q[1]->g); /* G_y <- trans(A) * G_y */
 804733c:	2200      	movs	r2, #0
 804733e:	6af3      	ldr	r3, [r6, #44]	@ 0x2c
 8047340:	f8d5 e02c 	ldr.w	lr, [r5, #44]	@ 0x2c
 8047344:	eb03 0c89 	add.w	ip, r3, r9, lsl #2
 8047348:	008b      	lsls	r3, r1, #2
 804734a:	eb07 0581 	add.w	r5, r7, r1, lsl #2
		for (k = 0; k < K; ++k)
 804734e:	4610      	mov	r0, r2
 8047350:	4619      	mov	r1, r3
			for (i = 0; i < M; ++i)
 8047352:	ebc9 7649 	rsb	r6, r9, r9, lsl #29
 8047356:	00f6      	lsls	r6, r6, #3
 8047358:	ea4f 0989 	mov.w	r9, r9, lsl #2
		for (i = 0; i < M; i += x)
 804735c:	46e2      	mov	sl, ip
 804735e:	eb07 0b82 	add.w	fp, r7, r2, lsl #2
 8047362:	9201      	str	r2, [sp, #4]
				kad_saxpy_inlined(N, A[k*M+i], &B[k*N], &C[i*N]);
 8047364:	ebaa 0209 	sub.w	r2, sl, r9
 8047368:	ecfb 6a01 	vldmia	fp!, {s13}
 804736c:	46f0      	mov	r8, lr
 804736e:	4613      	mov	r3, r2
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 8047370:	edd3 7a00 	vldr	s15, [r3]
 8047374:	ecb8 7a01 	vldmia	r8!, {s14}
 8047378:	eee6 7a87 	vfma.f32	s15, s13, s14
 804737c:	ece3 7a01 	vstmia	r3!, {s15}
 8047380:	459a      	cmp	sl, r3
 8047382:	d1f5      	bne.n	8047370 <kad_op_matmul+0x258>
			for (i = 0; i < M; ++i)
 8047384:	455d      	cmp	r5, fp
 8047386:	eba2 0a06 	sub.w	sl, r2, r6
 804738a:	d1eb      	bne.n	8047364 <kad_op_matmul+0x24c>
		for (k = 0; k < K; ++k)
 804738c:	9a01      	ldr	r2, [sp, #4]
 804738e:	9b02      	ldr	r3, [sp, #8]
 8047390:	3001      	adds	r0, #1
 8047392:	4284      	cmp	r4, r0
 8047394:	440d      	add	r5, r1
 8047396:	44ce      	add	lr, r9
 8047398:	441a      	add	r2, r3
 804739a:	d1df      	bne.n	804735c <kad_op_matmul+0x244>
 804739c:	e6fd      	b.n	804719a <kad_op_matmul+0x82>
		memset(p->x, 0, n_a_row * n_b_col * sizeof(float));
 804739e:	fb04 f209 	mul.w	r2, r4, r9
 80473a2:	2100      	movs	r1, #0
 80473a4:	6aa8      	ldr	r0, [r5, #40]	@ 0x28
 80473a6:	0092      	lsls	r2, r2, #2
 80473a8:	f004 fd44 	bl	804be34 <memset>
		if (q[0]->x && q[1]->x)
 80473ac:	6abf      	ldr	r7, [r7, #40]	@ 0x28
 80473ae:	2f00      	cmp	r7, #0
 80473b0:	f43f aef3 	beq.w	804719a <kad_op_matmul+0x82>
 80473b4:	f8d6 a028 	ldr.w	sl, [r6, #40]	@ 0x28
 80473b8:	f1ba 0f00 	cmp.w	sl, #0
 80473bc:	f43f aeed 	beq.w	804719a <kad_op_matmul+0x82>
		for (i = 0; i < M; ++i)
 80473c0:	2c00      	cmp	r4, #0
 80473c2:	f77f aeea 	ble.w	804719a <kad_op_matmul+0x82>
 80473c6:	f1bb 0f00 	cmp.w	fp, #0
 80473ca:	f77f aee6 	ble.w	804719a <kad_op_matmul+0x82>
 80473ce:	f1b9 0f00 	cmp.w	r9, #0
 80473d2:	f77f aee2 	ble.w	804719a <kad_op_matmul+0x82>
			kad_sgemm_simple(0, 0, n_a_row, n_b_col, n_a_col, q[0]->x, q[1]->x, p->x); /* Y = X * W */
 80473d6:	2300      	movs	r3, #0
 80473d8:	f8d5 e028 	ldr.w	lr, [r5, #40]	@ 0x28
 80473dc:	ea4f 028b 	mov.w	r2, fp, lsl #2
 80473e0:	eb0e 0089 	add.w	r0, lr, r9, lsl #2
 80473e4:	ea4f 0c89 	mov.w	ip, r9, lsl #2
 80473e8:	4601      	mov	r1, r0
		for (i = 0; i < M; ++i)
 80473ea:	461d      	mov	r5, r3
 80473ec:	46a0      	mov	r8, r4
 80473ee:	4691      	mov	r9, r2
 80473f0:	eb07 068b 	add.w	r6, r7, fp, lsl #2
	int n = 1, i;
 80473f4:	2400      	movs	r4, #0
 80473f6:	e9cd 8701 	strd	r8, r7, [sp, #4]
 80473fa:	eb07 0283 	add.w	r2, r7, r3, lsl #2
				kad_saxpy_inlined(N, A[i*K+k], &B[k*N], &C[i*N]);
 80473fe:	ecf2 6a01 	vldmia	r2!, {s13}
 8047402:	4677      	mov	r7, lr
 8047404:	eb0a 0804 	add.w	r8, sl, r4
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 8047408:	edd7 7a00 	vldr	s15, [r7]
 804740c:	ecb8 7a01 	vldmia	r8!, {s14}
 8047410:	eee6 7a87 	vfma.f32	s15, s13, s14
 8047414:	ece7 7a01 	vstmia	r7!, {s15}
 8047418:	428f      	cmp	r7, r1
 804741a:	d1f5      	bne.n	8047408 <kad_op_matmul+0x2f0>
			for (k = 0; k < K; ++k)
 804741c:	42b2      	cmp	r2, r6
 804741e:	4464      	add	r4, ip
 8047420:	d1ed      	bne.n	80473fe <kad_op_matmul+0x2e6>
		for (i = 0; i < M; ++i)
 8047422:	e9dd 8701 	ldrd	r8, r7, [sp, #4]
 8047426:	3501      	adds	r5, #1
 8047428:	4545      	cmp	r5, r8
 804742a:	4686      	mov	lr, r0
 804742c:	444e      	add	r6, r9
 804742e:	4461      	add	r1, ip
 8047430:	445b      	add	r3, fp
 8047432:	f43f aeb2 	beq.w	804719a <kad_op_matmul+0x82>
 8047436:	4460      	add	r0, ip
 8047438:	e7dc      	b.n	80473f4 <kad_op_matmul+0x2dc>
		if (n_a_col != n_b_row) return -1;
 804743a:	f04f 30ff 	mov.w	r0, #4294967295
 804743e:	e6ad      	b.n	804719c <kad_op_matmul+0x84>
 8047440:	00000000 	.word	0x00000000

08047444 <kad_op_conv1d>:
{
 8047444:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	kad_node_t *q = p->child[0], *w = p->child[1];
 8047448:	6b83      	ldr	r3, [r0, #56]	@ 0x38
{
 804744a:	b09f      	sub	sp, #124	@ 0x7c
	kad_node_t *q = p->child[0], *w = p->child[1];
 804744c:	681a      	ldr	r2, [r3, #0]
 804744e:	685e      	ldr	r6, [r3, #4]
	if (action == KAD_FORWARD || action == KAD_BACKWARD) { /* allocate working space */
 8047450:	1e8b      	subs	r3, r1, #2
 8047452:	2b01      	cmp	r3, #1
{
 8047454:	460c      	mov	r4, r1
	conv_conf_t *aux = (conv_conf_t*)p->ptr;
 8047456:	f8d0 b030 	ldr.w	fp, [r0, #48]	@ 0x30
{
 804745a:	900d      	str	r0, [sp, #52]	@ 0x34
	kad_node_t *q = p->child[0], *w = p->child[1];
 804745c:	9204      	str	r2, [sp, #16]
	if (action == KAD_FORWARD || action == KAD_BACKWARD) { /* allocate working space */
 804745e:	d93c      	bls.n	80474da <kad_op_conv1d+0x96>
	if (action == KAD_SYNC_DIM) {
 8047460:	2904      	cmp	r1, #4
 8047462:	d014      	beq.n	804748e <kad_op_conv1d+0x4a>
	float *t = 0, *q1 = 0, *w1 = 0, *x_padded = 0;
 8047464:	2300      	movs	r3, #0
 8047466:	9300      	str	r3, [sp, #0]
 8047468:	9309      	str	r3, [sp, #36]	@ 0x24
 804746a:	930b      	str	r3, [sp, #44]	@ 0x2c
 804746c:	930f      	str	r3, [sp, #60]	@ 0x3c
	free(t); free(q1); free(w1); free(x_padded);
 804746e:	980f      	ldr	r0, [sp, #60]	@ 0x3c
 8047470:	f004 f9fa 	bl	804b868 <free>
 8047474:	980b      	ldr	r0, [sp, #44]	@ 0x2c
 8047476:	f004 f9f7 	bl	804b868 <free>
 804747a:	9809      	ldr	r0, [sp, #36]	@ 0x24
 804747c:	f004 f9f4 	bl	804b868 <free>
 8047480:	9800      	ldr	r0, [sp, #0]
 8047482:	f004 f9f1 	bl	804b868 <free>
	return 0;
 8047486:	2000      	movs	r0, #0
}
 8047488:	b01f      	add	sp, #124	@ 0x7c
 804748a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (q->n_d != 3 || w->n_d != 3) return -1;
 804748e:	7813      	ldrb	r3, [r2, #0]
 8047490:	4610      	mov	r0, r2
 8047492:	2b03      	cmp	r3, #3
 8047494:	f040 8558 	bne.w	8047f48 <kad_op_conv1d+0xb04>
 8047498:	7833      	ldrb	r3, [r6, #0]
 804749a:	2b03      	cmp	r3, #3
 804749c:	f040 8554 	bne.w	8047f48 <kad_op_conv1d+0xb04>
		if (q->d[1] != w->d[1]) return -1; /* unmatched input channels */
 80474a0:	6951      	ldr	r1, [r2, #20]
 80474a2:	6972      	ldr	r2, [r6, #20]
 80474a4:	4291      	cmp	r1, r2
 80474a6:	f040 854f 	bne.w	8047f48 <kad_op_conv1d+0xb04>
		p->n_d = 3;
 80474aa:	990d      	ldr	r1, [sp, #52]	@ 0x34
 80474ac:	700b      	strb	r3, [r1, #0]
		p->d[0] = q->d[0], p->d[1] = w->d[0], p->d[2] = conv_out_size(q->d[2], aux);
 80474ae:	6983      	ldr	r3, [r0, #24]
 80474b0:	6902      	ldr	r2, [r0, #16]
 80474b2:	4608      	mov	r0, r1
 80474b4:	610a      	str	r2, [r1, #16]
 80474b6:	f8db 2000 	ldr.w	r2, [fp]
 80474ba:	6931      	ldr	r1, [r6, #16]
 80474bc:	1a9b      	subs	r3, r3, r2
 80474be:	f8db 2008 	ldr.w	r2, [fp, #8]
 80474c2:	6141      	str	r1, [r0, #20]
 80474c4:	f8db 100c 	ldr.w	r1, [fp, #12]
 80474c8:	4413      	add	r3, r2
 80474ca:	f8db 2004 	ldr.w	r2, [fp, #4]
 80474ce:	440b      	add	r3, r1
 80474d0:	fb93 f3f2 	sdiv	r3, r3, r2
 80474d4:	3301      	adds	r3, #1
 80474d6:	6183      	str	r3, [r0, #24]
 80474d8:	e7c4      	b.n	8047464 <kad_op_conv1d+0x20>
		if (w->d[2] * w->d[1] < 32) {
 80474da:	69b3      	ldr	r3, [r6, #24]
 80474dc:	6972      	ldr	r2, [r6, #20]
 80474de:	9303      	str	r3, [sp, #12]
 80474e0:	fb02 f303 	mul.w	r3, r2, r3
 80474e4:	2b1f      	cmp	r3, #31
 80474e6:	9205      	str	r2, [sp, #20]
 80474e8:	9311      	str	r3, [sp, #68]	@ 0x44
 80474ea:	f340 81be 	ble.w	804786a <kad_op_conv1d+0x426>
	for (i = 0; i < p->n_d; ++i) n *= p->d[i];
 80474ee:	9b04      	ldr	r3, [sp, #16]
 80474f0:	781a      	ldrb	r2, [r3, #0]
 80474f2:	2a00      	cmp	r2, #0
 80474f4:	f000 8270 	beq.w	80479d8 <kad_op_conv1d+0x594>
 80474f8:	2a01      	cmp	r2, #1
 80474fa:	6918      	ldr	r0, [r3, #16]
 80474fc:	d00b      	beq.n	8047516 <kad_op_conv1d+0xd2>
 80474fe:	6959      	ldr	r1, [r3, #20]
 8047500:	2a02      	cmp	r2, #2
 8047502:	fb01 f000 	mul.w	r0, r1, r0
 8047506:	d006      	beq.n	8047516 <kad_op_conv1d+0xd2>
 8047508:	6999      	ldr	r1, [r3, #24]
 804750a:	2a03      	cmp	r2, #3
 804750c:	fb01 f000 	mul.w	r0, r1, r0
 8047510:	bf1c      	itt	ne
 8047512:	69da      	ldrne	r2, [r3, #28]
 8047514:	4350      	mulne	r0, r2
			q1 = (float*)malloc(kad_len(q) * sizeof(float));
 8047516:	0080      	lsls	r0, r0, #2
 8047518:	f004 f99e 	bl	804b858 <malloc>
 804751c:	7832      	ldrb	r2, [r6, #0]
 804751e:	900b      	str	r0, [sp, #44]	@ 0x2c
 8047520:	2a00      	cmp	r2, #0
 8047522:	f000 8257 	beq.w	80479d4 <kad_op_conv1d+0x590>
 8047526:	2a01      	cmp	r2, #1
 8047528:	6930      	ldr	r0, [r6, #16]
 804752a:	d00b      	beq.n	8047544 <kad_op_conv1d+0x100>
 804752c:	9b05      	ldr	r3, [sp, #20]
 804752e:	2a02      	cmp	r2, #2
 8047530:	fb03 f000 	mul.w	r0, r3, r0
 8047534:	d006      	beq.n	8047544 <kad_op_conv1d+0x100>
 8047536:	9b03      	ldr	r3, [sp, #12]
 8047538:	2a03      	cmp	r2, #3
 804753a:	fb03 f000 	mul.w	r0, r3, r0
 804753e:	bf1c      	itt	ne
 8047540:	69f2      	ldrne	r2, [r6, #28]
 8047542:	4350      	mulne	r0, r2
			w1 = (float*)malloc(kad_len(w) * sizeof(float));
 8047544:	0080      	lsls	r0, r0, #2
 8047546:	f004 f987 	bl	804b858 <malloc>
			x_padded = aux->pad[0] + aux->pad[1] > 0? (float*)calloc((q->d[2] + aux->pad[0] + aux->pad[1]) * q->d[1], sizeof(float)) : 0;
 804754a:	e9db 3202 	ldrd	r3, r2, [fp, #8]
 804754e:	1899      	adds	r1, r3, r2
 8047550:	2900      	cmp	r1, #0
			w1 = (float*)malloc(kad_len(w) * sizeof(float));
 8047552:	9009      	str	r0, [sp, #36]	@ 0x24
			x_padded = aux->pad[0] + aux->pad[1] > 0? (float*)calloc((q->d[2] + aux->pad[0] + aux->pad[1]) * q->d[1], sizeof(float)) : 0;
 8047554:	f300 8113 	bgt.w	804777e <kad_op_conv1d+0x33a>
 8047558:	2300      	movs	r3, #0
			algo_switch = 1;
 804755a:	2701      	movs	r7, #1
			x_padded = aux->pad[0] + aux->pad[1] > 0? (float*)calloc((q->d[2] + aux->pad[0] + aux->pad[1]) * q->d[1], sizeof(float)) : 0;
 804755c:	9300      	str	r3, [sp, #0]
	float *t = 0, *q1 = 0, *w1 = 0, *x_padded = 0;
 804755e:	930f      	str	r3, [sp, #60]	@ 0x3c
	} else if (action == KAD_FORWARD) {
 8047560:	2c02      	cmp	r4, #2
 8047562:	f040 811d 	bne.w	80477a0 <kad_op_conv1d+0x35c>
		conv_rot180(w->d[0] * w->d[1], w->d[2], w->x);
 8047566:	6934      	ldr	r4, [r6, #16]
 8047568:	9b05      	ldr	r3, [sp, #20]
 804756a:	fb04 f303 	mul.w	r3, r4, r3
	for (i = 0; i < d0; ++i) {
 804756e:	2b00      	cmp	r3, #0
		conv_rot180(w->d[0] * w->d[1], w->d[2], w->x);
 8047570:	461c      	mov	r4, r3
	for (i = 0; i < d0; ++i) {
 8047572:	dd1a      	ble.n	80475aa <kad_op_conv1d+0x166>
		for (j = 0; j < d1>>1; ++j)
 8047574:	9b03      	ldr	r3, [sp, #12]
 8047576:	1059      	asrs	r1, r3, #1
 8047578:	2900      	cmp	r1, #0
 804757a:	dd16      	ble.n	80475aa <kad_op_conv1d+0x166>
	for (i = 0; i < d0; ++i) {
 804757c:	2500      	movs	r5, #0
 804757e:	6ab0      	ldr	r0, [r6, #40]	@ 0x28
 8047580:	ea4f 0c83 	mov.w	ip, r3, lsl #2
 8047584:	eb00 0181 	add.w	r1, r0, r1, lsl #2
		for (j = 0; j < d1>>1; ++j)
 8047588:	4603      	mov	r3, r0
 804758a:	4460      	add	r0, ip
	for (i = 0; i < d0; ++i) {
 804758c:	4602      	mov	r2, r0
			tmp = xi[j], xi[j] = xi[d1-1-j], xi[d1-1-j] = tmp; 
 804758e:	f852 8d04 	ldr.w	r8, [r2, #-4]!
 8047592:	f8d3 e000 	ldr.w	lr, [r3]
 8047596:	f843 8b04 	str.w	r8, [r3], #4
		for (j = 0; j < d1>>1; ++j)
 804759a:	4299      	cmp	r1, r3
			tmp = xi[j], xi[j] = xi[d1-1-j], xi[d1-1-j] = tmp; 
 804759c:	f8c2 e000 	str.w	lr, [r2]
		for (j = 0; j < d1>>1; ++j)
 80475a0:	d1f5      	bne.n	804758e <kad_op_conv1d+0x14a>
	for (i = 0; i < d0; ++i) {
 80475a2:	3501      	adds	r5, #1
 80475a4:	42ac      	cmp	r4, r5
 80475a6:	4461      	add	r1, ip
 80475a8:	d1ee      	bne.n	8047588 <kad_op_conv1d+0x144>
 80475aa:	9b0d      	ldr	r3, [sp, #52]	@ 0x34
 80475ac:	7819      	ldrb	r1, [r3, #0]
		memset(p->x, 0, kad_len(p) * sizeof(float));
 80475ae:	6a98      	ldr	r0, [r3, #40]	@ 0x28
 80475b0:	2900      	cmp	r1, #0
 80475b2:	f000 824c 	beq.w	8047a4e <kad_op_conv1d+0x60a>
 80475b6:	2901      	cmp	r1, #1
 80475b8:	461c      	mov	r4, r3
 80475ba:	691a      	ldr	r2, [r3, #16]
 80475bc:	d00b      	beq.n	80475d6 <kad_op_conv1d+0x192>
 80475be:	695b      	ldr	r3, [r3, #20]
 80475c0:	2902      	cmp	r1, #2
 80475c2:	fb03 f202 	mul.w	r2, r3, r2
 80475c6:	d006      	beq.n	80475d6 <kad_op_conv1d+0x192>
 80475c8:	69a3      	ldr	r3, [r4, #24]
 80475ca:	2903      	cmp	r1, #3
 80475cc:	fb03 f202 	mul.w	r2, r3, r2
 80475d0:	bf1c      	itt	ne
 80475d2:	69e3      	ldrne	r3, [r4, #28]
 80475d4:	435a      	mulne	r2, r3
 80475d6:	0092      	lsls	r2, r2, #2
 80475d8:	2100      	movs	r1, #0
 80475da:	f004 fc2b 	bl	804be34 <memset>
			conv1d_loop1(q->x, w->x, p->x, t, process_row_for);
 80475de:	9b04      	ldr	r3, [sp, #16]
		if (!algo_switch) { /* this is the first algorithm */
 80475e0:	2f00      	cmp	r7, #0
 80475e2:	f040 8710 	bne.w	8048406 <kad_op_conv1d+0xfc2>
			conv1d_loop1(q->x, w->x, p->x, t, process_row_for);
 80475e6:	691c      	ldr	r4, [r3, #16]
 80475e8:	6ab0      	ldr	r0, [r6, #40]	@ 0x28
 80475ea:	69b3      	ldr	r3, [r6, #24]
 80475ec:	6932      	ldr	r2, [r6, #16]
 80475ee:	6971      	ldr	r1, [r6, #20]
 80475f0:	2c00      	cmp	r4, #0
 80475f2:	9305      	str	r3, [sp, #20]
 80475f4:	900e      	str	r0, [sp, #56]	@ 0x38
 80475f6:	920a      	str	r2, [sp, #40]	@ 0x28
 80475f8:	9102      	str	r1, [sp, #8]
 80475fa:	f340 81d7 	ble.w	80479ac <kad_op_conv1d+0x568>
 80475fe:	2a00      	cmp	r2, #0
 8047600:	f340 81d4 	ble.w	80479ac <kad_op_conv1d+0x568>
 8047604:	2900      	cmp	r1, #0
 8047606:	f77f af32 	ble.w	804746e <kad_op_conv1d+0x2a>
 804760a:	461a      	mov	r2, r3
 804760c:	fb01 f303 	mul.w	r3, r1, r3
 8047610:	009b      	lsls	r3, r3, #2
 8047612:	9314      	str	r3, [sp, #80]	@ 0x50
 8047614:	4613      	mov	r3, r2
 8047616:	46be      	mov	lr, r7
 8047618:	0092      	lsls	r2, r2, #2
 804761a:	9f0f      	ldr	r7, [sp, #60]	@ 0x3c
 804761c:	9206      	str	r2, [sp, #24]
 804761e:	eb00 0683 	add.w	r6, r0, r3, lsl #2
 8047622:	f04f 0c00 	mov.w	ip, #0
 8047626:	465b      	mov	r3, fp
 8047628:	e9cd 4615 	strd	r4, r6, [sp, #84]	@ 0x54
 804762c:	960c      	str	r6, [sp, #48]	@ 0x30
 804762e:	f8cd e040 	str.w	lr, [sp, #64]	@ 0x40
 8047632:	9e0d      	ldr	r6, [sp, #52]	@ 0x34
 8047634:	f8dd e010 	ldr.w	lr, [sp, #16]
 8047638:	9810      	ldr	r0, [sp, #64]	@ 0x40
 804763a:	f8de 1014 	ldr.w	r1, [lr, #20]
 804763e:	6972      	ldr	r2, [r6, #20]
 8047640:	fb00 f101 	mul.w	r1, r0, r1
 8047644:	fb02 c200 	mla	r2, r2, r0, ip
 8047648:	f8de 0018 	ldr.w	r0, [lr, #24]
 804764c:	69b5      	ldr	r5, [r6, #24]
 804764e:	fb00 f401 	mul.w	r4, r0, r1
 8047652:	fb05 f202 	mul.w	r2, r5, r2
 8047656:	0081      	lsls	r1, r0, #2
 8047658:	9101      	str	r1, [sp, #4]
 804765a:	6ab0      	ldr	r0, [r6, #40]	@ 0x28
 804765c:	f8de 1028 	ldr.w	r1, [lr, #40]	@ 0x28
 8047660:	eb00 0982 	add.w	r9, r0, r2, lsl #2
 8047664:	eb01 0184 	add.w	r1, r1, r4, lsl #2
 8047668:	eb00 0485 	add.w	r4, r0, r5, lsl #2
 804766c:	eb04 0482 	add.w	r4, r4, r2, lsl #2
 8047670:	9a0c      	ldr	r2, [sp, #48]	@ 0x30
 8047672:	f04f 0a00 	mov.w	sl, #0
 8047676:	4690      	mov	r8, r2
 8047678:	9806      	ldr	r0, [sp, #24]
 804767a:	e9cd ec11 	strd	lr, ip, [sp, #68]	@ 0x44
 804767e:	9503      	str	r5, [sp, #12]
 8047680:	eba2 0b00 	sub.w	fp, r2, r0
 8047684:	eb07 0585 	add.w	r5, r7, r5, lsl #2
 8047688:	9613      	str	r6, [sp, #76]	@ 0x4c
 804768a:	9a00      	ldr	r2, [sp, #0]
 804768c:	460e      	mov	r6, r1
 804768e:	b152      	cbz	r2, 80476a6 <kad_op_conv1d+0x262>
 8047690:	689e      	ldr	r6, [r3, #8]
 8047692:	9308      	str	r3, [sp, #32]
 8047694:	eb02 0686 	add.w	r6, r2, r6, lsl #2
 8047698:	4630      	mov	r0, r6
 804769a:	9a01      	ldr	r2, [sp, #4]
 804769c:	9107      	str	r1, [sp, #28]
 804769e:	f004 fcc6 	bl	804c02e <memcpy>
 80476a2:	e9dd 1307 	ldrd	r1, r3, [sp, #28]
 80476a6:	6858      	ldr	r0, [r3, #4]
 80476a8:	9a05      	ldr	r2, [sp, #20]
 80476aa:	2801      	cmp	r0, #1
 80476ac:	f340 80bc 	ble.w	8047828 <kad_op_conv1d+0x3e4>
 80476b0:	2a00      	cmp	r2, #0
 80476b2:	dd27      	ble.n	8047704 <kad_op_conv1d+0x2c0>
 80476b4:	46dc      	mov	ip, fp
 80476b6:	689a      	ldr	r2, [r3, #8]
 80476b8:	0080      	lsls	r0, r0, #2
 80476ba:	ebc2 7282 	rsb	r2, r2, r2, lsl #30
 80476be:	eb06 0682 	add.w	r6, r6, r2, lsl #2
 80476c2:	9a03      	ldr	r2, [sp, #12]
 80476c4:	2a00      	cmp	r2, #0
 80476c6:	f340 80a7 	ble.w	8047818 <kad_op_conv1d+0x3d4>
 80476ca:	4632      	mov	r2, r6
 80476cc:	46be      	mov	lr, r7
 80476ce:	edd2 7a00 	vldr	s15, [r2]
 80476d2:	ecee 7a01 	vstmia	lr!, {s15}
 80476d6:	45ae      	cmp	lr, r5
 80476d8:	4402      	add	r2, r0
 80476da:	d1f8      	bne.n	80476ce <kad_op_conv1d+0x28a>
 80476dc:	eddc 6a00 	vldr	s13, [ip]
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 80476e0:	464a      	mov	r2, r9
			conv1d_loop1(q->x, w->x, p->x, t, process_row_for);
 80476e2:	46be      	mov	lr, r7
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 80476e4:	edd2 7a00 	vldr	s15, [r2]
 80476e8:	ecbe 7a01 	vldmia	lr!, {s14}
 80476ec:	eee6 7a87 	vfma.f32	s15, s13, s14
 80476f0:	ece2 7a01 	vstmia	r2!, {s15}
 80476f4:	4294      	cmp	r4, r2
 80476f6:	d1f5      	bne.n	80476e4 <kad_op_conv1d+0x2a0>
			conv1d_loop1(q->x, w->x, p->x, t, process_row_for);
 80476f8:	f10c 0c04 	add.w	ip, ip, #4
 80476fc:	45c4      	cmp	ip, r8
 80476fe:	f106 0604 	add.w	r6, r6, #4
 8047702:	d1e2      	bne.n	80476ca <kad_op_conv1d+0x286>
 8047704:	9a06      	ldr	r2, [sp, #24]
 8047706:	f10a 0a01 	add.w	sl, sl, #1
 804770a:	4490      	add	r8, r2
 804770c:	4493      	add	fp, r2
 804770e:	9a01      	ldr	r2, [sp, #4]
 8047710:	4411      	add	r1, r2
 8047712:	9a02      	ldr	r2, [sp, #8]
 8047714:	4592      	cmp	sl, r2
 8047716:	d1b8      	bne.n	804768a <kad_op_conv1d+0x246>
 8047718:	e9dd ec11 	ldrd	lr, ip, [sp, #68]	@ 0x44
 804771c:	9a0c      	ldr	r2, [sp, #48]	@ 0x30
 804771e:	9914      	ldr	r1, [sp, #80]	@ 0x50
 8047720:	f10c 0c01 	add.w	ip, ip, #1
 8047724:	440a      	add	r2, r1
 8047726:	920c      	str	r2, [sp, #48]	@ 0x30
 8047728:	9a0a      	ldr	r2, [sp, #40]	@ 0x28
 804772a:	9e13      	ldr	r6, [sp, #76]	@ 0x4c
 804772c:	4594      	cmp	ip, r2
 804772e:	d183      	bne.n	8047638 <kad_op_conv1d+0x1f4>
 8047730:	e9dd 4615 	ldrd	r4, r6, [sp, #84]	@ 0x54
 8047734:	f8dd e040 	ldr.w	lr, [sp, #64]	@ 0x40
 8047738:	469b      	mov	fp, r3
 804773a:	f10e 0e01 	add.w	lr, lr, #1
 804773e:	45a6      	cmp	lr, r4
 8047740:	f47f af6f 	bne.w	8047622 <kad_op_conv1d+0x1de>
		conv_rot180(w->d[0] * w->d[1], w->d[2], w->x);
 8047744:	fb0a f60c 	mul.w	r6, sl, ip
		for (j = 0; j < d1>>1; ++j)
 8047748:	9b05      	ldr	r3, [sp, #20]
 804774a:	1059      	asrs	r1, r3, #1
 804774c:	2900      	cmp	r1, #0
 804774e:	f77f ae8e 	ble.w	804746e <kad_op_conv1d+0x2a>
	for (i = 0; i < d0; ++i) {
 8047752:	2700      	movs	r7, #0
 8047754:	9d0e      	ldr	r5, [sp, #56]	@ 0x38
 8047756:	ea4f 0c83 	mov.w	ip, r3, lsl #2
 804775a:	eb05 0181 	add.w	r1, r5, r1, lsl #2
		for (j = 0; j < d1>>1; ++j)
 804775e:	462b      	mov	r3, r5
 8047760:	4465      	add	r5, ip
	for (i = 0; i < d0; ++i) {
 8047762:	462a      	mov	r2, r5
			tmp = xi[j], xi[j] = xi[d1-1-j], xi[d1-1-j] = tmp; 
 8047764:	f852 4d04 	ldr.w	r4, [r2, #-4]!
 8047768:	6818      	ldr	r0, [r3, #0]
 804776a:	f843 4b04 	str.w	r4, [r3], #4
		for (j = 0; j < d1>>1; ++j)
 804776e:	428b      	cmp	r3, r1
			tmp = xi[j], xi[j] = xi[d1-1-j], xi[d1-1-j] = tmp; 
 8047770:	6010      	str	r0, [r2, #0]
		for (j = 0; j < d1>>1; ++j)
 8047772:	d1f7      	bne.n	8047764 <kad_op_conv1d+0x320>
	for (i = 0; i < d0; ++i) {
 8047774:	3701      	adds	r7, #1
 8047776:	42b7      	cmp	r7, r6
 8047778:	4461      	add	r1, ip
 804777a:	d1f0      	bne.n	804775e <kad_op_conv1d+0x31a>
 804777c:	e677      	b.n	804746e <kad_op_conv1d+0x2a>
			x_padded = aux->pad[0] + aux->pad[1] > 0? (float*)calloc((q->d[2] + aux->pad[0] + aux->pad[1]) * q->d[1], sizeof(float)) : 0;
 804777e:	9804      	ldr	r0, [sp, #16]
			algo_switch = 1;
 8047780:	2701      	movs	r7, #1
			x_padded = aux->pad[0] + aux->pad[1] > 0? (float*)calloc((q->d[2] + aux->pad[0] + aux->pad[1]) * q->d[1], sizeof(float)) : 0;
 8047782:	6981      	ldr	r1, [r0, #24]
 8047784:	6940      	ldr	r0, [r0, #20]
 8047786:	440b      	add	r3, r1
 8047788:	4413      	add	r3, r2
 804778a:	fb03 f000 	mul.w	r0, r3, r0
 804778e:	2104      	movs	r1, #4
 8047790:	f004 f846 	bl	804b820 <calloc>
	float *t = 0, *q1 = 0, *w1 = 0, *x_padded = 0;
 8047794:	2300      	movs	r3, #0
	} else if (action == KAD_FORWARD) {
 8047796:	2c02      	cmp	r4, #2
	float *t = 0, *q1 = 0, *w1 = 0, *x_padded = 0;
 8047798:	930f      	str	r3, [sp, #60]	@ 0x3c
			x_padded = aux->pad[0] + aux->pad[1] > 0? (float*)calloc((q->d[2] + aux->pad[0] + aux->pad[1]) * q->d[1], sizeof(float)) : 0;
 804779a:	9000      	str	r0, [sp, #0]
	} else if (action == KAD_FORWARD) {
 804779c:	f43f aee3 	beq.w	8047566 <kad_op_conv1d+0x122>
		if (kad_is_back(p->child[0])) { /* backprop to the input array */
 80477a0:	9b04      	ldr	r3, [sp, #16]
 80477a2:	785b      	ldrb	r3, [r3, #1]
 80477a4:	07d9      	lsls	r1, r3, #31
 80477a6:	f100 8119 	bmi.w	80479dc <kad_op_conv1d+0x598>
		if (kad_is_back(p->child[1])) { /* backprop to the weight matrix */
 80477aa:	7873      	ldrb	r3, [r6, #1]
 80477ac:	07da      	lsls	r2, r3, #31
 80477ae:	f57f ae5e 	bpl.w	804746e <kad_op_conv1d+0x2a>
			conv_rot180(w->d[0] * w->d[1], w->d[2], w->g);
 80477b2:	6933      	ldr	r3, [r6, #16]
 80477b4:	9a05      	ldr	r2, [sp, #20]
 80477b6:	9308      	str	r3, [sp, #32]
 80477b8:	fb03 f302 	mul.w	r3, r3, r2
	for (i = 0; i < d0; ++i) {
 80477bc:	2b00      	cmp	r3, #0
			conv_rot180(w->d[0] * w->d[1], w->d[2], w->g);
 80477be:	f8d6 902c 	ldr.w	r9, [r6, #44]	@ 0x2c
 80477c2:	930e      	str	r3, [sp, #56]	@ 0x38
	for (i = 0; i < d0; ++i) {
 80477c4:	f340 8261 	ble.w	8047c8a <kad_op_conv1d+0x846>
		for (j = 0; j < d1>>1; ++j)
 80477c8:	9903      	ldr	r1, [sp, #12]
 80477ca:	104b      	asrs	r3, r1, #1
 80477cc:	2b00      	cmp	r3, #0
 80477ce:	f340 83bf 	ble.w	8047f50 <kad_op_conv1d+0xb0c>
 80477d2:	0089      	lsls	r1, r1, #2
 80477d4:	464a      	mov	r2, r9
	for (i = 0; i < d0; ++i) {
 80477d6:	2500      	movs	r5, #0
 80477d8:	468c      	mov	ip, r1
 80477da:	9102      	str	r1, [sp, #8]
 80477dc:	eb09 0083 	add.w	r0, r9, r3, lsl #2
		for (j = 0; j < d1>>1; ++j)
 80477e0:	4611      	mov	r1, r2
 80477e2:	4462      	add	r2, ip
	for (i = 0; i < d0; ++i) {
 80477e4:	4614      	mov	r4, r2
			tmp = xi[j], xi[j] = xi[d1-1-j], xi[d1-1-j] = tmp; 
 80477e6:	f854 8d04 	ldr.w	r8, [r4, #-4]!
 80477ea:	f8d1 e000 	ldr.w	lr, [r1]
 80477ee:	f841 8b04 	str.w	r8, [r1], #4
		for (j = 0; j < d1>>1; ++j)
 80477f2:	4288      	cmp	r0, r1
			tmp = xi[j], xi[j] = xi[d1-1-j], xi[d1-1-j] = tmp; 
 80477f4:	f8c4 e000 	str.w	lr, [r4]
		for (j = 0; j < d1>>1; ++j)
 80477f8:	d1f5      	bne.n	80477e6 <kad_op_conv1d+0x3a2>
	for (i = 0; i < d0; ++i) {
 80477fa:	990e      	ldr	r1, [sp, #56]	@ 0x38
 80477fc:	3501      	adds	r5, #1
 80477fe:	42a9      	cmp	r1, r5
 8047800:	4460      	add	r0, ip
 8047802:	d1ed      	bne.n	80477e0 <kad_op_conv1d+0x39c>
				conv1d_loop1(q->g, w->x, p->g, t, process_row_back_x);
 8047804:	9a04      	ldr	r2, [sp, #16]
 8047806:	6912      	ldr	r2, [r2, #16]
			if (!algo_switch) {
 8047808:	2f00      	cmp	r7, #0
 804780a:	f040 8492 	bne.w	8048132 <kad_op_conv1d+0xcee>
				conv1d_loop1(q->x, w->g, p->g, t, process_row_back_w);
 804780e:	2a00      	cmp	r2, #0
 8047810:	f300 83a6 	bgt.w	8047f60 <kad_op_conv1d+0xb1c>
 8047814:	f000 bc4e 	b.w	80480b4 <kad_op_conv1d+0xc70>
			conv1d_loop1(q->x, w->x, p->x, t, process_row_for);
 8047818:	f10c 0c04 	add.w	ip, ip, #4
 804781c:	45c4      	cmp	ip, r8
 804781e:	f106 0604 	add.w	r6, r6, #4
 8047822:	f47f af4e 	bne.w	80476c2 <kad_op_conv1d+0x27e>
 8047826:	e76d      	b.n	8047704 <kad_op_conv1d+0x2c0>
 8047828:	2a00      	cmp	r2, #0
 804782a:	f77f af6b 	ble.w	8047704 <kad_op_conv1d+0x2c0>
 804782e:	9803      	ldr	r0, [sp, #12]
 8047830:	689a      	ldr	r2, [r3, #8]
 8047832:	2800      	cmp	r0, #0
 8047834:	f77f af66 	ble.w	8047704 <kad_op_conv1d+0x2c0>
 8047838:	46de      	mov	lr, fp
 804783a:	ebc2 7282 	rsb	r2, r2, r2, lsl #30
 804783e:	ea4f 0c82 	mov.w	ip, r2, lsl #2
 8047842:	ecfe 6a01 	vldmia	lr!, {s13}
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 8047846:	464a      	mov	r2, r9
 8047848:	eb06 000c 	add.w	r0, r6, ip
 804784c:	edd2 7a00 	vldr	s15, [r2]
 8047850:	ecb0 7a01 	vldmia	r0!, {s14}
 8047854:	eee6 7a87 	vfma.f32	s15, s13, s14
 8047858:	ece2 7a01 	vstmia	r2!, {s15}
 804785c:	42a2      	cmp	r2, r4
 804785e:	d1f5      	bne.n	804784c <kad_op_conv1d+0x408>
			conv1d_loop1(q->x, w->x, p->x, t, process_row_for);
 8047860:	45f0      	cmp	r8, lr
 8047862:	f10c 0c04 	add.w	ip, ip, #4
 8047866:	d1ec      	bne.n	8047842 <kad_op_conv1d+0x3fe>
 8047868:	e74c      	b.n	8047704 <kad_op_conv1d+0x2c0>
			t = (float*)malloc(p->d[2] * sizeof(float));
 804786a:	9b0d      	ldr	r3, [sp, #52]	@ 0x34
 804786c:	6998      	ldr	r0, [r3, #24]
 804786e:	0080      	lsls	r0, r0, #2
 8047870:	f003 fff2 	bl	804b858 <malloc>
			x_padded = aux->pad[0] + aux->pad[1] > 0? (float*)calloc(q->d[2] + aux->pad[0] + aux->pad[1], sizeof(float)) : 0;
 8047874:	e9db 3202 	ldrd	r3, r2, [fp, #8]
 8047878:	1899      	adds	r1, r3, r2
 804787a:	2900      	cmp	r1, #0
			t = (float*)malloc(p->d[2] * sizeof(float));
 804787c:	900f      	str	r0, [sp, #60]	@ 0x3c
			x_padded = aux->pad[0] + aux->pad[1] > 0? (float*)calloc(q->d[2] + aux->pad[0] + aux->pad[1], sizeof(float)) : 0;
 804787e:	f300 809d 	bgt.w	80479bc <kad_op_conv1d+0x578>
	int algo_switch = 0;
 8047882:	2700      	movs	r7, #0
			x_padded = aux->pad[0] + aux->pad[1] > 0? (float*)calloc(q->d[2] + aux->pad[0] + aux->pad[1], sizeof(float)) : 0;
 8047884:	9700      	str	r7, [sp, #0]
	float *t = 0, *q1 = 0, *w1 = 0, *x_padded = 0;
 8047886:	9709      	str	r7, [sp, #36]	@ 0x24
 8047888:	970b      	str	r7, [sp, #44]	@ 0x2c
 804788a:	e669      	b.n	8047560 <kad_op_conv1d+0x11c>
	for (k = 0; k < d[0]; ++k)
 804788c:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 804788e:	f10e 0e01 	add.w	lr, lr, #1
 8047892:	459e      	cmp	lr, r3
 8047894:	44b4      	add	ip, r6
 8047896:	4417      	add	r7, r2
 8047898:	f2c0 860a 	blt.w	80484b0 <kad_op_conv1d+0x106c>
 804789c:	4611      	mov	r1, r2
			conv1d_loop2(q1, w1, p->x, (*_yy += kad_sdot(m, _ww, _xx)));
 804789e:	f8db 3004 	ldr.w	r3, [fp, #4]
 80478a2:	fb03 f209 	mul.w	r2, r3, r9
 80478a6:	9b05      	ldr	r3, [sp, #20]
 80478a8:	fb01 f303 	mul.w	r3, r1, r3
 80478ac:	9901      	ldr	r1, [sp, #4]
 80478ae:	2900      	cmp	r1, #0
 80478b0:	dd7c      	ble.n	80479ac <kad_op_conv1d+0x568>
 80478b2:	ea4f 0882 	mov.w	r8, r2, lsl #2
 80478b6:	9a0a      	ldr	r2, [sp, #40]	@ 0x28
 80478b8:	2a00      	cmp	r2, #0
 80478ba:	dd77      	ble.n	80479ac <kad_op_conv1d+0x568>
 80478bc:	2500      	movs	r5, #0
 80478be:	009a      	lsls	r2, r3, #2
 80478c0:	920c      	str	r2, [sp, #48]	@ 0x30
 80478c2:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 80478c4:	462e      	mov	r6, r5
 80478c6:	eb02 0e83 	add.w	lr, r2, r3, lsl #2
 80478ca:	462a      	mov	r2, r5
 80478cc:	461d      	mov	r5, r3
 80478ce:	980d      	ldr	r0, [sp, #52]	@ 0x34
 80478d0:	6943      	ldr	r3, [r0, #20]
			conv1d_loop1(q->x, w->x, p->x, t, process_row_for);
 80478d2:	6987      	ldr	r7, [r0, #24]
			conv1d_loop2(q1, w1, p->x, (*_yy += kad_sdot(m, _ww, _xx)));
 80478d4:	fb03 f406 	mul.w	r4, r3, r6
			conv1d_loop1(q->x, w->x, p->x, t, process_row_for);
 80478d8:	9b04      	ldr	r3, [sp, #16]
 80478da:	fb07 f404 	mul.w	r4, r7, r4
 80478de:	699b      	ldr	r3, [r3, #24]
 80478e0:	e9cd 6210 	strd	r6, r2, [sp, #64]	@ 0x40
			conv1d_loop2(q1, w1, p->x, (*_yy += kad_sdot(m, _ww, _xx)));
 80478e4:	fb03 f102 	mul.w	r1, r3, r2
 80478e8:	fb09 fc03 	mul.w	ip, r9, r3
 80478ec:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 80478ee:	f8dd a024 	ldr.w	sl, [sp, #36]	@ 0x24
 80478f2:	eb03 0181 	add.w	r1, r3, r1, lsl #2
 80478f6:	ea4f 038c 	mov.w	r3, ip, lsl #2
 80478fa:	9307      	str	r3, [sp, #28]
 80478fc:	6a83      	ldr	r3, [r0, #40]	@ 0x28
 80478fe:	f8cd e048 	str.w	lr, [sp, #72]	@ 0x48
 8047902:	eb03 0384 	add.w	r3, r3, r4, lsl #2
 8047906:	9c00      	ldr	r4, [sp, #0]
 8047908:	9303      	str	r3, [sp, #12]
 804790a:	4623      	mov	r3, r4
 804790c:	2c00      	cmp	r4, #0
 804790e:	bf08      	it	eq
 8047910:	460b      	moveq	r3, r1
 8047912:	9308      	str	r3, [sp, #32]
 8047914:	2300      	movs	r3, #0
 8047916:	9306      	str	r3, [sp, #24]
 8047918:	00bb      	lsls	r3, r7, #2
 804791a:	930d      	str	r3, [sp, #52]	@ 0x34
 804791c:	4674      	mov	r4, lr
 804791e:	4603      	mov	r3, r0
 8047920:	9800      	ldr	r0, [sp, #0]
 8047922:	9e03      	ldr	r6, [sp, #12]
 8047924:	b160      	cbz	r0, 8047940 <kad_op_conv1d+0x4fc>
 8047926:	f8db 2008 	ldr.w	r2, [fp, #8]
 804792a:	9314      	str	r3, [sp, #80]	@ 0x50
 804792c:	fb02 f209 	mul.w	r2, r2, r9
 8047930:	eb00 0082 	add.w	r0, r0, r2, lsl #2
 8047934:	9a07      	ldr	r2, [sp, #28]
 8047936:	9113      	str	r1, [sp, #76]	@ 0x4c
 8047938:	f004 fb79 	bl	804c02e <memcpy>
 804793c:	e9dd 1313 	ldrd	r1, r3, [sp, #76]	@ 0x4c
 8047940:	2f00      	cmp	r7, #0
 8047942:	dd1c      	ble.n	804797e <kad_op_conv1d+0x53a>
 8047944:	f04f 0c00 	mov.w	ip, #0
 8047948:	f8dd e020 	ldr.w	lr, [sp, #32]
	for (i = 0; i < n; ++i) s += x[i] * y[i];
 804794c:	2d00      	cmp	r5, #0
	float s = 0.;
 804794e:	eddf 7aba 	vldr	s15, [pc, #744]	@ 8047c38 <kad_op_conv1d+0x7f4>
	for (i = 0; i < n; ++i) s += x[i] * y[i];
 8047952:	dd09      	ble.n	8047968 <kad_op_conv1d+0x524>
 8047954:	4670      	mov	r0, lr
 8047956:	4652      	mov	r2, sl
 8047958:	ecf2 6a01 	vldmia	r2!, {s13}
 804795c:	ecb0 7a01 	vldmia	r0!, {s14}
 8047960:	4294      	cmp	r4, r2
 8047962:	eee6 7a87 	vfma.f32	s15, s13, s14
 8047966:	d1f7      	bne.n	8047958 <kad_op_conv1d+0x514>
			conv1d_loop2(q1, w1, p->x, (*_yy += kad_sdot(m, _ww, _xx)));
 8047968:	ed96 7a00 	vldr	s14, [r6]
 804796c:	ee77 7a27 	vadd.f32	s15, s14, s15
 8047970:	f10c 0c01 	add.w	ip, ip, #1
 8047974:	45bc      	cmp	ip, r7
 8047976:	ece6 7a01 	vstmia	r6!, {s15}
 804797a:	44c6      	add	lr, r8
 804797c:	d1e6      	bne.n	804794c <kad_op_conv1d+0x508>
 804797e:	9803      	ldr	r0, [sp, #12]
 8047980:	9e0d      	ldr	r6, [sp, #52]	@ 0x34
 8047982:	9a06      	ldr	r2, [sp, #24]
 8047984:	4430      	add	r0, r6
 8047986:	9003      	str	r0, [sp, #12]
 8047988:	980c      	ldr	r0, [sp, #48]	@ 0x30
 804798a:	3201      	adds	r2, #1
 804798c:	4482      	add	sl, r0
 804798e:	4404      	add	r4, r0
 8047990:	980a      	ldr	r0, [sp, #40]	@ 0x28
 8047992:	9206      	str	r2, [sp, #24]
 8047994:	4282      	cmp	r2, r0
 8047996:	d1c3      	bne.n	8047920 <kad_op_conv1d+0x4dc>
 8047998:	e9dd 6210 	ldrd	r6, r2, [sp, #64]	@ 0x40
 804799c:	4618      	mov	r0, r3
 804799e:	9b01      	ldr	r3, [sp, #4]
 80479a0:	3601      	adds	r6, #1
 80479a2:	429e      	cmp	r6, r3
 80479a4:	f8dd e048 	ldr.w	lr, [sp, #72]	@ 0x48
 80479a8:	444a      	add	r2, r9
 80479aa:	d191      	bne.n	80478d0 <kad_op_conv1d+0x48c>
		conv_rot180(w->d[0] * w->d[1], w->d[2], w->x);
 80479ac:	9e0a      	ldr	r6, [sp, #40]	@ 0x28
 80479ae:	9b02      	ldr	r3, [sp, #8]
 80479b0:	fb03 f606 	mul.w	r6, r3, r6
	for (i = 0; i < d0; ++i) {
 80479b4:	2e00      	cmp	r6, #0
 80479b6:	f73f aec7 	bgt.w	8047748 <kad_op_conv1d+0x304>
 80479ba:	e558      	b.n	804746e <kad_op_conv1d+0x2a>
			x_padded = aux->pad[0] + aux->pad[1] > 0? (float*)calloc(q->d[2] + aux->pad[0] + aux->pad[1], sizeof(float)) : 0;
 80479bc:	9904      	ldr	r1, [sp, #16]
	int algo_switch = 0;
 80479be:	2700      	movs	r7, #0
			x_padded = aux->pad[0] + aux->pad[1] > 0? (float*)calloc(q->d[2] + aux->pad[0] + aux->pad[1], sizeof(float)) : 0;
 80479c0:	6989      	ldr	r1, [r1, #24]
 80479c2:	440b      	add	r3, r1
 80479c4:	1898      	adds	r0, r3, r2
 80479c6:	2104      	movs	r1, #4
 80479c8:	f003 ff2a 	bl	804b820 <calloc>
	float *t = 0, *q1 = 0, *w1 = 0, *x_padded = 0;
 80479cc:	9709      	str	r7, [sp, #36]	@ 0x24
			x_padded = aux->pad[0] + aux->pad[1] > 0? (float*)calloc(q->d[2] + aux->pad[0] + aux->pad[1], sizeof(float)) : 0;
 80479ce:	9000      	str	r0, [sp, #0]
	float *t = 0, *q1 = 0, *w1 = 0, *x_padded = 0;
 80479d0:	970b      	str	r7, [sp, #44]	@ 0x2c
 80479d2:	e5c5      	b.n	8047560 <kad_op_conv1d+0x11c>
 80479d4:	2004      	movs	r0, #4
 80479d6:	e5b6      	b.n	8047546 <kad_op_conv1d+0x102>
 80479d8:	2004      	movs	r0, #4
 80479da:	e59d      	b.n	8047518 <kad_op_conv1d+0xd4>
			conv_rot180(w->d[0] * w->d[1], w->d[2], w->x);
 80479dc:	6933      	ldr	r3, [r6, #16]
 80479de:	9a05      	ldr	r2, [sp, #20]
 80479e0:	9308      	str	r3, [sp, #32]
 80479e2:	fb03 f302 	mul.w	r3, r3, r2
	for (i = 0; i < d0; ++i) {
 80479e6:	2b00      	cmp	r3, #0
			conv_rot180(w->d[0] * w->d[1], w->d[2], w->x);
 80479e8:	f8d6 8028 	ldr.w	r8, [r6, #40]	@ 0x28
 80479ec:	930e      	str	r3, [sp, #56]	@ 0x38
	for (i = 0; i < d0; ++i) {
 80479ee:	f340 8298 	ble.w	8047f22 <kad_op_conv1d+0xade>
		for (j = 0; j < d1>>1; ++j)
 80479f2:	9a03      	ldr	r2, [sp, #12]
 80479f4:	1053      	asrs	r3, r2, #1
 80479f6:	2b00      	cmp	r3, #0
 80479f8:	dd2b      	ble.n	8047a52 <kad_op_conv1d+0x60e>
 80479fa:	0092      	lsls	r2, r2, #2
 80479fc:	4641      	mov	r1, r8
	for (i = 0; i < d0; ++i) {
 80479fe:	2500      	movs	r5, #0
 8047a00:	4694      	mov	ip, r2
 8047a02:	9202      	str	r2, [sp, #8]
 8047a04:	eb08 0483 	add.w	r4, r8, r3, lsl #2
		for (j = 0; j < d1>>1; ++j)
 8047a08:	460a      	mov	r2, r1
 8047a0a:	4461      	add	r1, ip
	for (i = 0; i < d0; ++i) {
 8047a0c:	4608      	mov	r0, r1
			tmp = xi[j], xi[j] = xi[d1-1-j], xi[d1-1-j] = tmp; 
 8047a0e:	f850 9d04 	ldr.w	r9, [r0, #-4]!
 8047a12:	f8d2 e000 	ldr.w	lr, [r2]
 8047a16:	f842 9b04 	str.w	r9, [r2], #4
		for (j = 0; j < d1>>1; ++j)
 8047a1a:	42a2      	cmp	r2, r4
			tmp = xi[j], xi[j] = xi[d1-1-j], xi[d1-1-j] = tmp; 
 8047a1c:	f8c0 e000 	str.w	lr, [r0]
		for (j = 0; j < d1>>1; ++j)
 8047a20:	d1f5      	bne.n	8047a0e <kad_op_conv1d+0x5ca>
	for (i = 0; i < d0; ++i) {
 8047a22:	eb02 040c 	add.w	r4, r2, ip
 8047a26:	9a0e      	ldr	r2, [sp, #56]	@ 0x38
 8047a28:	3501      	adds	r5, #1
 8047a2a:	42aa      	cmp	r2, r5
 8047a2c:	d1ec      	bne.n	8047a08 <kad_op_conv1d+0x5c4>
			if (!algo_switch) {
 8047a2e:	2f00      	cmp	r7, #0
 8047a30:	f040 8138 	bne.w	8047ca4 <kad_op_conv1d+0x860>
				conv1d_loop1(q->g, w->x, p->g, t, process_row_back_x);
 8047a34:	9a04      	ldr	r2, [sp, #16]
 8047a36:	6912      	ldr	r2, [r2, #16]
 8047a38:	2a00      	cmp	r2, #0
 8047a3a:	f340 80e5 	ble.w	8047c08 <kad_op_conv1d+0x7c4>
 8047a3e:	9a08      	ldr	r2, [sp, #32]
 8047a40:	2a00      	cmp	r2, #0
 8047a42:	f340 80e1 	ble.w	8047c08 <kad_op_conv1d+0x7c4>
 8047a46:	9a05      	ldr	r2, [sp, #20]
 8047a48:	2a00      	cmp	r2, #0
 8047a4a:	dc14      	bgt.n	8047a76 <kad_op_conv1d+0x632>
 8047a4c:	e0dc      	b.n	8047c08 <kad_op_conv1d+0x7c4>
 8047a4e:	2204      	movs	r2, #4
 8047a50:	e5c2      	b.n	80475d8 <kad_op_conv1d+0x194>
			if (!algo_switch) {
 8047a52:	2f00      	cmp	r7, #0
 8047a54:	f040 8126 	bne.w	8047ca4 <kad_op_conv1d+0x860>
				conv1d_loop1(q->g, w->x, p->g, t, process_row_back_x);
 8047a58:	9b04      	ldr	r3, [sp, #16]
 8047a5a:	691b      	ldr	r3, [r3, #16]
 8047a5c:	2b00      	cmp	r3, #0
 8047a5e:	f77f aea4 	ble.w	80477aa <kad_op_conv1d+0x366>
 8047a62:	9b08      	ldr	r3, [sp, #32]
 8047a64:	2b00      	cmp	r3, #0
 8047a66:	f77f aea0 	ble.w	80477aa <kad_op_conv1d+0x366>
 8047a6a:	9b05      	ldr	r3, [sp, #20]
 8047a6c:	2b00      	cmp	r3, #0
 8047a6e:	f77f ae9c 	ble.w	80477aa <kad_op_conv1d+0x366>
 8047a72:	0093      	lsls	r3, r2, #2
 8047a74:	9302      	str	r3, [sp, #8]
 8047a76:	2000      	movs	r0, #0
 8047a78:	e9cd 6716 	strd	r6, r7, [sp, #88]	@ 0x58
 8047a7c:	4607      	mov	r7, r0
 8047a7e:	9b11      	ldr	r3, [sp, #68]	@ 0x44
 8047a80:	f8cd b01c 	str.w	fp, [sp, #28]
 8047a84:	ea4f 0c83 	mov.w	ip, r3, lsl #2
 8047a88:	9b02      	ldr	r3, [sp, #8]
 8047a8a:	f8dd e010 	ldr.w	lr, [sp, #16]
 8047a8e:	eb08 0903 	add.w	r9, r8, r3
 8047a92:	46cb      	mov	fp, r9
 8047a94:	f8dd 903c 	ldr.w	r9, [sp, #60]	@ 0x3c
 8047a98:	f8cd 8054 	str.w	r8, [sp, #84]	@ 0x54
 8047a9c:	463e      	mov	r6, r7
 8047a9e:	465d      	mov	r5, fp
 8047aa0:	2000      	movs	r0, #0
 8047aa2:	4677      	mov	r7, lr
 8047aa4:	f8cd b060 	str.w	fp, [sp, #96]	@ 0x60
 8047aa8:	9c0d      	ldr	r4, [sp, #52]	@ 0x34
				conv1d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _ww, _xx));
 8047aaa:	69b9      	ldr	r1, [r7, #24]
			t = (float*)malloc(p->d[2] * sizeof(float));
 8047aac:	f8d4 8018 	ldr.w	r8, [r4, #24]
				conv1d_loop1(q->g, w->x, p->g, t, process_row_back_x);
 8047ab0:	f8d4 a02c 	ldr.w	sl, [r4, #44]	@ 0x2c
 8047ab4:	6963      	ldr	r3, [r4, #20]
 8047ab6:	2400      	movs	r4, #0
 8047ab8:	fb03 0206 	mla	r2, r3, r6, r0
 8047abc:	fb08 f202 	mul.w	r2, r8, r2
 8047ac0:	940a      	str	r4, [sp, #40]	@ 0x28
 8047ac2:	0094      	lsls	r4, r2, #2
 8047ac4:	eb0a 0282 	add.w	r2, sl, r2, lsl #2
 8047ac8:	9213      	str	r2, [sp, #76]	@ 0x4c
 8047aca:	9a02      	ldr	r2, [sp, #8]
 8047acc:	697b      	ldr	r3, [r7, #20]
 8047ace:	1aaa      	subs	r2, r5, r2
 8047ad0:	9206      	str	r2, [sp, #24]
 8047ad2:	ea4f 0288 	mov.w	r2, r8, lsl #2
 8047ad6:	9201      	str	r2, [sp, #4]
 8047ad8:	4652      	mov	r2, sl
 8047ada:	46aa      	mov	sl, r5
 8047adc:	4693      	mov	fp, r2
 8047ade:	fb06 f303 	mul.w	r3, r6, r3
 8047ae2:	fb01 f303 	mul.w	r3, r1, r3
 8047ae6:	0089      	lsls	r1, r1, #2
 8047ae8:	910c      	str	r1, [sp, #48]	@ 0x30
 8047aea:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
 8047aec:	e9cd 5719 	strd	r5, r7, [sp, #100]	@ 0x64
 8047af0:	eb01 0183 	add.w	r1, r1, r3, lsl #2
 8047af4:	e9cd 601b 	strd	r6, r0, [sp, #108]	@ 0x6c
 8047af8:	ebc8 7388 	rsb	r3, r8, r8, lsl #30
 8047afc:	009b      	lsls	r3, r3, #2
 8047afe:	9412      	str	r4, [sp, #72]	@ 0x48
 8047b00:	f8cd c074 	str.w	ip, [sp, #116]	@ 0x74
 8047b04:	eb09 0488 	add.w	r4, r9, r8, lsl #2
 8047b08:	9314      	str	r3, [sp, #80]	@ 0x50
 8047b0a:	9b00      	ldr	r3, [sp, #0]
 8047b0c:	460d      	mov	r5, r1
 8047b0e:	b14b      	cbz	r3, 8047b24 <kad_op_conv1d+0x6e0>
 8047b10:	9a07      	ldr	r2, [sp, #28]
 8047b12:	9110      	str	r1, [sp, #64]	@ 0x40
 8047b14:	6895      	ldr	r5, [r2, #8]
 8047b16:	9a0c      	ldr	r2, [sp, #48]	@ 0x30
 8047b18:	eb03 0585 	add.w	r5, r3, r5, lsl #2
 8047b1c:	4628      	mov	r0, r5
 8047b1e:	f004 fa86 	bl	804c02e <memcpy>
 8047b22:	9910      	ldr	r1, [sp, #64]	@ 0x40
 8047b24:	9b07      	ldr	r3, [sp, #28]
 8047b26:	685e      	ldr	r6, [r3, #4]
 8047b28:	9b03      	ldr	r3, [sp, #12]
 8047b2a:	2e01      	cmp	r6, #1
 8047b2c:	f340 8086 	ble.w	8047c3c <kad_op_conv1d+0x7f8>
 8047b30:	2b00      	cmp	r3, #0
 8047b32:	dd36      	ble.n	8047ba2 <kad_op_conv1d+0x75e>
 8047b34:	e9dd 7306 	ldrd	r7, r3, [sp, #24]
 8047b38:	689a      	ldr	r2, [r3, #8]
 8047b3a:	464b      	mov	r3, r9
 8047b3c:	ebc2 7282 	rsb	r2, r2, r2, lsl #30
 8047b40:	f8dd 9048 	ldr.w	r9, [sp, #72]	@ 0x48
 8047b44:	00b6      	lsls	r6, r6, #2
 8047b46:	eb05 0582 	add.w	r5, r5, r2, lsl #2
 8047b4a:	9110      	str	r1, [sp, #64]	@ 0x40
 8047b4c:	4618      	mov	r0, r3
 8047b4e:	9a01      	ldr	r2, [sp, #4]
 8047b50:	2100      	movs	r1, #0
 8047b52:	f004 f96f 	bl	804be34 <memset>
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 8047b56:	f1b8 0f00 	cmp.w	r8, #0
				conv1d_loop1(q->g, w->x, p->g, t, process_row_back_x);
 8047b5a:	4603      	mov	r3, r0
 8047b5c:	ecf7 6a01 	vldmia	r7!, {s13}
 8047b60:	462a      	mov	r2, r5
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 8047b62:	dd18      	ble.n	8047b96 <kad_op_conv1d+0x752>
 8047b64:	4601      	mov	r1, r0
 8047b66:	eb0b 0009 	add.w	r0, fp, r9
 8047b6a:	edd1 7a00 	vldr	s15, [r1]
 8047b6e:	ecb0 7a01 	vldmia	r0!, {s14}
 8047b72:	eee6 7a87 	vfma.f32	s15, s13, s14
 8047b76:	ece1 7a01 	vstmia	r1!, {s15}
 8047b7a:	428c      	cmp	r4, r1
 8047b7c:	d1f5      	bne.n	8047b6a <kad_op_conv1d+0x726>
 8047b7e:	4619      	mov	r1, r3
				conv1d_loop1(q->g, w->x, p->g, t, process_row_back_x);
 8047b80:	edd2 7a00 	vldr	s15, [r2]
 8047b84:	ecb1 7a01 	vldmia	r1!, {s14}
 8047b88:	ee77 7a87 	vadd.f32	s15, s15, s14
 8047b8c:	428c      	cmp	r4, r1
 8047b8e:	edc2 7a00 	vstr	s15, [r2]
 8047b92:	4432      	add	r2, r6
 8047b94:	d1f4      	bne.n	8047b80 <kad_op_conv1d+0x73c>
 8047b96:	45ba      	cmp	sl, r7
 8047b98:	f105 0504 	add.w	r5, r5, #4
 8047b9c:	d1d6      	bne.n	8047b4c <kad_op_conv1d+0x708>
 8047b9e:	4699      	mov	r9, r3
 8047ba0:	9910      	ldr	r1, [sp, #64]	@ 0x40
 8047ba2:	9a02      	ldr	r2, [sp, #8]
 8047ba4:	9806      	ldr	r0, [sp, #24]
 8047ba6:	4492      	add	sl, r2
 8047ba8:	4410      	add	r0, r2
 8047baa:	9a0c      	ldr	r2, [sp, #48]	@ 0x30
 8047bac:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 8047bae:	4411      	add	r1, r2
 8047bb0:	9a05      	ldr	r2, [sp, #20]
 8047bb2:	3301      	adds	r3, #1
 8047bb4:	429a      	cmp	r2, r3
 8047bb6:	930a      	str	r3, [sp, #40]	@ 0x28
 8047bb8:	9006      	str	r0, [sp, #24]
 8047bba:	d1a6      	bne.n	8047b0a <kad_op_conv1d+0x6c6>
 8047bbc:	e9dd 601b 	ldrd	r6, r0, [sp, #108]	@ 0x6c
 8047bc0:	e9dd 5719 	ldrd	r5, r7, [sp, #100]	@ 0x64
 8047bc4:	9b08      	ldr	r3, [sp, #32]
 8047bc6:	f8dd c074 	ldr.w	ip, [sp, #116]	@ 0x74
 8047bca:	3001      	adds	r0, #1
 8047bcc:	4283      	cmp	r3, r0
 8047bce:	4465      	add	r5, ip
 8047bd0:	f47f af6a 	bne.w	8047aa8 <kad_op_conv1d+0x664>
 8047bd4:	46be      	mov	lr, r7
 8047bd6:	4637      	mov	r7, r6
 8047bd8:	f8de 3010 	ldr.w	r3, [lr, #16]
 8047bdc:	3701      	adds	r7, #1
 8047bde:	42bb      	cmp	r3, r7
 8047be0:	f8dd b060 	ldr.w	fp, [sp, #96]	@ 0x60
 8047be4:	f73f af5a 	bgt.w	8047a9c <kad_op_conv1d+0x658>
 8047be8:	e9dd 6716 	ldrd	r6, r7, [sp, #88]	@ 0x58
 8047bec:	f8dd 8054 	ldr.w	r8, [sp, #84]	@ 0x54
 8047bf0:	f8dd b01c 	ldr.w	fp, [sp, #28]
	for (i = 0; i < d0; ++i) {
 8047bf4:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
 8047bf6:	2b00      	cmp	r3, #0
 8047bf8:	dd41      	ble.n	8047c7e <kad_op_conv1d+0x83a>
		for (j = 0; j < d1>>1; ++j)
 8047bfa:	9a03      	ldr	r2, [sp, #12]
 8047bfc:	1053      	asrs	r3, r2, #1
 8047bfe:	2b00      	cmp	r3, #0
 8047c00:	f77f add3 	ble.w	80477aa <kad_op_conv1d+0x366>
 8047c04:	0092      	lsls	r2, r2, #2
 8047c06:	9202      	str	r2, [sp, #8]
 8047c08:	4642      	mov	r2, r8
	for (k = 0; k < d[0]; ++k)
 8047c0a:	2000      	movs	r0, #0
 8047c0c:	9d02      	ldr	r5, [sp, #8]
 8047c0e:	eb08 0383 	add.w	r3, r8, r3, lsl #2
		for (j = 0; j < d1>>1; ++j)
 8047c12:	4611      	mov	r1, r2
 8047c14:	442a      	add	r2, r5
	for (k = 0; k < d[0]; ++k)
 8047c16:	4614      	mov	r4, r2
			tmp = xi[j], xi[j] = xi[d1-1-j], xi[d1-1-j] = tmp; 
 8047c18:	f854 ed04 	ldr.w	lr, [r4, #-4]!
 8047c1c:	f8d1 c000 	ldr.w	ip, [r1]
 8047c20:	f841 eb04 	str.w	lr, [r1], #4
		for (j = 0; j < d1>>1; ++j)
 8047c24:	428b      	cmp	r3, r1
			tmp = xi[j], xi[j] = xi[d1-1-j], xi[d1-1-j] = tmp; 
 8047c26:	f8c4 c000 	str.w	ip, [r4]
		for (j = 0; j < d1>>1; ++j)
 8047c2a:	d1f5      	bne.n	8047c18 <kad_op_conv1d+0x7d4>
	for (i = 0; i < d0; ++i) {
 8047c2c:	990e      	ldr	r1, [sp, #56]	@ 0x38
 8047c2e:	3001      	adds	r0, #1
 8047c30:	4281      	cmp	r1, r0
 8047c32:	442b      	add	r3, r5
 8047c34:	d1ed      	bne.n	8047c12 <kad_op_conv1d+0x7ce>
 8047c36:	e5b8      	b.n	80477aa <kad_op_conv1d+0x366>
 8047c38:	00000000 	.word	0x00000000
				conv1d_loop1(q->g, w->x, p->g, t, process_row_back_x);
 8047c3c:	2b00      	cmp	r3, #0
 8047c3e:	ddb0      	ble.n	8047ba2 <kad_op_conv1d+0x75e>
 8047c40:	9b07      	ldr	r3, [sp, #28]
 8047c42:	f1b8 0f00 	cmp.w	r8, #0
 8047c46:	689a      	ldr	r2, [r3, #8]
 8047c48:	ddab      	ble.n	8047ba2 <kad_op_conv1d+0x75e>
 8047c4a:	e9dd 7313 	ldrd	r7, r3, [sp, #76]	@ 0x4c
 8047c4e:	eba8 0202 	sub.w	r2, r8, r2
 8047c52:	9e06      	ldr	r6, [sp, #24]
 8047c54:	eb05 0582 	add.w	r5, r5, r2, lsl #2
 8047c58:	ecf6 6a01 	vldmia	r6!, {s13}
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 8047c5c:	4638      	mov	r0, r7
 8047c5e:	195a      	adds	r2, r3, r5
 8047c60:	edd2 7a00 	vldr	s15, [r2]
 8047c64:	ecb0 7a01 	vldmia	r0!, {s14}
 8047c68:	eee6 7a87 	vfma.f32	s15, s13, s14
 8047c6c:	ece2 7a01 	vstmia	r2!, {s15}
 8047c70:	42aa      	cmp	r2, r5
 8047c72:	d1f5      	bne.n	8047c60 <kad_op_conv1d+0x81c>
				conv1d_loop1(q->g, w->x, p->g, t, process_row_back_x);
 8047c74:	4556      	cmp	r6, sl
 8047c76:	f105 0504 	add.w	r5, r5, #4
 8047c7a:	d1ed      	bne.n	8047c58 <kad_op_conv1d+0x814>
 8047c7c:	e791      	b.n	8047ba2 <kad_op_conv1d+0x75e>
		if (kad_is_back(p->child[1])) { /* backprop to the weight matrix */
 8047c7e:	7873      	ldrb	r3, [r6, #1]
 8047c80:	07db      	lsls	r3, r3, #31
 8047c82:	f57f abf4 	bpl.w	804746e <kad_op_conv1d+0x2a>
			conv_rot180(w->d[0] * w->d[1], w->d[2], w->g);
 8047c86:	f8d6 902c 	ldr.w	r9, [r6, #44]	@ 0x2c
			if (!algo_switch) {
 8047c8a:	2f00      	cmp	r7, #0
 8047c8c:	f040 8251 	bne.w	8048132 <kad_op_conv1d+0xcee>
				conv1d_loop1(q->x, w->g, p->g, t, process_row_back_w);
 8047c90:	9b04      	ldr	r3, [sp, #16]
 8047c92:	691b      	ldr	r3, [r3, #16]
 8047c94:	2b00      	cmp	r3, #0
 8047c96:	f77f abea 	ble.w	804746e <kad_op_conv1d+0x2a>
 8047c9a:	9b08      	ldr	r3, [sp, #32]
 8047c9c:	2b00      	cmp	r3, #0
 8047c9e:	f300 8163 	bgt.w	8047f68 <kad_op_conv1d+0xb24>
 8047ca2:	e1fb      	b.n	804809c <kad_op_conv1d+0xc58>
 8047ca4:	9b04      	ldr	r3, [sp, #16]
 8047ca6:	781a      	ldrb	r2, [r3, #0]
 8047ca8:	2a00      	cmp	r2, #0
 8047caa:	f000 8138 	beq.w	8047f1e <kad_op_conv1d+0xada>
 8047cae:	2a01      	cmp	r2, #1
 8047cb0:	4618      	mov	r0, r3
 8047cb2:	691b      	ldr	r3, [r3, #16]
 8047cb4:	d00b      	beq.n	8047cce <kad_op_conv1d+0x88a>
 8047cb6:	6941      	ldr	r1, [r0, #20]
 8047cb8:	2a02      	cmp	r2, #2
 8047cba:	fb01 f303 	mul.w	r3, r1, r3
 8047cbe:	d006      	beq.n	8047cce <kad_op_conv1d+0x88a>
 8047cc0:	6981      	ldr	r1, [r0, #24]
 8047cc2:	2a03      	cmp	r2, #3
 8047cc4:	fb01 f303 	mul.w	r3, r1, r3
 8047cc8:	bf1c      	itt	ne
 8047cca:	69c2      	ldrne	r2, [r0, #28]
 8047ccc:	4353      	mulne	r3, r2
				memset(q1, 0, kad_len(q) * sizeof(float));
 8047cce:	009a      	lsls	r2, r3, #2
 8047cd0:	2100      	movs	r1, #0
 8047cd2:	980b      	ldr	r0, [sp, #44]	@ 0x2c
 8047cd4:	f004 f8ae 	bl	804be34 <memset>
	for (k = 0; k < d[0]; ++k)
 8047cd8:	9b08      	ldr	r3, [sp, #32]
 8047cda:	2b00      	cmp	r3, #0
 8047cdc:	f340 8118 	ble.w	8047f10 <kad_op_conv1d+0xacc>
		for (j = 0; j < d[1]; ++j)
 8047ce0:	f8d6 e014 	ldr.w	lr, [r6, #20]
 8047ce4:	f1be 0f00 	cmp.w	lr, #0
 8047ce8:	dd39      	ble.n	8047d5e <kad_op_conv1d+0x91a>
			for (i = 0; i < d[2]; ++i)
 8047cea:	f04f 0900 	mov.w	r9, #0
	for (k = 0; k < d[0]; ++k)
 8047cee:	464a      	mov	r2, r9
			for (i = 0; i < d[2]; ++i)
 8047cf0:	f8d6 c018 	ldr.w	ip, [r6, #24]
 8047cf4:	ea4f 008e 	mov.w	r0, lr, lsl #2
 8047cf8:	ea4f 038c 	mov.w	r3, ip, lsl #2
 8047cfc:	9301      	str	r3, [sp, #4]
 8047cfe:	f8cd b008 	str.w	fp, [sp, #8]
		for (j = 0; j < d[1]; ++j)
 8047d02:	f1bc 0f00 	cmp.w	ip, #0
				y[(k * d[2] + i) * d[1] + j] = x[(k * d[1] + j) * d[2] + i];
 8047d06:	fb0c f502 	mul.w	r5, ip, r2
 8047d0a:	dd21      	ble.n	8047d50 <kad_op_conv1d+0x90c>
		for (j = 0; j < d[1]; ++j)
 8047d0c:	f04f 0b00 	mov.w	fp, #0
 8047d10:	fb0c f109 	mul.w	r1, ip, r9
 8047d14:	fb0e f505 	mul.w	r5, lr, r5
 8047d18:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8047d1a:	eb0c 0a01 	add.w	sl, ip, r1
 8047d1e:	eb03 0585 	add.w	r5, r3, r5, lsl #2
 8047d22:	eb08 048a 	add.w	r4, r8, sl, lsl #2
			for (i = 0; i < d[2]; ++i)
 8047d26:	eb08 0381 	add.w	r3, r8, r1, lsl #2
 8047d2a:	4629      	mov	r1, r5
				y[(k * d[2] + i) * d[1] + j] = x[(k * d[1] + j) * d[2] + i];
 8047d2c:	ecf3 7a01 	vldmia	r3!, {s15}
			for (i = 0; i < d[2]; ++i)
 8047d30:	42a3      	cmp	r3, r4
				y[(k * d[2] + i) * d[1] + j] = x[(k * d[1] + j) * d[2] + i];
 8047d32:	edc1 7a00 	vstr	s15, [r1]
			for (i = 0; i < d[2]; ++i)
 8047d36:	4401      	add	r1, r0
 8047d38:	d1f8      	bne.n	8047d2c <kad_op_conv1d+0x8e8>
		for (j = 0; j < d[1]; ++j)
 8047d3a:	9b01      	ldr	r3, [sp, #4]
 8047d3c:	f10b 0b01 	add.w	fp, fp, #1
 8047d40:	45f3      	cmp	fp, lr
 8047d42:	4651      	mov	r1, sl
 8047d44:	f105 0504 	add.w	r5, r5, #4
 8047d48:	441c      	add	r4, r3
 8047d4a:	d001      	beq.n	8047d50 <kad_op_conv1d+0x90c>
 8047d4c:	44e2      	add	sl, ip
 8047d4e:	e7ea      	b.n	8047d26 <kad_op_conv1d+0x8e2>
	for (k = 0; k < d[0]; ++k)
 8047d50:	9b08      	ldr	r3, [sp, #32]
 8047d52:	3201      	adds	r2, #1
 8047d54:	4293      	cmp	r3, r2
 8047d56:	44f1      	add	r9, lr
 8047d58:	d1d3      	bne.n	8047d02 <kad_op_conv1d+0x8be>
				conv1d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _ww, _xx));
 8047d5a:	f8dd b008 	ldr.w	fp, [sp, #8]
 8047d5e:	9a04      	ldr	r2, [sp, #16]
 8047d60:	6953      	ldr	r3, [r2, #20]
 8047d62:	f8d2 9010 	ldr.w	r9, [r2, #16]
 8047d66:	4619      	mov	r1, r3
 8047d68:	9302      	str	r3, [sp, #8]
 8047d6a:	f8db 3004 	ldr.w	r3, [fp, #4]
 8047d6e:	f1b9 0f00 	cmp.w	r9, #0
 8047d72:	fb01 f303 	mul.w	r3, r1, r3
 8047d76:	f77f af3d 	ble.w	8047bf4 <kad_op_conv1d+0x7b0>
 8047d7a:	2100      	movs	r1, #0
 8047d7c:	46b6      	mov	lr, r6
 8047d7e:	468a      	mov	sl, r1
 8047d80:	46bc      	mov	ip, r7
 8047d82:	009c      	lsls	r4, r3, #2
 8047d84:	9b11      	ldr	r3, [sp, #68]	@ 0x44
 8047d86:	9a0d      	ldr	r2, [sp, #52]	@ 0x34
 8047d88:	009b      	lsls	r3, r3, #2
 8047d8a:	9101      	str	r1, [sp, #4]
 8047d8c:	9306      	str	r3, [sp, #24]
 8047d8e:	f8cd 8028 	str.w	r8, [sp, #40]	@ 0x28
 8047d92:	6953      	ldr	r3, [r2, #20]
			t = (float*)malloc(p->d[2] * sizeof(float));
 8047d94:	6995      	ldr	r5, [r2, #24]
				conv1d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _ww, _xx));
 8047d96:	fb03 f30a 	mul.w	r3, r3, sl
 8047d9a:	fb05 f303 	mul.w	r3, r5, r3
 8047d9e:	6ad7      	ldr	r7, [r2, #44]	@ 0x2c
 8047da0:	f8cd a030 	str.w	sl, [sp, #48]	@ 0x30
 8047da4:	eb07 0783 	add.w	r7, r7, r3, lsl #2
 8047da8:	00ab      	lsls	r3, r5, #2
 8047daa:	9307      	str	r3, [sp, #28]
 8047dac:	f8cd 9040 	str.w	r9, [sp, #64]	@ 0x40
 8047db0:	f04f 0800 	mov.w	r8, #0
 8047db4:	4673      	mov	r3, lr
 8047db6:	46e1      	mov	r9, ip
 8047db8:	4692      	mov	sl, r2
 8047dba:	9e09      	ldr	r6, [sp, #36]	@ 0x24
 8047dbc:	9a04      	ldr	r2, [sp, #16]
 8047dbe:	9901      	ldr	r1, [sp, #4]
 8047dc0:	6992      	ldr	r2, [r2, #24]
 8047dc2:	980b      	ldr	r0, [sp, #44]	@ 0x2c
 8047dc4:	fb02 f101 	mul.w	r1, r2, r1
 8047dc8:	eb00 0181 	add.w	r1, r0, r1, lsl #2
 8047dcc:	9800      	ldr	r0, [sp, #0]
 8047dce:	b178      	cbz	r0, 8047df0 <kad_op_conv1d+0x9ac>
 8047dd0:	f8db 0008 	ldr.w	r0, [fp, #8]
 8047dd4:	9312      	str	r3, [sp, #72]	@ 0x48
 8047dd6:	9b02      	ldr	r3, [sp, #8]
 8047dd8:	fb03 f202 	mul.w	r2, r3, r2
 8047ddc:	fb03 f000 	mul.w	r0, r3, r0
 8047de0:	9b00      	ldr	r3, [sp, #0]
 8047de2:	0092      	lsls	r2, r2, #2
 8047de4:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 8047de8:	f004 f921 	bl	804c02e <memcpy>
 8047dec:	9900      	ldr	r1, [sp, #0]
 8047dee:	9b12      	ldr	r3, [sp, #72]	@ 0x48
 8047df0:	2d00      	cmp	r5, #0
 8047df2:	dd1f      	ble.n	8047e34 <kad_op_conv1d+0x9f0>
 8047df4:	9a11      	ldr	r2, [sp, #68]	@ 0x44
 8047df6:	2a00      	cmp	r2, #0
 8047df8:	dd1c      	ble.n	8047e34 <kad_op_conv1d+0x9f0>
 8047dfa:	46be      	mov	lr, r7
 8047dfc:	f04f 0c00 	mov.w	ip, #0
 8047e00:	9a06      	ldr	r2, [sp, #24]
 8047e02:	f8cd 8048 	str.w	r8, [sp, #72]	@ 0x48
 8047e06:	1888      	adds	r0, r1, r2
 8047e08:	ecfe 6a01 	vldmia	lr!, {s13}
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 8047e0c:	460a      	mov	r2, r1
				conv1d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _ww, _xx));
 8047e0e:	46b0      	mov	r8, r6
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 8047e10:	edd2 7a00 	vldr	s15, [r2]
 8047e14:	ecb8 7a01 	vldmia	r8!, {s14}
 8047e18:	eee6 7a87 	vfma.f32	s15, s13, s14
 8047e1c:	ece2 7a01 	vstmia	r2!, {s15}
 8047e20:	4282      	cmp	r2, r0
 8047e22:	d1f5      	bne.n	8047e10 <kad_op_conv1d+0x9cc>
				conv1d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _ww, _xx));
 8047e24:	f10c 0c01 	add.w	ip, ip, #1
 8047e28:	45ac      	cmp	ip, r5
 8047e2a:	4421      	add	r1, r4
 8047e2c:	4420      	add	r0, r4
 8047e2e:	d1eb      	bne.n	8047e08 <kad_op_conv1d+0x9c4>
 8047e30:	f8dd 8048 	ldr.w	r8, [sp, #72]	@ 0x48
 8047e34:	9a06      	ldr	r2, [sp, #24]
 8047e36:	f108 0801 	add.w	r8, r8, #1
 8047e3a:	4416      	add	r6, r2
 8047e3c:	9a07      	ldr	r2, [sp, #28]
 8047e3e:	4417      	add	r7, r2
 8047e40:	9a08      	ldr	r2, [sp, #32]
 8047e42:	4542      	cmp	r2, r8
 8047e44:	d1ba      	bne.n	8047dbc <kad_op_conv1d+0x978>
 8047e46:	4652      	mov	r2, sl
 8047e48:	f8dd a030 	ldr.w	sl, [sp, #48]	@ 0x30
 8047e4c:	46cc      	mov	ip, r9
 8047e4e:	f8dd 9040 	ldr.w	r9, [sp, #64]	@ 0x40
 8047e52:	f10a 0a01 	add.w	sl, sl, #1
 8047e56:	469e      	mov	lr, r3
 8047e58:	e9dd 3101 	ldrd	r3, r1, [sp, #4]
 8047e5c:	45ca      	cmp	sl, r9
 8047e5e:	440b      	add	r3, r1
 8047e60:	9301      	str	r3, [sp, #4]
 8047e62:	d196      	bne.n	8047d92 <kad_op_conv1d+0x94e>
 8047e64:	4676      	mov	r6, lr
 8047e66:	4667      	mov	r7, ip
 8047e68:	f8dd 8028 	ldr.w	r8, [sp, #40]	@ 0x28
		for (j = 0; j < d[1]; ++j)
 8047e6c:	9b04      	ldr	r3, [sp, #16]
 8047e6e:	f8d3 e014 	ldr.w	lr, [r3, #20]
				conv1d_add_2to1(q->d, q1, q->g);
 8047e72:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 8047e74:	f1be 0f00 	cmp.w	lr, #0
 8047e78:	9202      	str	r2, [sp, #8]
	for (k = 0; k < d[0]; ++k)
 8047e7a:	f77f aebb 	ble.w	8047bf4 <kad_op_conv1d+0x7b0>
			for (i = 0; i < d[2]; ++i)
 8047e7e:	f04f 0a00 	mov.w	sl, #0
 8047e82:	f8d3 c018 	ldr.w	ip, [r3, #24]
	for (k = 0; k < d[0]; ++k)
 8047e86:	4652      	mov	r2, sl
 8047e88:	ea4f 038c 	mov.w	r3, ip, lsl #2
 8047e8c:	9306      	str	r3, [sp, #24]
 8047e8e:	465b      	mov	r3, fp
 8047e90:	ea4f 008e 	mov.w	r0, lr, lsl #2
 8047e94:	f8cd 801c 	str.w	r8, [sp, #28]
		for (j = 0; j < d[1]; ++j)
 8047e98:	f1bc 0f00 	cmp.w	ip, #0
				x[(k * d[1] + j) * d[2] + i] += y[(k * d[2] + i) * d[1] + j];
 8047e9c:	fb0c f502 	mul.w	r5, ip, r2
 8047ea0:	dd2e      	ble.n	8047f00 <kad_op_conv1d+0xabc>
		for (j = 0; j < d[1]; ++j)
 8047ea2:	f04f 0b00 	mov.w	fp, #0
 8047ea6:	fb0e f505 	mul.w	r5, lr, r5
 8047eaa:	990b      	ldr	r1, [sp, #44]	@ 0x2c
 8047eac:	9c02      	ldr	r4, [sp, #8]
 8047eae:	eb01 0585 	add.w	r5, r1, r5, lsl #2
 8047eb2:	fb0c f10a 	mul.w	r1, ip, sl
 8047eb6:	eb0c 0801 	add.w	r8, ip, r1
 8047eba:	eb04 0488 	add.w	r4, r4, r8, lsl #2
 8047ebe:	f8cd 9028 	str.w	r9, [sp, #40]	@ 0x28
 8047ec2:	9301      	str	r3, [sp, #4]
				conv1d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _ww, _xx));
 8047ec4:	46a9      	mov	r9, r5
 8047ec6:	9b02      	ldr	r3, [sp, #8]
 8047ec8:	eb03 0181 	add.w	r1, r3, r1, lsl #2
 8047ecc:	9b01      	ldr	r3, [sp, #4]
				x[(k * d[1] + j) * d[2] + i] += y[(k * d[2] + i) * d[1] + j];
 8047ece:	ed91 7a00 	vldr	s14, [r1]
 8047ed2:	edd9 7a00 	vldr	s15, [r9]
 8047ed6:	ee77 7a87 	vadd.f32	s15, s15, s14
 8047eda:	ece1 7a01 	vstmia	r1!, {s15}
			for (i = 0; i < d[2]; ++i)
 8047ede:	42a1      	cmp	r1, r4
 8047ee0:	4481      	add	r9, r0
 8047ee2:	d1f4      	bne.n	8047ece <kad_op_conv1d+0xa8a>
		for (j = 0; j < d[1]; ++j)
 8047ee4:	9906      	ldr	r1, [sp, #24]
 8047ee6:	f10b 0b01 	add.w	fp, fp, #1
 8047eea:	45f3      	cmp	fp, lr
 8047eec:	440c      	add	r4, r1
 8047eee:	9301      	str	r3, [sp, #4]
 8047ef0:	4641      	mov	r1, r8
 8047ef2:	f105 0504 	add.w	r5, r5, #4
 8047ef6:	d001      	beq.n	8047efc <kad_op_conv1d+0xab8>
 8047ef8:	44e0      	add	r8, ip
 8047efa:	e7e3      	b.n	8047ec4 <kad_op_conv1d+0xa80>
 8047efc:	f8dd 9028 	ldr.w	r9, [sp, #40]	@ 0x28
	for (k = 0; k < d[0]; ++k)
 8047f00:	3201      	adds	r2, #1
 8047f02:	4591      	cmp	r9, r2
 8047f04:	44f2      	add	sl, lr
 8047f06:	d1c7      	bne.n	8047e98 <kad_op_conv1d+0xa54>
 8047f08:	469b      	mov	fp, r3
 8047f0a:	f8dd 801c 	ldr.w	r8, [sp, #28]
 8047f0e:	e671      	b.n	8047bf4 <kad_op_conv1d+0x7b0>
				conv1d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _ww, _xx));
 8047f10:	9b04      	ldr	r3, [sp, #16]
 8047f12:	f8d3 9010 	ldr.w	r9, [r3, #16]
 8047f16:	f1b9 0f00 	cmp.w	r9, #0
 8047f1a:	dca7      	bgt.n	8047e6c <kad_op_conv1d+0xa28>
 8047f1c:	e66a      	b.n	8047bf4 <kad_op_conv1d+0x7b0>
 8047f1e:	2204      	movs	r2, #4
 8047f20:	e6d6      	b.n	8047cd0 <kad_op_conv1d+0x88c>
			if (!algo_switch) {
 8047f22:	2f00      	cmp	r7, #0
 8047f24:	f47f aebe 	bne.w	8047ca4 <kad_op_conv1d+0x860>
				conv1d_loop1(q->g, w->x, p->g, t, process_row_back_x);
 8047f28:	9b04      	ldr	r3, [sp, #16]
 8047f2a:	691b      	ldr	r3, [r3, #16]
 8047f2c:	2b00      	cmp	r3, #0
 8047f2e:	f77f aea6 	ble.w	8047c7e <kad_op_conv1d+0x83a>
 8047f32:	9b08      	ldr	r3, [sp, #32]
 8047f34:	2b00      	cmp	r3, #0
 8047f36:	f77f aea2 	ble.w	8047c7e <kad_op_conv1d+0x83a>
 8047f3a:	2a00      	cmp	r2, #0
 8047f3c:	f77f ae9f 	ble.w	8047c7e <kad_op_conv1d+0x83a>
 8047f40:	9b03      	ldr	r3, [sp, #12]
 8047f42:	009b      	lsls	r3, r3, #2
 8047f44:	9302      	str	r3, [sp, #8]
 8047f46:	e596      	b.n	8047a76 <kad_op_conv1d+0x632>
		if (q->n_d != 3 || w->n_d != 3) return -1;
 8047f48:	f04f 30ff 	mov.w	r0, #4294967295
 8047f4c:	f7ff ba9c 	b.w	8047488 <kad_op_conv1d+0x44>
				conv1d_loop1(q->g, w->x, p->g, t, process_row_back_x);
 8047f50:	9a04      	ldr	r2, [sp, #16]
 8047f52:	6912      	ldr	r2, [r2, #16]
			if (!algo_switch) {
 8047f54:	2f00      	cmp	r7, #0
 8047f56:	f040 80ec 	bne.w	8048132 <kad_op_conv1d+0xcee>
				conv1d_loop1(q->x, w->g, p->g, t, process_row_back_w);
 8047f5a:	2a00      	cmp	r2, #0
 8047f5c:	f77f aa87 	ble.w	804746e <kad_op_conv1d+0x2a>
 8047f60:	9a08      	ldr	r2, [sp, #32]
 8047f62:	2a00      	cmp	r2, #0
 8047f64:	f340 80a0 	ble.w	80480a8 <kad_op_conv1d+0xc64>
 8047f68:	9b05      	ldr	r3, [sp, #20]
 8047f6a:	2b00      	cmp	r3, #0
 8047f6c:	f340 8096 	ble.w	804809c <kad_op_conv1d+0xc58>
 8047f70:	f04f 0c00 	mov.w	ip, #0
 8047f74:	9b11      	ldr	r3, [sp, #68]	@ 0x44
 8047f76:	f8dd e010 	ldr.w	lr, [sp, #16]
 8047f7a:	009b      	lsls	r3, r3, #2
 8047f7c:	930a      	str	r3, [sp, #40]	@ 0x28
 8047f7e:	9b03      	ldr	r3, [sp, #12]
 8047f80:	f8dd a03c 	ldr.w	sl, [sp, #60]	@ 0x3c
 8047f84:	009b      	lsls	r3, r3, #2
 8047f86:	9302      	str	r3, [sp, #8]
 8047f88:	2000      	movs	r0, #0
 8047f8a:	464a      	mov	r2, r9
 8047f8c:	4673      	mov	r3, lr
 8047f8e:	f8cd 9030 	str.w	r9, [sp, #48]	@ 0x30
 8047f92:	9d0d      	ldr	r5, [sp, #52]	@ 0x34
 8047f94:	695c      	ldr	r4, [r3, #20]
			t = (float*)malloc(p->d[2] * sizeof(float));
 8047f96:	69af      	ldr	r7, [r5, #24]
				conv1d_loop1(q->x, w->g, p->g, t, process_row_back_w);
 8047f98:	6969      	ldr	r1, [r5, #20]
				conv1d_loop1(q->g, w->x, p->g, t, process_row_back_x);
 8047f9a:	f8d5 902c 	ldr.w	r9, [r5, #44]	@ 0x2c
				conv1d_loop1(q->x, w->g, p->g, t, process_row_back_w);
 8047f9e:	2500      	movs	r5, #0
 8047fa0:	fb04 f40c 	mul.w	r4, r4, ip
 8047fa4:	fb01 080c 	mla	r8, r1, ip, r0
				conv1d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _ww, _xx));
 8047fa8:	6999      	ldr	r1, [r3, #24]
				conv1d_loop1(q->x, w->g, p->g, t, process_row_back_w);
 8047faa:	fb07 f808 	mul.w	r8, r7, r8
 8047fae:	fb01 f404 	mul.w	r4, r1, r4
 8047fb2:	0089      	lsls	r1, r1, #2
 8047fb4:	9106      	str	r1, [sp, #24]
 8047fb6:	6a99      	ldr	r1, [r3, #40]	@ 0x28
 8047fb8:	9504      	str	r5, [sp, #16]
 8047fba:	e9cd 3010 	strd	r3, r0, [sp, #64]	@ 0x40
 8047fbe:	9d02      	ldr	r5, [sp, #8]
 8047fc0:	e9cd c212 	strd	ip, r2, [sp, #72]	@ 0x48
 8047fc4:	eb01 0184 	add.w	r1, r1, r4, lsl #2
 8047fc8:	eb09 0487 	add.w	r4, r9, r7, lsl #2
 8047fcc:	eb04 0488 	add.w	r4, r4, r8, lsl #2
 8047fd0:	1956      	adds	r6, r2, r5
 8047fd2:	ea4f 0888 	mov.w	r8, r8, lsl #2
 8047fd6:	9201      	str	r2, [sp, #4]
 8047fd8:	eb0a 0587 	add.w	r5, sl, r7, lsl #2
 8047fdc:	9a00      	ldr	r2, [sp, #0]
 8047fde:	460b      	mov	r3, r1
 8047fe0:	b152      	cbz	r2, 8047ff8 <kad_op_conv1d+0xbb4>
 8047fe2:	f8db 3008 	ldr.w	r3, [fp, #8]
 8047fe6:	9107      	str	r1, [sp, #28]
 8047fe8:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 8047fec:	4618      	mov	r0, r3
 8047fee:	9a06      	ldr	r2, [sp, #24]
 8047ff0:	f004 f81d 	bl	804c02e <memcpy>
 8047ff4:	4603      	mov	r3, r0
 8047ff6:	9907      	ldr	r1, [sp, #28]
 8047ff8:	f8db 2004 	ldr.w	r2, [fp, #4]
 8047ffc:	2a01      	cmp	r2, #1
 8047ffe:	dd73      	ble.n	80480e8 <kad_op_conv1d+0xca4>
 8048000:	9803      	ldr	r0, [sp, #12]
 8048002:	2800      	cmp	r0, #0
 8048004:	dd2a      	ble.n	804805c <kad_op_conv1d+0xc18>
 8048006:	f8db 0008 	ldr.w	r0, [fp, #8]
 804800a:	f8dd c004 	ldr.w	ip, [sp, #4]
 804800e:	ebc0 7080 	rsb	r0, r0, r0, lsl #30
 8048012:	0092      	lsls	r2, r2, #2
 8048014:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 8048018:	2f00      	cmp	r7, #0
 804801a:	4603      	mov	r3, r0
 804801c:	dd61      	ble.n	80480e2 <kad_op_conv1d+0xc9e>
 804801e:	46d6      	mov	lr, sl
 8048020:	edd3 7a00 	vldr	s15, [r3]
 8048024:	ecee 7a01 	vstmia	lr!, {s15}
 8048028:	4575      	cmp	r5, lr
 804802a:	4413      	add	r3, r2
 804802c:	d1f8      	bne.n	8048020 <kad_op_conv1d+0xbdc>
	float s = 0.;
 804802e:	eddf 7ab3 	vldr	s15, [pc, #716]	@ 80482fc <kad_op_conv1d+0xeb8>
				conv1d_loop1(q->x, w->g, p->g, t, process_row_back_w);
 8048032:	46d6      	mov	lr, sl
 8048034:	eb09 0308 	add.w	r3, r9, r8
	for (i = 0; i < n; ++i) s += x[i] * y[i];
 8048038:	ecf3 6a01 	vldmia	r3!, {s13}
 804803c:	ecbe 7a01 	vldmia	lr!, {s14}
 8048040:	429c      	cmp	r4, r3
 8048042:	eee6 7a87 	vfma.f32	s15, s13, s14
 8048046:	d1f7      	bne.n	8048038 <kad_op_conv1d+0xbf4>
				conv1d_loop1(q->x, w->g, p->g, t, process_row_back_w);
 8048048:	ed9c 7a00 	vldr	s14, [ip]
 804804c:	ee77 7a27 	vadd.f32	s15, s14, s15
 8048050:	ecec 7a01 	vstmia	ip!, {s15}
 8048054:	4566      	cmp	r6, ip
 8048056:	f100 0004 	add.w	r0, r0, #4
 804805a:	d1dd      	bne.n	8048018 <kad_op_conv1d+0xbd4>
 804805c:	e9dd 2001 	ldrd	r2, r0, [sp, #4]
 8048060:	4402      	add	r2, r0
 8048062:	9201      	str	r2, [sp, #4]
 8048064:	9a06      	ldr	r2, [sp, #24]
 8048066:	9b04      	ldr	r3, [sp, #16]
 8048068:	4411      	add	r1, r2
 804806a:	9a05      	ldr	r2, [sp, #20]
 804806c:	3301      	adds	r3, #1
 804806e:	429a      	cmp	r2, r3
 8048070:	9304      	str	r3, [sp, #16]
 8048072:	4406      	add	r6, r0
 8048074:	d1b2      	bne.n	8047fdc <kad_op_conv1d+0xb98>
 8048076:	e9dd c212 	ldrd	ip, r2, [sp, #72]	@ 0x48
 804807a:	e9dd 3010 	ldrd	r3, r0, [sp, #64]	@ 0x40
 804807e:	990a      	ldr	r1, [sp, #40]	@ 0x28
 8048080:	3001      	adds	r0, #1
 8048082:	440a      	add	r2, r1
 8048084:	9908      	ldr	r1, [sp, #32]
 8048086:	4288      	cmp	r0, r1
 8048088:	d183      	bne.n	8047f92 <kad_op_conv1d+0xb4e>
 804808a:	469e      	mov	lr, r3
 804808c:	691b      	ldr	r3, [r3, #16]
 804808e:	f10c 0c01 	add.w	ip, ip, #1
 8048092:	4563      	cmp	r3, ip
 8048094:	f8dd 9030 	ldr.w	r9, [sp, #48]	@ 0x30
 8048098:	f73f af76 	bgt.w	8047f88 <kad_op_conv1d+0xb44>
	for (i = 0; i < d0; ++i) {
 804809c:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
 804809e:	2b00      	cmp	r3, #0
 80480a0:	f77f a9e5 	ble.w	804746e <kad_op_conv1d+0x2a>
 80480a4:	9b03      	ldr	r3, [sp, #12]
 80480a6:	105b      	asrs	r3, r3, #1
 80480a8:	2b00      	cmp	r3, #0
 80480aa:	f77f a9e0 	ble.w	804746e <kad_op_conv1d+0x2a>
 80480ae:	9a03      	ldr	r2, [sp, #12]
 80480b0:	0092      	lsls	r2, r2, #2
 80480b2:	9202      	str	r2, [sp, #8]
 80480b4:	464a      	mov	r2, r9
	for (k = 0; k < d[0]; ++k)
 80480b6:	2000      	movs	r0, #0
 80480b8:	9d02      	ldr	r5, [sp, #8]
 80480ba:	eb09 0383 	add.w	r3, r9, r3, lsl #2
		for (j = 0; j < d1>>1; ++j)
 80480be:	4611      	mov	r1, r2
 80480c0:	442a      	add	r2, r5
	for (k = 0; k < d[0]; ++k)
 80480c2:	4614      	mov	r4, r2
			tmp = xi[j], xi[j] = xi[d1-1-j], xi[d1-1-j] = tmp; 
 80480c4:	f854 7d04 	ldr.w	r7, [r4, #-4]!
 80480c8:	680e      	ldr	r6, [r1, #0]
 80480ca:	f841 7b04 	str.w	r7, [r1], #4
		for (j = 0; j < d1>>1; ++j)
 80480ce:	428b      	cmp	r3, r1
			tmp = xi[j], xi[j] = xi[d1-1-j], xi[d1-1-j] = tmp; 
 80480d0:	6026      	str	r6, [r4, #0]
		for (j = 0; j < d1>>1; ++j)
 80480d2:	d1f7      	bne.n	80480c4 <kad_op_conv1d+0xc80>
	for (i = 0; i < d0; ++i) {
 80480d4:	990e      	ldr	r1, [sp, #56]	@ 0x38
 80480d6:	3001      	adds	r0, #1
 80480d8:	4281      	cmp	r1, r0
 80480da:	442b      	add	r3, r5
 80480dc:	d1ef      	bne.n	80480be <kad_op_conv1d+0xc7a>
 80480de:	f7ff b9c6 	b.w	804746e <kad_op_conv1d+0x2a>
	float s = 0.;
 80480e2:	eddf 7a86 	vldr	s15, [pc, #536]	@ 80482fc <kad_op_conv1d+0xeb8>
 80480e6:	e7af      	b.n	8048048 <kad_op_conv1d+0xc04>
				conv1d_loop1(q->x, w->g, p->g, t, process_row_back_w);
 80480e8:	9a03      	ldr	r2, [sp, #12]
 80480ea:	2a00      	cmp	r2, #0
 80480ec:	ddb6      	ble.n	804805c <kad_op_conv1d+0xc18>
 80480ee:	f8db 2008 	ldr.w	r2, [fp, #8]
 80480f2:	9801      	ldr	r0, [sp, #4]
 80480f4:	ebc2 7282 	rsb	r2, r2, r2, lsl #30
 80480f8:	ea4f 0e82 	mov.w	lr, r2, lsl #2
	for (i = 0; i < n; ++i) s += x[i] * y[i];
 80480fc:	2f00      	cmp	r7, #0
	float s = 0.;
 80480fe:	eddf 7a7f 	vldr	s15, [pc, #508]	@ 80482fc <kad_op_conv1d+0xeb8>
	for (i = 0; i < n; ++i) s += x[i] * y[i];
 8048102:	dd0b      	ble.n	804811c <kad_op_conv1d+0xcd8>
 8048104:	eb09 0208 	add.w	r2, r9, r8
 8048108:	eb03 0c0e 	add.w	ip, r3, lr
 804810c:	ecf2 6a01 	vldmia	r2!, {s13}
 8048110:	ecbc 7a01 	vldmia	ip!, {s14}
 8048114:	4294      	cmp	r4, r2
 8048116:	eee6 7a87 	vfma.f32	s15, s13, s14
 804811a:	d1f7      	bne.n	804810c <kad_op_conv1d+0xcc8>
				conv1d_loop1(q->x, w->g, p->g, t, process_row_back_w);
 804811c:	ed90 7a00 	vldr	s14, [r0]
 8048120:	ee77 7a27 	vadd.f32	s15, s14, s15
 8048124:	ece0 7a01 	vstmia	r0!, {s15}
 8048128:	4286      	cmp	r6, r0
 804812a:	f10e 0e04 	add.w	lr, lr, #4
 804812e:	d1e5      	bne.n	80480fc <kad_op_conv1d+0xcb8>
 8048130:	e794      	b.n	804805c <kad_op_conv1d+0xc18>
	for (k = 0; k < d[0]; ++k)
 8048132:	9b04      	ldr	r3, [sp, #16]
 8048134:	691a      	ldr	r2, [r3, #16]
				conv1d_move_1to2(q->d, q->x, q1);
 8048136:	6a99      	ldr	r1, [r3, #40]	@ 0x28
	for (k = 0; k < d[0]; ++k)
 8048138:	2a00      	cmp	r2, #0
 804813a:	9202      	str	r2, [sp, #8]
				conv1d_move_1to2(q->d, q->x, q1);
 804813c:	9101      	str	r1, [sp, #4]
	for (k = 0; k < d[0]; ++k)
 804813e:	f340 814b 	ble.w	80483d8 <kad_op_conv1d+0xf94>
		for (j = 0; j < d[1]; ++j)
 8048142:	f8d3 c014 	ldr.w	ip, [r3, #20]
 8048146:	f1bc 0f00 	cmp.w	ip, #0
 804814a:	dd33      	ble.n	80481b4 <kad_op_conv1d+0xd70>
			for (i = 0; i < d[2]; ++i)
 804814c:	f04f 0800 	mov.w	r8, #0
	for (k = 0; k < d[0]; ++k)
 8048150:	4642      	mov	r2, r8
			for (i = 0; i < d[2]; ++i)
 8048152:	699f      	ldr	r7, [r3, #24]
 8048154:	ea4f 0e8c 	mov.w	lr, ip, lsl #2
 8048158:	00bb      	lsls	r3, r7, #2
 804815a:	9306      	str	r3, [sp, #24]
		for (j = 0; j < d[1]; ++j)
 804815c:	2f00      	cmp	r7, #0
				y[(k * d[2] + i) * d[1] + j] = x[(k * d[1] + j) * d[2] + i];
 804815e:	fb07 f402 	mul.w	r4, r7, r2
 8048162:	dd22      	ble.n	80481aa <kad_op_conv1d+0xd66>
		for (j = 0; j < d[1]; ++j)
 8048164:	f04f 0a00 	mov.w	sl, #0
 8048168:	fb0c f404 	mul.w	r4, ip, r4
 804816c:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 804816e:	9901      	ldr	r1, [sp, #4]
 8048170:	eb03 0484 	add.w	r4, r3, r4, lsl #2
 8048174:	fb07 f308 	mul.w	r3, r7, r8
 8048178:	19dd      	adds	r5, r3, r7
 804817a:	eb01 0085 	add.w	r0, r1, r5, lsl #2
			for (i = 0; i < d[2]; ++i)
 804817e:	9901      	ldr	r1, [sp, #4]
 8048180:	eb01 0383 	add.w	r3, r1, r3, lsl #2
				conv1d_loop1(q->x, w->g, p->g, t, process_row_back_w);
 8048184:	4621      	mov	r1, r4
				y[(k * d[2] + i) * d[1] + j] = x[(k * d[1] + j) * d[2] + i];
 8048186:	ecf3 7a01 	vldmia	r3!, {s15}
			for (i = 0; i < d[2]; ++i)
 804818a:	4298      	cmp	r0, r3
				y[(k * d[2] + i) * d[1] + j] = x[(k * d[1] + j) * d[2] + i];
 804818c:	edc1 7a00 	vstr	s15, [r1]
			for (i = 0; i < d[2]; ++i)
 8048190:	4471      	add	r1, lr
 8048192:	d1f8      	bne.n	8048186 <kad_op_conv1d+0xd42>
		for (j = 0; j < d[1]; ++j)
 8048194:	9b06      	ldr	r3, [sp, #24]
 8048196:	f10a 0a01 	add.w	sl, sl, #1
 804819a:	45e2      	cmp	sl, ip
 804819c:	4418      	add	r0, r3
 804819e:	f104 0404 	add.w	r4, r4, #4
 80481a2:	462b      	mov	r3, r5
 80481a4:	d001      	beq.n	80481aa <kad_op_conv1d+0xd66>
 80481a6:	443d      	add	r5, r7
 80481a8:	e7e9      	b.n	804817e <kad_op_conv1d+0xd3a>
	for (k = 0; k < d[0]; ++k)
 80481aa:	9b02      	ldr	r3, [sp, #8]
 80481ac:	3201      	adds	r2, #1
 80481ae:	429a      	cmp	r2, r3
 80481b0:	44e0      	add	r8, ip
 80481b2:	d1d3      	bne.n	804815c <kad_op_conv1d+0xd18>
 80481b4:	7832      	ldrb	r2, [r6, #0]
 80481b6:	4613      	mov	r3, r2
 80481b8:	2a00      	cmp	r2, #0
 80481ba:	f000 811a 	beq.w	80483f2 <kad_op_conv1d+0xfae>
 80481be:	2b01      	cmp	r3, #1
 80481c0:	f000 8115 	beq.w	80483ee <kad_op_conv1d+0xfaa>
 80481c4:	990e      	ldr	r1, [sp, #56]	@ 0x38
 80481c6:	2b02      	cmp	r3, #2
 80481c8:	460a      	mov	r2, r1
 80481ca:	d007      	beq.n	80481dc <kad_op_conv1d+0xd98>
 80481cc:	9903      	ldr	r1, [sp, #12]
 80481ce:	2b03      	cmp	r3, #3
 80481d0:	fb01 f202 	mul.w	r2, r1, r2
 80481d4:	d002      	beq.n	80481dc <kad_op_conv1d+0xd98>
 80481d6:	69f3      	ldr	r3, [r6, #28]
 80481d8:	fb03 f202 	mul.w	r2, r3, r2
				memset(w1, 0, kad_len(w) * sizeof(float));
 80481dc:	0092      	lsls	r2, r2, #2
 80481de:	2100      	movs	r1, #0
 80481e0:	9809      	ldr	r0, [sp, #36]	@ 0x24
 80481e2:	f003 fe27 	bl	804be34 <memset>
				conv1d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _xx, _ww));
 80481e6:	9b04      	ldr	r3, [sp, #16]
 80481e8:	9a02      	ldr	r2, [sp, #8]
 80481ea:	f8d3 8014 	ldr.w	r8, [r3, #20]
 80481ee:	f8db 3004 	ldr.w	r3, [fp, #4]
 80481f2:	2a00      	cmp	r2, #0
 80481f4:	fb03 f308 	mul.w	r3, r3, r8
 80481f8:	f340 80f5 	ble.w	80483e6 <kad_op_conv1d+0xfa2>
 80481fc:	009a      	lsls	r2, r3, #2
 80481fe:	9207      	str	r2, [sp, #28]
 8048200:	9a08      	ldr	r2, [sp, #32]
 8048202:	2a00      	cmp	r2, #0
 8048204:	f77f af4a 	ble.w	804809c <kad_op_conv1d+0xc58>
 8048208:	2000      	movs	r0, #0
 804820a:	00db      	lsls	r3, r3, #3
 804820c:	9313      	str	r3, [sp, #76]	@ 0x4c
 804820e:	9b11      	ldr	r3, [sp, #68]	@ 0x44
 8048210:	e9cd 9b16 	strd	r9, fp, [sp, #88]	@ 0x58
 8048214:	009a      	lsls	r2, r3, #2
 8048216:	9210      	str	r2, [sp, #64]	@ 0x40
 8048218:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 804821a:	4605      	mov	r5, r0
 804821c:	eb02 0c83 	add.w	ip, r2, r3, lsl #2
 8048220:	4682      	mov	sl, r0
 8048222:	46e3      	mov	fp, ip
 8048224:	990d      	ldr	r1, [sp, #52]	@ 0x34
				conv1d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _ww, _xx));
 8048226:	9b04      	ldr	r3, [sp, #16]
				conv1d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _xx, _ww));
 8048228:	9a0b      	ldr	r2, [sp, #44]	@ 0x2c
				conv1d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _ww, _xx));
 804822a:	6998      	ldr	r0, [r3, #24]
				conv1d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _xx, _ww));
 804822c:	694b      	ldr	r3, [r1, #20]
 804822e:	fb00 f40a 	mul.w	r4, r0, sl
 8048232:	fb08 f000 	mul.w	r0, r8, r0
 8048236:	eb02 0484 	add.w	r4, r2, r4, lsl #2
 804823a:	0082      	lsls	r2, r0, #2
 804823c:	920c      	str	r2, [sp, #48]	@ 0x30
 804823e:	9a00      	ldr	r2, [sp, #0]
 8048240:	fb05 f303 	mul.w	r3, r5, r3
 8048244:	4610      	mov	r0, r2
 8048246:	2a00      	cmp	r2, #0
 8048248:	bf08      	it	eq
 804824a:	4620      	moveq	r0, r4
			t = (float*)malloc(p->d[2] * sizeof(float));
 804824c:	698f      	ldr	r7, [r1, #24]
 804824e:	4602      	mov	r2, r0
 8048250:	9006      	str	r0, [sp, #24]
 8048252:	fb07 f003 	mul.w	r0, r7, r3
 8048256:	6acb      	ldr	r3, [r1, #44]	@ 0x2c
				conv1d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _xx, _ww));
 8048258:	9414      	str	r4, [sp, #80]	@ 0x50
 804825a:	eb03 0380 	add.w	r3, r3, r0, lsl #2
 804825e:	9301      	str	r3, [sp, #4]
 8048260:	2300      	movs	r3, #0
 8048262:	465c      	mov	r4, fp
 8048264:	460e      	mov	r6, r1
 8048266:	930a      	str	r3, [sp, #40]	@ 0x28
 8048268:	00bb      	lsls	r3, r7, #2
 804826a:	930d      	str	r3, [sp, #52]	@ 0x34
 804826c:	1e7b      	subs	r3, r7, #1
 804826e:	9315      	str	r3, [sp, #84]	@ 0x54
 8048270:	9b07      	ldr	r3, [sp, #28]
 8048272:	e9cd 5a18 	strd	r5, sl, [sp, #96]	@ 0x60
 8048276:	18d3      	adds	r3, r2, r3
 8048278:	f8dd 9024 	ldr.w	r9, [sp, #36]	@ 0x24
 804827c:	9312      	str	r3, [sp, #72]	@ 0x48
 804827e:	e9dd 2500 	ldrd	r2, r5, [sp]
 8048282:	b14a      	cbz	r2, 8048298 <kad_op_conv1d+0xe54>
 8048284:	9b17      	ldr	r3, [sp, #92]	@ 0x5c
 8048286:	9914      	ldr	r1, [sp, #80]	@ 0x50
 8048288:	689b      	ldr	r3, [r3, #8]
 804828a:	fb03 f308 	mul.w	r3, r3, r8
 804828e:	eb02 0083 	add.w	r0, r2, r3, lsl #2
 8048292:	9a0c      	ldr	r2, [sp, #48]	@ 0x30
 8048294:	f003 fecb 	bl	804c02e <memcpy>
 8048298:	2f00      	cmp	r7, #0
 804829a:	dd46      	ble.n	804832a <kad_op_conv1d+0xee6>
 804829c:	9b11      	ldr	r3, [sp, #68]	@ 0x44
 804829e:	2b00      	cmp	r3, #0
 80482a0:	dd43      	ble.n	804832a <kad_op_conv1d+0xee6>
 80482a2:	2f02      	cmp	r7, #2
 80482a4:	f340 8095 	ble.w	80483d2 <kad_op_conv1d+0xf8e>
 80482a8:	2301      	movs	r3, #1
 80482aa:	9901      	ldr	r1, [sp, #4]
 80482ac:	f8dd a048 	ldr.w	sl, [sp, #72]	@ 0x48
 80482b0:	9a06      	ldr	r2, [sp, #24]
 80482b2:	f101 0e04 	add.w	lr, r1, #4
 80482b6:	ed5e 5a01 	vldr	s11, [lr, #-4]
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 80482ba:	ed95 6a01 	vldr	s12, [r5, #4]
				conv1d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _xx, _ww));
 80482be:	46d4      	mov	ip, sl
 80482c0:	4610      	mov	r0, r2
 80482c2:	4649      	mov	r1, r9
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 80482c4:	edd1 7a00 	vldr	s15, [r1]
 80482c8:	ecf0 6a01 	vldmia	r0!, {s13}
 80482cc:	ecbc 7a01 	vldmia	ip!, {s14}
 80482d0:	eee5 7aa6 	vfma.f32	s15, s11, s13
 80482d4:	eee7 7a06 	vfma.f32	s15, s14, s12
 80482d8:	ece1 7a01 	vstmia	r1!, {s15}
 80482dc:	428c      	cmp	r4, r1
 80482de:	d1f1      	bne.n	80482c4 <kad_op_conv1d+0xe80>
				conv1d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _xx, _ww));
 80482e0:	9913      	ldr	r1, [sp, #76]	@ 0x4c
 80482e2:	9815      	ldr	r0, [sp, #84]	@ 0x54
 80482e4:	440a      	add	r2, r1
 80482e6:	448a      	add	sl, r1
 80482e8:	1c99      	adds	r1, r3, #2
 80482ea:	4281      	cmp	r1, r0
 80482ec:	f105 0508 	add.w	r5, r5, #8
 80482f0:	f10e 0e08 	add.w	lr, lr, #8
 80482f4:	da04      	bge.n	8048300 <kad_op_conv1d+0xebc>
 80482f6:	460b      	mov	r3, r1
 80482f8:	e7dd      	b.n	80482b6 <kad_op_conv1d+0xe72>
 80482fa:	bf00      	nop
 80482fc:	00000000 	.word	0x00000000
 8048300:	3301      	adds	r3, #1
 8048302:	f8dd c01c 	ldr.w	ip, [sp, #28]
 8048306:	ecf5 6a01 	vldmia	r5!, {s13}
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 804830a:	4610      	mov	r0, r2
				conv1d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _xx, _ww));
 804830c:	4649      	mov	r1, r9
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 804830e:	edd1 7a00 	vldr	s15, [r1]
 8048312:	ecb0 7a01 	vldmia	r0!, {s14}
 8048316:	eee7 7a26 	vfma.f32	s15, s14, s13
 804831a:	ece1 7a01 	vstmia	r1!, {s15}
 804831e:	428c      	cmp	r4, r1
 8048320:	d1f5      	bne.n	804830e <kad_op_conv1d+0xeca>
				conv1d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _xx, _ww));
 8048322:	3301      	adds	r3, #1
 8048324:	429f      	cmp	r7, r3
 8048326:	4462      	add	r2, ip
 8048328:	dced      	bgt.n	8048306 <kad_op_conv1d+0xec2>
 804832a:	9a10      	ldr	r2, [sp, #64]	@ 0x40
 804832c:	990d      	ldr	r1, [sp, #52]	@ 0x34
 804832e:	4491      	add	r9, r2
 8048330:	4414      	add	r4, r2
 8048332:	9a01      	ldr	r2, [sp, #4]
 8048334:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 8048336:	440a      	add	r2, r1
 8048338:	9201      	str	r2, [sp, #4]
 804833a:	9a08      	ldr	r2, [sp, #32]
 804833c:	3301      	adds	r3, #1
 804833e:	4293      	cmp	r3, r2
 8048340:	930a      	str	r3, [sp, #40]	@ 0x28
 8048342:	d19c      	bne.n	804827e <kad_op_conv1d+0xe3a>
 8048344:	e9dd 5a18 	ldrd	r5, sl, [sp, #96]	@ 0x60
 8048348:	9b02      	ldr	r3, [sp, #8]
 804834a:	3501      	adds	r5, #1
 804834c:	429d      	cmp	r5, r3
 804834e:	4631      	mov	r1, r6
 8048350:	44c2      	add	sl, r8
 8048352:	f47f af68 	bne.w	8048226 <kad_op_conv1d+0xde2>
 8048356:	f8dd 9058 	ldr.w	r9, [sp, #88]	@ 0x58
 804835a:	9b05      	ldr	r3, [sp, #20]
 804835c:	2b00      	cmp	r3, #0
 804835e:	f77f ae9d 	ble.w	804809c <kad_op_conv1d+0xc58>
 8048362:	9f03      	ldr	r7, [sp, #12]
 8048364:	2f00      	cmp	r7, #0
 8048366:	f77f a882 	ble.w	804746e <kad_op_conv1d+0x2a>
		for (j = 0; j < d[1]; ++j)
 804836a:	2000      	movs	r0, #0
 804836c:	4698      	mov	r8, r3
 804836e:	4684      	mov	ip, r0
	for (k = 0; k < d[0]; ++k)
 8048370:	4686      	mov	lr, r0
 8048372:	00ba      	lsls	r2, r7, #2
 8048374:	9202      	str	r2, [sp, #8]
 8048376:	009c      	lsls	r4, r3, #2
		for (j = 0; j < d[1]; ++j)
 8048378:	f04f 0a00 	mov.w	sl, #0
 804837c:	fb07 f300 	mul.w	r3, r7, r0
 8048380:	fb08 f50c 	mul.w	r5, r8, ip
 8048384:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 8048386:	18fe      	adds	r6, r7, r3
 8048388:	eb02 0585 	add.w	r5, r2, r5, lsl #2
 804838c:	eb09 0186 	add.w	r1, r9, r6, lsl #2
				conv1d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _xx, _ww));
 8048390:	462a      	mov	r2, r5
 8048392:	eb09 0383 	add.w	r3, r9, r3, lsl #2
				x[(k * d[1] + j) * d[2] + i] += y[(k * d[2] + i) * d[1] + j];
 8048396:	ed93 7a00 	vldr	s14, [r3]
 804839a:	edd2 7a00 	vldr	s15, [r2]
 804839e:	ee77 7a87 	vadd.f32	s15, s15, s14
 80483a2:	ece3 7a01 	vstmia	r3!, {s15}
			for (i = 0; i < d[2]; ++i)
 80483a6:	4299      	cmp	r1, r3
 80483a8:	4422      	add	r2, r4
 80483aa:	d1f4      	bne.n	8048396 <kad_op_conv1d+0xf52>
		for (j = 0; j < d[1]; ++j)
 80483ac:	9b02      	ldr	r3, [sp, #8]
 80483ae:	f10a 0a01 	add.w	sl, sl, #1
 80483b2:	45d0      	cmp	r8, sl
 80483b4:	4419      	add	r1, r3
 80483b6:	f105 0504 	add.w	r5, r5, #4
 80483ba:	4633      	mov	r3, r6
 80483bc:	d001      	beq.n	80483c2 <kad_op_conv1d+0xf7e>
 80483be:	443e      	add	r6, r7
 80483c0:	e7e6      	b.n	8048390 <kad_op_conv1d+0xf4c>
	for (k = 0; k < d[0]; ++k)
 80483c2:	9b08      	ldr	r3, [sp, #32]
 80483c4:	f10e 0e01 	add.w	lr, lr, #1
 80483c8:	4573      	cmp	r3, lr
 80483ca:	44bc      	add	ip, r7
 80483cc:	4440      	add	r0, r8
 80483ce:	d1d3      	bne.n	8048378 <kad_op_conv1d+0xf34>
 80483d0:	e664      	b.n	804809c <kad_op_conv1d+0xc58>
				conv1d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _xx, _ww));
 80483d2:	2300      	movs	r3, #0
 80483d4:	9a06      	ldr	r2, [sp, #24]
 80483d6:	e794      	b.n	8048302 <kad_op_conv1d+0xebe>
 80483d8:	7832      	ldrb	r2, [r6, #0]
 80483da:	4613      	mov	r3, r2
 80483dc:	2a00      	cmp	r2, #0
 80483de:	f47f aeee 	bne.w	80481be <kad_op_conv1d+0xd7a>
				memset(w1, 0, kad_len(w) * sizeof(float));
 80483e2:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 80483e4:	601a      	str	r2, [r3, #0]
	for (k = 0; k < d[0]; ++k)
 80483e6:	9b08      	ldr	r3, [sp, #32]
 80483e8:	2b00      	cmp	r3, #0
 80483ea:	dcb6      	bgt.n	804835a <kad_op_conv1d+0xf16>
 80483ec:	e656      	b.n	804809c <kad_op_conv1d+0xc58>
 80483ee:	9a08      	ldr	r2, [sp, #32]
 80483f0:	e6f4      	b.n	80481dc <kad_op_conv1d+0xd98>
				memset(w1, 0, kad_len(w) * sizeof(float));
 80483f2:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 80483f4:	601a      	str	r2, [r3, #0]
				conv1d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _xx, _ww));
 80483f6:	9b04      	ldr	r3, [sp, #16]
 80483f8:	f8d3 8014 	ldr.w	r8, [r3, #20]
 80483fc:	f8db 3004 	ldr.w	r3, [fp, #4]
 8048400:	fb03 f308 	mul.w	r3, r3, r8
 8048404:	e6fa      	b.n	80481fc <kad_op_conv1d+0xdb8>
			conv1d_loop1(q->x, w->x, p->x, t, process_row_for);
 8048406:	69b1      	ldr	r1, [r6, #24]
	for (k = 0; k < d[0]; ++k)
 8048408:	691a      	ldr	r2, [r3, #16]
			conv1d_loop1(q->x, w->x, p->x, t, process_row_for);
 804840a:	9105      	str	r1, [sp, #20]
 804840c:	6ab1      	ldr	r1, [r6, #40]	@ 0x28
	for (k = 0; k < d[0]; ++k)
 804840e:	2a00      	cmp	r2, #0
			conv1d_loop1(q->x, w->x, p->x, t, process_row_for);
 8048410:	910e      	str	r1, [sp, #56]	@ 0x38
 8048412:	6931      	ldr	r1, [r6, #16]
			conv1d_move_1to2(q->d, q->x, q1);
 8048414:	f8d3 8028 	ldr.w	r8, [r3, #40]	@ 0x28
			conv1d_loop1(q->x, w->x, p->x, t, process_row_for);
 8048418:	910a      	str	r1, [sp, #40]	@ 0x28
 804841a:	6971      	ldr	r1, [r6, #20]
	for (k = 0; k < d[0]; ++k)
 804841c:	9201      	str	r2, [sp, #4]
			conv1d_loop1(q->x, w->x, p->x, t, process_row_for);
 804841e:	9102      	str	r1, [sp, #8]
	for (k = 0; k < d[0]; ++k)
 8048420:	dd7f      	ble.n	8048522 <kad_op_conv1d+0x10de>
		for (j = 0; j < d[1]; ++j)
 8048422:	f8d3 9014 	ldr.w	r9, [r3, #20]
 8048426:	f1b9 0f00 	cmp.w	r9, #0
 804842a:	dd2f      	ble.n	804848c <kad_op_conv1d+0x1048>
			for (i = 0; i < d[2]; ++i)
 804842c:	f04f 0c00 	mov.w	ip, #0
	for (k = 0; k < d[0]; ++k)
 8048430:	46e6      	mov	lr, ip
			for (i = 0; i < d[2]; ++i)
 8048432:	699f      	ldr	r7, [r3, #24]
 8048434:	ea4f 0089 	mov.w	r0, r9, lsl #2
 8048438:	ea4f 0a87 	mov.w	sl, r7, lsl #2
		for (j = 0; j < d[1]; ++j)
 804843c:	2f00      	cmp	r7, #0
				y[(k * d[2] + i) * d[1] + j] = x[(k * d[1] + j) * d[2] + i];
 804843e:	fb07 f10e 	mul.w	r1, r7, lr
 8048442:	dd1d      	ble.n	8048480 <kad_op_conv1d+0x103c>
		for (j = 0; j < d[1]; ++j)
 8048444:	2500      	movs	r5, #0
 8048446:	fb09 f101 	mul.w	r1, r9, r1
 804844a:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 804844c:	eb03 0181 	add.w	r1, r3, r1, lsl #2
 8048450:	fb07 f30c 	mul.w	r3, r7, ip
 8048454:	18fc      	adds	r4, r7, r3
 8048456:	eb08 0284 	add.w	r2, r8, r4, lsl #2
			conv1d_loop1(q->x, w->x, p->x, t, process_row_for);
 804845a:	460e      	mov	r6, r1
 804845c:	eb08 0383 	add.w	r3, r8, r3, lsl #2
				y[(k * d[2] + i) * d[1] + j] = x[(k * d[1] + j) * d[2] + i];
 8048460:	ecf3 7a01 	vldmia	r3!, {s15}
			for (i = 0; i < d[2]; ++i)
 8048464:	429a      	cmp	r2, r3
				y[(k * d[2] + i) * d[1] + j] = x[(k * d[1] + j) * d[2] + i];
 8048466:	edc6 7a00 	vstr	s15, [r6]
			for (i = 0; i < d[2]; ++i)
 804846a:	4406      	add	r6, r0
 804846c:	d1f8      	bne.n	8048460 <kad_op_conv1d+0x101c>
		for (j = 0; j < d[1]; ++j)
 804846e:	3501      	adds	r5, #1
 8048470:	454d      	cmp	r5, r9
 8048472:	4623      	mov	r3, r4
 8048474:	f101 0104 	add.w	r1, r1, #4
 8048478:	4452      	add	r2, sl
 804847a:	d001      	beq.n	8048480 <kad_op_conv1d+0x103c>
 804847c:	443c      	add	r4, r7
 804847e:	e7ec      	b.n	804845a <kad_op_conv1d+0x1016>
	for (k = 0; k < d[0]; ++k)
 8048480:	9b01      	ldr	r3, [sp, #4]
 8048482:	f10e 0e01 	add.w	lr, lr, #1
 8048486:	459e      	cmp	lr, r3
 8048488:	44cc      	add	ip, r9
 804848a:	d1d7      	bne.n	804843c <kad_op_conv1d+0xff8>
 804848c:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 804848e:	2b00      	cmp	r3, #0
 8048490:	f77f aa8c 	ble.w	80479ac <kad_op_conv1d+0x568>
 8048494:	9b02      	ldr	r3, [sp, #8]
 8048496:	2b00      	cmp	r3, #0
 8048498:	dd39      	ble.n	804850e <kad_op_conv1d+0x10ca>
 804849a:	9b05      	ldr	r3, [sp, #20]
 804849c:	2b00      	cmp	r3, #0
 804849e:	dd2c      	ble.n	80484fa <kad_op_conv1d+0x10b6>
		for (j = 0; j < d[1]; ++j)
 80484a0:	2700      	movs	r7, #0
 80484a2:	46bc      	mov	ip, r7
	for (k = 0; k < d[0]; ++k)
 80484a4:	46be      	mov	lr, r7
 80484a6:	9e05      	ldr	r6, [sp, #20]
 80484a8:	9b02      	ldr	r3, [sp, #8]
 80484aa:	ea4f 0886 	mov.w	r8, r6, lsl #2
 80484ae:	0098      	lsls	r0, r3, #2
		for (j = 0; j < d[1]; ++j)
 80484b0:	f04f 0a00 	mov.w	sl, #0
 80484b4:	9a02      	ldr	r2, [sp, #8]
 80484b6:	fb06 f307 	mul.w	r3, r6, r7
 80484ba:	fb02 f40c 	mul.w	r4, r2, ip
 80484be:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 80484c0:	18f5      	adds	r5, r6, r3
 80484c2:	eb02 0484 	add.w	r4, r2, r4, lsl #2
 80484c6:	9a0e      	ldr	r2, [sp, #56]	@ 0x38
 80484c8:	eb02 0185 	add.w	r1, r2, r5, lsl #2
			for (i = 0; i < d[2]; ++i)
 80484cc:	9a0e      	ldr	r2, [sp, #56]	@ 0x38
 80484ce:	eb02 0383 	add.w	r3, r2, r3, lsl #2
	for (k = 0; k < d[0]; ++k)
 80484d2:	4622      	mov	r2, r4
				y[(k * d[2] + i) * d[1] + j] = x[(k * d[1] + j) * d[2] + i];
 80484d4:	ecf3 7a01 	vldmia	r3!, {s15}
			for (i = 0; i < d[2]; ++i)
 80484d8:	4299      	cmp	r1, r3
				y[(k * d[2] + i) * d[1] + j] = x[(k * d[1] + j) * d[2] + i];
 80484da:	edc2 7a00 	vstr	s15, [r2]
			for (i = 0; i < d[2]; ++i)
 80484de:	4402      	add	r2, r0
 80484e0:	d1f8      	bne.n	80484d4 <kad_op_conv1d+0x1090>
		for (j = 0; j < d[1]; ++j)
 80484e2:	9a02      	ldr	r2, [sp, #8]
 80484e4:	f10a 0a01 	add.w	sl, sl, #1
 80484e8:	4592      	cmp	sl, r2
 80484ea:	462b      	mov	r3, r5
 80484ec:	f104 0404 	add.w	r4, r4, #4
 80484f0:	4441      	add	r1, r8
 80484f2:	f43f a9cb 	beq.w	804788c <kad_op_conv1d+0x448>
 80484f6:	4435      	add	r5, r6
 80484f8:	e7e8      	b.n	80484cc <kad_op_conv1d+0x1088>
			conv1d_loop2(q1, w1, p->x, (*_yy += kad_sdot(m, _ww, _xx)));
 80484fa:	f8db 3004 	ldr.w	r3, [fp, #4]
 80484fe:	9902      	ldr	r1, [sp, #8]
 8048500:	fb03 f209 	mul.w	r2, r3, r9
 8048504:	9b05      	ldr	r3, [sp, #20]
 8048506:	fb01 f303 	mul.w	r3, r1, r3
 804850a:	f7ff b9d2 	b.w	80478b2 <kad_op_conv1d+0x46e>
 804850e:	4619      	mov	r1, r3
 8048510:	f8db 3004 	ldr.w	r3, [fp, #4]
 8048514:	fb03 f209 	mul.w	r2, r3, r9
 8048518:	9b05      	ldr	r3, [sp, #20]
 804851a:	fb01 f303 	mul.w	r3, r1, r3
 804851e:	f7ff b9c8 	b.w	80478b2 <kad_op_conv1d+0x46e>
	for (k = 0; k < d[0]; ++k)
 8048522:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 8048524:	2b00      	cmp	r3, #0
 8048526:	f77f aa41 	ble.w	80479ac <kad_op_conv1d+0x568>
 804852a:	2900      	cmp	r1, #0
 804852c:	f77e af9f 	ble.w	804746e <kad_op_conv1d+0x2a>
 8048530:	9b05      	ldr	r3, [sp, #20]
 8048532:	2b00      	cmp	r3, #0
 8048534:	f77f aa3a 	ble.w	80479ac <kad_op_conv1d+0x568>
			conv1d_loop1(q->x, w->x, p->x, t, process_row_for);
 8048538:	9b04      	ldr	r3, [sp, #16]
 804853a:	f8d3 9014 	ldr.w	r9, [r3, #20]
 804853e:	e7af      	b.n	80484a0 <kad_op_conv1d+0x105c>

08048540 <kad_op_conv2d>:
{
 8048540:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	kad_node_t *q = p->child[0], *w = p->child[1];
 8048544:	6b83      	ldr	r3, [r0, #56]	@ 0x38
{
 8048546:	4682      	mov	sl, r0
	kad_node_t *q = p->child[0], *w = p->child[1];
 8048548:	e9d3 9600 	ldrd	r9, r6, [r3]
	if (action == KAD_FORWARD || action == KAD_BACKWARD) { /* allocate working space */
 804854c:	1e8b      	subs	r3, r1, #2
 804854e:	2b01      	cmp	r3, #1
{
 8048550:	460c      	mov	r4, r1
	conv_conf_t *aux = (conv_conf_t*)p->ptr;
 8048552:	f8d0 b030 	ldr.w	fp, [r0, #48]	@ 0x30
{
 8048556:	b0a3      	sub	sp, #140	@ 0x8c
	if (action == KAD_FORWARD || action == KAD_BACKWARD) { /* allocate working space */
 8048558:	d917      	bls.n	804858a <kad_op_conv2d+0x4a>
	if (action == KAD_SYNC_DIM) {
 804855a:	2904      	cmp	r1, #4
 804855c:	f000 80a2 	beq.w	80486a4 <kad_op_conv2d+0x164>
	float *t = 0, *q1 = 0, *w1 = 0, *x_padded = 0;
 8048560:	2300      	movs	r3, #0
 8048562:	9301      	str	r3, [sp, #4]
 8048564:	9309      	str	r3, [sp, #36]	@ 0x24
 8048566:	930c      	str	r3, [sp, #48]	@ 0x30
 8048568:	9310      	str	r3, [sp, #64]	@ 0x40
	free(t); free(q1); free(w1); free(x_padded);
 804856a:	9810      	ldr	r0, [sp, #64]	@ 0x40
 804856c:	f003 f97c 	bl	804b868 <free>
 8048570:	980c      	ldr	r0, [sp, #48]	@ 0x30
 8048572:	f003 f979 	bl	804b868 <free>
 8048576:	9809      	ldr	r0, [sp, #36]	@ 0x24
 8048578:	f003 f976 	bl	804b868 <free>
 804857c:	9801      	ldr	r0, [sp, #4]
 804857e:	f003 f973 	bl	804b868 <free>
	return 0;
 8048582:	2000      	movs	r0, #0
}
 8048584:	b023      	add	sp, #140	@ 0x8c
 8048586:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (w->d[3] * w->d[1] < 16) {
 804858a:	69f3      	ldr	r3, [r6, #28]
 804858c:	6972      	ldr	r2, [r6, #20]
 804858e:	9303      	str	r3, [sp, #12]
 8048590:	fb02 f303 	mul.w	r3, r2, r3
 8048594:	2b0f      	cmp	r3, #15
 8048596:	9208      	str	r2, [sp, #32]
 8048598:	9312      	str	r3, [sp, #72]	@ 0x48
 804859a:	f340 80bb 	ble.w	8048714 <kad_op_conv2d+0x1d4>
 804859e:	f899 2000 	ldrb.w	r2, [r9]
 80485a2:	2a00      	cmp	r2, #0
 80485a4:	f000 8410 	beq.w	8048dc8 <kad_op_conv2d+0x888>
 80485a8:	2a01      	cmp	r2, #1
 80485aa:	f8d9 0010 	ldr.w	r0, [r9, #16]
 80485ae:	d00e      	beq.n	80485ce <kad_op_conv2d+0x8e>
 80485b0:	f8d9 1014 	ldr.w	r1, [r9, #20]
 80485b4:	2a02      	cmp	r2, #2
 80485b6:	fb01 f000 	mul.w	r0, r1, r0
 80485ba:	d008      	beq.n	80485ce <kad_op_conv2d+0x8e>
 80485bc:	f8d9 1018 	ldr.w	r1, [r9, #24]
 80485c0:	2a03      	cmp	r2, #3
 80485c2:	fb01 f000 	mul.w	r0, r1, r0
 80485c6:	bf1c      	itt	ne
 80485c8:	f8d9 201c 	ldrne.w	r2, [r9, #28]
 80485cc:	4350      	mulne	r0, r2
			q1 = (float*)malloc(kad_len(q) * sizeof(float));
 80485ce:	0080      	lsls	r0, r0, #2
 80485d0:	f003 f942 	bl	804b858 <malloc>
 80485d4:	7832      	ldrb	r2, [r6, #0]
 80485d6:	900c      	str	r0, [sp, #48]	@ 0x30
 80485d8:	2a00      	cmp	r2, #0
 80485da:	f000 83f3 	beq.w	8048dc4 <kad_op_conv2d+0x884>
 80485de:	2a01      	cmp	r2, #1
 80485e0:	6930      	ldr	r0, [r6, #16]
 80485e2:	d00b      	beq.n	80485fc <kad_op_conv2d+0xbc>
 80485e4:	9b08      	ldr	r3, [sp, #32]
 80485e6:	2a02      	cmp	r2, #2
 80485e8:	fb03 f000 	mul.w	r0, r3, r0
 80485ec:	d006      	beq.n	80485fc <kad_op_conv2d+0xbc>
 80485ee:	69b1      	ldr	r1, [r6, #24]
 80485f0:	2a03      	cmp	r2, #3
 80485f2:	fb01 f000 	mul.w	r0, r1, r0
 80485f6:	bf1c      	itt	ne
 80485f8:	9b03      	ldrne	r3, [sp, #12]
 80485fa:	4358      	mulne	r0, r3
			w1 = (float*)malloc(kad_len(w) * sizeof(float));
 80485fc:	0080      	lsls	r0, r0, #2
 80485fe:	f003 f92b 	bl	804b858 <malloc>
			x_padded = aux[1].pad[0] + aux[1].pad[1] > 0? (float*)calloc((q->d[3] + aux[1].pad[0] + aux[1].pad[1]) * q->d[1], sizeof(float)) : 0;
 8048602:	e9db 3206 	ldrd	r3, r2, [fp, #24]
 8048606:	1899      	adds	r1, r3, r2
 8048608:	2900      	cmp	r1, #0
			w1 = (float*)malloc(kad_len(w) * sizeof(float));
 804860a:	9009      	str	r0, [sp, #36]	@ 0x24
			x_padded = aux[1].pad[0] + aux[1].pad[1] > 0? (float*)calloc((q->d[3] + aux[1].pad[0] + aux[1].pad[1]) * q->d[1], sizeof(float)) : 0;
 804860c:	f300 83ca 	bgt.w	8048da4 <kad_op_conv2d+0x864>
 8048610:	2300      	movs	r3, #0
	} else if (action == KAD_FORWARD) {
 8048612:	2c02      	cmp	r4, #2
			algo_switch = 1;
 8048614:	f04f 0701 	mov.w	r7, #1
			x_padded = aux[1].pad[0] + aux[1].pad[1] > 0? (float*)calloc((q->d[3] + aux[1].pad[0] + aux[1].pad[1]) * q->d[1], sizeof(float)) : 0;
 8048618:	9301      	str	r3, [sp, #4]
	float *t = 0, *q1 = 0, *w1 = 0, *x_padded = 0;
 804861a:	9310      	str	r3, [sp, #64]	@ 0x40
	} else if (action == KAD_FORWARD) {
 804861c:	f000 808c 	beq.w	8048738 <kad_op_conv2d+0x1f8>
		if (kad_is_back(p->child[0])) { /* backprop to the input array */
 8048620:	f899 3001 	ldrb.w	r3, [r9, #1]
 8048624:	07d9      	lsls	r1, r3, #31
 8048626:	f100 8379 	bmi.w	8048d1c <kad_op_conv2d+0x7dc>
		if (kad_is_back(p->child[1])) { /* backprop to the weight matrix */
 804862a:	7873      	ldrb	r3, [r6, #1]
 804862c:	07da      	lsls	r2, r3, #31
 804862e:	d59c      	bpl.n	804856a <kad_op_conv2d+0x2a>
			conv_rot180(w->d[0] * w->d[1], w->d[2] * w->d[3], w->g);
 8048630:	6933      	ldr	r3, [r6, #16]
 8048632:	9908      	ldr	r1, [sp, #32]
 8048634:	69b2      	ldr	r2, [r6, #24]
 8048636:	fb03 f501 	mul.w	r5, r3, r1
 804863a:	9307      	str	r3, [sp, #28]
 804863c:	9b03      	ldr	r3, [sp, #12]
	for (i = 0; i < d0; ++i) {
 804863e:	2d00      	cmp	r5, #0
			conv_rot180(w->d[0] * w->d[1], w->d[2] * w->d[3], w->g);
 8048640:	fb02 f003 	mul.w	r0, r2, r3
 8048644:	f8d6 802c 	ldr.w	r8, [r6, #44]	@ 0x2c
 8048648:	9205      	str	r2, [sp, #20]
 804864a:	901c      	str	r0, [sp, #112]	@ 0x70
	for (i = 0; i < d0; ++i) {
 804864c:	f340 86cf 	ble.w	80493ee <kad_op_conv2d+0xeae>
		for (j = 0; j < d1>>1; ++j)
 8048650:	1043      	asrs	r3, r0, #1
 8048652:	2b00      	cmp	r3, #0
 8048654:	f340 86d4 	ble.w	8049400 <kad_op_conv2d+0xec0>
 8048658:	4642      	mov	r2, r8
	for (i = 0; i < d0; ++i) {
 804865a:	2100      	movs	r1, #0
 804865c:	ea4f 0c80 	mov.w	ip, r0, lsl #2
 8048660:	ea4f 0e83 	mov.w	lr, r3, lsl #2
		for (j = 0; j < d1>>1; ++j)
 8048664:	4610      	mov	r0, r2
 8048666:	4462      	add	r2, ip
 8048668:	eb00 040e 	add.w	r4, r0, lr
 804866c:	9400      	str	r4, [sp, #0]
 804866e:	4614      	mov	r4, r2
 8048670:	9302      	str	r3, [sp, #8]
			tmp = xi[j], xi[j] = xi[d1-1-j], xi[d1-1-j] = tmp; 
 8048672:	ed34 7a01 	vldmdb	r4!, {s14}
 8048676:	edd0 7a00 	vldr	s15, [r0]
 804867a:	eca0 7a01 	vstmia	r0!, {s14}
		for (j = 0; j < d1>>1; ++j)
 804867e:	9b00      	ldr	r3, [sp, #0]
			tmp = xi[j], xi[j] = xi[d1-1-j], xi[d1-1-j] = tmp; 
 8048680:	edc4 7a00 	vstr	s15, [r4]
		for (j = 0; j < d1>>1; ++j)
 8048684:	4283      	cmp	r3, r0
 8048686:	d1f4      	bne.n	8048672 <kad_op_conv2d+0x132>
	for (i = 0; i < d0; ++i) {
 8048688:	3101      	adds	r1, #1
 804868a:	428d      	cmp	r5, r1
 804868c:	9b02      	ldr	r3, [sp, #8]
 804868e:	d1e9      	bne.n	8048664 <kad_op_conv2d+0x124>
				conv2d_loop1(q->g, w->x, p->g, t, process_row_back_x);
 8048690:	f8d9 2010 	ldr.w	r2, [r9, #16]
			if (!algo_switch) {
 8048694:	2f00      	cmp	r7, #0
 8048696:	f040 87fd 	bne.w	8049694 <kad_op_conv2d+0x1154>
				conv2d_loop1(q->x, w->g, p->g, t, process_row_back_w);
 804869a:	2a00      	cmp	r2, #0
 804869c:	f300 86b8 	bgt.w	8049410 <kad_op_conv2d+0xed0>
 80486a0:	f000 bfbb 	b.w	804961a <kad_op_conv2d+0x10da>
		if (q->n_d != 4 || w->n_d != 4) return -1;
 80486a4:	f899 3000 	ldrb.w	r3, [r9]
 80486a8:	2b04      	cmp	r3, #4
 80486aa:	f040 8391 	bne.w	8048dd0 <kad_op_conv2d+0x890>
 80486ae:	7833      	ldrb	r3, [r6, #0]
 80486b0:	2b04      	cmp	r3, #4
 80486b2:	f040 838d 	bne.w	8048dd0 <kad_op_conv2d+0x890>
		if (q->d[1] != w->d[1]) return -1; /* unmatched input channels */
 80486b6:	f8d9 1014 	ldr.w	r1, [r9, #20]
 80486ba:	6972      	ldr	r2, [r6, #20]
 80486bc:	4291      	cmp	r1, r2
 80486be:	f040 8387 	bne.w	8048dd0 <kad_op_conv2d+0x890>
		p->n_d = 4;
 80486c2:	7003      	strb	r3, [r0, #0]
		p->d[0] = q->d[0], p->d[1] = w->d[0], p->d[2] = conv_out_size(q->d[2], &aux[0]), p->d[3] = conv_out_size(q->d[3], &aux[1]);
 80486c4:	f8d9 3010 	ldr.w	r3, [r9, #16]
 80486c8:	6103      	str	r3, [r0, #16]
 80486ca:	6931      	ldr	r1, [r6, #16]
 80486cc:	e9d9 2306 	ldrd	r2, r3, [r9, #24]
 80486d0:	6141      	str	r1, [r0, #20]
 80486d2:	f8db 1000 	ldr.w	r1, [fp]
 80486d6:	f8db 001c 	ldr.w	r0, [fp, #28]
 80486da:	1a52      	subs	r2, r2, r1
 80486dc:	f8db 1008 	ldr.w	r1, [fp, #8]
 80486e0:	440a      	add	r2, r1
 80486e2:	f8db 100c 	ldr.w	r1, [fp, #12]
 80486e6:	440a      	add	r2, r1
 80486e8:	f8db 1004 	ldr.w	r1, [fp, #4]
 80486ec:	fb92 f2f1 	sdiv	r2, r2, r1
 80486f0:	f8db 1010 	ldr.w	r1, [fp, #16]
 80486f4:	3201      	adds	r2, #1
 80486f6:	1a5b      	subs	r3, r3, r1
 80486f8:	f8db 1018 	ldr.w	r1, [fp, #24]
 80486fc:	440b      	add	r3, r1
 80486fe:	f8db 1014 	ldr.w	r1, [fp, #20]
 8048702:	4403      	add	r3, r0
 8048704:	fb93 f3f1 	sdiv	r3, r3, r1
 8048708:	3301      	adds	r3, #1
 804870a:	f8ca 2018 	str.w	r2, [sl, #24]
 804870e:	f8ca 301c 	str.w	r3, [sl, #28]
 8048712:	e725      	b.n	8048560 <kad_op_conv2d+0x20>
			t = (float*)malloc(p->d[3] * sizeof(float));
 8048714:	69c0      	ldr	r0, [r0, #28]
 8048716:	0080      	lsls	r0, r0, #2
 8048718:	f003 f89e 	bl	804b858 <malloc>
			x_padded = aux[1].pad[0] + aux[1].pad[1] > 0? (float*)calloc(q->d[3] + aux[1].pad[0] + aux[1].pad[1], sizeof(float)) : 0;
 804871c:	e9db 3206 	ldrd	r3, r2, [fp, #24]
 8048720:	1899      	adds	r1, r3, r2
 8048722:	2900      	cmp	r1, #0
			t = (float*)malloc(p->d[3] * sizeof(float));
 8048724:	9010      	str	r0, [sp, #64]	@ 0x40
			x_padded = aux[1].pad[0] + aux[1].pad[1] > 0? (float*)calloc(q->d[3] + aux[1].pad[0] + aux[1].pad[1], sizeof(float)) : 0;
 8048726:	f300 82ed 	bgt.w	8048d04 <kad_op_conv2d+0x7c4>
	int algo_switch = 0;
 804872a:	2700      	movs	r7, #0
			x_padded = aux[1].pad[0] + aux[1].pad[1] > 0? (float*)calloc(q->d[3] + aux[1].pad[0] + aux[1].pad[1], sizeof(float)) : 0;
 804872c:	9701      	str	r7, [sp, #4]
	float *t = 0, *q1 = 0, *w1 = 0, *x_padded = 0;
 804872e:	9709      	str	r7, [sp, #36]	@ 0x24
 8048730:	970c      	str	r7, [sp, #48]	@ 0x30
	} else if (action == KAD_FORWARD) {
 8048732:	2c02      	cmp	r4, #2
 8048734:	f47f af74 	bne.w	8048620 <kad_op_conv2d+0xe0>
		conv_rot180(w->d[0] * w->d[1], w->d[2] * w->d[3], w->x);
 8048738:	6931      	ldr	r1, [r6, #16]
 804873a:	9b08      	ldr	r3, [sp, #32]
 804873c:	9a03      	ldr	r2, [sp, #12]
 804873e:	fb01 f303 	mul.w	r3, r1, r3
 8048742:	4619      	mov	r1, r3
 8048744:	69b3      	ldr	r3, [r6, #24]
	for (i = 0; i < d0; ++i) {
 8048746:	2900      	cmp	r1, #0
		conv_rot180(w->d[0] * w->d[1], w->d[2] * w->d[3], w->x);
 8048748:	fb03 f202 	mul.w	r2, r3, r2
 804874c:	4613      	mov	r3, r2
	for (i = 0; i < d0; ++i) {
 804874e:	dd1a      	ble.n	8048786 <kad_op_conv2d+0x246>
		for (j = 0; j < d1>>1; ++j)
 8048750:	1052      	asrs	r2, r2, #1
 8048752:	2a00      	cmp	r2, #0
 8048754:	dd17      	ble.n	8048786 <kad_op_conv2d+0x246>
	for (i = 0; i < d0; ++i) {
 8048756:	2000      	movs	r0, #0
 8048758:	ea4f 0e82 	mov.w	lr, r2, lsl #2
 804875c:	6ab2      	ldr	r2, [r6, #40]	@ 0x28
 804875e:	ea4f 0c83 	mov.w	ip, r3, lsl #2
		for (j = 0; j < d1>>1; ++j)
 8048762:	4613      	mov	r3, r2
 8048764:	4462      	add	r2, ip
	for (i = 0; i < d0; ++i) {
 8048766:	4614      	mov	r4, r2
 8048768:	eb03 050e 	add.w	r5, r3, lr
			tmp = xi[j], xi[j] = xi[d1-1-j], xi[d1-1-j] = tmp; 
 804876c:	ed74 7a01 	vldmdb	r4!, {s15}
 8048770:	f8d3 8000 	ldr.w	r8, [r3]
 8048774:	ece3 7a01 	vstmia	r3!, {s15}
		for (j = 0; j < d1>>1; ++j)
 8048778:	429d      	cmp	r5, r3
			tmp = xi[j], xi[j] = xi[d1-1-j], xi[d1-1-j] = tmp; 
 804877a:	f8c4 8000 	str.w	r8, [r4]
		for (j = 0; j < d1>>1; ++j)
 804877e:	d1f5      	bne.n	804876c <kad_op_conv2d+0x22c>
	for (i = 0; i < d0; ++i) {
 8048780:	3001      	adds	r0, #1
 8048782:	4281      	cmp	r1, r0
 8048784:	d1ed      	bne.n	8048762 <kad_op_conv2d+0x222>
 8048786:	f89a 1000 	ldrb.w	r1, [sl]
		memset(p->x, 0, kad_len(p) * sizeof(float));
 804878a:	f8da 0028 	ldr.w	r0, [sl, #40]	@ 0x28
 804878e:	2900      	cmp	r1, #0
 8048790:	f000 831c 	beq.w	8048dcc <kad_op_conv2d+0x88c>
 8048794:	2901      	cmp	r1, #1
 8048796:	f8da 2010 	ldr.w	r2, [sl, #16]
 804879a:	d00e      	beq.n	80487ba <kad_op_conv2d+0x27a>
 804879c:	f8da 3014 	ldr.w	r3, [sl, #20]
 80487a0:	2902      	cmp	r1, #2
 80487a2:	fb03 f202 	mul.w	r2, r3, r2
 80487a6:	d008      	beq.n	80487ba <kad_op_conv2d+0x27a>
 80487a8:	f8da 3018 	ldr.w	r3, [sl, #24]
 80487ac:	2903      	cmp	r1, #3
 80487ae:	fb03 f202 	mul.w	r2, r3, r2
 80487b2:	bf1c      	itt	ne
 80487b4:	f8da 301c 	ldrne.w	r3, [sl, #28]
 80487b8:	435a      	mulne	r2, r3
 80487ba:	0092      	lsls	r2, r2, #2
 80487bc:	2100      	movs	r1, #0
 80487be:	f003 fb39 	bl	804be34 <memset>
			conv2d_loop1(q->x, w->x, p->x, t, process_row_for);
 80487c2:	f8d9 8010 	ldr.w	r8, [r9, #16]
		if (!algo_switch) { /* this is the first algorithm */
 80487c6:	2f00      	cmp	r7, #0
 80487c8:	f041 810e 	bne.w	80499e8 <kad_op_conv2d+0x14a8>
			conv2d_loop1(q->x, w->x, p->x, t, process_row_for);
 80487cc:	6ab3      	ldr	r3, [r6, #40]	@ 0x28
 80487ce:	f1b8 0f00 	cmp.w	r8, #0
 80487d2:	930b      	str	r3, [sp, #44]	@ 0x2c
 80487d4:	69f3      	ldr	r3, [r6, #28]
 80487d6:	6931      	ldr	r1, [r6, #16]
 80487d8:	9304      	str	r3, [sp, #16]
 80487da:	e9d6 3e05 	ldrd	r3, lr, [r6, #20]
 80487de:	930a      	str	r3, [sp, #40]	@ 0x28
 80487e0:	f340 8286 	ble.w	8048cf0 <kad_op_conv2d+0x7b0>
 80487e4:	2900      	cmp	r1, #0
 80487e6:	f340 8283 	ble.w	8048cf0 <kad_op_conv2d+0x7b0>
 80487ea:	2b00      	cmp	r3, #0
 80487ec:	f77f aebd 	ble.w	804856a <kad_op_conv2d+0x2a>
 80487f0:	f1be 0f00 	cmp.w	lr, #0
 80487f4:	f341 80f1 	ble.w	80499da <kad_op_conv2d+0x149a>
 80487f8:	9a04      	ldr	r2, [sp, #16]
 80487fa:	9707      	str	r7, [sp, #28]
 80487fc:	fb02 f40e 	mul.w	r4, r2, lr
 8048800:	00a6      	lsls	r6, r4, #2
 8048802:	4637      	mov	r7, r6
 8048804:	f8cd a04c 	str.w	sl, [sp, #76]	@ 0x4c
 8048808:	460d      	mov	r5, r1
 804880a:	4676      	mov	r6, lr
 804880c:	46a2      	mov	sl, r4
 804880e:	ebc2 7342 	rsb	r3, r2, r2, lsl #29
 8048812:	00db      	lsls	r3, r3, #3
 8048814:	9311      	str	r3, [sp, #68]	@ 0x44
 8048816:	4643      	mov	r3, r8
 8048818:	46c8      	mov	r8, r9
 804881a:	f8dd 9040 	ldr.w	r9, [sp, #64]	@ 0x40
 804881e:	0092      	lsls	r2, r2, #2
 8048820:	2100      	movs	r1, #0
 8048822:	462c      	mov	r4, r5
 8048824:	460d      	mov	r5, r1
 8048826:	4638      	mov	r0, r7
 8048828:	9f13      	ldr	r7, [sp, #76]	@ 0x4c
 804882a:	9106      	str	r1, [sp, #24]
 804882c:	9314      	str	r3, [sp, #80]	@ 0x50
 804882e:	fb06 f305 	mul.w	r3, r6, r5
 8048832:	990b      	ldr	r1, [sp, #44]	@ 0x2c
 8048834:	9612      	str	r6, [sp, #72]	@ 0x48
 8048836:	fb02 1303 	mla	r3, r2, r3, r1
 804883a:	2100      	movs	r1, #0
 804883c:	4413      	add	r3, r2
 804883e:	f8cd a05c 	str.w	sl, [sp, #92]	@ 0x5c
 8048842:	4686      	mov	lr, r0
 8048844:	461e      	mov	r6, r3
 8048846:	4692      	mov	sl, r2
 8048848:	9105      	str	r1, [sp, #20]
 804884a:	9515      	str	r5, [sp, #84]	@ 0x54
 804884c:	9416      	str	r4, [sp, #88]	@ 0x58
 804884e:	69bb      	ldr	r3, [r7, #24]
 8048850:	461a      	mov	r2, r3
 8048852:	2a00      	cmp	r2, #0
 8048854:	9303      	str	r3, [sp, #12]
 8048856:	f8db 3008 	ldr.w	r3, [fp, #8]
 804885a:	f340 8090 	ble.w	804897e <kad_op_conv2d+0x43e>
 804885e:	4635      	mov	r5, r6
 8048860:	9a12      	ldr	r2, [sp, #72]	@ 0x48
 8048862:	e9cd e618 	strd	lr, r6, [sp, #96]	@ 0x60
 8048866:	425c      	negs	r4, r3
 8048868:	1ad3      	subs	r3, r2, r3
 804886a:	930f      	str	r3, [sp, #60]	@ 0x3c
 804886c:	eba5 030a 	sub.w	r3, r5, sl
 8048870:	2c00      	cmp	r4, #0
 8048872:	4626      	mov	r6, r4
 8048874:	9308      	str	r3, [sp, #32]
 8048876:	db78      	blt.n	804896a <kad_op_conv2d+0x42a>
 8048878:	2300      	movs	r3, #0
 804887a:	e9cd 4a0d 	strd	r4, sl, [sp, #52]	@ 0x34
 804887e:	9300      	str	r3, [sp, #0]
 8048880:	f8d8 3018 	ldr.w	r3, [r8, #24]
 8048884:	9302      	str	r3, [sp, #8]
 8048886:	9b02      	ldr	r3, [sp, #8]
 8048888:	429e      	cmp	r6, r3
 804888a:	da6c      	bge.n	8048966 <kad_op_conv2d+0x426>
 804888c:	9a07      	ldr	r2, [sp, #28]
 804888e:	f8d8 3014 	ldr.w	r3, [r8, #20]
 8048892:	9905      	ldr	r1, [sp, #20]
 8048894:	9806      	ldr	r0, [sp, #24]
 8048896:	fb03 1102 	mla	r1, r3, r2, r1
 804889a:	9b02      	ldr	r3, [sp, #8]
 804889c:	f8d7 a01c 	ldr.w	sl, [r7, #28]
 80488a0:	fb03 6101 	mla	r1, r3, r1, r6
 80488a4:	697b      	ldr	r3, [r7, #20]
 80488a6:	6abc      	ldr	r4, [r7, #40]	@ 0x28
 80488a8:	fb03 0002 	mla	r0, r3, r2, r0
 80488ac:	9b00      	ldr	r3, [sp, #0]
 80488ae:	9a03      	ldr	r2, [sp, #12]
 80488b0:	fb02 3000 	mla	r0, r2, r0, r3
 80488b4:	f8d8 201c 	ldr.w	r2, [r8, #28]
 80488b8:	fb0a f000 	mul.w	r0, sl, r0
 80488bc:	fb02 f101 	mul.w	r1, r2, r1
 80488c0:	f8d8 3028 	ldr.w	r3, [r8, #40]	@ 0x28
 80488c4:	eb04 0480 	add.w	r4, r4, r0, lsl #2
 80488c8:	9801      	ldr	r0, [sp, #4]
 80488ca:	eb03 0181 	add.w	r1, r3, r1, lsl #2
 80488ce:	b140      	cbz	r0, 80488e2 <kad_op_conv2d+0x3a2>
 80488d0:	f8db 3018 	ldr.w	r3, [fp, #24]
 80488d4:	0092      	lsls	r2, r2, #2
 80488d6:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 80488da:	4618      	mov	r0, r3
 80488dc:	f003 fba7 	bl	804c02e <memcpy>
 80488e0:	4601      	mov	r1, r0
 80488e2:	f8db 2014 	ldr.w	r2, [fp, #20]
 80488e6:	9b04      	ldr	r3, [sp, #16]
 80488e8:	2a01      	cmp	r2, #1
 80488ea:	f340 808e 	ble.w	8048a0a <kad_op_conv2d+0x4ca>
 80488ee:	2b00      	cmp	r3, #0
 80488f0:	dd2c      	ble.n	804894c <kad_op_conv2d+0x40c>
 80488f2:	f8db 3018 	ldr.w	r3, [fp, #24]
 80488f6:	f8dd e020 	ldr.w	lr, [sp, #32]
 80488fa:	ebc3 7383 	rsb	r3, r3, r3, lsl #30
 80488fe:	eb01 0c83 	add.w	ip, r1, r3, lsl #2
 8048902:	0092      	lsls	r2, r2, #2
 8048904:	eb09 018a 	add.w	r1, r9, sl, lsl #2
 8048908:	eb04 008a 	add.w	r0, r4, sl, lsl #2
 804890c:	f1ba 0f00 	cmp.w	sl, #0
 8048910:	dd74      	ble.n	80489fc <kad_op_conv2d+0x4bc>
 8048912:	4663      	mov	r3, ip
 8048914:	46ca      	mov	sl, r9
 8048916:	edd3 7a00 	vldr	s15, [r3]
 804891a:	ecea 7a01 	vstmia	sl!, {s15}
 804891e:	4551      	cmp	r1, sl
 8048920:	4413      	add	r3, r2
 8048922:	d1f8      	bne.n	8048916 <kad_op_conv2d+0x3d6>
 8048924:	edde 6a00 	vldr	s13, [lr]
 8048928:	46ca      	mov	sl, r9
 804892a:	4623      	mov	r3, r4
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 804892c:	edd3 7a00 	vldr	s15, [r3]
 8048930:	ecba 7a01 	vldmia	sl!, {s14}
 8048934:	eee6 7a87 	vfma.f32	s15, s13, s14
 8048938:	ece3 7a01 	vstmia	r3!, {s15}
 804893c:	4283      	cmp	r3, r0
 804893e:	d1f5      	bne.n	804892c <kad_op_conv2d+0x3ec>
			conv2d_loop1(q->x, w->x, p->x, t, process_row_for);
 8048940:	f10e 0e04 	add.w	lr, lr, #4
 8048944:	4575      	cmp	r5, lr
 8048946:	f10c 0c04 	add.w	ip, ip, #4
 804894a:	d1e2      	bne.n	8048912 <kad_op_conv2d+0x3d2>
 804894c:	9b00      	ldr	r3, [sp, #0]
 804894e:	3301      	adds	r3, #1
 8048950:	461a      	mov	r2, r3
 8048952:	9300      	str	r3, [sp, #0]
 8048954:	f8db 3004 	ldr.w	r3, [fp, #4]
 8048958:	441e      	add	r6, r3
 804895a:	4613      	mov	r3, r2
 804895c:	9a03      	ldr	r2, [sp, #12]
 804895e:	4293      	cmp	r3, r2
 8048960:	d001      	beq.n	8048966 <kad_op_conv2d+0x426>
 8048962:	2e00      	cmp	r6, #0
 8048964:	da8f      	bge.n	8048886 <kad_op_conv2d+0x346>
 8048966:	e9dd 4a0d 	ldrd	r4, sl, [sp, #52]	@ 0x34
 804896a:	9b08      	ldr	r3, [sp, #32]
 804896c:	9a11      	ldr	r2, [sp, #68]	@ 0x44
 804896e:	3401      	adds	r4, #1
 8048970:	1a9d      	subs	r5, r3, r2
 8048972:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
 8048974:	429c      	cmp	r4, r3
 8048976:	f47f af79 	bne.w	804886c <kad_op_conv2d+0x32c>
 804897a:	e9dd e618 	ldrd	lr, r6, [sp, #96]	@ 0x60
 804897e:	9b05      	ldr	r3, [sp, #20]
 8048980:	9a0a      	ldr	r2, [sp, #40]	@ 0x28
 8048982:	3301      	adds	r3, #1
 8048984:	4293      	cmp	r3, r2
 8048986:	9305      	str	r3, [sp, #20]
 8048988:	4476      	add	r6, lr
 804898a:	f47f af60 	bne.w	804884e <kad_op_conv2d+0x30e>
 804898e:	4619      	mov	r1, r3
 8048990:	9b06      	ldr	r3, [sp, #24]
 8048992:	9c16      	ldr	r4, [sp, #88]	@ 0x58
 8048994:	3301      	adds	r3, #1
 8048996:	9d15      	ldr	r5, [sp, #84]	@ 0x54
 8048998:	42a3      	cmp	r3, r4
 804899a:	4652      	mov	r2, sl
 804899c:	4670      	mov	r0, lr
 804899e:	9e12      	ldr	r6, [sp, #72]	@ 0x48
 80489a0:	f8dd a05c 	ldr.w	sl, [sp, #92]	@ 0x5c
 80489a4:	9306      	str	r3, [sp, #24]
 80489a6:	440d      	add	r5, r1
 80489a8:	f47f af41 	bne.w	804882e <kad_op_conv2d+0x2ee>
 80489ac:	9907      	ldr	r1, [sp, #28]
 80489ae:	9b14      	ldr	r3, [sp, #80]	@ 0x50
 80489b0:	3101      	adds	r1, #1
 80489b2:	428b      	cmp	r3, r1
 80489b4:	4677      	mov	r7, lr
 80489b6:	4625      	mov	r5, r4
 80489b8:	9107      	str	r1, [sp, #28]
 80489ba:	f47f af31 	bne.w	8048820 <kad_op_conv2d+0x2e0>
		conv_rot180(w->d[0] * w->d[1], w->d[2] * w->d[3], w->x);
 80489be:	e9dd 3105 	ldrd	r3, r1, [sp, #20]
 80489c2:	4654      	mov	r4, sl
 80489c4:	fb03 f101 	mul.w	r1, r3, r1
		for (j = 0; j < d1>>1; ++j)
 80489c8:	1063      	asrs	r3, r4, #1
 80489ca:	2b00      	cmp	r3, #0
 80489cc:	f77f adcd 	ble.w	804856a <kad_op_conv2d+0x2a>
	for (i = 0; i < d0; ++i) {
 80489d0:	2500      	movs	r5, #0
 80489d2:	980b      	ldr	r0, [sp, #44]	@ 0x2c
 80489d4:	00a4      	lsls	r4, r4, #2
 80489d6:	009a      	lsls	r2, r3, #2
		for (j = 0; j < d1>>1; ++j)
 80489d8:	4603      	mov	r3, r0
 80489da:	4420      	add	r0, r4
	for (i = 0; i < d0; ++i) {
 80489dc:	4606      	mov	r6, r0
 80489de:	18d7      	adds	r7, r2, r3
			tmp = xi[j], xi[j] = xi[d1-1-j], xi[d1-1-j] = tmp; 
 80489e0:	f856 ed04 	ldr.w	lr, [r6, #-4]!
 80489e4:	f8d3 c000 	ldr.w	ip, [r3]
 80489e8:	f843 eb04 	str.w	lr, [r3], #4
		for (j = 0; j < d1>>1; ++j)
 80489ec:	42bb      	cmp	r3, r7
			tmp = xi[j], xi[j] = xi[d1-1-j], xi[d1-1-j] = tmp; 
 80489ee:	f8c6 c000 	str.w	ip, [r6]
		for (j = 0; j < d1>>1; ++j)
 80489f2:	d1f5      	bne.n	80489e0 <kad_op_conv2d+0x4a0>
	for (i = 0; i < d0; ++i) {
 80489f4:	3501      	adds	r5, #1
 80489f6:	428d      	cmp	r5, r1
 80489f8:	d1ee      	bne.n	80489d8 <kad_op_conv2d+0x498>
 80489fa:	e5b6      	b.n	804856a <kad_op_conv2d+0x2a>
			conv2d_loop1(q->x, w->x, p->x, t, process_row_for);
 80489fc:	f10e 0e04 	add.w	lr, lr, #4
 8048a00:	45ae      	cmp	lr, r5
 8048a02:	f10c 0c04 	add.w	ip, ip, #4
 8048a06:	d181      	bne.n	804890c <kad_op_conv2d+0x3cc>
 8048a08:	e7a0      	b.n	804894c <kad_op_conv2d+0x40c>
 8048a0a:	2b00      	cmp	r3, #0
 8048a0c:	dd9e      	ble.n	804894c <kad_op_conv2d+0x40c>
 8048a0e:	f1ba 0f00 	cmp.w	sl, #0
 8048a12:	f8db 3018 	ldr.w	r3, [fp, #24]
 8048a16:	dd99      	ble.n	804894c <kad_op_conv2d+0x40c>
 8048a18:	ebc3 7383 	rsb	r3, r3, r3, lsl #30
 8048a1c:	f8dd c020 	ldr.w	ip, [sp, #32]
 8048a20:	009b      	lsls	r3, r3, #2
 8048a22:	eb04 0a8a 	add.w	sl, r4, sl, lsl #2
 8048a26:	ecfc 6a01 	vldmia	ip!, {s13}
 8048a2a:	4622      	mov	r2, r4
 8048a2c:	18c8      	adds	r0, r1, r3
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 8048a2e:	edd2 7a00 	vldr	s15, [r2]
 8048a32:	ecb0 7a01 	vldmia	r0!, {s14}
 8048a36:	eee6 7a87 	vfma.f32	s15, s13, s14
 8048a3a:	ece2 7a01 	vstmia	r2!, {s15}
 8048a3e:	4552      	cmp	r2, sl
 8048a40:	d1f5      	bne.n	8048a2e <kad_op_conv2d+0x4ee>
			conv2d_loop1(q->x, w->x, p->x, t, process_row_for);
 8048a42:	4565      	cmp	r5, ip
 8048a44:	f103 0304 	add.w	r3, r3, #4
 8048a48:	d1ed      	bne.n	8048a26 <kad_op_conv2d+0x4e6>
 8048a4a:	e77f      	b.n	804894c <kad_op_conv2d+0x40c>
		for (j = 0; j < d[1]; ++j)
 8048a4c:	3201      	adds	r2, #1
 8048a4e:	4562      	cmp	r2, ip
 8048a50:	4438      	add	r0, r7
 8048a52:	f040 87fc 	bne.w	8049a4e <kad_op_conv2d+0x150e>
	for (i = 0; i < d[0]; ++i)
 8048a56:	3601      	adds	r6, #1
 8048a58:	4546      	cmp	r6, r8
 8048a5a:	4465      	add	r5, ip
 8048a5c:	f040 87e2 	bne.w	8049a24 <kad_op_conv2d+0x14e4>
 8048a60:	464b      	mov	r3, r9
 8048a62:	2c00      	cmp	r4, #0
 8048a64:	46f1      	mov	r9, lr
 8048a66:	4621      	mov	r1, r4
 8048a68:	469e      	mov	lr, r3
 8048a6a:	f340 8141 	ble.w	8048cf0 <kad_op_conv2d+0x7b0>
 8048a6e:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 8048a70:	2b00      	cmp	r3, #0
 8048a72:	f341 8025 	ble.w	8049ac0 <kad_op_conv2d+0x1580>
 8048a76:	f1be 0f00 	cmp.w	lr, #0
 8048a7a:	f341 8021 	ble.w	8049ac0 <kad_op_conv2d+0x1580>
 8048a7e:	9b04      	ldr	r3, [sp, #16]
 8048a80:	2b00      	cmp	r3, #0
 8048a82:	f341 8018 	ble.w	8049ab6 <kad_op_conv2d+0x1576>
 8048a86:	461a      	mov	r2, r3
		for (j = 0; j < d[1]; ++j)
 8048a88:	2400      	movs	r4, #0
 8048a8a:	9d0a      	ldr	r5, [sp, #40]	@ 0x28
 8048a8c:	0096      	lsls	r6, r2, #2
 8048a8e:	fb05 f303 	mul.w	r3, r5, r3
 8048a92:	9600      	str	r6, [sp, #0]
 8048a94:	9e0b      	ldr	r6, [sp, #44]	@ 0x2c
 8048a96:	fb0e f002 	mul.w	r0, lr, r2
 8048a9a:	eb06 0782 	add.w	r7, r6, r2, lsl #2
 8048a9e:	009a      	lsls	r2, r3, #2
 8048aa0:	e9cd c807 	strd	ip, r8, [sp, #28]
 8048aa4:	9202      	str	r2, [sp, #8]
	for (i = 0; i < d[0]; ++i)
 8048aa6:	4626      	mov	r6, r4
 8048aa8:	00aa      	lsls	r2, r5, #2
 8048aaa:	46d0      	mov	r8, sl
		for (j = 0; j < d[1]; ++j)
 8048aac:	4625      	mov	r5, r4
 8048aae:	469c      	mov	ip, r3
 8048ab0:	e9cd b905 	strd	fp, r9, [sp, #20]
 8048ab4:	9203      	str	r2, [sp, #12]
 8048ab6:	f04f 0a00 	mov.w	sl, #0
 8048aba:	4689      	mov	r9, r1
 8048abc:	9a04      	ldr	r2, [sp, #16]
 8048abe:	e9cd 640d 	strd	r6, r4, [sp, #52]	@ 0x34
 8048ac2:	fb02 f305 	mul.w	r3, r2, r5
 8048ac6:	9a0a      	ldr	r2, [sp, #40]	@ 0x28
 8048ac8:	950f      	str	r5, [sp, #60]	@ 0x3c
 8048aca:	fb02 f303 	mul.w	r3, r2, r3
 8048ace:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 8048ad0:	eb02 0b83 	add.w	fp, r2, r3, lsl #2
 8048ad4:	fb0e f304 	mul.w	r3, lr, r4
 8048ad8:	9a04      	ldr	r2, [sp, #16]
 8048ada:	fb02 f303 	mul.w	r3, r2, r3
	for (i = 0; i < d[0]; ++i)
 8048ade:	461d      	mov	r5, r3
 8048ae0:	465c      	mov	r4, fp
			for (k = 0; k < d[2]; ++k) {
 8048ae2:	2100      	movs	r1, #0
 8048ae4:	eb07 0283 	add.w	r2, r7, r3, lsl #2
 8048ae8:	f8cd a044 	str.w	sl, [sp, #68]	@ 0x44
 8048aec:	46a2      	mov	sl, r4
 8048aee:	9e0b      	ldr	r6, [sp, #44]	@ 0x2c
 8048af0:	9312      	str	r3, [sp, #72]	@ 0x48
 8048af2:	eb06 0685 	add.w	r6, r6, r5, lsl #2
					y[(ik + l) * d[1] + j] = x[ijk + l];
 8048af6:	ecf6 7a01 	vldmia	r6!, {s15}
				for (l = 0; l < d[3]; ++l)
 8048afa:	9b03      	ldr	r3, [sp, #12]
 8048afc:	42b2      	cmp	r2, r6
					y[(ik + l) * d[1] + j] = x[ijk + l];
 8048afe:	edca 7a00 	vstr	s15, [sl]
				for (l = 0; l < d[3]; ++l)
 8048b02:	449a      	add	sl, r3
 8048b04:	d1f7      	bne.n	8048af6 <kad_op_conv2d+0x5b6>
			for (k = 0; k < d[2]; ++k) {
 8048b06:	9e02      	ldr	r6, [sp, #8]
 8048b08:	3101      	adds	r1, #1
 8048b0a:	4434      	add	r4, r6
 8048b0c:	9e04      	ldr	r6, [sp, #16]
 8048b0e:	4571      	cmp	r1, lr
 8048b10:	4435      	add	r5, r6
 8048b12:	9e00      	ldr	r6, [sp, #0]
 8048b14:	9b12      	ldr	r3, [sp, #72]	@ 0x48
 8048b16:	4432      	add	r2, r6
 8048b18:	d1e8      	bne.n	8048aec <kad_op_conv2d+0x5ac>
		for (j = 0; j < d[1]; ++j)
 8048b1a:	f8dd a044 	ldr.w	sl, [sp, #68]	@ 0x44
 8048b1e:	9a0a      	ldr	r2, [sp, #40]	@ 0x28
 8048b20:	f10a 0a01 	add.w	sl, sl, #1
 8048b24:	4592      	cmp	sl, r2
 8048b26:	f10b 0b04 	add.w	fp, fp, #4
 8048b2a:	4403      	add	r3, r0
 8048b2c:	d1d7      	bne.n	8048ade <kad_op_conv2d+0x59e>
	for (i = 0; i < d[0]; ++i)
 8048b2e:	e9dd 640d 	ldrd	r6, r4, [sp, #52]	@ 0x34
 8048b32:	9d0f      	ldr	r5, [sp, #60]	@ 0x3c
 8048b34:	3601      	adds	r6, #1
 8048b36:	454e      	cmp	r6, r9
 8048b38:	4649      	mov	r1, r9
 8048b3a:	4475      	add	r5, lr
 8048b3c:	4414      	add	r4, r2
 8048b3e:	dbba      	blt.n	8048ab6 <kad_op_conv2d+0x576>
 8048b40:	e9dd b905 	ldrd	fp, r9, [sp, #20]
 8048b44:	46c2      	mov	sl, r8
 8048b46:	4663      	mov	r3, ip
 8048b48:	f8dd 8020 	ldr.w	r8, [sp, #32]
 8048b4c:	f8dd c01c 	ldr.w	ip, [sp, #28]
			conv2d_loop2(q1, w1, p->x, (*_yy += kad_sdot(m, _ww, _xx)));
 8048b50:	461f      	mov	r7, r3
 8048b52:	f8db 3014 	ldr.w	r3, [fp, #20]
 8048b56:	f1b8 0f00 	cmp.w	r8, #0
 8048b5a:	fb03 f30c 	mul.w	r3, r3, ip
 8048b5e:	f340 80c7 	ble.w	8048cf0 <kad_op_conv2d+0x7b0>
 8048b62:	009b      	lsls	r3, r3, #2
 8048b64:	2900      	cmp	r1, #0
 8048b66:	9312      	str	r3, [sp, #72]	@ 0x48
 8048b68:	f340 80c2 	ble.w	8048cf0 <kad_op_conv2d+0x7b0>
 8048b6c:	f1be 0f00 	cmp.w	lr, #0
 8048b70:	f340 80be 	ble.w	8048cf0 <kad_op_conv2d+0x7b0>
 8048b74:	fb07 f30e 	mul.w	r3, r7, lr
 8048b78:	009a      	lsls	r2, r3, #2
 8048b7a:	2300      	movs	r3, #0
 8048b7c:	9300      	str	r3, [sp, #0]
 8048b7e:	460b      	mov	r3, r1
 8048b80:	00b8      	lsls	r0, r7, #2
 8048b82:	4601      	mov	r1, r0
 8048b84:	f8cd b008 	str.w	fp, [sp, #8]
 8048b88:	f8cd 9034 	str.w	r9, [sp, #52]	@ 0x34
 8048b8c:	46bb      	mov	fp, r7
 8048b8e:	4644      	mov	r4, r8
 8048b90:	46f1      	mov	r9, lr
 8048b92:	4618      	mov	r0, r3
 8048b94:	f8cd c038 	str.w	ip, [sp, #56]	@ 0x38
 8048b98:	f8cd a00c 	str.w	sl, [sp, #12]
 8048b9c:	f04f 0e00 	mov.w	lr, #0
 8048ba0:	460d      	mov	r5, r1
 8048ba2:	4682      	mov	sl, r0
 8048ba4:	f8dd 8024 	ldr.w	r8, [sp, #36]	@ 0x24
 8048ba8:	9f12      	ldr	r7, [sp, #72]	@ 0x48
 8048baa:	9414      	str	r4, [sp, #80]	@ 0x50
			conv2d_loop1(q->x, w->x, p->x, t, process_row_for);
 8048bac:	9b03      	ldr	r3, [sp, #12]
 8048bae:	9902      	ldr	r1, [sp, #8]
 8048bb0:	699b      	ldr	r3, [r3, #24]
 8048bb2:	6888      	ldr	r0, [r1, #8]
 8048bb4:	2b00      	cmp	r3, #0
 8048bb6:	9308      	str	r3, [sp, #32]
 8048bb8:	f340 8087 	ble.w	8048cca <kad_op_conv2d+0x78a>
 8048bbc:	4643      	mov	r3, r8
 8048bbe:	4246      	negs	r6, r0
 8048bc0:	eba9 0000 	sub.w	r0, r9, r0
 8048bc4:	e9cd 2815 	strd	r2, r8, [sp, #84]	@ 0x54
 8048bc8:	e9cd a917 	strd	sl, r9, [sp, #92]	@ 0x5c
 8048bcc:	eb08 0405 	add.w	r4, r8, r5
 8048bd0:	46ac      	mov	ip, r5
 8048bd2:	4680      	mov	r8, r0
 8048bd4:	4699      	mov	r9, r3
 8048bd6:	f8cd e03c 	str.w	lr, [sp, #60]	@ 0x3c
			conv2d_loop2(q1, w1, p->x, (*_yy += kad_sdot(m, _ww, _xx)));
 8048bda:	2e00      	cmp	r6, #0
 8048bdc:	46b2      	mov	sl, r6
 8048bde:	db68      	blt.n	8048cb2 <kad_op_conv2d+0x772>
 8048be0:	2500      	movs	r5, #0
			conv2d_loop1(q->x, w->x, p->x, t, process_row_for);
 8048be2:	9b0d      	ldr	r3, [sp, #52]	@ 0x34
			conv2d_loop2(q1, w1, p->x, (*_yy += kad_sdot(m, _ww, _xx)));
 8048be4:	9a00      	ldr	r2, [sp, #0]
			conv2d_loop1(q->x, w->x, p->x, t, process_row_for);
 8048be6:	699b      	ldr	r3, [r3, #24]
 8048be8:	e9cd 8c05 	strd	r8, ip, [sp, #20]
 8048bec:	9313      	str	r3, [sp, #76]	@ 0x4c
			conv2d_loop2(q1, w1, p->x, (*_yy += kad_sdot(m, _ww, _xx)));
 8048bee:	fb03 f302 	mul.w	r3, r3, r2
 8048bf2:	9311      	str	r3, [sp, #68]	@ 0x44
 8048bf4:	9b03      	ldr	r3, [sp, #12]
 8048bf6:	9607      	str	r6, [sp, #28]
 8048bf8:	9a13      	ldr	r2, [sp, #76]	@ 0x4c
 8048bfa:	4592      	cmp	sl, r2
 8048bfc:	da56      	bge.n	8048cac <kad_op_conv2d+0x76c>
 8048bfe:	990f      	ldr	r1, [sp, #60]	@ 0x3c
 8048c00:	9800      	ldr	r0, [sp, #0]
 8048c02:	695a      	ldr	r2, [r3, #20]
 8048c04:	9e0e      	ldr	r6, [sp, #56]	@ 0x38
 8048c06:	fb02 1200 	mla	r2, r2, r0, r1
 8048c0a:	9908      	ldr	r1, [sp, #32]
 8048c0c:	f8d3 801c 	ldr.w	r8, [r3, #28]
 8048c10:	fb01 5202 	mla	r2, r1, r2, r5
 8048c14:	990d      	ldr	r1, [sp, #52]	@ 0x34
 8048c16:	fb08 f202 	mul.w	r2, r8, r2
 8048c1a:	69c8      	ldr	r0, [r1, #28]
 8048c1c:	9911      	ldr	r1, [sp, #68]	@ 0x44
 8048c1e:	4451      	add	r1, sl
 8048c20:	fb00 f101 	mul.w	r1, r0, r1
 8048c24:	fb06 f101 	mul.w	r1, r6, r1
 8048c28:	9e0c      	ldr	r6, [sp, #48]	@ 0x30
 8048c2a:	eb06 0181 	add.w	r1, r6, r1, lsl #2
 8048c2e:	6a9e      	ldr	r6, [r3, #40]	@ 0x28
 8048c30:	eb06 0682 	add.w	r6, r6, r2, lsl #2
 8048c34:	9a01      	ldr	r2, [sp, #4]
 8048c36:	b17a      	cbz	r2, 8048c58 <kad_op_conv2d+0x718>
 8048c38:	9319      	str	r3, [sp, #100]	@ 0x64
 8048c3a:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
 8048c3c:	fb03 f200 	mul.w	r2, r3, r0
 8048c40:	9802      	ldr	r0, [sp, #8]
 8048c42:	0092      	lsls	r2, r2, #2
 8048c44:	6980      	ldr	r0, [r0, #24]
 8048c46:	fb03 f000 	mul.w	r0, r3, r0
 8048c4a:	9b01      	ldr	r3, [sp, #4]
 8048c4c:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 8048c50:	f003 f9ed 	bl	804c02e <memcpy>
 8048c54:	9901      	ldr	r1, [sp, #4]
 8048c56:	9b19      	ldr	r3, [sp, #100]	@ 0x64
 8048c58:	f1b8 0f00 	cmp.w	r8, #0
 8048c5c:	bfc8      	it	gt
 8048c5e:	f04f 0c00 	movgt.w	ip, #0
 8048c62:	dd19      	ble.n	8048c98 <kad_op_conv2d+0x758>
	for (i = 0; i < n; ++i) s += x[i] * y[i];
 8048c64:	f1bb 0f00 	cmp.w	fp, #0
	float s = 0.;
 8048c68:	eddf 7a5b 	vldr	s15, [pc, #364]	@ 8048dd8 <kad_op_conv2d+0x898>
	for (i = 0; i < n; ++i) s += x[i] * y[i];
 8048c6c:	dd09      	ble.n	8048c82 <kad_op_conv2d+0x742>
 8048c6e:	4608      	mov	r0, r1
 8048c70:	464a      	mov	r2, r9
 8048c72:	ecf2 6a01 	vldmia	r2!, {s13}
 8048c76:	ecb0 7a01 	vldmia	r0!, {s14}
 8048c7a:	4294      	cmp	r4, r2
 8048c7c:	eee6 7a87 	vfma.f32	s15, s13, s14
 8048c80:	d1f7      	bne.n	8048c72 <kad_op_conv2d+0x732>
			conv2d_loop2(q1, w1, p->x, (*_yy += kad_sdot(m, _ww, _xx)));
 8048c82:	ed96 7a00 	vldr	s14, [r6]
 8048c86:	ee77 7a27 	vadd.f32	s15, s14, s15
 8048c8a:	f10c 0c01 	add.w	ip, ip, #1
 8048c8e:	45e0      	cmp	r8, ip
 8048c90:	ece6 7a01 	vstmia	r6!, {s15}
 8048c94:	4439      	add	r1, r7
 8048c96:	d1e5      	bne.n	8048c64 <kad_op_conv2d+0x724>
 8048c98:	9a02      	ldr	r2, [sp, #8]
 8048c9a:	3501      	adds	r5, #1
 8048c9c:	6852      	ldr	r2, [r2, #4]
 8048c9e:	4492      	add	sl, r2
 8048ca0:	9a08      	ldr	r2, [sp, #32]
 8048ca2:	4295      	cmp	r5, r2
 8048ca4:	d002      	beq.n	8048cac <kad_op_conv2d+0x76c>
 8048ca6:	f1ba 0f00 	cmp.w	sl, #0
 8048caa:	daa5      	bge.n	8048bf8 <kad_op_conv2d+0x6b8>
 8048cac:	9e07      	ldr	r6, [sp, #28]
 8048cae:	e9dd 8c05 	ldrd	r8, ip, [sp, #20]
 8048cb2:	3601      	adds	r6, #1
 8048cb4:	45b0      	cmp	r8, r6
 8048cb6:	44e1      	add	r9, ip
 8048cb8:	4464      	add	r4, ip
 8048cba:	d18e      	bne.n	8048bda <kad_op_conv2d+0x69a>
 8048cbc:	e9dd 2815 	ldrd	r2, r8, [sp, #84]	@ 0x54
 8048cc0:	e9dd a917 	ldrd	sl, r9, [sp, #92]	@ 0x5c
 8048cc4:	4665      	mov	r5, ip
 8048cc6:	f8dd e03c 	ldr.w	lr, [sp, #60]	@ 0x3c
 8048cca:	f10e 0e01 	add.w	lr, lr, #1
 8048cce:	45d6      	cmp	lr, sl
 8048cd0:	4490      	add	r8, r2
 8048cd2:	f47f af6b 	bne.w	8048bac <kad_op_conv2d+0x66c>
 8048cd6:	9b00      	ldr	r3, [sp, #0]
 8048cd8:	9c14      	ldr	r4, [sp, #80]	@ 0x50
 8048cda:	3301      	adds	r3, #1
 8048cdc:	42a3      	cmp	r3, r4
 8048cde:	4650      	mov	r0, sl
 8048ce0:	4629      	mov	r1, r5
 8048ce2:	f8dd a00c 	ldr.w	sl, [sp, #12]
 8048ce6:	9300      	str	r3, [sp, #0]
 8048ce8:	f47f af56 	bne.w	8048b98 <kad_op_conv2d+0x658>
 8048cec:	4601      	mov	r1, r0
 8048cee:	46ce      	mov	lr, r9
		conv_rot180(w->d[0] * w->d[1], w->d[2] * w->d[3], w->x);
 8048cf0:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 8048cf2:	fb03 f101 	mul.w	r1, r3, r1
	for (i = 0; i < d0; ++i) {
 8048cf6:	2900      	cmp	r1, #0
 8048cf8:	f77f ac37 	ble.w	804856a <kad_op_conv2d+0x2a>
		conv_rot180(w->d[0] * w->d[1], w->d[2] * w->d[3], w->x);
 8048cfc:	9b04      	ldr	r3, [sp, #16]
 8048cfe:	fb03 f40e 	mul.w	r4, r3, lr
 8048d02:	e661      	b.n	80489c8 <kad_op_conv2d+0x488>
			x_padded = aux[1].pad[0] + aux[1].pad[1] > 0? (float*)calloc(q->d[3] + aux[1].pad[0] + aux[1].pad[1], sizeof(float)) : 0;
 8048d04:	f8d9 101c 	ldr.w	r1, [r9, #28]
	int algo_switch = 0;
 8048d08:	2700      	movs	r7, #0
			x_padded = aux[1].pad[0] + aux[1].pad[1] > 0? (float*)calloc(q->d[3] + aux[1].pad[0] + aux[1].pad[1], sizeof(float)) : 0;
 8048d0a:	440b      	add	r3, r1
 8048d0c:	1898      	adds	r0, r3, r2
 8048d0e:	2104      	movs	r1, #4
 8048d10:	f002 fd86 	bl	804b820 <calloc>
	float *t = 0, *q1 = 0, *w1 = 0, *x_padded = 0;
 8048d14:	9709      	str	r7, [sp, #36]	@ 0x24
			x_padded = aux[1].pad[0] + aux[1].pad[1] > 0? (float*)calloc(q->d[3] + aux[1].pad[0] + aux[1].pad[1], sizeof(float)) : 0;
 8048d16:	9001      	str	r0, [sp, #4]
	float *t = 0, *q1 = 0, *w1 = 0, *x_padded = 0;
 8048d18:	970c      	str	r7, [sp, #48]	@ 0x30
 8048d1a:	e50a      	b.n	8048732 <kad_op_conv2d+0x1f2>
			conv_rot180(w->d[0] * w->d[1], w->d[2] * w->d[3], w->x);
 8048d1c:	6933      	ldr	r3, [r6, #16]
 8048d1e:	9908      	ldr	r1, [sp, #32]
 8048d20:	69b2      	ldr	r2, [r6, #24]
 8048d22:	fb03 f501 	mul.w	r5, r3, r1
 8048d26:	9307      	str	r3, [sp, #28]
 8048d28:	9b03      	ldr	r3, [sp, #12]
 8048d2a:	9205      	str	r2, [sp, #20]
 8048d2c:	fb02 f803 	mul.w	r8, r2, r3
 8048d30:	6ab2      	ldr	r2, [r6, #40]	@ 0x28
	for (i = 0; i < d0; ++i) {
 8048d32:	2d00      	cmp	r5, #0
			conv_rot180(w->d[0] * w->d[1], w->d[2] * w->d[3], w->x);
 8048d34:	9213      	str	r2, [sp, #76]	@ 0x4c
 8048d36:	f8cd 8070 	str.w	r8, [sp, #112]	@ 0x70
	for (i = 0; i < d0; ++i) {
 8048d3a:	f340 8342 	ble.w	80493c2 <kad_op_conv2d+0xe82>
		for (j = 0; j < d1>>1; ++j)
 8048d3e:	ea4f 0368 	mov.w	r3, r8, asr #1
 8048d42:	2b00      	cmp	r3, #0
 8048d44:	dd4a      	ble.n	8048ddc <kad_op_conv2d+0x89c>
	for (i = 0; i < d0; ++i) {
 8048d46:	2100      	movs	r1, #0
 8048d48:	ea4f 0c88 	mov.w	ip, r8, lsl #2
 8048d4c:	ea4f 0e83 	mov.w	lr, r3, lsl #2
		for (j = 0; j < d1>>1; ++j)
 8048d50:	4610      	mov	r0, r2
 8048d52:	4462      	add	r2, ip
 8048d54:	eb0e 0400 	add.w	r4, lr, r0
 8048d58:	9400      	str	r4, [sp, #0]
 8048d5a:	4614      	mov	r4, r2
 8048d5c:	9302      	str	r3, [sp, #8]
			tmp = xi[j], xi[j] = xi[d1-1-j], xi[d1-1-j] = tmp; 
 8048d5e:	ed34 7a01 	vldmdb	r4!, {s14}
 8048d62:	edd0 7a00 	vldr	s15, [r0]
 8048d66:	eca0 7a01 	vstmia	r0!, {s14}
		for (j = 0; j < d1>>1; ++j)
 8048d6a:	9b00      	ldr	r3, [sp, #0]
			tmp = xi[j], xi[j] = xi[d1-1-j], xi[d1-1-j] = tmp; 
 8048d6c:	edc4 7a00 	vstr	s15, [r4]
		for (j = 0; j < d1>>1; ++j)
 8048d70:	4298      	cmp	r0, r3
 8048d72:	d1f4      	bne.n	8048d5e <kad_op_conv2d+0x81e>
	for (i = 0; i < d0; ++i) {
 8048d74:	3101      	adds	r1, #1
 8048d76:	428d      	cmp	r5, r1
 8048d78:	9b02      	ldr	r3, [sp, #8]
 8048d7a:	d1e9      	bne.n	8048d50 <kad_op_conv2d+0x810>
			if (!algo_switch) {
 8048d7c:	2f00      	cmp	r7, #0
 8048d7e:	f040 8190 	bne.w	80490a2 <kad_op_conv2d+0xb62>
				conv2d_loop1(q->g, w->x, p->g, t, process_row_back_x);
 8048d82:	f8d9 2010 	ldr.w	r2, [r9, #16]
 8048d86:	2a00      	cmp	r2, #0
 8048d88:	f340 8150 	ble.w	804902c <kad_op_conv2d+0xaec>
 8048d8c:	9a07      	ldr	r2, [sp, #28]
 8048d8e:	2a00      	cmp	r2, #0
 8048d90:	f340 814c 	ble.w	804902c <kad_op_conv2d+0xaec>
 8048d94:	9a08      	ldr	r2, [sp, #32]
 8048d96:	2a00      	cmp	r2, #0
 8048d98:	f340 8148 	ble.w	804902c <kad_op_conv2d+0xaec>
 8048d9c:	9a05      	ldr	r2, [sp, #20]
 8048d9e:	2a00      	cmp	r2, #0
 8048da0:	dc2f      	bgt.n	8048e02 <kad_op_conv2d+0x8c2>
 8048da2:	e143      	b.n	804902c <kad_op_conv2d+0xaec>
			x_padded = aux[1].pad[0] + aux[1].pad[1] > 0? (float*)calloc((q->d[3] + aux[1].pad[0] + aux[1].pad[1]) * q->d[1], sizeof(float)) : 0;
 8048da4:	f8d9 101c 	ldr.w	r1, [r9, #28]
 8048da8:	f8d9 0014 	ldr.w	r0, [r9, #20]
 8048dac:	440b      	add	r3, r1
 8048dae:	4413      	add	r3, r2
 8048db0:	fb03 f000 	mul.w	r0, r3, r0
 8048db4:	2104      	movs	r1, #4
 8048db6:	f002 fd33 	bl	804b820 <calloc>
	float *t = 0, *q1 = 0, *w1 = 0, *x_padded = 0;
 8048dba:	2300      	movs	r3, #0
			algo_switch = 1;
 8048dbc:	2701      	movs	r7, #1
	float *t = 0, *q1 = 0, *w1 = 0, *x_padded = 0;
 8048dbe:	9310      	str	r3, [sp, #64]	@ 0x40
			x_padded = aux[1].pad[0] + aux[1].pad[1] > 0? (float*)calloc((q->d[3] + aux[1].pad[0] + aux[1].pad[1]) * q->d[1], sizeof(float)) : 0;
 8048dc0:	9001      	str	r0, [sp, #4]
	if (action == KAD_SYNC_DIM) {
 8048dc2:	e4b6      	b.n	8048732 <kad_op_conv2d+0x1f2>
 8048dc4:	2004      	movs	r0, #4
 8048dc6:	e41a      	b.n	80485fe <kad_op_conv2d+0xbe>
 8048dc8:	2004      	movs	r0, #4
 8048dca:	e401      	b.n	80485d0 <kad_op_conv2d+0x90>
 8048dcc:	2204      	movs	r2, #4
 8048dce:	e4f5      	b.n	80487bc <kad_op_conv2d+0x27c>
		if (q->n_d != 4 || w->n_d != 4) return -1;
 8048dd0:	f04f 30ff 	mov.w	r0, #4294967295
 8048dd4:	f7ff bbd6 	b.w	8048584 <kad_op_conv2d+0x44>
 8048dd8:	00000000 	.word	0x00000000
			if (!algo_switch) {
 8048ddc:	2f00      	cmp	r7, #0
 8048dde:	f040 8160 	bne.w	80490a2 <kad_op_conv2d+0xb62>
				conv2d_loop1(q->g, w->x, p->g, t, process_row_back_x);
 8048de2:	f8d9 3010 	ldr.w	r3, [r9, #16]
 8048de6:	2b00      	cmp	r3, #0
 8048de8:	f77f ac1f 	ble.w	804862a <kad_op_conv2d+0xea>
 8048dec:	9b07      	ldr	r3, [sp, #28]
 8048dee:	2b00      	cmp	r3, #0
 8048df0:	f77f ac1b 	ble.w	804862a <kad_op_conv2d+0xea>
 8048df4:	2900      	cmp	r1, #0
 8048df6:	f77f ac18 	ble.w	804862a <kad_op_conv2d+0xea>
 8048dfa:	9b05      	ldr	r3, [sp, #20]
 8048dfc:	2b00      	cmp	r3, #0
 8048dfe:	f77f ac14 	ble.w	804862a <kad_op_conv2d+0xea>
 8048e02:	2300      	movs	r3, #0
 8048e04:	930a      	str	r3, [sp, #40]	@ 0x28
 8048e06:	9b03      	ldr	r3, [sp, #12]
 8048e08:	ea4f 0488 	mov.w	r4, r8, lsl #2
 8048e0c:	009a      	lsls	r2, r3, #2
 8048e0e:	f8cd 9050 	str.w	r9, [sp, #80]	@ 0x50
 8048e12:	f8cd a038 	str.w	sl, [sp, #56]	@ 0x38
 8048e16:	46a9      	mov	r9, r5
 8048e18:	46ba      	mov	sl, r7
 8048e1a:	4615      	mov	r5, r2
 8048e1c:	4632      	mov	r2, r6
 8048e1e:	4626      	mov	r6, r4
 8048e20:	f8cd b074 	str.w	fp, [sp, #116]	@ 0x74
 8048e24:	f8dd b040 	ldr.w	fp, [sp, #64]	@ 0x40
 8048e28:	2400      	movs	r4, #0
 8048e2a:	4647      	mov	r7, r8
 8048e2c:	940b      	str	r4, [sp, #44]	@ 0x2c
 8048e2e:	9b05      	ldr	r3, [sp, #20]
 8048e30:	9913      	ldr	r1, [sp, #76]	@ 0x4c
 8048e32:	fb03 f304 	mul.w	r3, r3, r4
 8048e36:	fb05 1303 	mla	r3, r5, r3, r1
 8048e3a:	eb03 0805 	add.w	r8, r3, r5
 8048e3e:	2300      	movs	r3, #0
 8048e40:	46a6      	mov	lr, r4
 8048e42:	462c      	mov	r4, r5
 8048e44:	4645      	mov	r5, r8
 8048e46:	46b8      	mov	r8, r7
 8048e48:	930d      	str	r3, [sp, #52]	@ 0x34
 8048e4a:	9b1d      	ldr	r3, [sp, #116]	@ 0x74
 8048e4c:	f8cd a078 	str.w	sl, [sp, #120]	@ 0x78
 8048e50:	990e      	ldr	r1, [sp, #56]	@ 0x38
 8048e52:	6989      	ldr	r1, [r1, #24]
 8048e54:	4608      	mov	r0, r1
 8048e56:	2800      	cmp	r0, #0
 8048e58:	9106      	str	r1, [sp, #24]
				conv2d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _ww, _xx));
 8048e5a:	6899      	ldr	r1, [r3, #8]
 8048e5c:	f340 80b6 	ble.w	8048fcc <kad_op_conv2d+0xa8c>
 8048e60:	9805      	ldr	r0, [sp, #20]
 8048e62:	424f      	negs	r7, r1
 8048e64:	1a41      	subs	r1, r0, r1
				conv2d_loop1(q->g, w->x, p->g, t, process_row_back_x);
 8048e66:	9803      	ldr	r0, [sp, #12]
 8048e68:	e9cd 261f 	strd	r2, r6, [sp, #124]	@ 0x7c
 8048e6c:	ebc0 7c40 	rsb	ip, r0, r0, lsl #29
 8048e70:	f8cd 9084 	str.w	r9, [sp, #132]	@ 0x84
 8048e74:	46aa      	mov	sl, r5
 8048e76:	46a1      	mov	r9, r4
 8048e78:	460e      	mov	r6, r1
 8048e7a:	4664      	mov	r4, ip
 8048e7c:	2f00      	cmp	r7, #0
 8048e7e:	9700      	str	r7, [sp, #0]
 8048e80:	ebaa 0c09 	sub.w	ip, sl, r9
 8048e84:	f2c0 8097 	blt.w	8048fb6 <kad_op_conv2d+0xa76>
 8048e88:	2200      	movs	r2, #0
 8048e8a:	e9cd 9715 	strd	r9, r7, [sp, #84]	@ 0x54
 8048e8e:	e9cd 5618 	strd	r5, r6, [sp, #96]	@ 0x60
 8048e92:	e9cd 841a 	strd	r8, r4, [sp, #104]	@ 0x68
 8048e96:	9302      	str	r3, [sp, #8]
 8048e98:	9b14      	ldr	r3, [sp, #80]	@ 0x50
 8048e9a:	9204      	str	r2, [sp, #16]
 8048e9c:	f8cd e05c 	str.w	lr, [sp, #92]	@ 0x5c
 8048ea0:	f8cd c03c 	str.w	ip, [sp, #60]	@ 0x3c
 8048ea4:	6999      	ldr	r1, [r3, #24]
 8048ea6:	9a00      	ldr	r2, [sp, #0]
 8048ea8:	4291      	cmp	r1, r2
 8048eaa:	dd79      	ble.n	8048fa0 <kad_op_conv2d+0xa60>
 8048eac:	980d      	ldr	r0, [sp, #52]	@ 0x34
 8048eae:	9c0a      	ldr	r4, [sp, #40]	@ 0x28
 8048eb0:	695a      	ldr	r2, [r3, #20]
 8048eb2:	9d0b      	ldr	r5, [sp, #44]	@ 0x2c
 8048eb4:	fb02 0204 	mla	r2, r2, r4, r0
 8048eb8:	9800      	ldr	r0, [sp, #0]
 8048eba:	6ade      	ldr	r6, [r3, #44]	@ 0x2c
 8048ebc:	fb01 0102 	mla	r1, r1, r2, r0
 8048ec0:	980e      	ldr	r0, [sp, #56]	@ 0x38
 8048ec2:	6942      	ldr	r2, [r0, #20]
 8048ec4:	f8d0 801c 	ldr.w	r8, [r0, #28]
 8048ec8:	fb02 5404 	mla	r4, r2, r4, r5
 8048ecc:	9a04      	ldr	r2, [sp, #16]
 8048ece:	9d06      	ldr	r5, [sp, #24]
 8048ed0:	6ac0      	ldr	r0, [r0, #44]	@ 0x2c
 8048ed2:	fb05 2404 	mla	r4, r5, r4, r2
 8048ed6:	69da      	ldr	r2, [r3, #28]
 8048ed8:	fb08 f404 	mul.w	r4, r8, r4
 8048edc:	fb02 f501 	mul.w	r5, r2, r1
 8048ee0:	eb00 0984 	add.w	r9, r0, r4, lsl #2
 8048ee4:	9801      	ldr	r0, [sp, #4]
 8048ee6:	eb06 0185 	add.w	r1, r6, r5, lsl #2
 8048eea:	b150      	cbz	r0, 8048f02 <kad_op_conv2d+0x9c2>
 8048eec:	9311      	str	r3, [sp, #68]	@ 0x44
 8048eee:	9b02      	ldr	r3, [sp, #8]
 8048ef0:	0092      	lsls	r2, r2, #2
 8048ef2:	699d      	ldr	r5, [r3, #24]
 8048ef4:	eb00 0585 	add.w	r5, r0, r5, lsl #2
 8048ef8:	4628      	mov	r0, r5
 8048efa:	f003 f898 	bl	804c02e <memcpy>
 8048efe:	4629      	mov	r1, r5
 8048f00:	9b11      	ldr	r3, [sp, #68]	@ 0x44
 8048f02:	9a02      	ldr	r2, [sp, #8]
 8048f04:	6956      	ldr	r6, [r2, #20]
 8048f06:	9a03      	ldr	r2, [sp, #12]
 8048f08:	2e01      	cmp	r6, #1
 8048f0a:	f340 80a7 	ble.w	804905c <kad_op_conv2d+0xb1c>
 8048f0e:	2a00      	cmp	r2, #0
 8048f10:	dd39      	ble.n	8048f86 <kad_op_conv2d+0xa46>
 8048f12:	9a02      	ldr	r2, [sp, #8]
 8048f14:	eb0b 0488 	add.w	r4, fp, r8, lsl #2
 8048f18:	6992      	ldr	r2, [r2, #24]
 8048f1a:	9311      	str	r3, [sp, #68]	@ 0x44
 8048f1c:	ebc2 7282 	rsb	r2, r2, r2, lsl #30
 8048f20:	eb01 0582 	add.w	r5, r1, r2, lsl #2
 8048f24:	ea4f 0288 	mov.w	r2, r8, lsl #2
 8048f28:	465b      	mov	r3, fp
 8048f2a:	46cb      	mov	fp, r9
 8048f2c:	4691      	mov	r9, r2
				conv2d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _ww, _xx));
 8048f2e:	9f0f      	ldr	r7, [sp, #60]	@ 0x3c
				conv2d_loop1(q->g, w->x, p->g, t, process_row_back_x);
 8048f30:	00b6      	lsls	r6, r6, #2
 8048f32:	464a      	mov	r2, r9
 8048f34:	4618      	mov	r0, r3
 8048f36:	2100      	movs	r1, #0
 8048f38:	f002 ff7c 	bl	804be34 <memset>
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 8048f3c:	f1b8 0f00 	cmp.w	r8, #0
				conv2d_loop1(q->g, w->x, p->g, t, process_row_back_x);
 8048f40:	4603      	mov	r3, r0
 8048f42:	ecf7 6a01 	vldmia	r7!, {s13}
 8048f46:	462a      	mov	r2, r5
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 8048f48:	dd17      	ble.n	8048f7a <kad_op_conv2d+0xa3a>
 8048f4a:	4658      	mov	r0, fp
 8048f4c:	4619      	mov	r1, r3
 8048f4e:	edd1 7a00 	vldr	s15, [r1]
 8048f52:	ecb0 7a01 	vldmia	r0!, {s14}
 8048f56:	eee6 7a87 	vfma.f32	s15, s13, s14
 8048f5a:	ece1 7a01 	vstmia	r1!, {s15}
 8048f5e:	428c      	cmp	r4, r1
 8048f60:	d1f5      	bne.n	8048f4e <kad_op_conv2d+0xa0e>
 8048f62:	4619      	mov	r1, r3
				conv2d_loop1(q->g, w->x, p->g, t, process_row_back_x);
 8048f64:	edd2 7a00 	vldr	s15, [r2]
 8048f68:	ecb1 7a01 	vldmia	r1!, {s14}
 8048f6c:	ee77 7a87 	vadd.f32	s15, s15, s14
 8048f70:	42a1      	cmp	r1, r4
 8048f72:	edc2 7a00 	vstr	s15, [r2]
 8048f76:	4432      	add	r2, r6
 8048f78:	d1f4      	bne.n	8048f64 <kad_op_conv2d+0xa24>
 8048f7a:	4557      	cmp	r7, sl
 8048f7c:	f105 0504 	add.w	r5, r5, #4
 8048f80:	d1d7      	bne.n	8048f32 <kad_op_conv2d+0x9f2>
 8048f82:	469b      	mov	fp, r3
 8048f84:	9b11      	ldr	r3, [sp, #68]	@ 0x44
 8048f86:	9a02      	ldr	r2, [sp, #8]
 8048f88:	9800      	ldr	r0, [sp, #0]
 8048f8a:	6852      	ldr	r2, [r2, #4]
 8048f8c:	9904      	ldr	r1, [sp, #16]
 8048f8e:	4410      	add	r0, r2
 8048f90:	9a06      	ldr	r2, [sp, #24]
 8048f92:	3101      	adds	r1, #1
 8048f94:	4291      	cmp	r1, r2
 8048f96:	9104      	str	r1, [sp, #16]
 8048f98:	9000      	str	r0, [sp, #0]
 8048f9a:	d001      	beq.n	8048fa0 <kad_op_conv2d+0xa60>
 8048f9c:	2800      	cmp	r0, #0
 8048f9e:	da81      	bge.n	8048ea4 <kad_op_conv2d+0x964>
 8048fa0:	f8dd e05c 	ldr.w	lr, [sp, #92]	@ 0x5c
 8048fa4:	9b02      	ldr	r3, [sp, #8]
 8048fa6:	f8dd c03c 	ldr.w	ip, [sp, #60]	@ 0x3c
 8048faa:	e9dd 9715 	ldrd	r9, r7, [sp, #84]	@ 0x54
 8048fae:	e9dd 5618 	ldrd	r5, r6, [sp, #96]	@ 0x60
 8048fb2:	e9dd 841a 	ldrd	r8, r4, [sp, #104]	@ 0x68
 8048fb6:	3701      	adds	r7, #1
 8048fb8:	42be      	cmp	r6, r7
 8048fba:	ebac 0ac4 	sub.w	sl, ip, r4, lsl #3
 8048fbe:	f47f af5d 	bne.w	8048e7c <kad_op_conv2d+0x93c>
 8048fc2:	e9dd 261f 	ldrd	r2, r6, [sp, #124]	@ 0x7c
 8048fc6:	464c      	mov	r4, r9
 8048fc8:	f8dd 9084 	ldr.w	r9, [sp, #132]	@ 0x84
 8048fcc:	990d      	ldr	r1, [sp, #52]	@ 0x34
 8048fce:	9808      	ldr	r0, [sp, #32]
 8048fd0:	3101      	adds	r1, #1
 8048fd2:	4288      	cmp	r0, r1
 8048fd4:	910d      	str	r1, [sp, #52]	@ 0x34
 8048fd6:	4435      	add	r5, r6
 8048fd8:	f47f af3a 	bne.w	8048e50 <kad_op_conv2d+0x910>
 8048fdc:	4625      	mov	r5, r4
 8048fde:	4674      	mov	r4, lr
 8048fe0:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 8048fe2:	9907      	ldr	r1, [sp, #28]
 8048fe4:	3301      	adds	r3, #1
 8048fe6:	4299      	cmp	r1, r3
 8048fe8:	4647      	mov	r7, r8
 8048fea:	f8dd a078 	ldr.w	sl, [sp, #120]	@ 0x78
 8048fee:	930b      	str	r3, [sp, #44]	@ 0x2c
 8048ff0:	4404      	add	r4, r0
 8048ff2:	f47f af1c 	bne.w	8048e2e <kad_op_conv2d+0x8ee>
 8048ff6:	9b14      	ldr	r3, [sp, #80]	@ 0x50
 8048ff8:	990a      	ldr	r1, [sp, #40]	@ 0x28
 8048ffa:	691b      	ldr	r3, [r3, #16]
 8048ffc:	3101      	adds	r1, #1
 8048ffe:	428b      	cmp	r3, r1
 8049000:	910a      	str	r1, [sp, #40]	@ 0x28
 8049002:	f73f af11 	bgt.w	8048e28 <kad_op_conv2d+0x8e8>
 8049006:	4616      	mov	r6, r2
 8049008:	4657      	mov	r7, sl
 804900a:	464d      	mov	r5, r9
 804900c:	f8dd b074 	ldr.w	fp, [sp, #116]	@ 0x74
 8049010:	f8dd a038 	ldr.w	sl, [sp, #56]	@ 0x38
 8049014:	f8dd 9050 	ldr.w	r9, [sp, #80]	@ 0x50
	for (i = 0; i < d0; ++i) {
 8049018:	2d00      	cmp	r5, #0
 804901a:	f340 81e2 	ble.w	80493e2 <kad_op_conv2d+0xea2>
		for (j = 0; j < d1>>1; ++j)
 804901e:	ea4f 0368 	mov.w	r3, r8, asr #1
 8049022:	2b00      	cmp	r3, #0
 8049024:	f77f ab01 	ble.w	804862a <kad_op_conv2d+0xea>
 8049028:	ea4f 0c88 	mov.w	ip, r8, lsl #2
				conv2d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _ww, _xx));
 804902c:	2100      	movs	r1, #0
 804902e:	9a13      	ldr	r2, [sp, #76]	@ 0x4c
 8049030:	ea4f 0e83 	mov.w	lr, r3, lsl #2
		for (j = 0; j < d1>>1; ++j)
 8049034:	4613      	mov	r3, r2
 8049036:	4462      	add	r2, ip
				conv2d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _ww, _xx));
 8049038:	4610      	mov	r0, r2
 804903a:	eb0e 0403 	add.w	r4, lr, r3
			tmp = xi[j], xi[j] = xi[d1-1-j], xi[d1-1-j] = tmp; 
 804903e:	ed70 7a01 	vldmdb	r0!, {s15}
 8049042:	f8d3 8000 	ldr.w	r8, [r3]
 8049046:	ece3 7a01 	vstmia	r3!, {s15}
		for (j = 0; j < d1>>1; ++j)
 804904a:	42a3      	cmp	r3, r4
			tmp = xi[j], xi[j] = xi[d1-1-j], xi[d1-1-j] = tmp; 
 804904c:	f8c0 8000 	str.w	r8, [r0]
		for (j = 0; j < d1>>1; ++j)
 8049050:	d1f5      	bne.n	804903e <kad_op_conv2d+0xafe>
	for (i = 0; i < d0; ++i) {
 8049052:	3101      	adds	r1, #1
 8049054:	428d      	cmp	r5, r1
 8049056:	d1ed      	bne.n	8049034 <kad_op_conv2d+0xaf4>
 8049058:	f7ff bae7 	b.w	804862a <kad_op_conv2d+0xea>
				conv2d_loop1(q->g, w->x, p->g, t, process_row_back_x);
 804905c:	2a00      	cmp	r2, #0
 804905e:	dd92      	ble.n	8048f86 <kad_op_conv2d+0xa46>
 8049060:	9a02      	ldr	r2, [sp, #8]
 8049062:	f1b8 0f00 	cmp.w	r8, #0
 8049066:	6992      	ldr	r2, [r2, #24]
 8049068:	dd8d      	ble.n	8048f86 <kad_op_conv2d+0xa46>
 804906a:	eba8 0202 	sub.w	r2, r8, r2
 804906e:	9d0f      	ldr	r5, [sp, #60]	@ 0x3c
 8049070:	ebc8 7888 	rsb	r8, r8, r8, lsl #30
 8049074:	eb01 0082 	add.w	r0, r1, r2, lsl #2
 8049078:	ea4f 0488 	mov.w	r4, r8, lsl #2
 804907c:	ecf5 6a01 	vldmia	r5!, {s13}
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 8049080:	4649      	mov	r1, r9
 8049082:	1822      	adds	r2, r4, r0
 8049084:	edd2 7a00 	vldr	s15, [r2]
 8049088:	ecb1 7a01 	vldmia	r1!, {s14}
 804908c:	eee6 7a87 	vfma.f32	s15, s13, s14
 8049090:	ece2 7a01 	vstmia	r2!, {s15}
 8049094:	4282      	cmp	r2, r0
 8049096:	d1f5      	bne.n	8049084 <kad_op_conv2d+0xb44>
				conv2d_loop1(q->g, w->x, p->g, t, process_row_back_x);
 8049098:	45aa      	cmp	sl, r5
 804909a:	f100 0004 	add.w	r0, r0, #4
 804909e:	d1ed      	bne.n	804907c <kad_op_conv2d+0xb3c>
 80490a0:	e771      	b.n	8048f86 <kad_op_conv2d+0xa46>
 80490a2:	f899 2000 	ldrb.w	r2, [r9]
 80490a6:	2a00      	cmp	r2, #0
 80490a8:	f000 8167 	beq.w	804937a <kad_op_conv2d+0xe3a>
 80490ac:	2a01      	cmp	r2, #1
 80490ae:	f8d9 3010 	ldr.w	r3, [r9, #16]
 80490b2:	d00e      	beq.n	80490d2 <kad_op_conv2d+0xb92>
 80490b4:	f8d9 1014 	ldr.w	r1, [r9, #20]
 80490b8:	2a02      	cmp	r2, #2
 80490ba:	fb01 f303 	mul.w	r3, r1, r3
 80490be:	d008      	beq.n	80490d2 <kad_op_conv2d+0xb92>
 80490c0:	f8d9 1018 	ldr.w	r1, [r9, #24]
 80490c4:	2a03      	cmp	r2, #3
 80490c6:	fb01 f303 	mul.w	r3, r1, r3
 80490ca:	bf1c      	itt	ne
 80490cc:	f8d9 201c 	ldrne.w	r2, [r9, #28]
 80490d0:	4353      	mulne	r3, r2
				memset(q1, 0, kad_len(q) * sizeof(float));
 80490d2:	009a      	lsls	r2, r3, #2
 80490d4:	2100      	movs	r1, #0
 80490d6:	980c      	ldr	r0, [sp, #48]	@ 0x30
 80490d8:	f002 feac 	bl	804be34 <memset>
	for (i = 0; i < d[0]; ++i)
 80490dc:	9b07      	ldr	r3, [sp, #28]
 80490de:	2b00      	cmp	r3, #0
 80490e0:	f340 8143 	ble.w	804936a <kad_op_conv2d+0xe2a>
		for (j = 0; j < d[1]; ++j)
 80490e4:	f8d6 e014 	ldr.w	lr, [r6, #20]
 80490e8:	f1be 0f00 	cmp.w	lr, #0
 80490ec:	f340 8147 	ble.w	804937e <kad_op_conv2d+0xe3e>
 80490f0:	9a05      	ldr	r2, [sp, #20]
 80490f2:	2a00      	cmp	r2, #0
 80490f4:	f340 8139 	ble.w	804936a <kad_op_conv2d+0xe2a>
				int ik = (i * d[2] + k) * d[3], ijk = ((i * d[1] + j) * d[2] + k) * d[3];
 80490f8:	2000      	movs	r0, #0
 80490fa:	69f1      	ldr	r1, [r6, #28]
 80490fc:	ea4f 038e 	mov.w	r3, lr, lsl #2
 8049100:	9300      	str	r3, [sp, #0]
 8049102:	fb0e f301 	mul.w	r3, lr, r1
 8049106:	009b      	lsls	r3, r3, #2
 8049108:	9304      	str	r3, [sp, #16]
 804910a:	008b      	lsls	r3, r1, #2
 804910c:	930a      	str	r3, [sp, #40]	@ 0x28
 804910e:	f8cd 802c 	str.w	r8, [sp, #44]	@ 0x2c
 8049112:	465b      	mov	r3, fp
 8049114:	4604      	mov	r4, r0
 8049116:	46cb      	mov	fp, r9
	for (i = 0; i < d[0]; ++i)
 8049118:	4684      	mov	ip, r0
 804911a:	46b9      	mov	r9, r7
 804911c:	4690      	mov	r8, r2
 804911e:	462f      	mov	r7, r5
		for (j = 0; j < d[1]; ++j)
 8049120:	fb00 f201 	mul.w	r2, r0, r1
 8049124:	fb0e f202 	mul.w	r2, lr, r2
 8049128:	9206      	str	r2, [sp, #24]
 804912a:	2200      	movs	r2, #0
 804912c:	fb08 f504 	mul.w	r5, r8, r4
			for (k = 0; k < d[2]; ++k) {
 8049130:	2900      	cmp	r1, #0
 8049132:	dd32      	ble.n	804919a <kad_op_conv2d+0xc5a>
 8049134:	f8cd 9050 	str.w	r9, [sp, #80]	@ 0x50
 8049138:	46a1      	mov	r9, r4
 804913a:	e9cd 3b0d 	strd	r3, fp, [sp, #52]	@ 0x34
 804913e:	960f      	str	r6, [sp, #60]	@ 0x3c
 8049140:	f8cd c044 	str.w	ip, [sp, #68]	@ 0x44
 8049144:	f04f 0c00 	mov.w	ip, #0
 8049148:	9c06      	ldr	r4, [sp, #24]
 804914a:	9e09      	ldr	r6, [sp, #36]	@ 0x24
 804914c:	fb05 f301 	mul.w	r3, r5, r1
 8049150:	1914      	adds	r4, r2, r4
 8049152:	eb06 0484 	add.w	r4, r6, r4, lsl #2
 8049156:	9402      	str	r4, [sp, #8]
 8049158:	9c13      	ldr	r4, [sp, #76]	@ 0x4c
 804915a:	18ce      	adds	r6, r1, r3
 804915c:	eb04 0b86 	add.w	fp, r4, r6, lsl #2
 8049160:	9c02      	ldr	r4, [sp, #8]
 8049162:	9215      	str	r2, [sp, #84]	@ 0x54
				for (l = 0; l < d[3]; ++l)
 8049164:	9a13      	ldr	r2, [sp, #76]	@ 0x4c
			for (k = 0; k < d[2]; ++k) {
 8049166:	9102      	str	r1, [sp, #8]
 8049168:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 804916c:	4622      	mov	r2, r4
					y[(ik + l) * d[1] + j] = x[ijk + l];
 804916e:	ecf3 7a01 	vldmia	r3!, {s15}
				for (l = 0; l < d[3]; ++l)
 8049172:	9900      	ldr	r1, [sp, #0]
 8049174:	455b      	cmp	r3, fp
					y[(ik + l) * d[1] + j] = x[ijk + l];
 8049176:	edc2 7a00 	vstr	s15, [r2]
				for (l = 0; l < d[3]; ++l)
 804917a:	440a      	add	r2, r1
 804917c:	d1f7      	bne.n	804916e <kad_op_conv2d+0xc2e>
			for (k = 0; k < d[2]; ++k) {
 804917e:	9a04      	ldr	r2, [sp, #16]
 8049180:	f10c 0c01 	add.w	ip, ip, #1
 8049184:	4414      	add	r4, r2
 8049186:	9a0a      	ldr	r2, [sp, #40]	@ 0x28
 8049188:	45e0      	cmp	r8, ip
 804918a:	eb03 0b02 	add.w	fp, r3, r2
 804918e:	9902      	ldr	r1, [sp, #8]
 8049190:	4633      	mov	r3, r6
 8049192:	f000 8107 	beq.w	80493a4 <kad_op_conv2d+0xe64>
 8049196:	440e      	add	r6, r1
 8049198:	e7e4      	b.n	8049164 <kad_op_conv2d+0xc24>
		for (j = 0; j < d[1]; ++j)
 804919a:	3201      	adds	r2, #1
 804919c:	4572      	cmp	r2, lr
 804919e:	4445      	add	r5, r8
 80491a0:	d1c6      	bne.n	8049130 <kad_op_conv2d+0xbf0>
	for (i = 0; i < d[0]; ++i)
 80491a2:	9a07      	ldr	r2, [sp, #28]
 80491a4:	f10c 0c01 	add.w	ip, ip, #1
 80491a8:	4562      	cmp	r2, ip
 80491aa:	4474      	add	r4, lr
 80491ac:	4440      	add	r0, r8
 80491ae:	d1b7      	bne.n	8049120 <kad_op_conv2d+0xbe0>
				conv2d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _ww, _xx));
 80491b0:	463d      	mov	r5, r7
 80491b2:	464f      	mov	r7, r9
 80491b4:	46d9      	mov	r9, fp
 80491b6:	469b      	mov	fp, r3
 80491b8:	f8d9 3014 	ldr.w	r3, [r9, #20]
 80491bc:	f8d9 4010 	ldr.w	r4, [r9, #16]
 80491c0:	461a      	mov	r2, r3
 80491c2:	9304      	str	r3, [sp, #16]
 80491c4:	f8db 3014 	ldr.w	r3, [fp, #20]
 80491c8:	2c00      	cmp	r4, #0
 80491ca:	fb02 f303 	mul.w	r3, r2, r3
 80491ce:	f8dd 802c 	ldr.w	r8, [sp, #44]	@ 0x2c
 80491d2:	f340 80ca 	ble.w	804936a <kad_op_conv2d+0xe2a>
 80491d6:	009b      	lsls	r3, r3, #2
 80491d8:	4618      	mov	r0, r3
 80491da:	f04f 0e00 	mov.w	lr, #0
 80491de:	9912      	ldr	r1, [sp, #72]	@ 0x48
 80491e0:	9b05      	ldr	r3, [sp, #20]
 80491e2:	f8cd b008 	str.w	fp, [sp, #8]
 80491e6:	fb03 f301 	mul.w	r3, r3, r1
 80491ea:	009a      	lsls	r2, r3, #2
 80491ec:	9616      	str	r6, [sp, #88]	@ 0x58
 80491ee:	008b      	lsls	r3, r1, #2
 80491f0:	46f3      	mov	fp, lr
 80491f2:	4639      	mov	r1, r7
 80491f4:	4616      	mov	r6, r2
 80491f6:	462f      	mov	r7, r5
 80491f8:	4645      	mov	r5, r8
 80491fa:	4680      	mov	r8, r0
 80491fc:	9311      	str	r3, [sp, #68]	@ 0x44
 80491fe:	f8cd 9028 	str.w	r9, [sp, #40]	@ 0x28
 8049202:	2300      	movs	r3, #0
 8049204:	f8cd b050 	str.w	fp, [sp, #80]	@ 0x50
 8049208:	46ab      	mov	fp, r5
 804920a:	f8dd 9024 	ldr.w	r9, [sp, #36]	@ 0x24
 804920e:	9306      	str	r3, [sp, #24]
 8049210:	9417      	str	r4, [sp, #92]	@ 0x5c
				conv2d_loop1(q->g, w->x, p->g, t, process_row_back_x);
 8049212:	f8da 3018 	ldr.w	r3, [sl, #24]
				conv2d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _ww, _xx));
 8049216:	9a02      	ldr	r2, [sp, #8]
 8049218:	2b00      	cmp	r3, #0
 804921a:	6890      	ldr	r0, [r2, #8]
				conv2d_loop1(q->g, w->x, p->g, t, process_row_back_x);
 804921c:	930f      	str	r3, [sp, #60]	@ 0x3c
 804921e:	f340 808b 	ble.w	8049338 <kad_op_conv2d+0xdf8>
 8049222:	9b05      	ldr	r3, [sp, #20]
 8049224:	4632      	mov	r2, r6
 8049226:	eba3 0c00 	sub.w	ip, r3, r0
 804922a:	463b      	mov	r3, r7
 804922c:	464c      	mov	r4, r9
 804922e:	4667      	mov	r7, ip
 8049230:	465e      	mov	r6, fp
 8049232:	469c      	mov	ip, r3
 8049234:	4245      	negs	r5, r0
 8049236:	f8cd 9060 	str.w	r9, [sp, #96]	@ 0x60
				conv2d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _ww, _xx));
 804923a:	2d00      	cmp	r5, #0
 804923c:	46a9      	mov	r9, r5
 804923e:	db71      	blt.n	8049324 <kad_op_conv2d+0xde4>
 8049240:	970e      	str	r7, [sp, #56]	@ 0x38
 8049242:	f04f 0b00 	mov.w	fp, #0
 8049246:	4613      	mov	r3, r2
 8049248:	4667      	mov	r7, ip
 804924a:	910b      	str	r1, [sp, #44]	@ 0x2c
 804924c:	950d      	str	r5, [sp, #52]	@ 0x34
 804924e:	9400      	str	r4, [sp, #0]
 8049250:	9a0a      	ldr	r2, [sp, #40]	@ 0x28
 8049252:	6991      	ldr	r1, [r2, #24]
 8049254:	4549      	cmp	r1, r9
 8049256:	dd5f      	ble.n	8049318 <kad_op_conv2d+0xdd8>
 8049258:	9814      	ldr	r0, [sp, #80]	@ 0x50
 804925a:	9d06      	ldr	r5, [sp, #24]
 804925c:	f8da 2014 	ldr.w	r2, [sl, #20]
 8049260:	fb00 9101 	mla	r1, r0, r1, r9
 8049264:	fb02 5200 	mla	r2, r2, r0, r5
 8049268:	980f      	ldr	r0, [sp, #60]	@ 0x3c
 804926a:	9d04      	ldr	r5, [sp, #16]
 804926c:	fb00 b002 	mla	r0, r0, r2, fp
 8049270:	9a0a      	ldr	r2, [sp, #40]	@ 0x28
 8049272:	f8da 402c 	ldr.w	r4, [sl, #44]	@ 0x2c
 8049276:	69d2      	ldr	r2, [r2, #28]
 8049278:	fb02 f101 	mul.w	r1, r2, r1
 804927c:	fb05 f101 	mul.w	r1, r5, r1
 8049280:	9d0c      	ldr	r5, [sp, #48]	@ 0x30
 8049282:	eb05 0181 	add.w	r1, r5, r1, lsl #2
 8049286:	f8da 501c 	ldr.w	r5, [sl, #28]
 804928a:	fb05 f000 	mul.w	r0, r5, r0
 804928e:	eb04 0080 	add.w	r0, r4, r0, lsl #2
 8049292:	9015      	str	r0, [sp, #84]	@ 0x54
 8049294:	9801      	ldr	r0, [sp, #4]
 8049296:	b178      	cbz	r0, 80492b8 <kad_op_conv2d+0xd78>
 8049298:	9c02      	ldr	r4, [sp, #8]
 804929a:	9319      	str	r3, [sp, #100]	@ 0x64
 804929c:	69a0      	ldr	r0, [r4, #24]
 804929e:	9b04      	ldr	r3, [sp, #16]
 80492a0:	9c01      	ldr	r4, [sp, #4]
 80492a2:	fb03 f202 	mul.w	r2, r3, r2
 80492a6:	fb03 f000 	mul.w	r0, r3, r0
 80492aa:	0092      	lsls	r2, r2, #2
 80492ac:	eb04 0080 	add.w	r0, r4, r0, lsl #2
 80492b0:	f002 febd 	bl	804c02e <memcpy>
 80492b4:	4621      	mov	r1, r4
 80492b6:	9b19      	ldr	r3, [sp, #100]	@ 0x64
 80492b8:	2d00      	cmp	r5, #0
 80492ba:	dd22      	ble.n	8049302 <kad_op_conv2d+0xdc2>
 80492bc:	9a12      	ldr	r2, [sp, #72]	@ 0x48
 80492be:	2a00      	cmp	r2, #0
 80492c0:	dd1f      	ble.n	8049302 <kad_op_conv2d+0xdc2>
 80492c2:	f04f 0c00 	mov.w	ip, #0
 80492c6:	9a11      	ldr	r2, [sp, #68]	@ 0x44
 80492c8:	9c00      	ldr	r4, [sp, #0]
 80492ca:	f8dd e054 	ldr.w	lr, [sp, #84]	@ 0x54
 80492ce:	1888      	adds	r0, r1, r2
 80492d0:	f8cd b054 	str.w	fp, [sp, #84]	@ 0x54
 80492d4:	ecfe 6a01 	vldmia	lr!, {s13}
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 80492d8:	460a      	mov	r2, r1
				conv2d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _ww, _xx));
 80492da:	46a3      	mov	fp, r4
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 80492dc:	edd2 7a00 	vldr	s15, [r2]
 80492e0:	ecbb 7a01 	vldmia	fp!, {s14}
 80492e4:	eee6 7a87 	vfma.f32	s15, s13, s14
 80492e8:	ece2 7a01 	vstmia	r2!, {s15}
 80492ec:	4282      	cmp	r2, r0
 80492ee:	d1f5      	bne.n	80492dc <kad_op_conv2d+0xd9c>
				conv2d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _ww, _xx));
 80492f0:	f10c 0c01 	add.w	ip, ip, #1
 80492f4:	4565      	cmp	r5, ip
 80492f6:	4441      	add	r1, r8
 80492f8:	4440      	add	r0, r8
 80492fa:	d1eb      	bne.n	80492d4 <kad_op_conv2d+0xd94>
 80492fc:	f8dd b054 	ldr.w	fp, [sp, #84]	@ 0x54
 8049300:	9400      	str	r4, [sp, #0]
 8049302:	9a02      	ldr	r2, [sp, #8]
 8049304:	f10b 0b01 	add.w	fp, fp, #1
 8049308:	6852      	ldr	r2, [r2, #4]
 804930a:	4491      	add	r9, r2
 804930c:	9a0f      	ldr	r2, [sp, #60]	@ 0x3c
 804930e:	4593      	cmp	fp, r2
 8049310:	d002      	beq.n	8049318 <kad_op_conv2d+0xdd8>
 8049312:	f1b9 0f00 	cmp.w	r9, #0
 8049316:	da9b      	bge.n	8049250 <kad_op_conv2d+0xd10>
 8049318:	461a      	mov	r2, r3
 804931a:	46bc      	mov	ip, r7
 804931c:	990b      	ldr	r1, [sp, #44]	@ 0x2c
 804931e:	9d0d      	ldr	r5, [sp, #52]	@ 0x34
 8049320:	9c00      	ldr	r4, [sp, #0]
 8049322:	9f0e      	ldr	r7, [sp, #56]	@ 0x38
 8049324:	9b11      	ldr	r3, [sp, #68]	@ 0x44
 8049326:	3501      	adds	r5, #1
 8049328:	42bd      	cmp	r5, r7
 804932a:	441c      	add	r4, r3
 804932c:	d185      	bne.n	804923a <kad_op_conv2d+0xcfa>
 804932e:	46b3      	mov	fp, r6
 8049330:	4667      	mov	r7, ip
 8049332:	4616      	mov	r6, r2
 8049334:	f8dd 9060 	ldr.w	r9, [sp, #96]	@ 0x60
 8049338:	9b06      	ldr	r3, [sp, #24]
 804933a:	9a07      	ldr	r2, [sp, #28]
 804933c:	3301      	adds	r3, #1
 804933e:	429a      	cmp	r2, r3
 8049340:	9306      	str	r3, [sp, #24]
 8049342:	44b1      	add	r9, r6
 8049344:	f47f af65 	bne.w	8049212 <kad_op_conv2d+0xcd2>
 8049348:	465d      	mov	r5, fp
 804934a:	f8dd b050 	ldr.w	fp, [sp, #80]	@ 0x50
 804934e:	9c17      	ldr	r4, [sp, #92]	@ 0x5c
 8049350:	f10b 0b01 	add.w	fp, fp, #1
 8049354:	455c      	cmp	r4, fp
 8049356:	f47f af54 	bne.w	8049202 <kad_op_conv2d+0xcc2>
 804935a:	46a8      	mov	r8, r5
 804935c:	463d      	mov	r5, r7
 804935e:	460f      	mov	r7, r1
 8049360:	f8dd b008 	ldr.w	fp, [sp, #8]
 8049364:	f8dd 9028 	ldr.w	r9, [sp, #40]	@ 0x28
 8049368:	9e16      	ldr	r6, [sp, #88]	@ 0x58
				conv2d_add_3to1(q->d, q1, q->g);
 804936a:	990c      	ldr	r1, [sp, #48]	@ 0x30
 804936c:	f8d9 202c 	ldr.w	r2, [r9, #44]	@ 0x2c
 8049370:	f109 0010 	add.w	r0, r9, #16
 8049374:	f7f9 fd3c 	bl	8042df0 <conv2d_add_3to1>
 8049378:	e64e      	b.n	8049018 <kad_op_conv2d+0xad8>
 804937a:	2204      	movs	r2, #4
 804937c:	e6aa      	b.n	80490d4 <kad_op_conv2d+0xb94>
				conv2d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _ww, _xx));
 804937e:	f8d9 3014 	ldr.w	r3, [r9, #20]
 8049382:	f8d9 4010 	ldr.w	r4, [r9, #16]
 8049386:	461a      	mov	r2, r3
 8049388:	9304      	str	r3, [sp, #16]
 804938a:	f8db 3014 	ldr.w	r3, [fp, #20]
 804938e:	2c00      	cmp	r4, #0
 8049390:	fb02 f303 	mul.w	r3, r2, r3
 8049394:	dde9      	ble.n	804936a <kad_op_conv2d+0xe2a>
 8049396:	009b      	lsls	r3, r3, #2
 8049398:	4618      	mov	r0, r3
 804939a:	9b05      	ldr	r3, [sp, #20]
 804939c:	2b00      	cmp	r3, #0
 804939e:	f73f af1c 	bgt.w	80491da <kad_op_conv2d+0xc9a>
 80493a2:	e7e2      	b.n	804936a <kad_op_conv2d+0xe2a>
		for (j = 0; j < d[1]; ++j)
 80493a4:	9a15      	ldr	r2, [sp, #84]	@ 0x54
 80493a6:	4445      	add	r5, r8
 80493a8:	3201      	adds	r2, #1
 80493aa:	4596      	cmp	lr, r2
 80493ac:	f47f aeca 	bne.w	8049144 <kad_op_conv2d+0xc04>
 80493b0:	e9dd 3b0d 	ldrd	r3, fp, [sp, #52]	@ 0x34
 80493b4:	464c      	mov	r4, r9
 80493b6:	9e0f      	ldr	r6, [sp, #60]	@ 0x3c
 80493b8:	f8dd c044 	ldr.w	ip, [sp, #68]	@ 0x44
 80493bc:	f8dd 9050 	ldr.w	r9, [sp, #80]	@ 0x50
 80493c0:	e6ef      	b.n	80491a2 <kad_op_conv2d+0xc62>
			if (!algo_switch) {
 80493c2:	2f00      	cmp	r7, #0
 80493c4:	f47f ae6d 	bne.w	80490a2 <kad_op_conv2d+0xb62>
				conv2d_loop1(q->g, w->x, p->g, t, process_row_back_x);
 80493c8:	f8d9 3010 	ldr.w	r3, [r9, #16]
 80493cc:	2b00      	cmp	r3, #0
 80493ce:	dd08      	ble.n	80493e2 <kad_op_conv2d+0xea2>
 80493d0:	9b07      	ldr	r3, [sp, #28]
 80493d2:	2b00      	cmp	r3, #0
 80493d4:	dd05      	ble.n	80493e2 <kad_op_conv2d+0xea2>
 80493d6:	2900      	cmp	r1, #0
 80493d8:	dd03      	ble.n	80493e2 <kad_op_conv2d+0xea2>
 80493da:	9b05      	ldr	r3, [sp, #20]
 80493dc:	2b00      	cmp	r3, #0
 80493de:	f73f ad10 	bgt.w	8048e02 <kad_op_conv2d+0x8c2>
		if (kad_is_back(p->child[1])) { /* backprop to the weight matrix */
 80493e2:	7873      	ldrb	r3, [r6, #1]
 80493e4:	07db      	lsls	r3, r3, #31
 80493e6:	f57f a8c0 	bpl.w	804856a <kad_op_conv2d+0x2a>
			conv_rot180(w->d[0] * w->d[1], w->d[2] * w->d[3], w->g);
 80493ea:	f8d6 802c 	ldr.w	r8, [r6, #44]	@ 0x2c
			if (!algo_switch) {
 80493ee:	2f00      	cmp	r7, #0
 80493f0:	f040 8150 	bne.w	8049694 <kad_op_conv2d+0x1154>
				conv2d_loop1(q->x, w->g, p->g, t, process_row_back_w);
 80493f4:	f8d9 3010 	ldr.w	r3, [r9, #16]
 80493f8:	2b00      	cmp	r3, #0
 80493fa:	dc09      	bgt.n	8049410 <kad_op_conv2d+0xed0>
 80493fc:	f7ff b8b5 	b.w	804856a <kad_op_conv2d+0x2a>
				conv2d_loop1(q->g, w->x, p->g, t, process_row_back_x);
 8049400:	f8d9 3010 	ldr.w	r3, [r9, #16]
			if (!algo_switch) {
 8049404:	2f00      	cmp	r7, #0
 8049406:	f040 8145 	bne.w	8049694 <kad_op_conv2d+0x1154>
				conv2d_loop1(q->x, w->g, p->g, t, process_row_back_w);
 804940a:	2b00      	cmp	r3, #0
 804940c:	f77f a8ad 	ble.w	804856a <kad_op_conv2d+0x2a>
 8049410:	9b07      	ldr	r3, [sp, #28]
 8049412:	2b00      	cmp	r3, #0
 8049414:	f340 80f7 	ble.w	8049606 <kad_op_conv2d+0x10c6>
 8049418:	9b08      	ldr	r3, [sp, #32]
 804941a:	2b00      	cmp	r3, #0
 804941c:	f340 80f3 	ble.w	8049606 <kad_op_conv2d+0x10c6>
 8049420:	9805      	ldr	r0, [sp, #20]
 8049422:	2800      	cmp	r0, #0
 8049424:	f340 80ef 	ble.w	8049606 <kad_op_conv2d+0x10c6>
 8049428:	9a03      	ldr	r2, [sp, #12]
 804942a:	4646      	mov	r6, r8
 804942c:	0093      	lsls	r3, r2, #2
 804942e:	ebc2 7242 	rsb	r2, r2, r2, lsl #29
 8049432:	00d1      	lsls	r1, r2, #3
 8049434:	2200      	movs	r2, #0
 8049436:	468c      	mov	ip, r1
 8049438:	fb03 f700 	mul.w	r7, r3, r0
 804943c:	f8cd a054 	str.w	sl, [sp, #84]	@ 0x54
 8049440:	46ca      	mov	sl, r9
 8049442:	f8dd 9040 	ldr.w	r9, [sp, #64]	@ 0x40
 8049446:	9206      	str	r2, [sp, #24]
 8049448:	2400      	movs	r4, #0
 804944a:	f8dd 8014 	ldr.w	r8, [sp, #20]
 804944e:	940a      	str	r4, [sp, #40]	@ 0x28
 8049450:	fb08 f204 	mul.w	r2, r8, r4
 8049454:	fb03 6202 	mla	r2, r3, r2, r6
 8049458:	2100      	movs	r1, #0
 804945a:	441a      	add	r2, r3
 804945c:	e9cd 6416 	strd	r6, r4, [sp, #88]	@ 0x58
 8049460:	4614      	mov	r4, r2
 8049462:	461a      	mov	r2, r3
 8049464:	46c6      	mov	lr, r8
 8049466:	f8dd 8054 	ldr.w	r8, [sp, #84]	@ 0x54
 804946a:	910b      	str	r1, [sp, #44]	@ 0x2c
 804946c:	9714      	str	r7, [sp, #80]	@ 0x50
 804946e:	9518      	str	r5, [sp, #96]	@ 0x60
				conv2d_loop1(q->g, w->x, p->g, t, process_row_back_x);
 8049470:	f8d8 3018 	ldr.w	r3, [r8, #24]
 8049474:	4619      	mov	r1, r3
 8049476:	2900      	cmp	r1, #0
 8049478:	9302      	str	r3, [sp, #8]
				conv2d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _ww, _xx));
 804947a:	f8db 3008 	ldr.w	r3, [fp, #8]
 804947e:	f340 80a1 	ble.w	80495c4 <kad_op_conv2d+0x1084>
 8049482:	425d      	negs	r5, r3
 8049484:	ebae 0303 	sub.w	r3, lr, r3
				conv2d_loop1(q->g, w->x, p->g, t, process_row_back_x);
 8049488:	4627      	mov	r7, r4
 804948a:	e9cd e419 	strd	lr, r4, [sp, #100]	@ 0x64
 804948e:	4666      	mov	r6, ip
 8049490:	462c      	mov	r4, r5
 8049492:	4615      	mov	r5, r2
 8049494:	461a      	mov	r2, r3
				conv2d_loop1(q->x, w->g, p->g, t, process_row_back_w);
 8049496:	1b79      	subs	r1, r7, r5
 8049498:	2c00      	cmp	r4, #0
 804949a:	4623      	mov	r3, r4
 804949c:	910d      	str	r1, [sp, #52]	@ 0x34
 804949e:	f2c0 8086 	blt.w	80495ae <kad_op_conv2d+0x106e>
 80494a2:	2100      	movs	r1, #0
 80494a4:	e9cd 4511 	strd	r4, r5, [sp, #68]	@ 0x44
 80494a8:	9100      	str	r1, [sp, #0]
				conv2d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _ww, _xx));
 80494aa:	f8da 1018 	ldr.w	r1, [sl, #24]
 80494ae:	920f      	str	r2, [sp, #60]	@ 0x3c
 80494b0:	9104      	str	r1, [sp, #16]
 80494b2:	9613      	str	r6, [sp, #76]	@ 0x4c
				conv2d_loop1(q->x, w->g, p->g, t, process_row_back_w);
 80494b4:	9a04      	ldr	r2, [sp, #16]
 80494b6:	4293      	cmp	r3, r2
 80494b8:	da75      	bge.n	80495a6 <kad_op_conv2d+0x1066>
 80494ba:	9906      	ldr	r1, [sp, #24]
 80494bc:	f8da 2014 	ldr.w	r2, [sl, #20]
 80494c0:	980b      	ldr	r0, [sp, #44]	@ 0x2c
 80494c2:	f8d8 401c 	ldr.w	r4, [r8, #28]
 80494c6:	fb02 0501 	mla	r5, r2, r1, r0
 80494ca:	9a04      	ldr	r2, [sp, #16]
 80494cc:	980a      	ldr	r0, [sp, #40]	@ 0x28
 80494ce:	fb02 3505 	mla	r5, r2, r5, r3
 80494d2:	f8d8 2014 	ldr.w	r2, [r8, #20]
 80494d6:	fb02 0001 	mla	r0, r2, r1, r0
 80494da:	9a00      	ldr	r2, [sp, #0]
 80494dc:	9902      	ldr	r1, [sp, #8]
 80494de:	fb01 2000 	mla	r0, r1, r0, r2
 80494e2:	f8da 201c 	ldr.w	r2, [sl, #28]
 80494e6:	fb04 f000 	mul.w	r0, r4, r0
 80494ea:	fb02 f505 	mul.w	r5, r2, r5
 80494ee:	f8da 1028 	ldr.w	r1, [sl, #40]	@ 0x28
 80494f2:	eb01 0185 	add.w	r1, r1, r5, lsl #2
 80494f6:	f8d8 502c 	ldr.w	r5, [r8, #44]	@ 0x2c
 80494fa:	eb05 0580 	add.w	r5, r5, r0, lsl #2
 80494fe:	9801      	ldr	r0, [sp, #4]
 8049500:	b150      	cbz	r0, 8049518 <kad_op_conv2d+0xfd8>
 8049502:	f8db 6018 	ldr.w	r6, [fp, #24]
 8049506:	0092      	lsls	r2, r2, #2
 8049508:	eb00 0686 	add.w	r6, r0, r6, lsl #2
 804950c:	4630      	mov	r0, r6
 804950e:	930e      	str	r3, [sp, #56]	@ 0x38
 8049510:	f002 fd8d 	bl	804c02e <memcpy>
 8049514:	4631      	mov	r1, r6
 8049516:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
 8049518:	f8db 2014 	ldr.w	r2, [fp, #20]
 804951c:	2a01      	cmp	r2, #1
 804951e:	f340 8093 	ble.w	8049648 <kad_op_conv2d+0x1108>
 8049522:	9803      	ldr	r0, [sp, #12]
 8049524:	2800      	cmp	r0, #0
 8049526:	dd31      	ble.n	804958c <kad_op_conv2d+0x104c>
 8049528:	f8db 0018 	ldr.w	r0, [fp, #24]
 804952c:	f8dd c034 	ldr.w	ip, [sp, #52]	@ 0x34
 8049530:	ebc0 7080 	rsb	r0, r0, r0, lsl #30
 8049534:	eb01 0680 	add.w	r6, r1, r0, lsl #2
 8049538:	0092      	lsls	r2, r2, #2
 804953a:	eb09 0084 	add.w	r0, r9, r4, lsl #2
 804953e:	eb05 0184 	add.w	r1, r5, r4, lsl #2
 8049542:	f8cd b038 	str.w	fp, [sp, #56]	@ 0x38
 8049546:	2c00      	cmp	r4, #0
 8049548:	46b6      	mov	lr, r6
 804954a:	dd7a      	ble.n	8049642 <kad_op_conv2d+0x1102>
 804954c:	46cb      	mov	fp, r9
 804954e:	edde 7a00 	vldr	s15, [lr]
 8049552:	eceb 7a01 	vstmia	fp!, {s15}
 8049556:	4558      	cmp	r0, fp
 8049558:	4496      	add	lr, r2
 804955a:	d1f8      	bne.n	804954e <kad_op_conv2d+0x100e>
	float s = 0.;
 804955c:	eddf 7a7b 	vldr	s15, [pc, #492]	@ 804974c <kad_op_conv2d+0x120c>
 8049560:	46cb      	mov	fp, r9
 8049562:	46ae      	mov	lr, r5
	for (i = 0; i < n; ++i) s += x[i] * y[i];
 8049564:	ecfe 6a01 	vldmia	lr!, {s13}
 8049568:	ecbb 7a01 	vldmia	fp!, {s14}
 804956c:	4571      	cmp	r1, lr
 804956e:	eee6 7a87 	vfma.f32	s15, s13, s14
 8049572:	d1f7      	bne.n	8049564 <kad_op_conv2d+0x1024>
				conv2d_loop1(q->x, w->g, p->g, t, process_row_back_w);
 8049574:	ed9c 7a00 	vldr	s14, [ip]
 8049578:	ee77 7a27 	vadd.f32	s15, s14, s15
 804957c:	ecec 7a01 	vstmia	ip!, {s15}
 8049580:	4567      	cmp	r7, ip
 8049582:	f106 0604 	add.w	r6, r6, #4
 8049586:	d1de      	bne.n	8049546 <kad_op_conv2d+0x1006>
 8049588:	f8dd b038 	ldr.w	fp, [sp, #56]	@ 0x38
 804958c:	9a00      	ldr	r2, [sp, #0]
 804958e:	3201      	adds	r2, #1
 8049590:	4611      	mov	r1, r2
 8049592:	9200      	str	r2, [sp, #0]
 8049594:	f8db 2004 	ldr.w	r2, [fp, #4]
 8049598:	4413      	add	r3, r2
 804959a:	460a      	mov	r2, r1
 804959c:	9902      	ldr	r1, [sp, #8]
 804959e:	428a      	cmp	r2, r1
 80495a0:	d001      	beq.n	80495a6 <kad_op_conv2d+0x1066>
 80495a2:	2b00      	cmp	r3, #0
 80495a4:	da86      	bge.n	80494b4 <kad_op_conv2d+0xf74>
 80495a6:	9a0f      	ldr	r2, [sp, #60]	@ 0x3c
 80495a8:	9e13      	ldr	r6, [sp, #76]	@ 0x4c
 80495aa:	e9dd 4511 	ldrd	r4, r5, [sp, #68]	@ 0x44
 80495ae:	9b0d      	ldr	r3, [sp, #52]	@ 0x34
 80495b0:	3401      	adds	r4, #1
 80495b2:	42a2      	cmp	r2, r4
 80495b4:	eba3 0706 	sub.w	r7, r3, r6
 80495b8:	f47f af6d 	bne.w	8049496 <kad_op_conv2d+0xf56>
 80495bc:	e9dd e419 	ldrd	lr, r4, [sp, #100]	@ 0x64
 80495c0:	462a      	mov	r2, r5
 80495c2:	46b4      	mov	ip, r6
 80495c4:	9914      	ldr	r1, [sp, #80]	@ 0x50
 80495c6:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 80495c8:	440c      	add	r4, r1
 80495ca:	9908      	ldr	r1, [sp, #32]
 80495cc:	3301      	adds	r3, #1
 80495ce:	4299      	cmp	r1, r3
 80495d0:	930b      	str	r3, [sp, #44]	@ 0x2c
 80495d2:	f47f af4d 	bne.w	8049470 <kad_op_conv2d+0xf30>
 80495d6:	e9dd 6416 	ldrd	r6, r4, [sp, #88]	@ 0x58
 80495da:	4613      	mov	r3, r2
 80495dc:	9a0a      	ldr	r2, [sp, #40]	@ 0x28
 80495de:	440c      	add	r4, r1
 80495e0:	9907      	ldr	r1, [sp, #28]
 80495e2:	3201      	adds	r2, #1
 80495e4:	428a      	cmp	r2, r1
 80495e6:	46f0      	mov	r8, lr
 80495e8:	9f14      	ldr	r7, [sp, #80]	@ 0x50
 80495ea:	9d18      	ldr	r5, [sp, #96]	@ 0x60
 80495ec:	920a      	str	r2, [sp, #40]	@ 0x28
 80495ee:	f47f af2f 	bne.w	8049450 <kad_op_conv2d+0xf10>
 80495f2:	9a06      	ldr	r2, [sp, #24]
 80495f4:	3201      	adds	r2, #1
 80495f6:	4611      	mov	r1, r2
 80495f8:	9206      	str	r2, [sp, #24]
 80495fa:	f8da 2010 	ldr.w	r2, [sl, #16]
 80495fe:	428a      	cmp	r2, r1
 8049600:	f73f af22 	bgt.w	8049448 <kad_op_conv2d+0xf08>
 8049604:	46b0      	mov	r8, r6
	for (i = 0; i < d0; ++i) {
 8049606:	2d00      	cmp	r5, #0
 8049608:	f77e afaf 	ble.w	804856a <kad_op_conv2d+0x2a>
		for (j = 0; j < d1>>1; ++j)
 804960c:	9a1c      	ldr	r2, [sp, #112]	@ 0x70
 804960e:	1053      	asrs	r3, r2, #1
 8049610:	2b00      	cmp	r3, #0
 8049612:	f77e afaa 	ble.w	804856a <kad_op_conv2d+0x2a>
 8049616:	ea4f 0c82 	mov.w	ip, r2, lsl #2
 804961a:	4641      	mov	r1, r8
				conv2d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _xx, _ww));
 804961c:	2000      	movs	r0, #0
 804961e:	009b      	lsls	r3, r3, #2
		for (j = 0; j < d1>>1; ++j)
 8049620:	460a      	mov	r2, r1
 8049622:	4461      	add	r1, ip
				conv2d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _xx, _ww));
 8049624:	460c      	mov	r4, r1
 8049626:	18d6      	adds	r6, r2, r3
			tmp = xi[j], xi[j] = xi[d1-1-j], xi[d1-1-j] = tmp; 
 8049628:	f854 ed04 	ldr.w	lr, [r4, #-4]!
 804962c:	6817      	ldr	r7, [r2, #0]
 804962e:	f842 eb04 	str.w	lr, [r2], #4
		for (j = 0; j < d1>>1; ++j)
 8049632:	4296      	cmp	r6, r2
			tmp = xi[j], xi[j] = xi[d1-1-j], xi[d1-1-j] = tmp; 
 8049634:	6027      	str	r7, [r4, #0]
		for (j = 0; j < d1>>1; ++j)
 8049636:	d1f7      	bne.n	8049628 <kad_op_conv2d+0x10e8>
	for (i = 0; i < d0; ++i) {
 8049638:	3001      	adds	r0, #1
 804963a:	4285      	cmp	r5, r0
 804963c:	d1f0      	bne.n	8049620 <kad_op_conv2d+0x10e0>
 804963e:	f7fe bf94 	b.w	804856a <kad_op_conv2d+0x2a>
	float s = 0.;
 8049642:	eddf 7a42 	vldr	s15, [pc, #264]	@ 804974c <kad_op_conv2d+0x120c>
 8049646:	e795      	b.n	8049574 <kad_op_conv2d+0x1034>
				conv2d_loop1(q->x, w->g, p->g, t, process_row_back_w);
 8049648:	9a03      	ldr	r2, [sp, #12]
 804964a:	2a00      	cmp	r2, #0
 804964c:	dd9e      	ble.n	804958c <kad_op_conv2d+0x104c>
 804964e:	f8db 2018 	ldr.w	r2, [fp, #24]
 8049652:	9e0d      	ldr	r6, [sp, #52]	@ 0x34
 8049654:	ebc2 7282 	rsb	r2, r2, r2, lsl #30
 8049658:	ea4f 0e82 	mov.w	lr, r2, lsl #2
 804965c:	eb05 0c84 	add.w	ip, r5, r4, lsl #2
	for (i = 0; i < n; ++i) s += x[i] * y[i];
 8049660:	2c00      	cmp	r4, #0
	float s = 0.;
 8049662:	eddf 7a3a 	vldr	s15, [pc, #232]	@ 804974c <kad_op_conv2d+0x120c>
	for (i = 0; i < n; ++i) s += x[i] * y[i];
 8049666:	dd0a      	ble.n	804967e <kad_op_conv2d+0x113e>
 8049668:	462a      	mov	r2, r5
 804966a:	eb01 000e 	add.w	r0, r1, lr
 804966e:	ecf2 6a01 	vldmia	r2!, {s13}
 8049672:	ecb0 7a01 	vldmia	r0!, {s14}
 8049676:	4594      	cmp	ip, r2
 8049678:	eee6 7a87 	vfma.f32	s15, s13, s14
 804967c:	d1f7      	bne.n	804966e <kad_op_conv2d+0x112e>
				conv2d_loop1(q->x, w->g, p->g, t, process_row_back_w);
 804967e:	ed96 7a00 	vldr	s14, [r6]
 8049682:	ee77 7a27 	vadd.f32	s15, s14, s15
 8049686:	ece6 7a01 	vstmia	r6!, {s15}
 804968a:	42b7      	cmp	r7, r6
 804968c:	f10e 0e04 	add.w	lr, lr, #4
 8049690:	d1e6      	bne.n	8049660 <kad_op_conv2d+0x1120>
 8049692:	e77b      	b.n	804958c <kad_op_conv2d+0x104c>
	for (i = 0; i < d[0]; ++i)
 8049694:	f8d9 3010 	ldr.w	r3, [r9, #16]
				conv2d_move_1to3(q->d, q->x, q1);
 8049698:	f8d9 2028 	ldr.w	r2, [r9, #40]	@ 0x28
	for (i = 0; i < d[0]; ++i)
 804969c:	2b00      	cmp	r3, #0
 804969e:	9304      	str	r3, [sp, #16]
				conv2d_move_1to3(q->d, q->x, q1);
 80496a0:	9202      	str	r2, [sp, #8]
	for (i = 0; i < d[0]; ++i)
 80496a2:	f340 8192 	ble.w	80499ca <kad_op_conv2d+0x148a>
		for (j = 0; j < d[1]; ++j)
 80496a6:	f8d9 7014 	ldr.w	r7, [r9, #20]
 80496aa:	2f00      	cmp	r7, #0
 80496ac:	dd5a      	ble.n	8049764 <kad_op_conv2d+0x1224>
			for (k = 0; k < d[2]; ++k) {
 80496ae:	f04f 0c00 	mov.w	ip, #0
	for (i = 0; i < d[0]; ++i)
 80496b2:	46e6      	mov	lr, ip
 80496b4:	00bb      	lsls	r3, r7, #2
			for (k = 0; k < d[2]; ++k) {
 80496b6:	f8d9 0018 	ldr.w	r0, [r9, #24]
 80496ba:	930b      	str	r3, [sp, #44]	@ 0x2c
		for (j = 0; j < d[1]; ++j)
 80496bc:	2800      	cmp	r0, #0
				int ik = (i * d[2] + k) * d[3], ijk = ((i * d[1] + j) * d[2] + k) * d[3];
 80496be:	fb00 f20e 	mul.w	r2, r0, lr
 80496c2:	dd49      	ble.n	8049758 <kad_op_conv2d+0x1218>
 80496c4:	f8d9 301c 	ldr.w	r3, [r9, #28]
 80496c8:	fb00 f40c 	mul.w	r4, r0, ip
 80496cc:	fb03 f202 	mul.w	r2, r3, r2
 80496d0:	fb07 f202 	mul.w	r2, r7, r2
 80496d4:	9208      	str	r2, [sp, #32]
 80496d6:	fb03 f207 	mul.w	r2, r3, r7
 80496da:	0092      	lsls	r2, r2, #2
 80496dc:	920a      	str	r2, [sp, #40]	@ 0x28
		for (j = 0; j < d[1]; ++j)
 80496de:	2200      	movs	r2, #0
 80496e0:	0099      	lsls	r1, r3, #2
 80496e2:	9106      	str	r1, [sp, #24]
			for (k = 0; k < d[2]; ++k) {
 80496e4:	2b00      	cmp	r3, #0
 80496e6:	dd33      	ble.n	8049750 <kad_op_conv2d+0x1210>
 80496e8:	e9cd 8c0d 	strd	r8, ip, [sp, #52]	@ 0x34
 80496ec:	f8cd b03c 	str.w	fp, [sp, #60]	@ 0x3c
 80496f0:	f8cd 9044 	str.w	r9, [sp, #68]	@ 0x44
 80496f4:	9600      	str	r6, [sp, #0]
 80496f6:	f04f 0900 	mov.w	r9, #0
 80496fa:	fb04 fb03 	mul.w	fp, r4, r3
 80496fe:	9e08      	ldr	r6, [sp, #32]
 8049700:	990c      	ldr	r1, [sp, #48]	@ 0x30
 8049702:	4416      	add	r6, r2
 8049704:	eb01 0686 	add.w	r6, r1, r6, lsl #2
 8049708:	9902      	ldr	r1, [sp, #8]
 804970a:	eb0b 0c03 	add.w	ip, fp, r3
 804970e:	eb01 088c 	add.w	r8, r1, ip, lsl #2
 8049712:	9900      	ldr	r1, [sp, #0]
 8049714:	9413      	str	r4, [sp, #76]	@ 0x4c
				for (l = 0; l < d[3]; ++l)
 8049716:	9c02      	ldr	r4, [sp, #8]
			for (k = 0; k < d[2]; ++k) {
 8049718:	9300      	str	r3, [sp, #0]
 804971a:	eb04 048b 	add.w	r4, r4, fp, lsl #2
 804971e:	46b3      	mov	fp, r6
					y[(ik + l) * d[1] + j] = x[ijk + l];
 8049720:	ecf4 7a01 	vldmia	r4!, {s15}
				for (l = 0; l < d[3]; ++l)
 8049724:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 8049726:	45a0      	cmp	r8, r4
					y[(ik + l) * d[1] + j] = x[ijk + l];
 8049728:	edcb 7a00 	vstr	s15, [fp]
				for (l = 0; l < d[3]; ++l)
 804972c:	449b      	add	fp, r3
 804972e:	d1f7      	bne.n	8049720 <kad_op_conv2d+0x11e0>
			for (k = 0; k < d[2]; ++k) {
 8049730:	9c0a      	ldr	r4, [sp, #40]	@ 0x28
 8049732:	f109 0901 	add.w	r9, r9, #1
 8049736:	4426      	add	r6, r4
 8049738:	9c06      	ldr	r4, [sp, #24]
 804973a:	4581      	cmp	r9, r0
 804973c:	46e3      	mov	fp, ip
 804973e:	9b00      	ldr	r3, [sp, #0]
 8049740:	44a0      	add	r8, r4
 8049742:	f000 8133 	beq.w	80499ac <kad_op_conv2d+0x146c>
 8049746:	449c      	add	ip, r3
 8049748:	e7e5      	b.n	8049716 <kad_op_conv2d+0x11d6>
 804974a:	bf00      	nop
 804974c:	00000000 	.word	0x00000000
		for (j = 0; j < d[1]; ++j)
 8049750:	3201      	adds	r2, #1
 8049752:	42ba      	cmp	r2, r7
 8049754:	4404      	add	r4, r0
 8049756:	d1c5      	bne.n	80496e4 <kad_op_conv2d+0x11a4>
	for (i = 0; i < d[0]; ++i)
 8049758:	9b04      	ldr	r3, [sp, #16]
 804975a:	f10e 0e01 	add.w	lr, lr, #1
 804975e:	459e      	cmp	lr, r3
 8049760:	44bc      	add	ip, r7
 8049762:	d1ab      	bne.n	80496bc <kad_op_conv2d+0x117c>
 8049764:	7832      	ldrb	r2, [r6, #0]
 8049766:	4613      	mov	r3, r2
 8049768:	2a00      	cmp	r2, #0
 804976a:	f000 8116 	beq.w	804999a <kad_op_conv2d+0x145a>
 804976e:	2b01      	cmp	r3, #1
 8049770:	f000 8111 	beq.w	8049996 <kad_op_conv2d+0x1456>
 8049774:	2b02      	cmp	r3, #2
 8049776:	462a      	mov	r2, r5
 8049778:	d007      	beq.n	804978a <kad_op_conv2d+0x124a>
 804977a:	9a05      	ldr	r2, [sp, #20]
 804977c:	2b03      	cmp	r3, #3
 804977e:	fb02 f205 	mul.w	r2, r2, r5
 8049782:	d002      	beq.n	804978a <kad_op_conv2d+0x124a>
 8049784:	9b03      	ldr	r3, [sp, #12]
 8049786:	fb03 f202 	mul.w	r2, r3, r2
				memset(w1, 0, kad_len(w) * sizeof(float));
 804978a:	0092      	lsls	r2, r2, #2
 804978c:	2100      	movs	r1, #0
 804978e:	9809      	ldr	r0, [sp, #36]	@ 0x24
 8049790:	f002 fb50 	bl	804be34 <memset>
				conv2d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _xx, _ww));
 8049794:	9a04      	ldr	r2, [sp, #16]
 8049796:	f8d9 7014 	ldr.w	r7, [r9, #20]
 804979a:	f8db 3014 	ldr.w	r3, [fp, #20]
 804979e:	2a00      	cmp	r2, #0
 80497a0:	fb07 f303 	mul.w	r3, r7, r3
 80497a4:	f340 80ee 	ble.w	8049984 <kad_op_conv2d+0x1444>
 80497a8:	009a      	lsls	r2, r3, #2
 80497aa:	9214      	str	r2, [sp, #80]	@ 0x50
 80497ac:	9a07      	ldr	r2, [sp, #28]
 80497ae:	2a00      	cmp	r2, #0
 80497b0:	f340 80e8 	ble.w	8049984 <kad_op_conv2d+0x1444>
 80497b4:	9905      	ldr	r1, [sp, #20]
 80497b6:	2900      	cmp	r1, #0
 80497b8:	f340 80e4 	ble.w	8049984 <kad_op_conv2d+0x1444>
 80497bc:	00db      	lsls	r3, r3, #3
 80497be:	9315      	str	r3, [sp, #84]	@ 0x54
 80497c0:	9b12      	ldr	r3, [sp, #72]	@ 0x48
 80497c2:	9718      	str	r7, [sp, #96]	@ 0x60
 80497c4:	009a      	lsls	r2, r3, #2
 80497c6:	fb02 f101 	mul.w	r1, r2, r1
 80497ca:	2300      	movs	r3, #0
 80497cc:	4647      	mov	r7, r8
 80497ce:	f8cd b00c 	str.w	fp, [sp, #12]
 80497d2:	4688      	mov	r8, r1
 80497d4:	46d3      	mov	fp, sl
 80497d6:	462c      	mov	r4, r5
 80497d8:	9300      	str	r3, [sp, #0]
 80497da:	f8cd 903c 	str.w	r9, [sp, #60]	@ 0x3c
 80497de:	4641      	mov	r1, r8
 80497e0:	4692      	mov	sl, r2
 80497e2:	2000      	movs	r0, #0
 80497e4:	463a      	mov	r2, r7
 80497e6:	46d8      	mov	r8, fp
 80497e8:	9d09      	ldr	r5, [sp, #36]	@ 0x24
				conv2d_loop1(q->g, w->x, p->g, t, process_row_back_x);
 80497ea:	f8d8 7018 	ldr.w	r7, [r8, #24]
				conv2d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _ww, _xx));
 80497ee:	9b03      	ldr	r3, [sp, #12]
 80497f0:	2f00      	cmp	r7, #0
 80497f2:	689b      	ldr	r3, [r3, #8]
				conv2d_loop1(q->g, w->x, p->g, t, process_row_back_x);
 80497f4:	970e      	str	r7, [sp, #56]	@ 0x38
 80497f6:	f340 80b2 	ble.w	804995e <kad_op_conv2d+0x141e>
 80497fa:	9f05      	ldr	r7, [sp, #20]
 80497fc:	f1c3 0b00 	rsb	fp, r3, #0
 8049800:	1afb      	subs	r3, r7, r3
 8049802:	46a9      	mov	r9, r5
 8049804:	e9cd 151a 	strd	r1, r5, [sp, #104]	@ 0x68
 8049808:	eb05 070a 	add.w	r7, r5, sl
 804980c:	461d      	mov	r5, r3
 804980e:	9619      	str	r6, [sp, #100]	@ 0x64
 8049810:	9011      	str	r0, [sp, #68]	@ 0x44
				conv2d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _xx, _ww));
 8049812:	f1bb 0f00 	cmp.w	fp, #0
 8049816:	465e      	mov	r6, fp
 8049818:	f2c0 8096 	blt.w	8049948 <kad_op_conv2d+0x1408>
 804981c:	2100      	movs	r1, #0
				conv2d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _ww, _xx));
 804981e:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
				conv2d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _xx, _ww));
 8049820:	9102      	str	r1, [sp, #8]
				conv2d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _ww, _xx));
 8049822:	699b      	ldr	r3, [r3, #24]
				conv2d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _xx, _ww));
 8049824:	9900      	ldr	r1, [sp, #0]
				conv2d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _ww, _xx));
 8049826:	9316      	str	r3, [sp, #88]	@ 0x58
				conv2d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _xx, _ww));
 8049828:	fb03 f301 	mul.w	r3, r3, r1
 804982c:	e9cd ba0a 	strd	fp, sl, [sp, #40]	@ 0x28
 8049830:	940d      	str	r4, [sp, #52]	@ 0x34
 8049832:	9c14      	ldr	r4, [sp, #80]	@ 0x50
 8049834:	9313      	str	r3, [sp, #76]	@ 0x4c
 8049836:	9206      	str	r2, [sp, #24]
 8049838:	9508      	str	r5, [sp, #32]
 804983a:	9b16      	ldr	r3, [sp, #88]	@ 0x58
 804983c:	429e      	cmp	r6, r3
 804983e:	da7e      	bge.n	804993e <kad_op_conv2d+0x13fe>
 8049840:	9a11      	ldr	r2, [sp, #68]	@ 0x44
 8049842:	9900      	ldr	r1, [sp, #0]
 8049844:	f8d8 3014 	ldr.w	r3, [r8, #20]
 8049848:	9818      	ldr	r0, [sp, #96]	@ 0x60
 804984a:	fb03 2301 	mla	r3, r3, r1, r2
 804984e:	9a02      	ldr	r2, [sp, #8]
 8049850:	990e      	ldr	r1, [sp, #56]	@ 0x38
 8049852:	f8d8 a01c 	ldr.w	sl, [r8, #28]
 8049856:	fb01 2303 	mla	r3, r1, r3, r2
 804985a:	9a0f      	ldr	r2, [sp, #60]	@ 0x3c
 804985c:	9913      	ldr	r1, [sp, #76]	@ 0x4c
 804985e:	69d2      	ldr	r2, [r2, #28]
 8049860:	4431      	add	r1, r6
 8049862:	fb02 f101 	mul.w	r1, r2, r1
 8049866:	fb00 f101 	mul.w	r1, r0, r1
 804986a:	fb0a f303 	mul.w	r3, sl, r3
 804986e:	9d0c      	ldr	r5, [sp, #48]	@ 0x30
 8049870:	eb05 0181 	add.w	r1, r5, r1, lsl #2
 8049874:	f8d8 502c 	ldr.w	r5, [r8, #44]	@ 0x2c
 8049878:	eb05 0583 	add.w	r5, r5, r3, lsl #2
 804987c:	9b01      	ldr	r3, [sp, #4]
 804987e:	b163      	cbz	r3, 804989a <kad_op_conv2d+0x135a>
 8049880:	9b03      	ldr	r3, [sp, #12]
 8049882:	fb00 f202 	mul.w	r2, r0, r2
 8049886:	699b      	ldr	r3, [r3, #24]
 8049888:	0092      	lsls	r2, r2, #2
 804988a:	fb00 f303 	mul.w	r3, r0, r3
 804988e:	9801      	ldr	r0, [sp, #4]
 8049890:	eb00 0083 	add.w	r0, r0, r3, lsl #2
 8049894:	f002 fbcb 	bl	804c02e <memcpy>
 8049898:	9901      	ldr	r1, [sp, #4]
 804989a:	f1ba 0f00 	cmp.w	sl, #0
 804989e:	dd42      	ble.n	8049926 <kad_op_conv2d+0x13e6>
 80498a0:	9b12      	ldr	r3, [sp, #72]	@ 0x48
 80498a2:	2b00      	cmp	r3, #0
 80498a4:	dd3f      	ble.n	8049926 <kad_op_conv2d+0x13e6>
 80498a6:	f10a 33ff 	add.w	r3, sl, #4294967295
 80498aa:	f1ba 0f02 	cmp.w	sl, #2
 80498ae:	9317      	str	r3, [sp, #92]	@ 0x5c
 80498b0:	dd6f      	ble.n	8049992 <kad_op_conv2d+0x1452>
 80498b2:	2301      	movs	r3, #1
 80498b4:	f105 0b04 	add.w	fp, r5, #4
 80498b8:	eb01 0e04 	add.w	lr, r1, r4
 80498bc:	ed5b 5a01 	vldr	s11, [fp, #-4]
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 80498c0:	ed95 6a01 	vldr	s12, [r5, #4]
				conv2d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _xx, _ww));
 80498c4:	46f4      	mov	ip, lr
 80498c6:	4608      	mov	r0, r1
 80498c8:	464a      	mov	r2, r9
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 80498ca:	edd2 7a00 	vldr	s15, [r2]
 80498ce:	ecf0 6a01 	vldmia	r0!, {s13}
 80498d2:	ecbc 7a01 	vldmia	ip!, {s14}
 80498d6:	eee5 7aa6 	vfma.f32	s15, s11, s13
 80498da:	eee7 7a06 	vfma.f32	s15, s14, s12
 80498de:	ece2 7a01 	vstmia	r2!, {s15}
 80498e2:	4297      	cmp	r7, r2
 80498e4:	d1f1      	bne.n	80498ca <kad_op_conv2d+0x138a>
				conv2d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _xx, _ww));
 80498e6:	9a15      	ldr	r2, [sp, #84]	@ 0x54
 80498e8:	9817      	ldr	r0, [sp, #92]	@ 0x5c
 80498ea:	4411      	add	r1, r2
 80498ec:	4496      	add	lr, r2
 80498ee:	1c9a      	adds	r2, r3, #2
 80498f0:	4282      	cmp	r2, r0
 80498f2:	f105 0508 	add.w	r5, r5, #8
 80498f6:	f10b 0b08 	add.w	fp, fp, #8
 80498fa:	da01      	bge.n	8049900 <kad_op_conv2d+0x13c0>
 80498fc:	4613      	mov	r3, r2
 80498fe:	e7dd      	b.n	80498bc <kad_op_conv2d+0x137c>
 8049900:	3301      	adds	r3, #1
 8049902:	ecf5 6a01 	vldmia	r5!, {s13}
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 8049906:	4608      	mov	r0, r1
				conv2d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _xx, _ww));
 8049908:	464a      	mov	r2, r9
	for (i = 0; i < n; ++i) y[i] += a * x[i];
 804990a:	edd2 7a00 	vldr	s15, [r2]
 804990e:	ecb0 7a01 	vldmia	r0!, {s14}
 8049912:	eee7 7a26 	vfma.f32	s15, s14, s13
 8049916:	ece2 7a01 	vstmia	r2!, {s15}
 804991a:	4297      	cmp	r7, r2
 804991c:	d1f5      	bne.n	804990a <kad_op_conv2d+0x13ca>
				conv2d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _xx, _ww));
 804991e:	3301      	adds	r3, #1
 8049920:	459a      	cmp	sl, r3
 8049922:	4421      	add	r1, r4
 8049924:	dced      	bgt.n	8049902 <kad_op_conv2d+0x13c2>
 8049926:	9b03      	ldr	r3, [sp, #12]
 8049928:	9a02      	ldr	r2, [sp, #8]
 804992a:	685b      	ldr	r3, [r3, #4]
 804992c:	3201      	adds	r2, #1
 804992e:	441e      	add	r6, r3
 8049930:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
 8049932:	9202      	str	r2, [sp, #8]
 8049934:	429a      	cmp	r2, r3
 8049936:	d002      	beq.n	804993e <kad_op_conv2d+0x13fe>
 8049938:	2e00      	cmp	r6, #0
 804993a:	f6bf af7e 	bge.w	804983a <kad_op_conv2d+0x12fa>
 804993e:	9a06      	ldr	r2, [sp, #24]
 8049940:	9d08      	ldr	r5, [sp, #32]
 8049942:	9c0d      	ldr	r4, [sp, #52]	@ 0x34
 8049944:	e9dd ba0a 	ldrd	fp, sl, [sp, #40]	@ 0x28
 8049948:	f10b 0b01 	add.w	fp, fp, #1
 804994c:	455d      	cmp	r5, fp
 804994e:	44d1      	add	r9, sl
 8049950:	4457      	add	r7, sl
 8049952:	f47f af5e 	bne.w	8049812 <kad_op_conv2d+0x12d2>
 8049956:	e9dd 151a 	ldrd	r1, r5, [sp, #104]	@ 0x68
 804995a:	9e19      	ldr	r6, [sp, #100]	@ 0x64
 804995c:	9811      	ldr	r0, [sp, #68]	@ 0x44
 804995e:	9b07      	ldr	r3, [sp, #28]
 8049960:	3001      	adds	r0, #1
 8049962:	4298      	cmp	r0, r3
 8049964:	440d      	add	r5, r1
 8049966:	f47f af40 	bne.w	80497ea <kad_op_conv2d+0x12aa>
 804996a:	9b00      	ldr	r3, [sp, #0]
 804996c:	46c3      	mov	fp, r8
 804996e:	4688      	mov	r8, r1
 8049970:	9904      	ldr	r1, [sp, #16]
 8049972:	3301      	adds	r3, #1
 8049974:	428b      	cmp	r3, r1
 8049976:	4617      	mov	r7, r2
 8049978:	9300      	str	r3, [sp, #0]
 804997a:	4652      	mov	r2, sl
 804997c:	f47f af2f 	bne.w	80497de <kad_op_conv2d+0x129e>
 8049980:	46b8      	mov	r8, r7
 8049982:	4625      	mov	r5, r4
				conv2d_add_3to1(w->d, w1, w->g);
 8049984:	4642      	mov	r2, r8
 8049986:	9909      	ldr	r1, [sp, #36]	@ 0x24
 8049988:	f106 0010 	add.w	r0, r6, #16
 804998c:	f7f9 fa30 	bl	8042df0 <conv2d_add_3to1>
 8049990:	e639      	b.n	8049606 <kad_op_conv2d+0x10c6>
				conv2d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _xx, _ww));
 8049992:	2300      	movs	r3, #0
 8049994:	e7b5      	b.n	8049902 <kad_op_conv2d+0x13c2>
 8049996:	9a07      	ldr	r2, [sp, #28]
 8049998:	e6f7      	b.n	804978a <kad_op_conv2d+0x124a>
				memset(w1, 0, kad_len(w) * sizeof(float));
 804999a:	9b09      	ldr	r3, [sp, #36]	@ 0x24
				conv2d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _xx, _ww));
 804999c:	f8d9 7014 	ldr.w	r7, [r9, #20]
				memset(w1, 0, kad_len(w) * sizeof(float));
 80499a0:	601a      	str	r2, [r3, #0]
				conv2d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _xx, _ww));
 80499a2:	f8db 3014 	ldr.w	r3, [fp, #20]
 80499a6:	fb07 f303 	mul.w	r3, r7, r3
 80499aa:	e6fd      	b.n	80497a8 <kad_op_conv2d+0x1268>
		for (j = 0; j < d[1]; ++j)
 80499ac:	9c13      	ldr	r4, [sp, #76]	@ 0x4c
 80499ae:	3201      	adds	r2, #1
 80499b0:	4297      	cmp	r7, r2
 80499b2:	9100      	str	r1, [sp, #0]
 80499b4:	4404      	add	r4, r0
 80499b6:	f47f ae9e 	bne.w	80496f6 <kad_op_conv2d+0x11b6>
 80499ba:	e9dd 8c0d 	ldrd	r8, ip, [sp, #52]	@ 0x34
 80499be:	460e      	mov	r6, r1
 80499c0:	f8dd b03c 	ldr.w	fp, [sp, #60]	@ 0x3c
 80499c4:	f8dd 9044 	ldr.w	r9, [sp, #68]	@ 0x44
 80499c8:	e6c6      	b.n	8049758 <kad_op_conv2d+0x1218>
 80499ca:	7832      	ldrb	r2, [r6, #0]
 80499cc:	4613      	mov	r3, r2
 80499ce:	2a00      	cmp	r2, #0
 80499d0:	f47f aecd 	bne.w	804976e <kad_op_conv2d+0x122e>
				memset(w1, 0, kad_len(w) * sizeof(float));
 80499d4:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 80499d6:	601a      	str	r2, [r3, #0]
				conv2d_loop2(q1, w1, p->g, kad_saxpy(m, *_yy, _xx, _ww));
 80499d8:	e7d4      	b.n	8049984 <kad_op_conv2d+0x1444>
		conv_rot180(w->d[0] * w->d[1], w->d[2] * w->d[3], w->x);
 80499da:	fb03 f101 	mul.w	r1, r3, r1
 80499de:	9b04      	ldr	r3, [sp, #16]
 80499e0:	fb0e f403 	mul.w	r4, lr, r3
	for (i = 0; i < d0; ++i) {
 80499e4:	f7fe bff0 	b.w	80489c8 <kad_op_conv2d+0x488>
			conv2d_move_1to3(q->d, q->x, q1);
 80499e8:	f8d9 3028 	ldr.w	r3, [r9, #40]	@ 0x28
	for (i = 0; i < d[0]; ++i)
 80499ec:	f1b8 0f00 	cmp.w	r8, #0
			conv2d_move_1to3(q->d, q->x, q1);
 80499f0:	9300      	str	r3, [sp, #0]
			conv2d_loop1(q->x, w->x, p->x, t, process_row_for);
 80499f2:	6ab3      	ldr	r3, [r6, #40]	@ 0x28
 80499f4:	6931      	ldr	r1, [r6, #16]
 80499f6:	930b      	str	r3, [sp, #44]	@ 0x2c
 80499f8:	69f3      	ldr	r3, [r6, #28]
 80499fa:	9304      	str	r3, [sp, #16]
 80499fc:	e9d6 3e05 	ldrd	r3, lr, [r6, #20]
 8049a00:	930a      	str	r3, [sp, #40]	@ 0x28
	for (i = 0; i < d[0]; ++i)
 8049a02:	dd7a      	ble.n	8049afa <kad_op_conv2d+0x15ba>
		for (j = 0; j < d[1]; ++j)
 8049a04:	f8d9 c014 	ldr.w	ip, [r9, #20]
 8049a08:	f1bc 0f00 	cmp.w	ip, #0
 8049a0c:	dd70      	ble.n	8049af0 <kad_op_conv2d+0x15b0>
 8049a0e:	ea4f 038c 	mov.w	r3, ip, lsl #2
			for (k = 0; k < d[2]; ++k) {
 8049a12:	2500      	movs	r5, #0
 8049a14:	9307      	str	r3, [sp, #28]
 8049a16:	4673      	mov	r3, lr
 8049a18:	f8d9 7018 	ldr.w	r7, [r9, #24]
 8049a1c:	46ce      	mov	lr, r9
	for (i = 0; i < d[0]; ++i)
 8049a1e:	462e      	mov	r6, r5
 8049a20:	460c      	mov	r4, r1
 8049a22:	4699      	mov	r9, r3
		for (j = 0; j < d[1]; ++j)
 8049a24:	2f00      	cmp	r7, #0
				int ik = (i * d[2] + k) * d[3], ijk = ((i * d[1] + j) * d[2] + k) * d[3];
 8049a26:	fb07 f206 	mul.w	r2, r7, r6
 8049a2a:	f77f a814 	ble.w	8048a56 <kad_op_conv2d+0x516>
 8049a2e:	f8de 301c 	ldr.w	r3, [lr, #28]
 8049a32:	fb07 f005 	mul.w	r0, r7, r5
 8049a36:	fb03 f202 	mul.w	r2, r3, r2
 8049a3a:	fb0c f202 	mul.w	r2, ip, r2
 8049a3e:	9203      	str	r2, [sp, #12]
 8049a40:	fb0c f203 	mul.w	r2, ip, r3
 8049a44:	0092      	lsls	r2, r2, #2
 8049a46:	9205      	str	r2, [sp, #20]
		for (j = 0; j < d[1]; ++j)
 8049a48:	2200      	movs	r2, #0
 8049a4a:	0099      	lsls	r1, r3, #2
 8049a4c:	9102      	str	r1, [sp, #8]
			for (k = 0; k < d[2]; ++k) {
 8049a4e:	2b00      	cmp	r3, #0
 8049a50:	f77e affc 	ble.w	8048a4c <kad_op_conv2d+0x50c>
 8049a54:	4629      	mov	r1, r5
 8049a56:	e9cd e60d 	strd	lr, r6, [sp, #52]	@ 0x34
 8049a5a:	f8cd b020 	str.w	fp, [sp, #32]
 8049a5e:	f8cd 803c 	str.w	r8, [sp, #60]	@ 0x3c
 8049a62:	f04f 0800 	mov.w	r8, #0
 8049a66:	9d03      	ldr	r5, [sp, #12]
 8049a68:	9e0c      	ldr	r6, [sp, #48]	@ 0x30
 8049a6a:	fb00 fb03 	mul.w	fp, r0, r3
 8049a6e:	1955      	adds	r5, r2, r5
 8049a70:	eb06 0585 	add.w	r5, r6, r5, lsl #2
 8049a74:	9506      	str	r5, [sp, #24]
 8049a76:	9d00      	ldr	r5, [sp, #0]
 8049a78:	eb03 060b 	add.w	r6, r3, fp
 8049a7c:	eb05 0e86 	add.w	lr, r5, r6, lsl #2
 8049a80:	9d06      	ldr	r5, [sp, #24]
 8049a82:	9211      	str	r2, [sp, #68]	@ 0x44
				for (l = 0; l < d[3]; ++l)
 8049a84:	9a00      	ldr	r2, [sp, #0]
			for (k = 0; k < d[2]; ++k) {
 8049a86:	9306      	str	r3, [sp, #24]
 8049a88:	eb02 028b 	add.w	r2, r2, fp, lsl #2
 8049a8c:	46ab      	mov	fp, r5
					y[(ik + l) * d[1] + j] = x[ijk + l];
 8049a8e:	ecf2 7a01 	vldmia	r2!, {s15}
				for (l = 0; l < d[3]; ++l)
 8049a92:	9b07      	ldr	r3, [sp, #28]
 8049a94:	4596      	cmp	lr, r2
					y[(ik + l) * d[1] + j] = x[ijk + l];
 8049a96:	edcb 7a00 	vstr	s15, [fp]
				for (l = 0; l < d[3]; ++l)
 8049a9a:	449b      	add	fp, r3
 8049a9c:	d1f7      	bne.n	8049a8e <kad_op_conv2d+0x154e>
			for (k = 0; k < d[2]; ++k) {
 8049a9e:	9a05      	ldr	r2, [sp, #20]
 8049aa0:	f108 0801 	add.w	r8, r8, #1
 8049aa4:	4415      	add	r5, r2
 8049aa6:	9a02      	ldr	r2, [sp, #8]
 8049aa8:	45b8      	cmp	r8, r7
 8049aaa:	46b3      	mov	fp, r6
 8049aac:	9b06      	ldr	r3, [sp, #24]
 8049aae:	4496      	add	lr, r2
 8049ab0:	d010      	beq.n	8049ad4 <kad_op_conv2d+0x1594>
 8049ab2:	441e      	add	r6, r3
 8049ab4:	e7e6      	b.n	8049a84 <kad_op_conv2d+0x1544>
 8049ab6:	9a0a      	ldr	r2, [sp, #40]	@ 0x28
 8049ab8:	fb02 f303 	mul.w	r3, r2, r3
 8049abc:	f7ff b848 	b.w	8048b50 <kad_op_conv2d+0x610>
 8049ac0:	4618      	mov	r0, r3
			conv2d_loop2(q1, w1, p->x, (*_yy += kad_sdot(m, _ww, _xx)));
 8049ac2:	9a04      	ldr	r2, [sp, #16]
 8049ac4:	f8db 3014 	ldr.w	r3, [fp, #20]
 8049ac8:	fb00 f702 	mul.w	r7, r0, r2
 8049acc:	fb03 f30c 	mul.w	r3, r3, ip
 8049ad0:	f7ff b847 	b.w	8048b62 <kad_op_conv2d+0x622>
		for (j = 0; j < d[1]; ++j)
 8049ad4:	9a11      	ldr	r2, [sp, #68]	@ 0x44
 8049ad6:	4438      	add	r0, r7
 8049ad8:	3201      	adds	r2, #1
 8049ada:	4594      	cmp	ip, r2
 8049adc:	d1c1      	bne.n	8049a62 <kad_op_conv2d+0x1522>
 8049ade:	e9dd e60d 	ldrd	lr, r6, [sp, #52]	@ 0x34
 8049ae2:	460d      	mov	r5, r1
 8049ae4:	f8dd b020 	ldr.w	fp, [sp, #32]
 8049ae8:	f8dd 803c 	ldr.w	r8, [sp, #60]	@ 0x3c
 8049aec:	f7fe bfb3 	b.w	8048a56 <kad_op_conv2d+0x516>
	for (i = 0; i < d[0]; ++i)
 8049af0:	2900      	cmp	r1, #0
 8049af2:	f73e afbc 	bgt.w	8048a6e <kad_op_conv2d+0x52e>
 8049af6:	f7ff b8fb 	b.w	8048cf0 <kad_op_conv2d+0x7b0>
 8049afa:	2900      	cmp	r1, #0
 8049afc:	f77f a8f8 	ble.w	8048cf0 <kad_op_conv2d+0x7b0>
 8049b00:	2b00      	cmp	r3, #0
 8049b02:	f77e ad32 	ble.w	804856a <kad_op_conv2d+0x2a>
 8049b06:	f1be 0f00 	cmp.w	lr, #0
 8049b0a:	f77f a8f1 	ble.w	8048cf0 <kad_op_conv2d+0x7b0>
			conv2d_loop1(q->x, w->x, p->x, t, process_row_for);
 8049b0e:	f8d9 c014 	ldr.w	ip, [r9, #20]
 8049b12:	f7fe bfb4 	b.w	8048a7e <kad_op_conv2d+0x53e>
 8049b16:	bf00      	nop

08049b18 <kad_const>:
{
 8049b18:	b40e      	push	{r1, r2, r3}
 8049b1a:	b5f0      	push	{r4, r5, r6, r7, lr}
 8049b1c:	b082      	sub	sp, #8
 8049b1e:	ad07      	add	r5, sp, #28
 8049b20:	f855 6b04 	ldr.w	r6, [r5], #4
	if (n_d > KAD_MAX_DIM) return 0;
 8049b24:	2e04      	cmp	r6, #4
	va_start(ap, n_d); p = kad_vleaf(KAD_CONST, x, 0, n_d, ap); va_end(ap);
 8049b26:	9501      	str	r5, [sp, #4]
	if (n_d > KAD_MAX_DIM) return 0;
 8049b28:	dc1d      	bgt.n	8049b66 <kad_const+0x4e>
 8049b2a:	4607      	mov	r7, r0
	p = (kad_node_t*)calloc(1, sizeof(kad_node_t));
 8049b2c:	2140      	movs	r1, #64	@ 0x40
 8049b2e:	2001      	movs	r0, #1
 8049b30:	f001 fe76 	bl	804b820 <calloc>
	heapSize += 1 * sizeof(kad_node_t);
 8049b34:	4a0d      	ldr	r2, [pc, #52]	@ (8049b6c <kad_const+0x54>)
	for (i = 0; i < n_d; ++i)
 8049b36:	2e00      	cmp	r6, #0
	heapSize += 1 * sizeof(kad_node_t);
 8049b38:	6813      	ldr	r3, [r2, #0]
	p = (kad_node_t*)calloc(1, sizeof(kad_node_t));
 8049b3a:	4604      	mov	r4, r0
	heapSize += 1 * sizeof(kad_node_t);
 8049b3c:	f103 0340 	add.w	r3, r3, #64	@ 0x40
 8049b40:	6013      	str	r3, [r2, #0]
	p->n_d = n_d;
 8049b42:	7006      	strb	r6, [r0, #0]
	for (i = 0; i < n_d; ++i)
 8049b44:	dd04      	ble.n	8049b50 <kad_const+0x38>
		p->d[i] = va_arg(ap, int32_t);
 8049b46:	4629      	mov	r1, r5
 8049b48:	00b2      	lsls	r2, r6, #2
 8049b4a:	3010      	adds	r0, #16
 8049b4c:	f002 fa6f 	bl	804c02e <memcpy>
	p->x = x, p->g = g, p->flag = flag;
 8049b50:	2200      	movs	r2, #0
 8049b52:	2302      	movs	r3, #2
 8049b54:	e9c4 720a 	strd	r7, r2, [r4, #40]	@ 0x28
 8049b58:	7063      	strb	r3, [r4, #1]
}
 8049b5a:	4620      	mov	r0, r4
 8049b5c:	b002      	add	sp, #8
 8049b5e:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
 8049b62:	b003      	add	sp, #12
 8049b64:	4770      	bx	lr
	if (n_d > KAD_MAX_DIM) return 0;
 8049b66:	2400      	movs	r4, #0
	return p;
 8049b68:	e7f7      	b.n	8049b5a <kad_const+0x42>
 8049b6a:	bf00      	nop
 8049b6c:	20018acc 	.word	0x20018acc

08049b70 <kad_feed>:
{
 8049b70:	b40f      	push	{r0, r1, r2, r3}
 8049b72:	b570      	push	{r4, r5, r6, lr}
 8049b74:	b082      	sub	sp, #8
 8049b76:	ad06      	add	r5, sp, #24
 8049b78:	f855 6b04 	ldr.w	r6, [r5], #4
	if (n_d > KAD_MAX_DIM) return 0;
 8049b7c:	2e04      	cmp	r6, #4
	va_start(ap, n_d); p = kad_vleaf(0, 0, 0, n_d, ap); va_end(ap);
 8049b7e:	9501      	str	r5, [sp, #4]
	if (n_d > KAD_MAX_DIM) return 0;
 8049b80:	dc1d      	bgt.n	8049bbe <kad_feed+0x4e>
	p = (kad_node_t*)calloc(1, sizeof(kad_node_t));
 8049b82:	2140      	movs	r1, #64	@ 0x40
 8049b84:	2001      	movs	r0, #1
 8049b86:	f001 fe4b 	bl	804b820 <calloc>
	heapSize += 1 * sizeof(kad_node_t);
 8049b8a:	4a0e      	ldr	r2, [pc, #56]	@ (8049bc4 <kad_feed+0x54>)
	for (i = 0; i < n_d; ++i)
 8049b8c:	2e00      	cmp	r6, #0
	heapSize += 1 * sizeof(kad_node_t);
 8049b8e:	6813      	ldr	r3, [r2, #0]
	p = (kad_node_t*)calloc(1, sizeof(kad_node_t));
 8049b90:	4604      	mov	r4, r0
	heapSize += 1 * sizeof(kad_node_t);
 8049b92:	f103 0340 	add.w	r3, r3, #64	@ 0x40
 8049b96:	6013      	str	r3, [r2, #0]
	p->n_d = n_d;
 8049b98:	7006      	strb	r6, [r0, #0]
	for (i = 0; i < n_d; ++i)
 8049b9a:	dd04      	ble.n	8049ba6 <kad_feed+0x36>
		p->d[i] = va_arg(ap, int32_t);
 8049b9c:	4629      	mov	r1, r5
 8049b9e:	00b2      	lsls	r2, r6, #2
 8049ba0:	3010      	adds	r0, #16
 8049ba2:	f002 fa44 	bl	804c02e <memcpy>
	p->x = x, p->g = g, p->flag = flag;
 8049ba6:	2000      	movs	r0, #0
 8049ba8:	2100      	movs	r1, #0
 8049baa:	2300      	movs	r3, #0
 8049bac:	e9c4 010a 	strd	r0, r1, [r4, #40]	@ 0x28
 8049bb0:	7063      	strb	r3, [r4, #1]
}
 8049bb2:	4620      	mov	r0, r4
 8049bb4:	b002      	add	sp, #8
 8049bb6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 8049bba:	b004      	add	sp, #16
 8049bbc:	4770      	bx	lr
	if (n_d > KAD_MAX_DIM) return 0;
 8049bbe:	2400      	movs	r4, #0
	return p;
 8049bc0:	e7f7      	b.n	8049bb2 <kad_feed+0x42>
 8049bc2:	bf00      	nop
 8049bc4:	20018acc 	.word	0x20018acc

08049bc8 <kad_var>:
{
 8049bc8:	b40c      	push	{r2, r3}
 8049bca:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8049bce:	b082      	sub	sp, #8
 8049bd0:	ad08      	add	r5, sp, #32
 8049bd2:	f855 6b04 	ldr.w	r6, [r5], #4
	if (n_d > KAD_MAX_DIM) return 0;
 8049bd6:	2e04      	cmp	r6, #4
	va_start(ap, n_d); p = kad_vleaf(KAD_VAR, x, g, n_d, ap); va_end(ap);
 8049bd8:	9501      	str	r5, [sp, #4]
	if (n_d > KAD_MAX_DIM) return 0;
 8049bda:	dc1d      	bgt.n	8049c18 <kad_var+0x50>
 8049bdc:	4680      	mov	r8, r0
 8049bde:	460f      	mov	r7, r1
	p = (kad_node_t*)calloc(1, sizeof(kad_node_t));
 8049be0:	2001      	movs	r0, #1
 8049be2:	2140      	movs	r1, #64	@ 0x40
 8049be4:	f001 fe1c 	bl	804b820 <calloc>
	heapSize += 1 * sizeof(kad_node_t);
 8049be8:	4a0c      	ldr	r2, [pc, #48]	@ (8049c1c <kad_var+0x54>)
	for (i = 0; i < n_d; ++i)
 8049bea:	2e00      	cmp	r6, #0
	heapSize += 1 * sizeof(kad_node_t);
 8049bec:	6813      	ldr	r3, [r2, #0]
	p = (kad_node_t*)calloc(1, sizeof(kad_node_t));
 8049bee:	4604      	mov	r4, r0
	heapSize += 1 * sizeof(kad_node_t);
 8049bf0:	f103 0340 	add.w	r3, r3, #64	@ 0x40
 8049bf4:	6013      	str	r3, [r2, #0]
	p->n_d = n_d;
 8049bf6:	7006      	strb	r6, [r0, #0]
	for (i = 0; i < n_d; ++i)
 8049bf8:	dd04      	ble.n	8049c04 <kad_var+0x3c>
		p->d[i] = va_arg(ap, int32_t);
 8049bfa:	4629      	mov	r1, r5
 8049bfc:	00b2      	lsls	r2, r6, #2
 8049bfe:	3010      	adds	r0, #16
 8049c00:	f002 fa15 	bl	804c02e <memcpy>
	p->x = x, p->g = g, p->flag = flag;
 8049c04:	2301      	movs	r3, #1
 8049c06:	e9c4 870a 	strd	r8, r7, [r4, #40]	@ 0x28
 8049c0a:	7063      	strb	r3, [r4, #1]
}
 8049c0c:	4620      	mov	r0, r4
 8049c0e:	b002      	add	sp, #8
 8049c10:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8049c14:	b002      	add	sp, #8
 8049c16:	4770      	bx	lr
	if (n_d > KAD_MAX_DIM) return 0;
 8049c18:	2400      	movs	r4, #0
	return p;
 8049c1a:	e7f7      	b.n	8049c0c <kad_var+0x44>
 8049c1c:	20018acc 	.word	0x20018acc

08049c20 <kad_add>:
KAD_FUNC_OP2(kad_add, 1)
 8049c20:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8049c24:	4680      	mov	r8, r0
 8049c26:	460f      	mov	r7, r1
	s = (kad_node_t*)calloc(1, sizeof(kad_node_t));
 8049c28:	2001      	movs	r0, #1
 8049c2a:	2140      	movs	r1, #64	@ 0x40
 8049c2c:	f001 fdf8 	bl	804b820 <calloc>
	s->n_d = n_d, s->op = op, s->n_child = n_child;
 8049c30:	2400      	movs	r4, #0
 8049c32:	2202      	movs	r2, #2
 8049c34:	f04f 0c01 	mov.w	ip, #1
	heapSize += 1 * sizeof(kad_node_t);
 8049c38:	4e20      	ldr	r6, [pc, #128]	@ (8049cbc <kad_add+0x9c>)
	s = (kad_node_t*)calloc(1, sizeof(kad_node_t));
 8049c3a:	4605      	mov	r5, r0
	heapSize += 1 * sizeof(kad_node_t);
 8049c3c:	6833      	ldr	r3, [r6, #0]
	s->n_d = n_d, s->op = op, s->n_child = n_child;
 8049c3e:	f8a0 c002 	strh.w	ip, [r0, #2]
	heapSize += 1 * sizeof(kad_node_t);
 8049c42:	3340      	adds	r3, #64	@ 0x40
	s->n_d = n_d, s->op = op, s->n_child = n_child;
 8049c44:	6042      	str	r2, [r0, #4]
		s->child = (kad_node_t**)calloc(s->n_child, sizeof(kad_node_t*));
 8049c46:	2104      	movs	r1, #4
	s->n_d = n_d, s->op = op, s->n_child = n_child;
 8049c48:	7004      	strb	r4, [r0, #0]
		s->child = (kad_node_t**)calloc(s->n_child, sizeof(kad_node_t*));
 8049c4a:	4610      	mov	r0, r2
	heapSize += 1 * sizeof(kad_node_t);
 8049c4c:	6033      	str	r3, [r6, #0]
		s->child = (kad_node_t**)calloc(s->n_child, sizeof(kad_node_t*));
 8049c4e:	f001 fde7 	bl	804b820 <calloc>
 8049c52:	4603      	mov	r3, r0
		heapSize += s->n_child * sizeof(kad_node_t*);
 8049c54:	6832      	ldr	r2, [r6, #0]
	if (kad_op_list[s->op](s, KAD_SYNC_DIM) < 0) { /* check dimension */
 8049c56:	2104      	movs	r1, #4
		heapSize += s->n_child * sizeof(kad_node_t*);
 8049c58:	3208      	adds	r2, #8
 8049c5a:	6032      	str	r2, [r6, #0]
	if (kad_op_list[s->op](s, KAD_SYNC_DIM) < 0) { /* check dimension */
 8049c5c:	4a18      	ldr	r2, [pc, #96]	@ (8049cc0 <kad_add+0xa0>)
 8049c5e:	4628      	mov	r0, r5
	s->child[0] = x, s->child[1] = y;
 8049c60:	e9c3 8700 	strd	r8, r7, [r3]
	if (kad_op_list[s->op](s, KAD_SYNC_DIM) < 0) { /* check dimension */
 8049c64:	6852      	ldr	r2, [r2, #4]
		s->child = (kad_node_t**)calloc(s->n_child, sizeof(kad_node_t*));
 8049c66:	63ab      	str	r3, [r5, #56]	@ 0x38
	if (kad_op_list[s->op](s, KAD_SYNC_DIM) < 0) { /* check dimension */
 8049c68:	4790      	blx	r2
 8049c6a:	42a0      	cmp	r0, r4
 8049c6c:	db17      	blt.n	8049c9e <kad_add+0x7e>
	for (i = 0; i < s->n_child; ++i)
 8049c6e:	6868      	ldr	r0, [r5, #4]
 8049c70:	42a0      	cmp	r0, r4
 8049c72:	dd11      	ble.n	8049c98 <kad_add+0x78>
 8049c74:	6baa      	ldr	r2, [r5, #56]	@ 0x38
 8049c76:	4623      	mov	r3, r4
 8049c78:	3a04      	subs	r2, #4
 8049c7a:	e002      	b.n	8049c82 <kad_add+0x62>
 8049c7c:	3301      	adds	r3, #1
 8049c7e:	4298      	cmp	r0, r3
 8049c80:	d00a      	beq.n	8049c98 <kad_add+0x78>
		if (kad_is_back(s->child[i]))
 8049c82:	f852 1f04 	ldr.w	r1, [r2, #4]!
 8049c86:	7849      	ldrb	r1, [r1, #1]
 8049c88:	07c9      	lsls	r1, r1, #31
 8049c8a:	d5f7      	bpl.n	8049c7c <kad_add+0x5c>
	if (i < s->n_child) s->flag |= KAD_VAR;
 8049c8c:	4283      	cmp	r3, r0
 8049c8e:	da03      	bge.n	8049c98 <kad_add+0x78>
 8049c90:	786b      	ldrb	r3, [r5, #1]
 8049c92:	f043 0301 	orr.w	r3, r3, #1
 8049c96:	706b      	strb	r3, [r5, #1]
KAD_FUNC_OP2(kad_add, 1)
 8049c98:	4628      	mov	r0, r5
 8049c9a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (s->ptr) free(s->ptr);
 8049c9e:	6b28      	ldr	r0, [r5, #48]	@ 0x30
 8049ca0:	b108      	cbz	r0, 8049ca6 <kad_add+0x86>
 8049ca2:	f001 fde1 	bl	804b868 <free>
		free(s->child); free(s);
 8049ca6:	6ba8      	ldr	r0, [r5, #56]	@ 0x38
 8049ca8:	f001 fdde 	bl	804b868 <free>
 8049cac:	4628      	mov	r0, r5
 8049cae:	2500      	movs	r5, #0
 8049cb0:	f001 fdda 	bl	804b868 <free>
KAD_FUNC_OP2(kad_add, 1)
 8049cb4:	4628      	mov	r0, r5
 8049cb6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8049cba:	bf00      	nop
 8049cbc:	20018acc 	.word	0x20018acc
 8049cc0:	20018004 	.word	0x20018004

08049cc4 <kad_mul>:
KAD_FUNC_OP2(kad_mul, 2)
 8049cc4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8049cc8:	4680      	mov	r8, r0
 8049cca:	460f      	mov	r7, r1
	s = (kad_node_t*)calloc(1, sizeof(kad_node_t));
 8049ccc:	2001      	movs	r0, #1
 8049cce:	2140      	movs	r1, #64	@ 0x40
 8049cd0:	f001 fda6 	bl	804b820 <calloc>
	s->n_d = n_d, s->op = op, s->n_child = n_child;
 8049cd4:	2400      	movs	r4, #0
	s = (kad_node_t*)calloc(1, sizeof(kad_node_t));
 8049cd6:	4605      	mov	r5, r0
	s->n_d = n_d, s->op = op, s->n_child = n_child;
 8049cd8:	2302      	movs	r3, #2
	heapSize += 1 * sizeof(kad_node_t);
 8049cda:	4e1f      	ldr	r6, [pc, #124]	@ (8049d58 <kad_mul+0x94>)
		s->child = (kad_node_t**)calloc(s->n_child, sizeof(kad_node_t*));
 8049cdc:	2104      	movs	r1, #4
	heapSize += 1 * sizeof(kad_node_t);
 8049cde:	6832      	ldr	r2, [r6, #0]
		s->child = (kad_node_t**)calloc(s->n_child, sizeof(kad_node_t*));
 8049ce0:	4618      	mov	r0, r3
	heapSize += 1 * sizeof(kad_node_t);
 8049ce2:	3240      	adds	r2, #64	@ 0x40
	s->n_d = n_d, s->op = op, s->n_child = n_child;
 8049ce4:	806b      	strh	r3, [r5, #2]
 8049ce6:	606b      	str	r3, [r5, #4]
 8049ce8:	702c      	strb	r4, [r5, #0]
	heapSize += 1 * sizeof(kad_node_t);
 8049cea:	6032      	str	r2, [r6, #0]
		s->child = (kad_node_t**)calloc(s->n_child, sizeof(kad_node_t*));
 8049cec:	f001 fd98 	bl	804b820 <calloc>
 8049cf0:	4603      	mov	r3, r0
		heapSize += s->n_child * sizeof(kad_node_t*);
 8049cf2:	6832      	ldr	r2, [r6, #0]
	if (kad_op_list[s->op](s, KAD_SYNC_DIM) < 0) { /* check dimension */
 8049cf4:	2104      	movs	r1, #4
		heapSize += s->n_child * sizeof(kad_node_t*);
 8049cf6:	3208      	adds	r2, #8
 8049cf8:	6032      	str	r2, [r6, #0]
	if (kad_op_list[s->op](s, KAD_SYNC_DIM) < 0) { /* check dimension */
 8049cfa:	4a18      	ldr	r2, [pc, #96]	@ (8049d5c <kad_mul+0x98>)
 8049cfc:	4628      	mov	r0, r5
	s->child[0] = x, s->child[1] = y;
 8049cfe:	e9c3 8700 	strd	r8, r7, [r3]
	if (kad_op_list[s->op](s, KAD_SYNC_DIM) < 0) { /* check dimension */
 8049d02:	6892      	ldr	r2, [r2, #8]
		s->child = (kad_node_t**)calloc(s->n_child, sizeof(kad_node_t*));
 8049d04:	63ab      	str	r3, [r5, #56]	@ 0x38
	if (kad_op_list[s->op](s, KAD_SYNC_DIM) < 0) { /* check dimension */
 8049d06:	4790      	blx	r2
 8049d08:	42a0      	cmp	r0, r4
 8049d0a:	db17      	blt.n	8049d3c <kad_mul+0x78>
	for (i = 0; i < s->n_child; ++i)
 8049d0c:	6868      	ldr	r0, [r5, #4]
 8049d0e:	42a0      	cmp	r0, r4
 8049d10:	dd11      	ble.n	8049d36 <kad_mul+0x72>
 8049d12:	6baa      	ldr	r2, [r5, #56]	@ 0x38
 8049d14:	4623      	mov	r3, r4
 8049d16:	3a04      	subs	r2, #4
 8049d18:	e002      	b.n	8049d20 <kad_mul+0x5c>
 8049d1a:	3301      	adds	r3, #1
 8049d1c:	4298      	cmp	r0, r3
 8049d1e:	d00a      	beq.n	8049d36 <kad_mul+0x72>
		if (kad_is_back(s->child[i]))
 8049d20:	f852 1f04 	ldr.w	r1, [r2, #4]!
 8049d24:	7849      	ldrb	r1, [r1, #1]
 8049d26:	07c9      	lsls	r1, r1, #31
 8049d28:	d5f7      	bpl.n	8049d1a <kad_mul+0x56>
	if (i < s->n_child) s->flag |= KAD_VAR;
 8049d2a:	4283      	cmp	r3, r0
 8049d2c:	da03      	bge.n	8049d36 <kad_mul+0x72>
 8049d2e:	786b      	ldrb	r3, [r5, #1]
 8049d30:	f043 0301 	orr.w	r3, r3, #1
 8049d34:	706b      	strb	r3, [r5, #1]
KAD_FUNC_OP2(kad_mul, 2)
 8049d36:	4628      	mov	r0, r5
 8049d38:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (s->ptr) free(s->ptr);
 8049d3c:	6b28      	ldr	r0, [r5, #48]	@ 0x30
 8049d3e:	b108      	cbz	r0, 8049d44 <kad_mul+0x80>
 8049d40:	f001 fd92 	bl	804b868 <free>
		free(s->child); free(s);
 8049d44:	6ba8      	ldr	r0, [r5, #56]	@ 0x38
 8049d46:	f001 fd8f 	bl	804b868 <free>
 8049d4a:	4628      	mov	r0, r5
 8049d4c:	2500      	movs	r5, #0
 8049d4e:	f001 fd8b 	bl	804b868 <free>
KAD_FUNC_OP2(kad_mul, 2)
 8049d52:	4628      	mov	r0, r5
 8049d54:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8049d58:	20018acc 	.word	0x20018acc
 8049d5c:	20018004 	.word	0x20018004

08049d60 <kad_cmul>:
KAD_FUNC_OP2(kad_cmul, 3)
 8049d60:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8049d64:	4680      	mov	r8, r0
 8049d66:	460f      	mov	r7, r1
	s = (kad_node_t*)calloc(1, sizeof(kad_node_t));
 8049d68:	2001      	movs	r0, #1
 8049d6a:	2140      	movs	r1, #64	@ 0x40
 8049d6c:	f001 fd58 	bl	804b820 <calloc>
	s->n_d = n_d, s->op = op, s->n_child = n_child;
 8049d70:	2400      	movs	r4, #0
 8049d72:	2202      	movs	r2, #2
 8049d74:	f04f 0c03 	mov.w	ip, #3
	heapSize += 1 * sizeof(kad_node_t);
 8049d78:	4e20      	ldr	r6, [pc, #128]	@ (8049dfc <kad_cmul+0x9c>)
	s = (kad_node_t*)calloc(1, sizeof(kad_node_t));
 8049d7a:	4605      	mov	r5, r0
	heapSize += 1 * sizeof(kad_node_t);
 8049d7c:	6833      	ldr	r3, [r6, #0]
	s->n_d = n_d, s->op = op, s->n_child = n_child;
 8049d7e:	f8a0 c002 	strh.w	ip, [r0, #2]
	heapSize += 1 * sizeof(kad_node_t);
 8049d82:	3340      	adds	r3, #64	@ 0x40
	s->n_d = n_d, s->op = op, s->n_child = n_child;
 8049d84:	6042      	str	r2, [r0, #4]
		s->child = (kad_node_t**)calloc(s->n_child, sizeof(kad_node_t*));
 8049d86:	2104      	movs	r1, #4
	s->n_d = n_d, s->op = op, s->n_child = n_child;
 8049d88:	7004      	strb	r4, [r0, #0]
		s->child = (kad_node_t**)calloc(s->n_child, sizeof(kad_node_t*));
 8049d8a:	4610      	mov	r0, r2
	heapSize += 1 * sizeof(kad_node_t);
 8049d8c:	6033      	str	r3, [r6, #0]
		s->child = (kad_node_t**)calloc(s->n_child, sizeof(kad_node_t*));
 8049d8e:	f001 fd47 	bl	804b820 <calloc>
 8049d92:	4603      	mov	r3, r0
		heapSize += s->n_child * sizeof(kad_node_t*);
 8049d94:	6832      	ldr	r2, [r6, #0]
	if (kad_op_list[s->op](s, KAD_SYNC_DIM) < 0) { /* check dimension */
 8049d96:	2104      	movs	r1, #4
		heapSize += s->n_child * sizeof(kad_node_t*);
 8049d98:	3208      	adds	r2, #8
 8049d9a:	6032      	str	r2, [r6, #0]
	if (kad_op_list[s->op](s, KAD_SYNC_DIM) < 0) { /* check dimension */
 8049d9c:	4a18      	ldr	r2, [pc, #96]	@ (8049e00 <kad_cmul+0xa0>)
 8049d9e:	4628      	mov	r0, r5
	s->child[0] = x, s->child[1] = y;
 8049da0:	e9c3 8700 	strd	r8, r7, [r3]
	if (kad_op_list[s->op](s, KAD_SYNC_DIM) < 0) { /* check dimension */
 8049da4:	68d2      	ldr	r2, [r2, #12]
		s->child = (kad_node_t**)calloc(s->n_child, sizeof(kad_node_t*));
 8049da6:	63ab      	str	r3, [r5, #56]	@ 0x38
	if (kad_op_list[s->op](s, KAD_SYNC_DIM) < 0) { /* check dimension */
 8049da8:	4790      	blx	r2
 8049daa:	42a0      	cmp	r0, r4
 8049dac:	db17      	blt.n	8049dde <kad_cmul+0x7e>
	for (i = 0; i < s->n_child; ++i)
 8049dae:	6868      	ldr	r0, [r5, #4]
 8049db0:	42a0      	cmp	r0, r4
 8049db2:	dd11      	ble.n	8049dd8 <kad_cmul+0x78>
 8049db4:	6baa      	ldr	r2, [r5, #56]	@ 0x38
 8049db6:	4623      	mov	r3, r4
 8049db8:	3a04      	subs	r2, #4
 8049dba:	e002      	b.n	8049dc2 <kad_cmul+0x62>
 8049dbc:	3301      	adds	r3, #1
 8049dbe:	4298      	cmp	r0, r3
 8049dc0:	d00a      	beq.n	8049dd8 <kad_cmul+0x78>
		if (kad_is_back(s->child[i]))
 8049dc2:	f852 1f04 	ldr.w	r1, [r2, #4]!
 8049dc6:	7849      	ldrb	r1, [r1, #1]
 8049dc8:	07c9      	lsls	r1, r1, #31
 8049dca:	d5f7      	bpl.n	8049dbc <kad_cmul+0x5c>
	if (i < s->n_child) s->flag |= KAD_VAR;
 8049dcc:	4283      	cmp	r3, r0
 8049dce:	da03      	bge.n	8049dd8 <kad_cmul+0x78>
 8049dd0:	786b      	ldrb	r3, [r5, #1]
 8049dd2:	f043 0301 	orr.w	r3, r3, #1
 8049dd6:	706b      	strb	r3, [r5, #1]
KAD_FUNC_OP2(kad_cmul, 3)
 8049dd8:	4628      	mov	r0, r5
 8049dda:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (s->ptr) free(s->ptr);
 8049dde:	6b28      	ldr	r0, [r5, #48]	@ 0x30
 8049de0:	b108      	cbz	r0, 8049de6 <kad_cmul+0x86>
 8049de2:	f001 fd41 	bl	804b868 <free>
		free(s->child); free(s);
 8049de6:	6ba8      	ldr	r0, [r5, #56]	@ 0x38
 8049de8:	f001 fd3e 	bl	804b868 <free>
 8049dec:	4628      	mov	r0, r5
 8049dee:	2500      	movs	r5, #0
 8049df0:	f001 fd3a 	bl	804b868 <free>
KAD_FUNC_OP2(kad_cmul, 3)
 8049df4:	4628      	mov	r0, r5
 8049df6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8049dfa:	bf00      	nop
 8049dfc:	20018acc 	.word	0x20018acc
 8049e00:	20018004 	.word	0x20018004

08049e04 <kad_ce_multi>:
KAD_FUNC_OP2(kad_ce_multi, 13)
 8049e04:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8049e08:	4680      	mov	r8, r0
 8049e0a:	460f      	mov	r7, r1
	s = (kad_node_t*)calloc(1, sizeof(kad_node_t));
 8049e0c:	2001      	movs	r0, #1
 8049e0e:	2140      	movs	r1, #64	@ 0x40
 8049e10:	f001 fd06 	bl	804b820 <calloc>
	s->n_d = n_d, s->op = op, s->n_child = n_child;
 8049e14:	2400      	movs	r4, #0
 8049e16:	2202      	movs	r2, #2
 8049e18:	f04f 0c0d 	mov.w	ip, #13
	heapSize += 1 * sizeof(kad_node_t);
 8049e1c:	4e20      	ldr	r6, [pc, #128]	@ (8049ea0 <kad_ce_multi+0x9c>)
	s = (kad_node_t*)calloc(1, sizeof(kad_node_t));
 8049e1e:	4605      	mov	r5, r0
	heapSize += 1 * sizeof(kad_node_t);
 8049e20:	6833      	ldr	r3, [r6, #0]
	s->n_d = n_d, s->op = op, s->n_child = n_child;
 8049e22:	f8a0 c002 	strh.w	ip, [r0, #2]
	heapSize += 1 * sizeof(kad_node_t);
 8049e26:	3340      	adds	r3, #64	@ 0x40
	s->n_d = n_d, s->op = op, s->n_child = n_child;
 8049e28:	6042      	str	r2, [r0, #4]
		s->child = (kad_node_t**)calloc(s->n_child, sizeof(kad_node_t*));
 8049e2a:	2104      	movs	r1, #4
	s->n_d = n_d, s->op = op, s->n_child = n_child;
 8049e2c:	7004      	strb	r4, [r0, #0]
		s->child = (kad_node_t**)calloc(s->n_child, sizeof(kad_node_t*));
 8049e2e:	4610      	mov	r0, r2
	heapSize += 1 * sizeof(kad_node_t);
 8049e30:	6033      	str	r3, [r6, #0]
		s->child = (kad_node_t**)calloc(s->n_child, sizeof(kad_node_t*));
 8049e32:	f001 fcf5 	bl	804b820 <calloc>
 8049e36:	4603      	mov	r3, r0
		heapSize += s->n_child * sizeof(kad_node_t*);
 8049e38:	6832      	ldr	r2, [r6, #0]
	if (kad_op_list[s->op](s, KAD_SYNC_DIM) < 0) { /* check dimension */
 8049e3a:	2104      	movs	r1, #4
		heapSize += s->n_child * sizeof(kad_node_t*);
 8049e3c:	3208      	adds	r2, #8
 8049e3e:	6032      	str	r2, [r6, #0]
	if (kad_op_list[s->op](s, KAD_SYNC_DIM) < 0) { /* check dimension */
 8049e40:	4a18      	ldr	r2, [pc, #96]	@ (8049ea4 <kad_ce_multi+0xa0>)
 8049e42:	4628      	mov	r0, r5
	s->child[0] = x, s->child[1] = y;
 8049e44:	e9c3 8700 	strd	r8, r7, [r3]
	if (kad_op_list[s->op](s, KAD_SYNC_DIM) < 0) { /* check dimension */
 8049e48:	6b52      	ldr	r2, [r2, #52]	@ 0x34
		s->child = (kad_node_t**)calloc(s->n_child, sizeof(kad_node_t*));
 8049e4a:	63ab      	str	r3, [r5, #56]	@ 0x38
	if (kad_op_list[s->op](s, KAD_SYNC_DIM) < 0) { /* check dimension */
 8049e4c:	4790      	blx	r2
 8049e4e:	42a0      	cmp	r0, r4
 8049e50:	db17      	blt.n	8049e82 <kad_ce_multi+0x7e>
	for (i = 0; i < s->n_child; ++i)
 8049e52:	6868      	ldr	r0, [r5, #4]
 8049e54:	42a0      	cmp	r0, r4
 8049e56:	dd11      	ble.n	8049e7c <kad_ce_multi+0x78>
 8049e58:	6baa      	ldr	r2, [r5, #56]	@ 0x38
 8049e5a:	4623      	mov	r3, r4
 8049e5c:	3a04      	subs	r2, #4
 8049e5e:	e002      	b.n	8049e66 <kad_ce_multi+0x62>
 8049e60:	3301      	adds	r3, #1
 8049e62:	4298      	cmp	r0, r3
 8049e64:	d00a      	beq.n	8049e7c <kad_ce_multi+0x78>
		if (kad_is_back(s->child[i]))
 8049e66:	f852 1f04 	ldr.w	r1, [r2, #4]!
 8049e6a:	7849      	ldrb	r1, [r1, #1]
 8049e6c:	07c9      	lsls	r1, r1, #31
 8049e6e:	d5f7      	bpl.n	8049e60 <kad_ce_multi+0x5c>
	if (i < s->n_child) s->flag |= KAD_VAR;
 8049e70:	4283      	cmp	r3, r0
 8049e72:	da03      	bge.n	8049e7c <kad_ce_multi+0x78>
 8049e74:	786b      	ldrb	r3, [r5, #1]
 8049e76:	f043 0301 	orr.w	r3, r3, #1
 8049e7a:	706b      	strb	r3, [r5, #1]
KAD_FUNC_OP2(kad_ce_multi, 13)
 8049e7c:	4628      	mov	r0, r5
 8049e7e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (s->ptr) free(s->ptr);
 8049e82:	6b28      	ldr	r0, [r5, #48]	@ 0x30
 8049e84:	b108      	cbz	r0, 8049e8a <kad_ce_multi+0x86>
 8049e86:	f001 fcef 	bl	804b868 <free>
		free(s->child); free(s);
 8049e8a:	6ba8      	ldr	r0, [r5, #56]	@ 0x38
 8049e8c:	f001 fcec 	bl	804b868 <free>
 8049e90:	4628      	mov	r0, r5
 8049e92:	2500      	movs	r5, #0
 8049e94:	f001 fce8 	bl	804b868 <free>
KAD_FUNC_OP2(kad_ce_multi, 13)
 8049e98:	4628      	mov	r0, r5
 8049e9a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8049e9e:	bf00      	nop
 8049ea0:	20018acc 	.word	0x20018acc
 8049ea4:	20018004 	.word	0x20018004

08049ea8 <kad_sigm>:
KAD_FUNC_OP1(kad_sigm, 6)
 8049ea8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	s = (kad_node_t*)calloc(1, sizeof(kad_node_t));
 8049eaa:	2140      	movs	r1, #64	@ 0x40
KAD_FUNC_OP1(kad_sigm, 6)
 8049eac:	4607      	mov	r7, r0
	s = (kad_node_t*)calloc(1, sizeof(kad_node_t));
 8049eae:	2001      	movs	r0, #1
 8049eb0:	f001 fcb6 	bl	804b820 <calloc>
	heapSize += 1 * sizeof(kad_node_t);
 8049eb4:	4e1f      	ldr	r6, [pc, #124]	@ (8049f34 <kad_sigm+0x8c>)
	s = (kad_node_t*)calloc(1, sizeof(kad_node_t));
 8049eb6:	4605      	mov	r5, r0
	heapSize += 1 * sizeof(kad_node_t);
 8049eb8:	6833      	ldr	r3, [r6, #0]
	s->n_d = n_d, s->op = op, s->n_child = n_child;
 8049eba:	2206      	movs	r2, #6
	heapSize += 1 * sizeof(kad_node_t);
 8049ebc:	3340      	adds	r3, #64	@ 0x40
	s->n_d = n_d, s->op = op, s->n_child = n_child;
 8049ebe:	2400      	movs	r4, #0
	heapSize += 1 * sizeof(kad_node_t);
 8049ec0:	6033      	str	r3, [r6, #0]
	s->n_d = n_d, s->op = op, s->n_child = n_child;
 8049ec2:	2301      	movs	r3, #1
		s->child = (kad_node_t**)calloc(s->n_child, sizeof(kad_node_t*));
 8049ec4:	2104      	movs	r1, #4
 8049ec6:	4618      	mov	r0, r3
	s->n_d = n_d, s->op = op, s->n_child = n_child;
 8049ec8:	606b      	str	r3, [r5, #4]
 8049eca:	806a      	strh	r2, [r5, #2]
 8049ecc:	702c      	strb	r4, [r5, #0]
		s->child = (kad_node_t**)calloc(s->n_child, sizeof(kad_node_t*));
 8049ece:	f001 fca7 	bl	804b820 <calloc>
 8049ed2:	4603      	mov	r3, r0
		heapSize += s->n_child * sizeof(kad_node_t*);
 8049ed4:	6832      	ldr	r2, [r6, #0]
	if (kad_op_list[s->op](s, KAD_SYNC_DIM) < 0) { /* check dimension */
 8049ed6:	2104      	movs	r1, #4
		heapSize += s->n_child * sizeof(kad_node_t*);
 8049ed8:	3204      	adds	r2, #4
 8049eda:	6032      	str	r2, [r6, #0]
	if (kad_op_list[s->op](s, KAD_SYNC_DIM) < 0) { /* check dimension */
 8049edc:	4a16      	ldr	r2, [pc, #88]	@ (8049f38 <kad_sigm+0x90>)
 8049ede:	4628      	mov	r0, r5
 8049ee0:	6992      	ldr	r2, [r2, #24]
		s->child = (kad_node_t**)calloc(s->n_child, sizeof(kad_node_t*));
 8049ee2:	63ab      	str	r3, [r5, #56]	@ 0x38
	s->child[0] = x;
 8049ee4:	601f      	str	r7, [r3, #0]
	if (kad_op_list[s->op](s, KAD_SYNC_DIM) < 0) { /* check dimension */
 8049ee6:	4790      	blx	r2
 8049ee8:	42a0      	cmp	r0, r4
 8049eea:	db16      	blt.n	8049f1a <kad_sigm+0x72>
	for (i = 0; i < s->n_child; ++i)
 8049eec:	6868      	ldr	r0, [r5, #4]
 8049eee:	42a0      	cmp	r0, r4
 8049ef0:	dd11      	ble.n	8049f16 <kad_sigm+0x6e>
 8049ef2:	6baa      	ldr	r2, [r5, #56]	@ 0x38
 8049ef4:	4623      	mov	r3, r4
 8049ef6:	3a04      	subs	r2, #4
 8049ef8:	e002      	b.n	8049f00 <kad_sigm+0x58>
 8049efa:	3301      	adds	r3, #1
 8049efc:	4298      	cmp	r0, r3
 8049efe:	d00a      	beq.n	8049f16 <kad_sigm+0x6e>
		if (kad_is_back(s->child[i]))
 8049f00:	f852 1f04 	ldr.w	r1, [r2, #4]!
 8049f04:	7849      	ldrb	r1, [r1, #1]
 8049f06:	07c9      	lsls	r1, r1, #31
 8049f08:	d5f7      	bpl.n	8049efa <kad_sigm+0x52>
	if (i < s->n_child) s->flag |= KAD_VAR;
 8049f0a:	4283      	cmp	r3, r0
 8049f0c:	da03      	bge.n	8049f16 <kad_sigm+0x6e>
 8049f0e:	786b      	ldrb	r3, [r5, #1]
 8049f10:	f043 0301 	orr.w	r3, r3, #1
 8049f14:	706b      	strb	r3, [r5, #1]
KAD_FUNC_OP1(kad_sigm, 6)
 8049f16:	4628      	mov	r0, r5
 8049f18:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (s->ptr) free(s->ptr);
 8049f1a:	6b28      	ldr	r0, [r5, #48]	@ 0x30
 8049f1c:	b108      	cbz	r0, 8049f22 <kad_sigm+0x7a>
 8049f1e:	f001 fca3 	bl	804b868 <free>
		free(s->child); free(s);
 8049f22:	6ba8      	ldr	r0, [r5, #56]	@ 0x38
 8049f24:	f001 fca0 	bl	804b868 <free>
 8049f28:	4628      	mov	r0, r5
 8049f2a:	2500      	movs	r5, #0
 8049f2c:	f001 fc9c 	bl	804b868 <free>
KAD_FUNC_OP1(kad_sigm, 6)
 8049f30:	4628      	mov	r0, r5
 8049f32:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8049f34:	20018acc 	.word	0x20018acc
 8049f38:	20018004 	.word	0x20018004

08049f3c <kad_tanh>:
KAD_FUNC_OP1(kad_tanh, 7)
 8049f3c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	s = (kad_node_t*)calloc(1, sizeof(kad_node_t));
 8049f3e:	2140      	movs	r1, #64	@ 0x40
KAD_FUNC_OP1(kad_tanh, 7)
 8049f40:	4607      	mov	r7, r0
	s = (kad_node_t*)calloc(1, sizeof(kad_node_t));
 8049f42:	2001      	movs	r0, #1
 8049f44:	f001 fc6c 	bl	804b820 <calloc>
	heapSize += 1 * sizeof(kad_node_t);
 8049f48:	4e1f      	ldr	r6, [pc, #124]	@ (8049fc8 <kad_tanh+0x8c>)
	s = (kad_node_t*)calloc(1, sizeof(kad_node_t));
 8049f4a:	4605      	mov	r5, r0
	heapSize += 1 * sizeof(kad_node_t);
 8049f4c:	6833      	ldr	r3, [r6, #0]
	s->n_d = n_d, s->op = op, s->n_child = n_child;
 8049f4e:	2207      	movs	r2, #7
	heapSize += 1 * sizeof(kad_node_t);
 8049f50:	3340      	adds	r3, #64	@ 0x40
	s->n_d = n_d, s->op = op, s->n_child = n_child;
 8049f52:	2400      	movs	r4, #0
	heapSize += 1 * sizeof(kad_node_t);
 8049f54:	6033      	str	r3, [r6, #0]
	s->n_d = n_d, s->op = op, s->n_child = n_child;
 8049f56:	2301      	movs	r3, #1
		s->child = (kad_node_t**)calloc(s->n_child, sizeof(kad_node_t*));
 8049f58:	2104      	movs	r1, #4
 8049f5a:	4618      	mov	r0, r3
	s->n_d = n_d, s->op = op, s->n_child = n_child;
 8049f5c:	606b      	str	r3, [r5, #4]
 8049f5e:	806a      	strh	r2, [r5, #2]
 8049f60:	702c      	strb	r4, [r5, #0]
		s->child = (kad_node_t**)calloc(s->n_child, sizeof(kad_node_t*));
 8049f62:	f001 fc5d 	bl	804b820 <calloc>
 8049f66:	4603      	mov	r3, r0
		heapSize += s->n_child * sizeof(kad_node_t*);
 8049f68:	6832      	ldr	r2, [r6, #0]
	if (kad_op_list[s->op](s, KAD_SYNC_DIM) < 0) { /* check dimension */
 8049f6a:	2104      	movs	r1, #4
		heapSize += s->n_child * sizeof(kad_node_t*);
 8049f6c:	3204      	adds	r2, #4
 8049f6e:	6032      	str	r2, [r6, #0]
	if (kad_op_list[s->op](s, KAD_SYNC_DIM) < 0) { /* check dimension */
 8049f70:	4a16      	ldr	r2, [pc, #88]	@ (8049fcc <kad_tanh+0x90>)
 8049f72:	4628      	mov	r0, r5
 8049f74:	69d2      	ldr	r2, [r2, #28]
		s->child = (kad_node_t**)calloc(s->n_child, sizeof(kad_node_t*));
 8049f76:	63ab      	str	r3, [r5, #56]	@ 0x38
	s->child[0] = x;
 8049f78:	601f      	str	r7, [r3, #0]
	if (kad_op_list[s->op](s, KAD_SYNC_DIM) < 0) { /* check dimension */
 8049f7a:	4790      	blx	r2
 8049f7c:	42a0      	cmp	r0, r4
 8049f7e:	db16      	blt.n	8049fae <kad_tanh+0x72>
	for (i = 0; i < s->n_child; ++i)
 8049f80:	6868      	ldr	r0, [r5, #4]
 8049f82:	42a0      	cmp	r0, r4
 8049f84:	dd11      	ble.n	8049faa <kad_tanh+0x6e>
 8049f86:	6baa      	ldr	r2, [r5, #56]	@ 0x38
 8049f88:	4623      	mov	r3, r4
 8049f8a:	3a04      	subs	r2, #4
 8049f8c:	e002      	b.n	8049f94 <kad_tanh+0x58>
 8049f8e:	3301      	adds	r3, #1
 8049f90:	4298      	cmp	r0, r3
 8049f92:	d00a      	beq.n	8049faa <kad_tanh+0x6e>
		if (kad_is_back(s->child[i]))
 8049f94:	f852 1f04 	ldr.w	r1, [r2, #4]!
 8049f98:	7849      	ldrb	r1, [r1, #1]
 8049f9a:	07c9      	lsls	r1, r1, #31
 8049f9c:	d5f7      	bpl.n	8049f8e <kad_tanh+0x52>
	if (i < s->n_child) s->flag |= KAD_VAR;
 8049f9e:	4283      	cmp	r3, r0
 8049fa0:	da03      	bge.n	8049faa <kad_tanh+0x6e>
 8049fa2:	786b      	ldrb	r3, [r5, #1]
 8049fa4:	f043 0301 	orr.w	r3, r3, #1
 8049fa8:	706b      	strb	r3, [r5, #1]
KAD_FUNC_OP1(kad_tanh, 7)
 8049faa:	4628      	mov	r0, r5
 8049fac:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (s->ptr) free(s->ptr);
 8049fae:	6b28      	ldr	r0, [r5, #48]	@ 0x30
 8049fb0:	b108      	cbz	r0, 8049fb6 <kad_tanh+0x7a>
 8049fb2:	f001 fc59 	bl	804b868 <free>
		free(s->child); free(s);
 8049fb6:	6ba8      	ldr	r0, [r5, #56]	@ 0x38
 8049fb8:	f001 fc56 	bl	804b868 <free>
 8049fbc:	4628      	mov	r0, r5
 8049fbe:	2500      	movs	r5, #0
 8049fc0:	f001 fc52 	bl	804b868 <free>
KAD_FUNC_OP1(kad_tanh, 7)
 8049fc4:	4628      	mov	r0, r5
 8049fc6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8049fc8:	20018acc 	.word	0x20018acc
 8049fcc:	20018004 	.word	0x20018004

08049fd0 <kad_softmax>:
KAD_FUNC_OP1(kad_softmax, 14)
 8049fd0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	s = (kad_node_t*)calloc(1, sizeof(kad_node_t));
 8049fd2:	2140      	movs	r1, #64	@ 0x40
KAD_FUNC_OP1(kad_softmax, 14)
 8049fd4:	4607      	mov	r7, r0
	s = (kad_node_t*)calloc(1, sizeof(kad_node_t));
 8049fd6:	2001      	movs	r0, #1
 8049fd8:	f001 fc22 	bl	804b820 <calloc>
	heapSize += 1 * sizeof(kad_node_t);
 8049fdc:	4e1f      	ldr	r6, [pc, #124]	@ (804a05c <kad_softmax+0x8c>)
	s = (kad_node_t*)calloc(1, sizeof(kad_node_t));
 8049fde:	4605      	mov	r5, r0
	heapSize += 1 * sizeof(kad_node_t);
 8049fe0:	6833      	ldr	r3, [r6, #0]
	s->n_d = n_d, s->op = op, s->n_child = n_child;
 8049fe2:	220e      	movs	r2, #14
	heapSize += 1 * sizeof(kad_node_t);
 8049fe4:	3340      	adds	r3, #64	@ 0x40
	s->n_d = n_d, s->op = op, s->n_child = n_child;
 8049fe6:	2400      	movs	r4, #0
	heapSize += 1 * sizeof(kad_node_t);
 8049fe8:	6033      	str	r3, [r6, #0]
	s->n_d = n_d, s->op = op, s->n_child = n_child;
 8049fea:	2301      	movs	r3, #1
		s->child = (kad_node_t**)calloc(s->n_child, sizeof(kad_node_t*));
 8049fec:	2104      	movs	r1, #4
 8049fee:	4618      	mov	r0, r3
	s->n_d = n_d, s->op = op, s->n_child = n_child;
 8049ff0:	606b      	str	r3, [r5, #4]
 8049ff2:	806a      	strh	r2, [r5, #2]
 8049ff4:	702c      	strb	r4, [r5, #0]
		s->child = (kad_node_t**)calloc(s->n_child, sizeof(kad_node_t*));
 8049ff6:	f001 fc13 	bl	804b820 <calloc>
 8049ffa:	4603      	mov	r3, r0
		heapSize += s->n_child * sizeof(kad_node_t*);
 8049ffc:	6832      	ldr	r2, [r6, #0]
	if (kad_op_list[s->op](s, KAD_SYNC_DIM) < 0) { /* check dimension */
 8049ffe:	2104      	movs	r1, #4
		heapSize += s->n_child * sizeof(kad_node_t*);
 804a000:	3204      	adds	r2, #4
 804a002:	6032      	str	r2, [r6, #0]
	if (kad_op_list[s->op](s, KAD_SYNC_DIM) < 0) { /* check dimension */
 804a004:	4a16      	ldr	r2, [pc, #88]	@ (804a060 <kad_softmax+0x90>)
 804a006:	4628      	mov	r0, r5
 804a008:	6b92      	ldr	r2, [r2, #56]	@ 0x38
		s->child = (kad_node_t**)calloc(s->n_child, sizeof(kad_node_t*));
 804a00a:	63ab      	str	r3, [r5, #56]	@ 0x38
	s->child[0] = x;
 804a00c:	601f      	str	r7, [r3, #0]
	if (kad_op_list[s->op](s, KAD_SYNC_DIM) < 0) { /* check dimension */
 804a00e:	4790      	blx	r2
 804a010:	42a0      	cmp	r0, r4
 804a012:	db16      	blt.n	804a042 <kad_softmax+0x72>
	for (i = 0; i < s->n_child; ++i)
 804a014:	6868      	ldr	r0, [r5, #4]
 804a016:	42a0      	cmp	r0, r4
 804a018:	dd11      	ble.n	804a03e <kad_softmax+0x6e>
 804a01a:	6baa      	ldr	r2, [r5, #56]	@ 0x38
 804a01c:	4623      	mov	r3, r4
 804a01e:	3a04      	subs	r2, #4
 804a020:	e002      	b.n	804a028 <kad_softmax+0x58>
 804a022:	3301      	adds	r3, #1
 804a024:	4298      	cmp	r0, r3
 804a026:	d00a      	beq.n	804a03e <kad_softmax+0x6e>
		if (kad_is_back(s->child[i]))
 804a028:	f852 1f04 	ldr.w	r1, [r2, #4]!
 804a02c:	7849      	ldrb	r1, [r1, #1]
 804a02e:	07c9      	lsls	r1, r1, #31
 804a030:	d5f7      	bpl.n	804a022 <kad_softmax+0x52>
	if (i < s->n_child) s->flag |= KAD_VAR;
 804a032:	4283      	cmp	r3, r0
 804a034:	da03      	bge.n	804a03e <kad_softmax+0x6e>
 804a036:	786b      	ldrb	r3, [r5, #1]
 804a038:	f043 0301 	orr.w	r3, r3, #1
 804a03c:	706b      	strb	r3, [r5, #1]
KAD_FUNC_OP1(kad_softmax, 14)
 804a03e:	4628      	mov	r0, r5
 804a040:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (s->ptr) free(s->ptr);
 804a042:	6b28      	ldr	r0, [r5, #48]	@ 0x30
 804a044:	b108      	cbz	r0, 804a04a <kad_softmax+0x7a>
 804a046:	f001 fc0f 	bl	804b868 <free>
		free(s->child); free(s);
 804a04a:	6ba8      	ldr	r0, [r5, #56]	@ 0x38
 804a04c:	f001 fc0c 	bl	804b868 <free>
 804a050:	4628      	mov	r0, r5
 804a052:	2500      	movs	r5, #0
 804a054:	f001 fc08 	bl	804b868 <free>
KAD_FUNC_OP1(kad_softmax, 14)
 804a058:	4628      	mov	r0, r5
 804a05a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 804a05c:	20018acc 	.word	0x20018acc
 804a060:	20018004 	.word	0x20018004

0804a064 <kad_stdnorm>:
KAD_FUNC_OP1(kad_stdnorm, 32)
 804a064:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	s = (kad_node_t*)calloc(1, sizeof(kad_node_t));
 804a066:	2140      	movs	r1, #64	@ 0x40
KAD_FUNC_OP1(kad_stdnorm, 32)
 804a068:	4607      	mov	r7, r0
	s = (kad_node_t*)calloc(1, sizeof(kad_node_t));
 804a06a:	2001      	movs	r0, #1
 804a06c:	f001 fbd8 	bl	804b820 <calloc>
	heapSize += 1 * sizeof(kad_node_t);
 804a070:	4e20      	ldr	r6, [pc, #128]	@ (804a0f4 <kad_stdnorm+0x90>)
	s = (kad_node_t*)calloc(1, sizeof(kad_node_t));
 804a072:	4605      	mov	r5, r0
	heapSize += 1 * sizeof(kad_node_t);
 804a074:	6833      	ldr	r3, [r6, #0]
	s->n_d = n_d, s->op = op, s->n_child = n_child;
 804a076:	2220      	movs	r2, #32
	heapSize += 1 * sizeof(kad_node_t);
 804a078:	3340      	adds	r3, #64	@ 0x40
	s->n_d = n_d, s->op = op, s->n_child = n_child;
 804a07a:	2400      	movs	r4, #0
	heapSize += 1 * sizeof(kad_node_t);
 804a07c:	6033      	str	r3, [r6, #0]
	s->n_d = n_d, s->op = op, s->n_child = n_child;
 804a07e:	2301      	movs	r3, #1
		s->child = (kad_node_t**)calloc(s->n_child, sizeof(kad_node_t*));
 804a080:	2104      	movs	r1, #4
 804a082:	4618      	mov	r0, r3
	s->n_d = n_d, s->op = op, s->n_child = n_child;
 804a084:	606b      	str	r3, [r5, #4]
 804a086:	806a      	strh	r2, [r5, #2]
 804a088:	702c      	strb	r4, [r5, #0]
		s->child = (kad_node_t**)calloc(s->n_child, sizeof(kad_node_t*));
 804a08a:	f001 fbc9 	bl	804b820 <calloc>
 804a08e:	4603      	mov	r3, r0
		heapSize += s->n_child * sizeof(kad_node_t*);
 804a090:	6832      	ldr	r2, [r6, #0]
	if (kad_op_list[s->op](s, KAD_SYNC_DIM) < 0) { /* check dimension */
 804a092:	2104      	movs	r1, #4
		heapSize += s->n_child * sizeof(kad_node_t*);
 804a094:	3204      	adds	r2, #4
 804a096:	6032      	str	r2, [r6, #0]
	if (kad_op_list[s->op](s, KAD_SYNC_DIM) < 0) { /* check dimension */
 804a098:	4a17      	ldr	r2, [pc, #92]	@ (804a0f8 <kad_stdnorm+0x94>)
 804a09a:	4628      	mov	r0, r5
 804a09c:	f8d2 2080 	ldr.w	r2, [r2, #128]	@ 0x80
		s->child = (kad_node_t**)calloc(s->n_child, sizeof(kad_node_t*));
 804a0a0:	63ab      	str	r3, [r5, #56]	@ 0x38
	s->child[0] = x;
 804a0a2:	601f      	str	r7, [r3, #0]
	if (kad_op_list[s->op](s, KAD_SYNC_DIM) < 0) { /* check dimension */
 804a0a4:	4790      	blx	r2
 804a0a6:	42a0      	cmp	r0, r4
 804a0a8:	db16      	blt.n	804a0d8 <kad_stdnorm+0x74>
	for (i = 0; i < s->n_child; ++i)
 804a0aa:	6868      	ldr	r0, [r5, #4]
 804a0ac:	42a0      	cmp	r0, r4
 804a0ae:	dd11      	ble.n	804a0d4 <kad_stdnorm+0x70>
 804a0b0:	6baa      	ldr	r2, [r5, #56]	@ 0x38
 804a0b2:	4623      	mov	r3, r4
 804a0b4:	3a04      	subs	r2, #4
 804a0b6:	e002      	b.n	804a0be <kad_stdnorm+0x5a>
 804a0b8:	3301      	adds	r3, #1
 804a0ba:	4298      	cmp	r0, r3
 804a0bc:	d00a      	beq.n	804a0d4 <kad_stdnorm+0x70>
		if (kad_is_back(s->child[i]))
 804a0be:	f852 1f04 	ldr.w	r1, [r2, #4]!
 804a0c2:	7849      	ldrb	r1, [r1, #1]
 804a0c4:	07c9      	lsls	r1, r1, #31
 804a0c6:	d5f7      	bpl.n	804a0b8 <kad_stdnorm+0x54>
	if (i < s->n_child) s->flag |= KAD_VAR;
 804a0c8:	4283      	cmp	r3, r0
 804a0ca:	da03      	bge.n	804a0d4 <kad_stdnorm+0x70>
 804a0cc:	786b      	ldrb	r3, [r5, #1]
 804a0ce:	f043 0301 	orr.w	r3, r3, #1
 804a0d2:	706b      	strb	r3, [r5, #1]
KAD_FUNC_OP1(kad_stdnorm, 32)
 804a0d4:	4628      	mov	r0, r5
 804a0d6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (s->ptr) free(s->ptr);
 804a0d8:	6b28      	ldr	r0, [r5, #48]	@ 0x30
 804a0da:	b108      	cbz	r0, 804a0e0 <kad_stdnorm+0x7c>
 804a0dc:	f001 fbc4 	bl	804b868 <free>
		free(s->child); free(s);
 804a0e0:	6ba8      	ldr	r0, [r5, #56]	@ 0x38
 804a0e2:	f001 fbc1 	bl	804b868 <free>
 804a0e6:	4628      	mov	r0, r5
 804a0e8:	2500      	movs	r5, #0
 804a0ea:	f001 fbbd 	bl	804b868 <free>
KAD_FUNC_OP1(kad_stdnorm, 32)
 804a0ee:	4628      	mov	r0, r5
 804a0f0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 804a0f2:	bf00      	nop
 804a0f4:	20018acc 	.word	0x20018acc
 804a0f8:	20018004 	.word	0x20018004

0804a0fc <kad_avg>:
kad_node_t *kad_avg(int n, kad_node_t **x)   { return kad_pooling_general(10, n, x); }
 804a0fc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 804a0fe:	4605      	mov	r5, r0
 804a100:	460f      	mov	r7, r1
	s = (kad_node_t*)calloc(1, sizeof(kad_node_t));
 804a102:	2001      	movs	r0, #1
 804a104:	2140      	movs	r1, #64	@ 0x40
 804a106:	f001 fb8b 	bl	804b820 <calloc>
	s->n_d = n_d, s->op = op, s->n_child = n_child;
 804a10a:	2100      	movs	r1, #0
 804a10c:	220a      	movs	r2, #10
	heapSize += 1 * sizeof(kad_node_t);
 804a10e:	4e26      	ldr	r6, [pc, #152]	@ (804a1a8 <kad_avg+0xac>)
	s = (kad_node_t*)calloc(1, sizeof(kad_node_t));
 804a110:	4604      	mov	r4, r0
	heapSize += 1 * sizeof(kad_node_t);
 804a112:	6833      	ldr	r3, [r6, #0]
	s->n_d = n_d, s->op = op, s->n_child = n_child;
 804a114:	7001      	strb	r1, [r0, #0]
	heapSize += 1 * sizeof(kad_node_t);
 804a116:	3340      	adds	r3, #64	@ 0x40
 804a118:	6033      	str	r3, [r6, #0]
	s->n_d = n_d, s->op = op, s->n_child = n_child;
 804a11a:	8042      	strh	r2, [r0, #2]
 804a11c:	6045      	str	r5, [r0, #4]
	if (s->n_child) {
 804a11e:	bb0d      	cbnz	r5, 804a164 <kad_avg+0x68>
	s->flag |= KAD_POOL;
 804a120:	7843      	ldrb	r3, [r0, #1]
 804a122:	f043 0304 	orr.w	r3, r3, #4
 804a126:	7043      	strb	r3, [r0, #1]
	if (kad_op_list[s->op](s, KAD_SYNC_DIM) < 0) { /* check dimension */
 804a128:	4b20      	ldr	r3, [pc, #128]	@ (804a1ac <kad_avg+0xb0>)
 804a12a:	2104      	movs	r1, #4
 804a12c:	4620      	mov	r0, r4
 804a12e:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 804a130:	4798      	blx	r3
 804a132:	2800      	cmp	r0, #0
 804a134:	db2b      	blt.n	804a18e <kad_avg+0x92>
	for (i = 0; i < s->n_child; ++i)
 804a136:	6860      	ldr	r0, [r4, #4]
 804a138:	2800      	cmp	r0, #0
 804a13a:	dd11      	ble.n	804a160 <kad_avg+0x64>
 804a13c:	6ba2      	ldr	r2, [r4, #56]	@ 0x38
 804a13e:	2300      	movs	r3, #0
 804a140:	3a04      	subs	r2, #4
 804a142:	e002      	b.n	804a14a <kad_avg+0x4e>
 804a144:	3301      	adds	r3, #1
 804a146:	4298      	cmp	r0, r3
 804a148:	d00a      	beq.n	804a160 <kad_avg+0x64>
		if (kad_is_back(s->child[i]))
 804a14a:	f852 1f04 	ldr.w	r1, [r2, #4]!
 804a14e:	7849      	ldrb	r1, [r1, #1]
 804a150:	07c9      	lsls	r1, r1, #31
 804a152:	d5f7      	bpl.n	804a144 <kad_avg+0x48>
	if (i < s->n_child) s->flag |= KAD_VAR;
 804a154:	4283      	cmp	r3, r0
 804a156:	da03      	bge.n	804a160 <kad_avg+0x64>
 804a158:	7863      	ldrb	r3, [r4, #1]
 804a15a:	f043 0301 	orr.w	r3, r3, #1
 804a15e:	7063      	strb	r3, [r4, #1]
kad_node_t *kad_avg(int n, kad_node_t **x)   { return kad_pooling_general(10, n, x); }
 804a160:	4620      	mov	r0, r4
 804a162:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		s->child = (kad_node_t**)calloc(s->n_child, sizeof(kad_node_t*));
 804a164:	2104      	movs	r1, #4
 804a166:	4628      	mov	r0, r5
 804a168:	f001 fb5a 	bl	804b820 <calloc>
		heapSize += s->n_child * sizeof(kad_node_t*);
 804a16c:	6833      	ldr	r3, [r6, #0]
	for (i = 0; i < n; ++i)
 804a16e:	2d00      	cmp	r5, #0
		heapSize += s->n_child * sizeof(kad_node_t*);
 804a170:	eb03 0385 	add.w	r3, r3, r5, lsl #2
 804a174:	6033      	str	r3, [r6, #0]
	s->flag |= KAD_POOL;
 804a176:	7863      	ldrb	r3, [r4, #1]
		s->child = (kad_node_t**)calloc(s->n_child, sizeof(kad_node_t*));
 804a178:	63a0      	str	r0, [r4, #56]	@ 0x38
	s->flag |= KAD_POOL;
 804a17a:	f043 0304 	orr.w	r3, r3, #4
 804a17e:	7063      	strb	r3, [r4, #1]
		heapSize += s->n_child * sizeof(kad_node_t*);
 804a180:	ea4f 0285 	mov.w	r2, r5, lsl #2
	for (i = 0; i < n; ++i)
 804a184:	ddd0      	ble.n	804a128 <kad_avg+0x2c>
		s->child[i] = x[i];
 804a186:	4639      	mov	r1, r7
 804a188:	f001 ff51 	bl	804c02e <memcpy>
 804a18c:	e7cc      	b.n	804a128 <kad_avg+0x2c>
		if (s->ptr) free(s->ptr);
 804a18e:	6b20      	ldr	r0, [r4, #48]	@ 0x30
 804a190:	b108      	cbz	r0, 804a196 <kad_avg+0x9a>
 804a192:	f001 fb69 	bl	804b868 <free>
		free(s->child); free(s);
 804a196:	6ba0      	ldr	r0, [r4, #56]	@ 0x38
 804a198:	f001 fb66 	bl	804b868 <free>
 804a19c:	4620      	mov	r0, r4
 804a19e:	2400      	movs	r4, #0
 804a1a0:	f001 fb62 	bl	804b868 <free>
kad_node_t *kad_avg(int n, kad_node_t **x)   { return kad_pooling_general(10, n, x); }
 804a1a4:	4620      	mov	r0, r4
 804a1a6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 804a1a8:	20018acc 	.word	0x20018acc
 804a1ac:	20018004 	.word	0x20018004

0804a1b0 <kad_sync_dim>:
{
 804a1b0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	for (i = 0; i < n; ++i) {
 804a1b4:	1e06      	subs	r6, r0, #0
{
 804a1b6:	4617      	mov	r7, r2
	for (i = 0; i < n; ++i) {
 804a1b8:	dd5a      	ble.n	804a270 <kad_sync_dim+0xc0>
 804a1ba:	2a00      	cmp	r2, #0
 804a1bc:	4689      	mov	r9, r1
 804a1be:	f1a1 0404 	sub.w	r4, r1, #4
 804a1c2:	dd3d      	ble.n	804a240 <kad_sync_dim+0x90>
	int i, req_alloc = 0, req_sync = 0, old_size = 0;
 804a1c4:	f04f 0800 	mov.w	r8, #0
 804a1c8:	46a3      	mov	fp, r4
 804a1ca:	46c2      	mov	sl, r8
	for (i = 0; i < n; ++i) {
 804a1cc:	4645      	mov	r5, r8
		if (kad_is_feed(v[i])) {
 804a1ce:	f85b 0f04 	ldr.w	r0, [fp, #4]!
 804a1d2:	6842      	ldr	r2, [r0, #4]
 804a1d4:	2a00      	cmp	r2, #0
 804a1d6:	d125      	bne.n	804a224 <kad_sync_dim+0x74>
 804a1d8:	7842      	ldrb	r2, [r0, #1]
 804a1da:	0793      	lsls	r3, r2, #30
 804a1dc:	d106      	bne.n	804a1ec <kad_sync_dim+0x3c>
			old_size = v[i]->d[0]; /* TODO: check if all feeds have the same batch size */
 804a1de:	f8d0 8010 	ldr.w	r8, [r0, #16]
			if (batch_size > 0 && v[i]->d[0] != batch_size)
 804a1e2:	4547      	cmp	r7, r8
 804a1e4:	d002      	beq.n	804a1ec <kad_sync_dim+0x3c>
				v[i]->d[0] = batch_size, req_sync = 1;
 804a1e6:	f04f 0a01 	mov.w	sl, #1
 804a1ea:	6107      	str	r7, [r0, #16]
	for (i = 0; i < n; ++i) {
 804a1ec:	3501      	adds	r5, #1
 804a1ee:	42ae      	cmp	r6, r5
 804a1f0:	d1ed      	bne.n	804a1ce <kad_sync_dim+0x1e>
 804a1f2:	00b1      	lsls	r1, r6, #2
	if (old_size < batch_size) req_alloc = 1;
 804a1f4:	45b8      	cmp	r8, r7
 804a1f6:	4623      	mov	r3, r4
 804a1f8:	bfac      	ite	ge
 804a1fa:	2200      	movge	r2, #0
 804a1fc:	2201      	movlt	r2, #1
	for (i = 0; i < n; ++i)
 804a1fe:	4421      	add	r1, r4
		if (v[i]->n_child > 0 && v[i]->x == 0) req_alloc = 1;
 804a200:	f853 4f04 	ldr.w	r4, [r3, #4]!
 804a204:	6860      	ldr	r0, [r4, #4]
 804a206:	2800      	cmp	r0, #0
 804a208:	dd03      	ble.n	804a212 <kad_sync_dim+0x62>
 804a20a:	6aa0      	ldr	r0, [r4, #40]	@ 0x28
 804a20c:	2800      	cmp	r0, #0
 804a20e:	bf08      	it	eq
 804a210:	2201      	moveq	r2, #1
	for (i = 0; i < n; ++i)
 804a212:	4299      	cmp	r1, r3
 804a214:	d1f4      	bne.n	804a200 <kad_sync_dim+0x50>
	if (req_alloc) kad_allocate_internal(n, v);
 804a216:	bb32      	cbnz	r2, 804a266 <kad_sync_dim+0xb6>
	return batch_size > 0? batch_size : old_size;
 804a218:	2f00      	cmp	r7, #0
 804a21a:	dd00      	ble.n	804a21e <kad_sync_dim+0x6e>
	int i, req_alloc = 0, req_sync = 0, old_size = 0;
 804a21c:	46b8      	mov	r8, r7
}
 804a21e:	4640      	mov	r0, r8
 804a220:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		} else if (v[i]->n_child > 0 && req_sync)
 804a224:	dde2      	ble.n	804a1ec <kad_sync_dim+0x3c>
 804a226:	f1ba 0f00 	cmp.w	sl, #0
 804a22a:	d0df      	beq.n	804a1ec <kad_sync_dim+0x3c>
			kad_op_list[v[i]->op](v[i], KAD_SYNC_DIM);
 804a22c:	8842      	ldrh	r2, [r0, #2]
 804a22e:	4b14      	ldr	r3, [pc, #80]	@ (804a280 <kad_sync_dim+0xd0>)
 804a230:	2104      	movs	r1, #4
 804a232:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
	for (i = 0; i < n; ++i) {
 804a236:	3501      	adds	r5, #1
			kad_op_list[v[i]->op](v[i], KAD_SYNC_DIM);
 804a238:	4790      	blx	r2
	for (i = 0; i < n; ++i) {
 804a23a:	42ae      	cmp	r6, r5
 804a23c:	d1c7      	bne.n	804a1ce <kad_sync_dim+0x1e>
 804a23e:	e7d8      	b.n	804a1f2 <kad_sync_dim+0x42>
 804a240:	4623      	mov	r3, r4
	int i, req_alloc = 0, req_sync = 0, old_size = 0;
 804a242:	f04f 0800 	mov.w	r8, #0
 804a246:	00b1      	lsls	r1, r6, #2
 804a248:	eb04 0586 	add.w	r5, r4, r6, lsl #2
		if (kad_is_feed(v[i])) {
 804a24c:	f853 0f04 	ldr.w	r0, [r3, #4]!
 804a250:	6842      	ldr	r2, [r0, #4]
 804a252:	b92a      	cbnz	r2, 804a260 <kad_sync_dim+0xb0>
 804a254:	7842      	ldrb	r2, [r0, #1]
 804a256:	f012 0f03 	tst.w	r2, #3
			old_size = v[i]->d[0]; /* TODO: check if all feeds have the same batch size */
 804a25a:	bf08      	it	eq
 804a25c:	f8d0 8010 	ldreq.w	r8, [r0, #16]
	for (i = 0; i < n; ++i) {
 804a260:	42ab      	cmp	r3, r5
 804a262:	d1f3      	bne.n	804a24c <kad_sync_dim+0x9c>
 804a264:	e7c6      	b.n	804a1f4 <kad_sync_dim+0x44>
	if (req_alloc) kad_allocate_internal(n, v);
 804a266:	4649      	mov	r1, r9
 804a268:	4630      	mov	r0, r6
 804a26a:	f7fc fb87 	bl	804697c <kad_allocate_internal>
 804a26e:	e7d3      	b.n	804a218 <kad_sync_dim+0x68>
 804a270:	2a00      	cmp	r2, #0
 804a272:	dc02      	bgt.n	804a27a <kad_sync_dim+0xca>
	int i, req_alloc = 0, req_sync = 0, old_size = 0;
 804a274:	f04f 0800 	mov.w	r8, #0
	return batch_size > 0? batch_size : old_size;
 804a278:	e7d1      	b.n	804a21e <kad_sync_dim+0x6e>
	if (req_alloc) kad_allocate_internal(n, v);
 804a27a:	f7fc fb7f 	bl	804697c <kad_allocate_internal>
	return batch_size > 0? batch_size : old_size;
 804a27e:	e7cd      	b.n	804a21c <kad_sync_dim+0x6c>
 804a280:	20018004 	.word	0x20018004

0804a284 <kad_compile_array>:
{
 804a284:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	for (i = 0; i < n_roots; ++i) {
 804a288:	1e0b      	subs	r3, r1, #0
{
 804a28a:	b085      	sub	sp, #20
 804a28c:	9003      	str	r0, [sp, #12]
	for (i = 0; i < n_roots; ++i) {
 804a28e:	9301      	str	r3, [sp, #4]
 804a290:	f340 80f0 	ble.w	804a474 <kad_compile_array+0x1f0>
	kvec_t(kad_node_p) stack = {0,0,0}, a = {0,0,0};
 804a294:	2700      	movs	r7, #0
 804a296:	1f13      	subs	r3, r2, #4
 804a298:	461e      	mov	r6, r3
	for (i = 0; i < n_roots; ++i) {
 804a29a:	4698      	mov	r8, r3
		roots[i]->tmp = 1; /* mark the root */
 804a29c:	f04f 0a01 	mov.w	sl, #1
	for (i = 0; i < n_roots; ++i) {
 804a2a0:	463c      	mov	r4, r7
	kvec_t(kad_node_p) stack = {0,0,0}, a = {0,0,0};
 804a2a2:	46b9      	mov	r9, r7
 804a2a4:	9302      	str	r3, [sp, #8]
 804a2a6:	e005      	b.n	804a2b4 <kad_compile_array+0x30>
	for (i = 0; i < n_roots; ++i) {
 804a2a8:	9b01      	ldr	r3, [sp, #4]
		kv_push(kad_node_p, stack, roots[i]);
 804a2aa:	f847 5024 	str.w	r5, [r7, r4, lsl #2]
	for (i = 0; i < n_roots; ++i) {
 804a2ae:	3401      	adds	r4, #1
 804a2b0:	42a3      	cmp	r3, r4
 804a2b2:	d013      	beq.n	804a2dc <kad_compile_array+0x58>
		roots[i]->tmp = 1; /* mark the root */
 804a2b4:	f858 5f04 	ldr.w	r5, [r8, #4]!
		kv_push(kad_node_p, stack, roots[i]);
 804a2b8:	454c      	cmp	r4, r9
		roots[i]->tmp = 1; /* mark the root */
 804a2ba:	f8c5 a008 	str.w	sl, [r5, #8]
		kv_push(kad_node_p, stack, roots[i]);
 804a2be:	d1f3      	bne.n	804a2a8 <kad_compile_array+0x24>
 804a2c0:	b394      	cbz	r4, 804a328 <kad_compile_array+0xa4>
 804a2c2:	ea4f 0944 	mov.w	r9, r4, lsl #1
 804a2c6:	00e1      	lsls	r1, r4, #3
 804a2c8:	4638      	mov	r0, r7
 804a2ca:	f001 fbb1 	bl	804ba30 <realloc>
 804a2ce:	4607      	mov	r7, r0
	for (i = 0; i < n_roots; ++i) {
 804a2d0:	9b01      	ldr	r3, [sp, #4]
		kv_push(kad_node_p, stack, roots[i]);
 804a2d2:	f847 5024 	str.w	r5, [r7, r4, lsl #2]
	for (i = 0; i < n_roots; ++i) {
 804a2d6:	3401      	adds	r4, #1
 804a2d8:	42a3      	cmp	r3, r4
 804a2da:	d1eb      	bne.n	804a2b4 <kad_compile_array+0x30>
 804a2dc:	f103 38ff 	add.w	r8, r3, #4294967295
		for (i = 0; i < p->n_child; ++i) {
 804a2e0:	686a      	ldr	r2, [r5, #4]
 804a2e2:	2a00      	cmp	r2, #0
 804a2e4:	dd24      	ble.n	804a330 <kad_compile_array+0xac>
			kad_node_t *q = p->child[i];
 804a2e6:	6bab      	ldr	r3, [r5, #56]	@ 0x38
 804a2e8:	f1a3 0b04 	sub.w	fp, r3, #4
 804a2ec:	eb0b 0a82 	add.w	sl, fp, r2, lsl #2
 804a2f0:	e007      	b.n	804a302 <kad_compile_array+0x7e>
			if (q->tmp == 0) kv_push(kad_node_p, stack, q);
 804a2f2:	f847 5028 	str.w	r5, [r7, r8, lsl #2]
 804a2f6:	f108 0801 	add.w	r8, r8, #1
			q->tmp += 1<<1;
 804a2fa:	3402      	adds	r4, #2
		for (i = 0; i < p->n_child; ++i) {
 804a2fc:	45da      	cmp	sl, fp
			q->tmp += 1<<1;
 804a2fe:	60ac      	str	r4, [r5, #8]
		for (i = 0; i < p->n_child; ++i) {
 804a300:	d016      	beq.n	804a330 <kad_compile_array+0xac>
			kad_node_t *q = p->child[i];
 804a302:	f85b 5f04 	ldr.w	r5, [fp, #4]!
			if (q->tmp == 0) kv_push(kad_node_p, stack, q);
 804a306:	68ac      	ldr	r4, [r5, #8]
 804a308:	2c00      	cmp	r4, #0
 804a30a:	d1f6      	bne.n	804a2fa <kad_compile_array+0x76>
 804a30c:	45c1      	cmp	r9, r8
 804a30e:	d1f0      	bne.n	804a2f2 <kad_compile_array+0x6e>
 804a310:	f1b9 0f00 	cmp.w	r9, #0
 804a314:	d014      	beq.n	804a340 <kad_compile_array+0xbc>
 804a316:	ea4f 0949 	mov.w	r9, r9, lsl #1
 804a31a:	ea4f 0189 	mov.w	r1, r9, lsl #2
 804a31e:	4638      	mov	r0, r7
 804a320:	f001 fb86 	bl	804ba30 <realloc>
 804a324:	4607      	mov	r7, r0
 804a326:	e7e4      	b.n	804a2f2 <kad_compile_array+0x6e>
 804a328:	2108      	movs	r1, #8
		kv_push(kad_node_p, stack, roots[i]);
 804a32a:	f04f 0902 	mov.w	r9, #2
 804a32e:	e7cb      	b.n	804a2c8 <kad_compile_array+0x44>
	while (stack.n) {
 804a330:	f1b8 0f00 	cmp.w	r8, #0
 804a334:	d008      	beq.n	804a348 <kad_compile_array+0xc4>
		kad_node_t *p = kv_pop(stack);
 804a336:	f108 38ff 	add.w	r8, r8, #4294967295
 804a33a:	f857 5028 	ldr.w	r5, [r7, r8, lsl #2]
 804a33e:	e7cf      	b.n	804a2e0 <kad_compile_array+0x5c>
 804a340:	2108      	movs	r1, #8
			if (q->tmp == 0) kv_push(kad_node_p, stack, q);
 804a342:	f04f 0902 	mov.w	r9, #2
 804a346:	e7ea      	b.n	804a31e <kad_compile_array+0x9a>
 804a348:	e9dd 2301 	ldrd	r2, r3, [sp, #4]
	while (stack.n) {
 804a34c:	4644      	mov	r4, r8
 804a34e:	eb03 0a82 	add.w	sl, r3, r2, lsl #2
 804a352:	e004      	b.n	804a35e <kad_compile_array+0xda>
			kv_push(kad_node_p, stack, roots[i]);
 804a354:	f847 5024 	str.w	r5, [r7, r4, lsl #2]
 804a358:	3401      	adds	r4, #1
	for (i = 0; i < n_roots; ++i)
 804a35a:	45b2      	cmp	sl, r6
 804a35c:	d010      	beq.n	804a380 <kad_compile_array+0xfc>
		if (roots[i]->tmp>>1 == 0) /* if roots[i]->tmp>>1 != 0, it is not a real root */
 804a35e:	f856 5f04 	ldr.w	r5, [r6, #4]!
 804a362:	68ab      	ldr	r3, [r5, #8]
 804a364:	085b      	lsrs	r3, r3, #1
 804a366:	d1f8      	bne.n	804a35a <kad_compile_array+0xd6>
			kv_push(kad_node_p, stack, roots[i]);
 804a368:	454c      	cmp	r4, r9
 804a36a:	d1f3      	bne.n	804a354 <kad_compile_array+0xd0>
 804a36c:	2c00      	cmp	r4, #0
 804a36e:	d07d      	beq.n	804a46c <kad_compile_array+0x1e8>
 804a370:	ea4f 0944 	mov.w	r9, r4, lsl #1
 804a374:	00e1      	lsls	r1, r4, #3
 804a376:	4638      	mov	r0, r7
 804a378:	f001 fb5a 	bl	804ba30 <realloc>
 804a37c:	4607      	mov	r7, r0
 804a37e:	e7e9      	b.n	804a354 <kad_compile_array+0xd0>
	while (stack.n) {
 804a380:	2c00      	cmp	r4, #0
 804a382:	d078      	beq.n	804a476 <kad_compile_array+0x1f2>
	kvec_t(kad_node_p) stack = {0,0,0}, a = {0,0,0};
 804a384:	f04f 0b00 	mov.w	fp, #0
 804a388:	f8cd b004 	str.w	fp, [sp, #4]
		kad_node_t *p = kv_pop(stack);
 804a38c:	3c01      	subs	r4, #1
		kv_push(kad_node_p, a, p);
 804a38e:	45c3      	cmp	fp, r8
		kad_node_t *p = kv_pop(stack);
 804a390:	f857 5024 	ldr.w	r5, [r7, r4, lsl #2]
		kv_push(kad_node_p, a, p);
 804a394:	d05a      	beq.n	804a44c <kad_compile_array+0x1c8>
		for (i = 0; i < p->n_child; ++i) {
 804a396:	686b      	ldr	r3, [r5, #4]
		kv_push(kad_node_p, a, p);
 804a398:	9a01      	ldr	r2, [sp, #4]
 804a39a:	f10b 0b01 	add.w	fp, fp, #1
 804a39e:	eb02 028b 	add.w	r2, r2, fp, lsl #2
		for (i = 0; i < p->n_child; ++i) {
 804a3a2:	2b00      	cmp	r3, #0
		kv_push(kad_node_p, a, p);
 804a3a4:	9202      	str	r2, [sp, #8]
 804a3a6:	f842 5c04 	str.w	r5, [r2, #-4]
		for (i = 0; i < p->n_child; ++i) {
 804a3aa:	dd1c      	ble.n	804a3e6 <kad_compile_array+0x162>
			p->child[i]->tmp -= 1<<1;
 804a3ac:	6bae      	ldr	r6, [r5, #56]	@ 0x38
 804a3ae:	3e04      	subs	r6, #4
 804a3b0:	eb06 0a83 	add.w	sl, r6, r3, lsl #2
 804a3b4:	e004      	b.n	804a3c0 <kad_compile_array+0x13c>
				kv_push(kad_node_p, stack, p->child[i]);
 804a3b6:	f847 5024 	str.w	r5, [r7, r4, lsl #2]
 804a3ba:	3401      	adds	r4, #1
		for (i = 0; i < p->n_child; ++i) {
 804a3bc:	45b2      	cmp	sl, r6
 804a3be:	d012      	beq.n	804a3e6 <kad_compile_array+0x162>
			p->child[i]->tmp -= 1<<1;
 804a3c0:	f856 5f04 	ldr.w	r5, [r6, #4]!
 804a3c4:	68a9      	ldr	r1, [r5, #8]
 804a3c6:	3902      	subs	r1, #2
 804a3c8:	60a9      	str	r1, [r5, #8]
			if (p->child[i]->tmp>>1 == 0)
 804a3ca:	0849      	lsrs	r1, r1, #1
 804a3cc:	d1f6      	bne.n	804a3bc <kad_compile_array+0x138>
				kv_push(kad_node_p, stack, p->child[i]);
 804a3ce:	454c      	cmp	r4, r9
 804a3d0:	d1f1      	bne.n	804a3b6 <kad_compile_array+0x132>
 804a3d2:	2c00      	cmp	r4, #0
 804a3d4:	d036      	beq.n	804a444 <kad_compile_array+0x1c0>
 804a3d6:	ea4f 0944 	mov.w	r9, r4, lsl #1
 804a3da:	00e1      	lsls	r1, r4, #3
 804a3dc:	4638      	mov	r0, r7
 804a3de:	f001 fb27 	bl	804ba30 <realloc>
 804a3e2:	4607      	mov	r7, r0
 804a3e4:	e7e7      	b.n	804a3b6 <kad_compile_array+0x132>
	while (stack.n) {
 804a3e6:	2c00      	cmp	r4, #0
 804a3e8:	d1d0      	bne.n	804a38c <kad_compile_array+0x108>
	free(stack.a);
 804a3ea:	4638      	mov	r0, r7
 804a3ec:	f001 fa3c 	bl	804b868 <free>
	for (i = 0; i < (int)a.n; ++i) { /* check cycles; no cycles if constructed with kad_add() etc */
 804a3f0:	f1bb 0f00 	cmp.w	fp, #0
 804a3f4:	dd4d      	ble.n	804a492 <kad_compile_array+0x20e>
 804a3f6:	9b01      	ldr	r3, [sp, #4]
 804a3f8:	1f1d      	subs	r5, r3, #4
 804a3fa:	4628      	mov	r0, r5
		assert(a.a[i]->tmp>>1 == 0);
 804a3fc:	f850 1f04 	ldr.w	r1, [r0, #4]!
 804a400:	688b      	ldr	r3, [r1, #8]
 804a402:	105b      	asrs	r3, r3, #1
 804a404:	d13e      	bne.n	804a484 <kad_compile_array+0x200>
	for (i = 0; i < (int)a.n; ++i) { /* check cycles; no cycles if constructed with kad_add() etc */
 804a406:	3401      	adds	r4, #1
 804a408:	45a3      	cmp	fp, r4
		a.a[i]->tmp = 0;
 804a40a:	608b      	str	r3, [r1, #8]
	for (i = 0; i < (int)a.n; ++i) { /* check cycles; no cycles if constructed with kad_add() etc */
 804a40c:	d1f6      	bne.n	804a3fc <kad_compile_array+0x178>
	for (i = 0; i < (int)a.n>>1; ++i) { /* reverse a.a[] */
 804a40e:	1061      	asrs	r1, r4, #1
 804a410:	d03f      	beq.n	804a492 <kad_compile_array+0x20e>
 804a412:	e9dd 3a01 	ldrd	r3, sl, [sp, #4]
 804a416:	eb03 0181 	add.w	r1, r3, r1, lsl #2
 804a41a:	3904      	subs	r1, #4
		t = a.a[i], a.a[i] = a.a[a.n-1-i], a.a[a.n-1-i] = t;
 804a41c:	f855 3f04 	ldr.w	r3, [r5, #4]!
 804a420:	f85a 2d04 	ldr.w	r2, [sl, #-4]!
	for (i = 0; i < (int)a.n>>1; ++i) { /* reverse a.a[] */
 804a424:	42a9      	cmp	r1, r5
		t = a.a[i], a.a[i] = a.a[a.n-1-i], a.a[a.n-1-i] = t;
 804a426:	602a      	str	r2, [r5, #0]
 804a428:	f8ca 3000 	str.w	r3, [sl]
	for (i = 0; i < (int)a.n>>1; ++i) { /* reverse a.a[] */
 804a42c:	d1f6      	bne.n	804a41c <kad_compile_array+0x198>
	kad_allocate_internal(a.n, a.a);
 804a42e:	9d01      	ldr	r5, [sp, #4]
 804a430:	4620      	mov	r0, r4
 804a432:	4629      	mov	r1, r5
 804a434:	f7fc faa2 	bl	804697c <kad_allocate_internal>
}
 804a438:	4628      	mov	r0, r5
	*n_node = a.n;
 804a43a:	9b03      	ldr	r3, [sp, #12]
 804a43c:	601c      	str	r4, [r3, #0]
}
 804a43e:	b005      	add	sp, #20
 804a440:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 804a444:	2108      	movs	r1, #8
				kv_push(kad_node_p, stack, p->child[i]);
 804a446:	f04f 0902 	mov.w	r9, #2
 804a44a:	e7c7      	b.n	804a3dc <kad_compile_array+0x158>
		kv_push(kad_node_p, a, p);
 804a44c:	f1bb 0f00 	cmp.w	fp, #0
 804a450:	d008      	beq.n	804a464 <kad_compile_array+0x1e0>
 804a452:	ea4f 084b 	mov.w	r8, fp, lsl #1
 804a456:	ea4f 01cb 	mov.w	r1, fp, lsl #3
 804a45a:	9801      	ldr	r0, [sp, #4]
 804a45c:	f001 fae8 	bl	804ba30 <realloc>
 804a460:	9001      	str	r0, [sp, #4]
 804a462:	e798      	b.n	804a396 <kad_compile_array+0x112>
 804a464:	2108      	movs	r1, #8
 804a466:	f04f 0802 	mov.w	r8, #2
 804a46a:	e7f6      	b.n	804a45a <kad_compile_array+0x1d6>
 804a46c:	2108      	movs	r1, #8
			kv_push(kad_node_p, stack, roots[i]);
 804a46e:	f04f 0902 	mov.w	r9, #2
 804a472:	e780      	b.n	804a376 <kad_compile_array+0xf2>
	for (i = 0; i < n_roots; ++i) {
 804a474:	2700      	movs	r7, #0
	free(stack.a);
 804a476:	2300      	movs	r3, #0
 804a478:	4638      	mov	r0, r7
 804a47a:	461c      	mov	r4, r3
 804a47c:	9301      	str	r3, [sp, #4]
 804a47e:	f001 f9f3 	bl	804b868 <free>
	for (i = 0; i < (int)a.n>>1; ++i) { /* reverse a.a[] */
 804a482:	e7d4      	b.n	804a42e <kad_compile_array+0x1aa>
		assert(a.a[i]->tmp>>1 == 0);
 804a484:	f44f 71f1 	mov.w	r1, #482	@ 0x1e2
 804a488:	4b03      	ldr	r3, [pc, #12]	@ (804a498 <kad_compile_array+0x214>)
 804a48a:	4a04      	ldr	r2, [pc, #16]	@ (804a49c <kad_compile_array+0x218>)
 804a48c:	4804      	ldr	r0, [pc, #16]	@ (804a4a0 <kad_compile_array+0x21c>)
 804a48e:	f001 f9a9 	bl	804b7e4 <__assert_func>
	for (i = 0; i < (int)a.n; ++i) { /* check cycles; no cycles if constructed with kad_add() etc */
 804a492:	465c      	mov	r4, fp
 804a494:	e7cb      	b.n	804a42e <kad_compile_array+0x1aa>
 804a496:	bf00      	nop
 804a498:	0804e49c 	.word	0x0804e49c
 804a49c:	0804e5e8 	.word	0x0804e5e8
 804a4a0:	0804e3dc 	.word	0x0804e3dc

0804a4a4 <kad_delete>:
{
 804a4a4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	for (i = 0; i < n; ++i) {
 804a4a6:	1e06      	subs	r6, r0, #0
{
 804a4a8:	460f      	mov	r7, r1
	for (i = 0; i < n; ++i) {
 804a4aa:	dd1d      	ble.n	804a4e8 <kad_delete+0x44>
 804a4ac:	1f0d      	subs	r5, r1, #4
 804a4ae:	eb05 0686 	add.w	r6, r5, r6, lsl #2
 804a4b2:	e00d      	b.n	804a4d0 <kad_delete+0x2c>
		free(p->child); free(p->ptr); free(p->gtmp); free(p);
 804a4b4:	6ba0      	ldr	r0, [r4, #56]	@ 0x38
 804a4b6:	f001 f9d7 	bl	804b868 <free>
 804a4ba:	6b20      	ldr	r0, [r4, #48]	@ 0x30
 804a4bc:	f001 f9d4 	bl	804b868 <free>
 804a4c0:	6b60      	ldr	r0, [r4, #52]	@ 0x34
 804a4c2:	f001 f9d1 	bl	804b868 <free>
 804a4c6:	4620      	mov	r0, r4
 804a4c8:	f001 f9ce 	bl	804b868 <free>
	for (i = 0; i < n; ++i) {
 804a4cc:	42b5      	cmp	r5, r6
 804a4ce:	d00b      	beq.n	804a4e8 <kad_delete+0x44>
		kad_node_t *p = a[i];
 804a4d0:	f855 4f04 	ldr.w	r4, [r5, #4]!
		if (p->n_child) {
 804a4d4:	6863      	ldr	r3, [r4, #4]
 804a4d6:	2b00      	cmp	r3, #0
 804a4d8:	d0ec      	beq.n	804a4b4 <kad_delete+0x10>
			free(p->x); free(p->g);
 804a4da:	6aa0      	ldr	r0, [r4, #40]	@ 0x28
 804a4dc:	f001 f9c4 	bl	804b868 <free>
 804a4e0:	6ae0      	ldr	r0, [r4, #44]	@ 0x2c
 804a4e2:	f001 f9c1 	bl	804b868 <free>
		free(p->child); free(p->ptr); free(p->gtmp); free(p);
 804a4e6:	e7e5      	b.n	804a4b4 <kad_delete+0x10>
	free(a);
 804a4e8:	4638      	mov	r0, r7
}
 804a4ea:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	free(a);
 804a4ee:	f001 b9bb 	b.w	804b868 <free>
 804a4f2:	bf00      	nop

0804a4f4 <kad_size_var>:
	for (i = c = 0; i < n; ++i)
 804a4f4:	f1b0 0c00 	subs.w	ip, r0, #0
 804a4f8:	f04f 0000 	mov.w	r0, #0
 804a4fc:	dd32      	ble.n	804a564 <kad_size_var+0x70>
 804a4fe:	3904      	subs	r1, #4
 804a500:	eb01 0c8c 	add.w	ip, r1, ip, lsl #2
 804a504:	e001      	b.n	804a50a <kad_size_var+0x16>
 804a506:	4561      	cmp	r1, ip
 804a508:	d029      	beq.n	804a55e <kad_size_var+0x6a>
		if (kad_is_var(v[i]))
 804a50a:	f851 3f04 	ldr.w	r3, [r1, #4]!
 804a50e:	685a      	ldr	r2, [r3, #4]
 804a510:	2a00      	cmp	r2, #0
 804a512:	d1f8      	bne.n	804a506 <kad_size_var+0x12>
 804a514:	785a      	ldrb	r2, [r3, #1]
 804a516:	07d2      	lsls	r2, r2, #31
 804a518:	d5f5      	bpl.n	804a506 <kad_size_var+0x12>
{
 804a51a:	b430      	push	{r4, r5}
 804a51c:	781c      	ldrb	r4, [r3, #0]
 804a51e:	b1fc      	cbz	r4, 804a560 <kad_size_var+0x6c>
 804a520:	2c01      	cmp	r4, #1
 804a522:	691a      	ldr	r2, [r3, #16]
 804a524:	d00c      	beq.n	804a540 <kad_size_var+0x4c>
 804a526:	695d      	ldr	r5, [r3, #20]
 804a528:	2c02      	cmp	r4, #2
 804a52a:	fb05 f202 	mul.w	r2, r5, r2
 804a52e:	d007      	beq.n	804a540 <kad_size_var+0x4c>
 804a530:	699d      	ldr	r5, [r3, #24]
 804a532:	2c03      	cmp	r4, #3
 804a534:	fb05 f202 	mul.w	r2, r5, r2
 804a538:	d002      	beq.n	804a540 <kad_size_var+0x4c>
 804a53a:	69db      	ldr	r3, [r3, #28]
 804a53c:	fb03 f202 	mul.w	r2, r3, r2
			c += kad_len(v[i]);
 804a540:	4410      	add	r0, r2
	for (i = c = 0; i < n; ++i)
 804a542:	4561      	cmp	r1, ip
 804a544:	d009      	beq.n	804a55a <kad_size_var+0x66>
		if (kad_is_var(v[i]))
 804a546:	f851 3f04 	ldr.w	r3, [r1, #4]!
 804a54a:	685a      	ldr	r2, [r3, #4]
 804a54c:	2a00      	cmp	r2, #0
 804a54e:	d1f8      	bne.n	804a542 <kad_size_var+0x4e>
 804a550:	785a      	ldrb	r2, [r3, #1]
 804a552:	07d4      	lsls	r4, r2, #31
 804a554:	d4e2      	bmi.n	804a51c <kad_size_var+0x28>
	for (i = c = 0; i < n; ++i)
 804a556:	4561      	cmp	r1, ip
 804a558:	d1f5      	bne.n	804a546 <kad_size_var+0x52>
}
 804a55a:	bc30      	pop	{r4, r5}
 804a55c:	4770      	bx	lr
 804a55e:	4770      	bx	lr
	int n = 1, i;
 804a560:	2201      	movs	r2, #1
 804a562:	e7ed      	b.n	804a540 <kad_size_var+0x4c>
	return c;
 804a564:	4770      	bx	lr
 804a566:	bf00      	nop

0804a568 <kad_size_const>:
	for (i = c = 0; i < n; ++i)
 804a568:	f1b0 0c00 	subs.w	ip, r0, #0
 804a56c:	f04f 0000 	mov.w	r0, #0
 804a570:	dd32      	ble.n	804a5d8 <kad_size_const+0x70>
 804a572:	3904      	subs	r1, #4
 804a574:	eb01 0c8c 	add.w	ip, r1, ip, lsl #2
 804a578:	e001      	b.n	804a57e <kad_size_const+0x16>
 804a57a:	4561      	cmp	r1, ip
 804a57c:	d029      	beq.n	804a5d2 <kad_size_const+0x6a>
		if (kad_is_const(v[i]))
 804a57e:	f851 3f04 	ldr.w	r3, [r1, #4]!
 804a582:	685a      	ldr	r2, [r3, #4]
 804a584:	2a00      	cmp	r2, #0
 804a586:	d1f8      	bne.n	804a57a <kad_size_const+0x12>
 804a588:	785a      	ldrb	r2, [r3, #1]
 804a58a:	0792      	lsls	r2, r2, #30
 804a58c:	d5f5      	bpl.n	804a57a <kad_size_const+0x12>
{
 804a58e:	b430      	push	{r4, r5}
	for (i = 0; i < p->n_d; ++i) n *= p->d[i];
 804a590:	781c      	ldrb	r4, [r3, #0]
 804a592:	b1fc      	cbz	r4, 804a5d4 <kad_size_const+0x6c>
 804a594:	2c01      	cmp	r4, #1
 804a596:	691a      	ldr	r2, [r3, #16]
 804a598:	d00c      	beq.n	804a5b4 <kad_size_const+0x4c>
 804a59a:	695d      	ldr	r5, [r3, #20]
 804a59c:	2c02      	cmp	r4, #2
 804a59e:	fb05 f202 	mul.w	r2, r5, r2
 804a5a2:	d007      	beq.n	804a5b4 <kad_size_const+0x4c>
 804a5a4:	699d      	ldr	r5, [r3, #24]
 804a5a6:	2c03      	cmp	r4, #3
 804a5a8:	fb05 f202 	mul.w	r2, r5, r2
 804a5ac:	d002      	beq.n	804a5b4 <kad_size_const+0x4c>
 804a5ae:	69db      	ldr	r3, [r3, #28]
 804a5b0:	fb03 f202 	mul.w	r2, r3, r2
			c += kad_len(v[i]);
 804a5b4:	4410      	add	r0, r2
	for (i = c = 0; i < n; ++i)
 804a5b6:	4561      	cmp	r1, ip
 804a5b8:	d009      	beq.n	804a5ce <kad_size_const+0x66>
		if (kad_is_const(v[i]))
 804a5ba:	f851 3f04 	ldr.w	r3, [r1, #4]!
 804a5be:	685a      	ldr	r2, [r3, #4]
 804a5c0:	2a00      	cmp	r2, #0
 804a5c2:	d1f8      	bne.n	804a5b6 <kad_size_const+0x4e>
 804a5c4:	785a      	ldrb	r2, [r3, #1]
 804a5c6:	0794      	lsls	r4, r2, #30
 804a5c8:	d4e2      	bmi.n	804a590 <kad_size_const+0x28>
	for (i = c = 0; i < n; ++i)
 804a5ca:	4561      	cmp	r1, ip
 804a5cc:	d1f5      	bne.n	804a5ba <kad_size_const+0x52>
}
 804a5ce:	bc30      	pop	{r4, r5}
 804a5d0:	4770      	bx	lr
 804a5d2:	4770      	bx	lr
	int n = 1, i;
 804a5d4:	2201      	movs	r2, #1
 804a5d6:	e7ed      	b.n	804a5b4 <kad_size_const+0x4c>
	return c;
 804a5d8:	4770      	bx	lr
 804a5da:	bf00      	nop

0804a5dc <kad_eval_at>:
{
 804a5dc:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (from < 0 || from >= n) from = n - 1;
 804a5e0:	f1b2 0a00 	subs.w	sl, r2, #0
{
 804a5e4:	4689      	mov	r9, r1
	if (from < 0 || from >= n) from = n - 1;
 804a5e6:	db38      	blt.n	804a65a <kad_eval_at+0x7e>
 804a5e8:	4582      	cmp	sl, r0
 804a5ea:	da36      	bge.n	804a65a <kad_eval_at+0x7e>
 804a5ec:	f1a9 0804 	sub.w	r8, r9, #4
 804a5f0:	4645      	mov	r5, r8
{
 804a5f2:	4643      	mov	r3, r8
	for (i = 0; i < n; ++i) a[i]->tmp = (i == from);
 804a5f4:	2400      	movs	r4, #0
 804a5f6:	eba4 060a 	sub.w	r6, r4, sl
 804a5fa:	fab6 f686 	clz	r6, r6
 804a5fe:	46a3      	mov	fp, r4
 804a600:	f853 1f04 	ldr.w	r1, [r3, #4]!
 804a604:	3401      	adds	r4, #1
 804a606:	0976      	lsrs	r6, r6, #5
 804a608:	42a0      	cmp	r0, r4
 804a60a:	608e      	str	r6, [r1, #8]
 804a60c:	d1f3      	bne.n	804a5f6 <kad_eval_at+0x1a>
	kad_propagate_marks(n, a);
 804a60e:	4649      	mov	r1, r9
 804a610:	4620      	mov	r0, r4
 804a612:	f7f8 fb0f 	bl	8042c34 <kad_propagate_marks>
 804a616:	4647      	mov	r7, r8
	for (i = 0; i < n; ++i)
 804a618:	2600      	movs	r6, #0
 804a61a:	e000      	b.n	804a61e <kad_eval_at+0x42>
 804a61c:	461e      	mov	r6, r3
		if (a[i]->n_child && a[i]->tmp > 0)
 804a61e:	f857 0f04 	ldr.w	r0, [r7, #4]!
 804a622:	6843      	ldr	r3, [r0, #4]
 804a624:	b143      	cbz	r3, 804a638 <kad_eval_at+0x5c>
 804a626:	6883      	ldr	r3, [r0, #8]
 804a628:	2b00      	cmp	r3, #0
 804a62a:	dd05      	ble.n	804a638 <kad_eval_at+0x5c>
			kad_op_list[a[i]->op](a[i], KAD_FORWARD);
 804a62c:	8843      	ldrh	r3, [r0, #2]
 804a62e:	4a11      	ldr	r2, [pc, #68]	@ (804a674 <kad_eval_at+0x98>)
 804a630:	2102      	movs	r1, #2
 804a632:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 804a636:	4798      	blx	r3
	for (i = 0; i < n; ++i)
 804a638:	455e      	cmp	r6, fp
 804a63a:	f106 0301 	add.w	r3, r6, #1
 804a63e:	d1ed      	bne.n	804a61c <kad_eval_at+0x40>
	for (i = 0; i < n; ++i) a[i]->tmp = 0;
 804a640:	2100      	movs	r1, #0
 804a642:	eb08 0884 	add.w	r8, r8, r4, lsl #2
 804a646:	f855 3f04 	ldr.w	r3, [r5, #4]!
 804a64a:	45a8      	cmp	r8, r5
 804a64c:	6099      	str	r1, [r3, #8]
 804a64e:	d1fa      	bne.n	804a646 <kad_eval_at+0x6a>
	return a[from]->x;
 804a650:	f859 302a 	ldr.w	r3, [r9, sl, lsl #2]
}
 804a654:	6a98      	ldr	r0, [r3, #40]	@ 0x28
 804a656:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	for (i = 0; i < n; ++i) a[i]->tmp = (i == from);
 804a65a:	2800      	cmp	r0, #0
	if (from < 0 || from >= n) from = n - 1;
 804a65c:	f100 3aff 	add.w	sl, r0, #4294967295
	for (i = 0; i < n; ++i) a[i]->tmp = (i == from);
 804a660:	dcc4      	bgt.n	804a5ec <kad_eval_at+0x10>
	kad_propagate_marks(n, a);
 804a662:	4649      	mov	r1, r9
 804a664:	f7f8 fae6 	bl	8042c34 <kad_propagate_marks>
	return a[from]->x;
 804a668:	f859 302a 	ldr.w	r3, [r9, sl, lsl #2]
}
 804a66c:	6a98      	ldr	r0, [r3, #40]	@ 0x28
 804a66e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 804a672:	bf00      	nop
 804a674:	20018004 	.word	0x20018004

0804a678 <kad_grad>:
{
 804a678:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	if (from < 0 || from >= n) from = n - 1;
 804a67c:	1e15      	subs	r5, r2, #0
{
 804a67e:	4688      	mov	r8, r1
	if (from < 0 || from >= n) from = n - 1;
 804a680:	db01      	blt.n	804a686 <kad_grad+0xe>
 804a682:	4285      	cmp	r5, r0
 804a684:	db63      	blt.n	804a74e <kad_grad+0xd6>
 804a686:	1e45      	subs	r5, r0, #1
	assert(a[from]->n_d == 0);
 804a688:	f858 9025 	ldr.w	r9, [r8, r5, lsl #2]
 804a68c:	ea4f 0a85 	mov.w	sl, r5, lsl #2
 804a690:	f899 3000 	ldrb.w	r3, [r9]
 804a694:	eb08 0785 	add.w	r7, r8, r5, lsl #2
 804a698:	2b00      	cmp	r3, #0
 804a69a:	d162      	bne.n	804a762 <kad_grad+0xea>
	for (i = 0; i < n; ++i) a[i]->tmp = (i == from);
 804a69c:	2800      	cmp	r0, #0
 804a69e:	dd0c      	ble.n	804a6ba <kad_grad+0x42>
 804a6a0:	2300      	movs	r3, #0
 804a6a2:	f1a8 0204 	sub.w	r2, r8, #4
 804a6a6:	1aee      	subs	r6, r5, r3
 804a6a8:	fab6 f686 	clz	r6, r6
 804a6ac:	f852 1f04 	ldr.w	r1, [r2, #4]!
 804a6b0:	3301      	adds	r3, #1
 804a6b2:	0976      	lsrs	r6, r6, #5
 804a6b4:	4298      	cmp	r0, r3
 804a6b6:	608e      	str	r6, [r1, #8]
 804a6b8:	d1f5      	bne.n	804a6a6 <kad_grad+0x2e>
	kad_propagate_marks(n, a);
 804a6ba:	4641      	mov	r1, r8
 804a6bc:	f7f8 faba 	bl	8042c34 <kad_propagate_marks>
	for (i = 0; i <= from; ++i) /* set all grandients to zero */
 804a6c0:	2d00      	cmp	r5, #0
 804a6c2:	db57      	blt.n	804a774 <kad_grad+0xfc>
 804a6c4:	f1a8 0504 	sub.w	r5, r8, #4
 804a6c8:	462e      	mov	r6, r5
 804a6ca:	e001      	b.n	804a6d0 <kad_grad+0x58>
 804a6cc:	42b7      	cmp	r7, r6
 804a6ce:	d01f      	beq.n	804a710 <kad_grad+0x98>
		if (a[i]->g && a[i]->tmp > 0)
 804a6d0:	f856 3f04 	ldr.w	r3, [r6, #4]!
 804a6d4:	6ad8      	ldr	r0, [r3, #44]	@ 0x2c
 804a6d6:	2800      	cmp	r0, #0
 804a6d8:	d0f8      	beq.n	804a6cc <kad_grad+0x54>
 804a6da:	689a      	ldr	r2, [r3, #8]
 804a6dc:	2a00      	cmp	r2, #0
 804a6de:	ddf5      	ble.n	804a6cc <kad_grad+0x54>
	for (i = 0; i < p->n_d; ++i) n *= p->d[i];
 804a6e0:	7819      	ldrb	r1, [r3, #0]
 804a6e2:	2900      	cmp	r1, #0
 804a6e4:	d044      	beq.n	804a770 <kad_grad+0xf8>
 804a6e6:	2901      	cmp	r1, #1
 804a6e8:	691a      	ldr	r2, [r3, #16]
 804a6ea:	d00b      	beq.n	804a704 <kad_grad+0x8c>
 804a6ec:	695c      	ldr	r4, [r3, #20]
 804a6ee:	2902      	cmp	r1, #2
 804a6f0:	fb04 f202 	mul.w	r2, r4, r2
 804a6f4:	d006      	beq.n	804a704 <kad_grad+0x8c>
 804a6f6:	699c      	ldr	r4, [r3, #24]
 804a6f8:	2903      	cmp	r1, #3
 804a6fa:	fb04 f202 	mul.w	r2, r4, r2
 804a6fe:	bf1c      	itt	ne
 804a700:	69db      	ldrne	r3, [r3, #28]
 804a702:	435a      	mulne	r2, r3
			memset(a[i]->g, 0, kad_len(a[i]) * sizeof(float));
 804a704:	0092      	lsls	r2, r2, #2
 804a706:	2100      	movs	r1, #0
 804a708:	f001 fb94 	bl	804be34 <memset>
	for (i = 0; i <= from; ++i) /* set all grandients to zero */
 804a70c:	42b7      	cmp	r7, r6
 804a70e:	d1df      	bne.n	804a6d0 <kad_grad+0x58>
	for (i = from, a[i]->g[0] = 1.0f; i >= 0; --i) /* backprop */
 804a710:	f04f 527e 	mov.w	r2, #1065353216	@ 0x3f800000
 804a714:	683b      	ldr	r3, [r7, #0]
 804a716:	f10a 0404 	add.w	r4, sl, #4
 804a71a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
			kad_op_list[a[i]->op](a[i], KAD_BACKWARD);
 804a71c:	4e19      	ldr	r6, [pc, #100]	@ (804a784 <kad_grad+0x10c>)
 804a71e:	4444      	add	r4, r8
	for (i = from, a[i]->g[0] = 1.0f; i >= 0; --i) /* backprop */
 804a720:	601a      	str	r2, [r3, #0]
		if (a[i]->n_child && a[i]->tmp > 0)
 804a722:	f854 0d04 	ldr.w	r0, [r4, #-4]!
 804a726:	6843      	ldr	r3, [r0, #4]
 804a728:	b13b      	cbz	r3, 804a73a <kad_grad+0xc2>
 804a72a:	6883      	ldr	r3, [r0, #8]
 804a72c:	2b00      	cmp	r3, #0
 804a72e:	dd04      	ble.n	804a73a <kad_grad+0xc2>
			kad_op_list[a[i]->op](a[i], KAD_BACKWARD);
 804a730:	8843      	ldrh	r3, [r0, #2]
 804a732:	2103      	movs	r1, #3
 804a734:	f856 3023 	ldr.w	r3, [r6, r3, lsl #2]
 804a738:	4798      	blx	r3
	for (i = from, a[i]->g[0] = 1.0f; i >= 0; --i) /* backprop */
 804a73a:	4544      	cmp	r4, r8
 804a73c:	d1f1      	bne.n	804a722 <kad_grad+0xaa>
	for (i = 0; i <= from; ++i) a[i]->tmp = 0;
 804a73e:	2200      	movs	r2, #0
 804a740:	f855 3f04 	ldr.w	r3, [r5, #4]!
 804a744:	42af      	cmp	r7, r5
 804a746:	609a      	str	r2, [r3, #8]
 804a748:	d1fa      	bne.n	804a740 <kad_grad+0xc8>
}
 804a74a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	assert(a[from]->n_d == 0);
 804a74e:	f851 9025 	ldr.w	r9, [r1, r5, lsl #2]
 804a752:	ea4f 0a85 	mov.w	sl, r5, lsl #2
 804a756:	f899 3000 	ldrb.w	r3, [r9]
 804a75a:	eb01 0785 	add.w	r7, r1, r5, lsl #2
 804a75e:	2b00      	cmp	r3, #0
 804a760:	d09e      	beq.n	804a6a0 <kad_grad+0x28>
 804a762:	f240 2151 	movw	r1, #593	@ 0x251
 804a766:	4b08      	ldr	r3, [pc, #32]	@ (804a788 <kad_grad+0x110>)
 804a768:	4a08      	ldr	r2, [pc, #32]	@ (804a78c <kad_grad+0x114>)
 804a76a:	4809      	ldr	r0, [pc, #36]	@ (804a790 <kad_grad+0x118>)
 804a76c:	f001 f83a 	bl	804b7e4 <__assert_func>
 804a770:	2204      	movs	r2, #4
 804a772:	e7c8      	b.n	804a706 <kad_grad+0x8e>
	for (i = from, a[i]->g[0] = 1.0f; i >= 0; --i) /* backprop */
 804a774:	f04f 527e 	mov.w	r2, #1065353216	@ 0x3f800000
 804a778:	f8d9 302c 	ldr.w	r3, [r9, #44]	@ 0x2c
 804a77c:	601a      	str	r2, [r3, #0]
}
 804a77e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 804a782:	bf00      	nop
 804a784:	20018004 	.word	0x20018004
 804a788:	0804e4b0 	.word	0x0804e4b0
 804a78c:	0804e5dc 	.word	0x0804e5dc
 804a790:	0804e3dc 	.word	0x0804e3dc

0804a794 <kad_n_pivots>:
	for (i = 0; i < n_v; ++i)
 804a794:	f1b0 0c00 	subs.w	ip, r0, #0
	int i, n_pivots = 0;
 804a798:	f04f 0000 	mov.w	r0, #0
	for (i = 0; i < n_v; ++i)
 804a79c:	dd0e      	ble.n	804a7bc <kad_n_pivots+0x28>
 804a79e:	3904      	subs	r1, #4
 804a7a0:	eb01 0c8c 	add.w	ip, r1, ip, lsl #2
		if (kad_is_pivot(v[i])) ++n_pivots;
 804a7a4:	f851 3f04 	ldr.w	r3, [r1, #4]!
 804a7a8:	685a      	ldr	r2, [r3, #4]
 804a7aa:	2a01      	cmp	r2, #1
 804a7ac:	d103      	bne.n	804a7b6 <kad_n_pivots+0x22>
 804a7ae:	785b      	ldrb	r3, [r3, #1]
 804a7b0:	075b      	lsls	r3, r3, #29
 804a7b2:	bf48      	it	mi
 804a7b4:	3001      	addmi	r0, #1
	for (i = 0; i < n_v; ++i)
 804a7b6:	458c      	cmp	ip, r1
 804a7b8:	d1f4      	bne.n	804a7a4 <kad_n_pivots+0x10>
 804a7ba:	4770      	bx	lr
}
 804a7bc:	4770      	bx	lr
 804a7be:	bf00      	nop

0804a7c0 <kad_rng>:
{
 804a7c0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	r = (kad_rng_t*)calloc(1, sizeof(kad_rng_t));
 804a7c4:	2120      	movs	r1, #32
{
 804a7c6:	b083      	sub	sp, #12
	r = (kad_rng_t*)calloc(1, sizeof(kad_rng_t));
 804a7c8:	2001      	movs	r0, #1
 804a7ca:	f001 f829 	bl	804b820 <calloc>
	heapSize += 1 * sizeof(kad_rng_t);
 804a7ce:	4a51      	ldr	r2, [pc, #324]	@ (804a914 <kad_rng+0x154>)
 804a7d0:	4951      	ldr	r1, [pc, #324]	@ (804a918 <kad_rng+0x158>)
 804a7d2:	6813      	ldr	r3, [r2, #0]
	uint64_t s0 = 0, s1 = 0;
 804a7d4:	2500      	movs	r5, #0
	heapSize += 1 * sizeof(kad_rng_t);
 804a7d6:	3320      	adds	r3, #32
	r = (kad_rng_t*)calloc(1, sizeof(kad_rng_t));
 804a7d8:	4682      	mov	sl, r0
	heapSize += 1 * sizeof(kad_rng_t);
 804a7da:	6013      	str	r3, [r2, #0]
 804a7dc:	460b      	mov	r3, r1
 804a7de:	680c      	ldr	r4, [r1, #0]
	uint64_t s0 = 0, s1 = 0;
 804a7e0:	462e      	mov	r6, r5
 804a7e2:	e9d1 e101 	ldrd	lr, r1, [r1, #4]
 804a7e6:	46a8      	mov	r8, r5
 804a7e8:	462f      	mov	r7, r5
		for (b = 0; b < 64; b++) {
 804a7ea:	4628      	mov	r0, r5
 804a7ec:	f8d3 c00c 	ldr.w	ip, [r3, #12]
			if (JUMP[i] & 1ULL << b)
 804a7f0:	f8df 9130 	ldr.w	r9, [pc, #304]	@ 804a924 <kad_rng+0x164>
 804a7f4:	f8cd a004 	str.w	sl, [sp, #4]
 804a7f8:	e001      	b.n	804a7fe <kad_rng+0x3e>
	r->s[0] = (s0 << 55 | s0 >> 9) ^ s1 ^ (s1 << 14);
 804a7fa:	461c      	mov	r4, r3
 804a7fc:	4696      	mov	lr, r2
			if (JUMP[i] & 1ULL << b)
 804a7fe:	4b47      	ldr	r3, [pc, #284]	@ (804a91c <kad_rng+0x15c>)
 804a800:	f1c0 0b20 	rsb	fp, r0, #32
 804a804:	f1a0 0a20 	sub.w	sl, r0, #32
 804a808:	40c3      	lsrs	r3, r0
 804a80a:	fa09 fb0b 	lsl.w	fp, r9, fp
 804a80e:	ea43 030b 	orr.w	r3, r3, fp
 804a812:	fa29 fa0a 	lsr.w	sl, r9, sl
 804a816:	ea43 030a 	orr.w	r3, r3, sl
 804a81a:	07db      	lsls	r3, r3, #31
	s1 ^= s0;
 804a81c:	ea8e 020c 	eor.w	r2, lr, ip
 804a820:	ea84 0b01 	eor.w	fp, r4, r1
		for (b = 0; b < 64; b++) {
 804a824:	f100 0001 	add.w	r0, r0, #1
			if (JUMP[i] & 1ULL << b)
 804a828:	d506      	bpl.n	804a838 <kad_rng+0x78>
				s0 ^= r->s[0], s1 ^= r->s[1];
 804a82a:	ea84 0808 	eor.w	r8, r4, r8
 804a82e:	ea8e 0707 	eor.w	r7, lr, r7
 804a832:	404d      	eors	r5, r1
 804a834:	ea86 060c 	eor.w	r6, r6, ip
	r->s[0] = (s0 << 55 | s0 >> 9) ^ s1 ^ (s1 << 14);
 804a838:	0a63      	lsrs	r3, r4, #9
 804a83a:	ea4f 215e 	mov.w	r1, lr, lsr #9
 804a83e:	ea41 51c4 	orr.w	r1, r1, r4, lsl #23
 804a842:	ea4f 3a82 	mov.w	sl, r2, lsl #14
 804a846:	ea43 53ce 	orr.w	r3, r3, lr, lsl #23
 804a84a:	404a      	eors	r2, r1
 804a84c:	ea83 030b 	eor.w	r3, r3, fp
 804a850:	ea4a 4a9b 	orr.w	sl, sl, fp, lsr #18
	r->s[1] = s0 << 36 | s0 >> 28;
 804a854:	0f21      	lsrs	r1, r4, #28
 804a856:	ea4f 7c1e 	mov.w	ip, lr, lsr #28
		for (b = 0; b < 64; b++) {
 804a85a:	2840      	cmp	r0, #64	@ 0x40
	r->s[0] = (s0 << 55 | s0 >> 9) ^ s1 ^ (s1 << 14);
 804a85c:	ea83 338b 	eor.w	r3, r3, fp, lsl #14
 804a860:	ea82 020a 	eor.w	r2, r2, sl
	r->s[1] = s0 << 36 | s0 >> 28;
 804a864:	ea41 110e 	orr.w	r1, r1, lr, lsl #4
 804a868:	ea4c 1c04 	orr.w	ip, ip, r4, lsl #4
		for (b = 0; b < 64; b++) {
 804a86c:	d1c5      	bne.n	804a7fa <kad_rng+0x3a>
 804a86e:	f04f 0e00 	mov.w	lr, #0
 804a872:	460c      	mov	r4, r1
			if (JUMP[i] & 1ULL << b)
 804a874:	f8df 90b0 	ldr.w	r9, [pc, #176]	@ 804a928 <kad_rng+0x168>
 804a878:	e001      	b.n	804a87e <kad_rng+0xbe>
	r->s[0] = (s0 << 55 | s0 >> 9) ^ s1 ^ (s1 << 14);
 804a87a:	4603      	mov	r3, r0
 804a87c:	460a      	mov	r2, r1
			if (JUMP[i] & 1ULL << b)
 804a87e:	4928      	ldr	r1, [pc, #160]	@ (804a920 <kad_rng+0x160>)
 804a880:	f1ce 0b20 	rsb	fp, lr, #32
 804a884:	fa21 f00e 	lsr.w	r0, r1, lr
 804a888:	f1ae 0a20 	sub.w	sl, lr, #32
 804a88c:	fa09 fb0b 	lsl.w	fp, r9, fp
 804a890:	ea40 000b 	orr.w	r0, r0, fp
 804a894:	fa29 fa0a 	lsr.w	sl, r9, sl
 804a898:	ea40 000a 	orr.w	r0, r0, sl
 804a89c:	07c0      	lsls	r0, r0, #31
	s1 ^= s0;
 804a89e:	ea82 010c 	eor.w	r1, r2, ip
 804a8a2:	ea83 0b04 	eor.w	fp, r3, r4
		for (b = 0; b < 64; b++) {
 804a8a6:	f10e 0e01 	add.w	lr, lr, #1
			if (JUMP[i] & 1ULL << b)
 804a8aa:	d505      	bpl.n	804a8b8 <kad_rng+0xf8>
				s0 ^= r->s[0], s1 ^= r->s[1];
 804a8ac:	ea88 0803 	eor.w	r8, r8, r3
 804a8b0:	4057      	eors	r7, r2
 804a8b2:	4065      	eors	r5, r4
 804a8b4:	ea86 060c 	eor.w	r6, r6, ip
	r->s[0] = (s0 << 55 | s0 >> 9) ^ s1 ^ (s1 << 14);
 804a8b8:	0a58      	lsrs	r0, r3, #9
 804a8ba:	0a54      	lsrs	r4, r2, #9
 804a8bc:	ea44 54c3 	orr.w	r4, r4, r3, lsl #23
 804a8c0:	ea4f 3a81 	mov.w	sl, r1, lsl #14
 804a8c4:	ea40 50c2 	orr.w	r0, r0, r2, lsl #23
 804a8c8:	4061      	eors	r1, r4
 804a8ca:	ea80 000b 	eor.w	r0, r0, fp
 804a8ce:	ea4a 4a9b 	orr.w	sl, sl, fp, lsr #18
	r->s[1] = s0 << 36 | s0 >> 28;
 804a8d2:	0f1c      	lsrs	r4, r3, #28
 804a8d4:	ea4f 7c12 	mov.w	ip, r2, lsr #28
		for (b = 0; b < 64; b++) {
 804a8d8:	f1be 0f40 	cmp.w	lr, #64	@ 0x40
	r->s[0] = (s0 << 55 | s0 >> 9) ^ s1 ^ (s1 << 14);
 804a8dc:	ea80 308b 	eor.w	r0, r0, fp, lsl #14
 804a8e0:	ea81 010a 	eor.w	r1, r1, sl
	r->s[1] = s0 << 36 | s0 >> 28;
 804a8e4:	ea44 1402 	orr.w	r4, r4, r2, lsl #4
 804a8e8:	ea4c 1c03 	orr.w	ip, ip, r3, lsl #4
		for (b = 0; b < 64; b++) {
 804a8ec:	d1c5      	bne.n	804a87a <kad_rng+0xba>
	r->s[0] = s0, r->s[1] = s1;
 804a8ee:	f8dd a004 	ldr.w	sl, [sp, #4]
 804a8f2:	4b09      	ldr	r3, [pc, #36]	@ (804a918 <kad_rng+0x158>)
}
 804a8f4:	4650      	mov	r0, sl
	r->s[0] = s0, r->s[1] = s1;
 804a8f6:	e9c3 7501 	strd	r7, r5, [r3, #4]
	r->s[0] = kad_rng_dat.s[0], r->s[1] = kad_rng_dat.s[1];
 804a8fa:	e9ca 7501 	strd	r7, r5, [sl, #4]
	r->s[0] = s0, r->s[1] = s1;
 804a8fe:	f8c3 8000 	str.w	r8, [r3]
	r->s[0] = kad_rng_dat.s[0], r->s[1] = kad_rng_dat.s[1];
 804a902:	f8ca 8000 	str.w	r8, [sl]
	r->s[0] = s0, r->s[1] = s1;
 804a906:	60de      	str	r6, [r3, #12]
	r->s[0] = kad_rng_dat.s[0], r->s[1] = kad_rng_dat.s[1];
 804a908:	f8ca 600c 	str.w	r6, [sl, #12]
}
 804a90c:	b003      	add	sp, #12
 804a90e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 804a912:	bf00      	nop
 804a914:	20018acc 	.word	0x20018acc
 804a918:	20018108 	.word	0x20018108
 804a91c:	eba5facb 	.word	0xeba5facb
 804a920:	86aa9922 	.word	0x86aa9922
 804a924:	beac0467 	.word	0xbeac0467
 804a928:	d86b048b 	.word	0xd86b048b
 804a92c:	00000000 	.word	0x00000000

0804a930 <kad_unroll>:
{
 804a930:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 804a934:	ed2d 8b02 	vpush	{d8}
 804a938:	4689      	mov	r9, r1
 804a93a:	4604      	mov	r4, r0
 804a93c:	b09b      	sub	sp, #108	@ 0x6c
	t = (kad_node_t**)calloc(n_v, sizeof(kad_node_t*));
 804a93e:	2104      	movs	r1, #4
{
 804a940:	4692      	mov	sl, r2
 804a942:	461e      	mov	r6, r3
 804a944:	9010      	str	r0, [sp, #64]	@ 0x40
 804a946:	f8cd 9034 	str.w	r9, [sp, #52]	@ 0x34
	t = (kad_node_t**)calloc(n_v, sizeof(kad_node_t*));
 804a94a:	f000 ff69 	bl	804b820 <calloc>
	for (i = 0; i < n_v; ++i)
 804a94e:	2c00      	cmp	r4, #0
 804a950:	f340 8379 	ble.w	804b046 <kad_unroll+0x716>
 804a954:	4622      	mov	r2, r4
 804a956:	f1a9 0404 	sub.w	r4, r9, #4
 804a95a:	4680      	mov	r8, r0
 804a95c:	4623      	mov	r3, r4
	int i, n_pivots = 0;
 804a95e:	2000      	movs	r0, #0
 804a960:	f8cd 9050 	str.w	r9, [sp, #80]	@ 0x50
 804a964:	eb04 0782 	add.w	r7, r4, r2, lsl #2
		if (kad_is_pivot(v[i])) ++n_pivots;
 804a968:	f853 2f04 	ldr.w	r2, [r3, #4]!
 804a96c:	6851      	ldr	r1, [r2, #4]
 804a96e:	2901      	cmp	r1, #1
 804a970:	d103      	bne.n	804a97a <kad_unroll+0x4a>
 804a972:	7852      	ldrb	r2, [r2, #1]
 804a974:	0751      	lsls	r1, r2, #29
 804a976:	bf48      	it	mi
 804a978:	3001      	addmi	r0, #1
	for (i = 0; i < n_v; ++i)
 804a97a:	429f      	cmp	r7, r3
 804a97c:	d1f4      	bne.n	804a968 <kad_unroll+0x38>
 804a97e:	4622      	mov	r2, r4
	for (i = 0; i < n_v; ++i) v[i]->tmp = i;
 804a980:	2300      	movs	r3, #0
	for (i = 0; i < n_v; ++i)
 804a982:	900e      	str	r0, [sp, #56]	@ 0x38
	for (i = 0; i < n_v; ++i) v[i]->tmp = i;
 804a984:	9810      	ldr	r0, [sp, #64]	@ 0x40
 804a986:	f852 1f04 	ldr.w	r1, [r2, #4]!
 804a98a:	461d      	mov	r5, r3
 804a98c:	608b      	str	r3, [r1, #8]
 804a98e:	3301      	adds	r3, #1
 804a990:	4298      	cmp	r0, r3
 804a992:	d1f8      	bne.n	804a986 <kad_unroll+0x56>
	if (n_pivots) {
 804a994:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
 804a996:	2b00      	cmp	r3, #0
 804a998:	f040 80d8 	bne.w	804ab4c <kad_unroll+0x21c>
	nodes_t w = {0,0,0};
 804a99c:	e9cd 3304 	strd	r3, r3, [sp, #16]
	for (i = 0; i < n_v; ++i) { /* copy over the rest of nodes */
 804a9a0:	2600      	movs	r6, #0
 804a9a2:	9500      	str	r5, [sp, #0]
	q->pre = 0, q->tmp = 0, q->gtmp = 0;
 804a9a4:	46b3      	mov	fp, r6
	heapSize += sizeof(kad_node_t);
 804a9a6:	f8df 93ac 	ldr.w	r9, [pc, #940]	@ 804ad54 <kad_unroll+0x424>
 804a9aa:	9d14      	ldr	r5, [sp, #80]	@ 0x50
 804a9ac:	9702      	str	r7, [sp, #8]
 804a9ae:	9403      	str	r4, [sp, #12]
 804a9b0:	f8cd a018 	str.w	sl, [sp, #24]
 804a9b4:	e006      	b.n	804a9c4 <kad_unroll+0x94>
	for (i = 0; i < n_v; ++i) { /* copy over the rest of nodes */
 804a9b6:	9a00      	ldr	r2, [sp, #0]
 804a9b8:	1c73      	adds	r3, r6, #1
 804a9ba:	42b2      	cmp	r2, r6
 804a9bc:	f105 0504 	add.w	r5, r5, #4
 804a9c0:	d057      	beq.n	804aa72 <kad_unroll+0x142>
 804a9c2:	461e      	mov	r6, r3
		if (t[i]) continue;
 804a9c4:	f858 3026 	ldr.w	r3, [r8, r6, lsl #2]
 804a9c8:	2b00      	cmp	r3, #0
 804a9ca:	d1f4      	bne.n	804a9b6 <kad_unroll+0x86>
	q = (kad_node_t*)malloc(sizeof(kad_node_t));
 804a9cc:	2040      	movs	r0, #64	@ 0x40
		t[i] = kad_dup1(v[i]);
 804a9ce:	682f      	ldr	r7, [r5, #0]
	q = (kad_node_t*)malloc(sizeof(kad_node_t));
 804a9d0:	f000 ff42 	bl	804b858 <malloc>
	memcpy(q, p, sizeof(kad_node_t));
 804a9d4:	463c      	mov	r4, r7
	q = (kad_node_t*)malloc(sizeof(kad_node_t));
 804a9d6:	4682      	mov	sl, r0
	memcpy(q, p, sizeof(kad_node_t));
 804a9d8:	4684      	mov	ip, r0
	heapSize += sizeof(kad_node_t);
 804a9da:	f8d9 3000 	ldr.w	r3, [r9]
	memcpy(q, p, sizeof(kad_node_t));
 804a9de:	f107 0e40 	add.w	lr, r7, #64	@ 0x40
	heapSize += sizeof(kad_node_t);
 804a9e2:	3340      	adds	r3, #64	@ 0x40
 804a9e4:	f8c9 3000 	str.w	r3, [r9]
	memcpy(q, p, sizeof(kad_node_t));
 804a9e8:	9701      	str	r7, [sp, #4]
 804a9ea:	4667      	mov	r7, ip
 804a9ec:	6820      	ldr	r0, [r4, #0]
 804a9ee:	6861      	ldr	r1, [r4, #4]
 804a9f0:	68a2      	ldr	r2, [r4, #8]
 804a9f2:	68e3      	ldr	r3, [r4, #12]
 804a9f4:	3410      	adds	r4, #16
 804a9f6:	4574      	cmp	r4, lr
 804a9f8:	c70f      	stmia	r7!, {r0, r1, r2, r3}
 804a9fa:	f10c 0c10 	add.w	ip, ip, #16
 804a9fe:	d1f4      	bne.n	804a9ea <kad_unroll+0xba>
	q->pre = 0, q->tmp = 0, q->gtmp = 0;
 804aa00:	9f01      	ldr	r7, [sp, #4]
 804aa02:	f8ca b03c 	str.w	fp, [sl, #60]	@ 0x3c
	if (p->ptr && p->ptr_size > 0) {
 804aa06:	6b39      	ldr	r1, [r7, #48]	@ 0x30
	q->pre = 0, q->tmp = 0, q->gtmp = 0;
 804aa08:	f8ca b008 	str.w	fp, [sl, #8]
 804aa0c:	f8ca b034 	str.w	fp, [sl, #52]	@ 0x34
	if (p->ptr && p->ptr_size > 0) {
 804aa10:	b1b1      	cbz	r1, 804aa40 <kad_unroll+0x110>
 804aa12:	68fc      	ldr	r4, [r7, #12]
 804aa14:	2c00      	cmp	r4, #0
 804aa16:	dd13      	ble.n	804aa40 <kad_unroll+0x110>
		if (kad_use_rng(p) && !(p->flag & KAD_SHARE_RNG) && p->ptr_size == sizeof(kad_rng_t)) {
 804aa18:	887b      	ldrh	r3, [r7, #2]
 804aa1a:	2b0f      	cmp	r3, #15
 804aa1c:	d058      	beq.n	804aad0 <kad_unroll+0x1a0>
 804aa1e:	2b18      	cmp	r3, #24
 804aa20:	d056      	beq.n	804aad0 <kad_unroll+0x1a0>
			q->ptr = malloc(p->ptr_size);
 804aa22:	4620      	mov	r0, r4
 804aa24:	9101      	str	r1, [sp, #4]
 804aa26:	f000 ff17 	bl	804b858 <malloc>
			heapSize += p->ptr_size;
 804aa2a:	f8d9 3000 	ldr.w	r3, [r9]
			memcpy(q->ptr, p->ptr, p->ptr_size);
 804aa2e:	4622      	mov	r2, r4
			heapSize += p->ptr_size;
 804aa30:	4423      	add	r3, r4
			memcpy(q->ptr, p->ptr, p->ptr_size);
 804aa32:	9901      	ldr	r1, [sp, #4]
			q->ptr = malloc(p->ptr_size);
 804aa34:	f8ca 0030 	str.w	r0, [sl, #48]	@ 0x30
			heapSize += p->ptr_size;
 804aa38:	f8c9 3000 	str.w	r3, [r9]
			memcpy(q->ptr, p->ptr, p->ptr_size);
 804aa3c:	f001 faf7 	bl	804c02e <memcpy>
	if (q->n_child) {
 804aa40:	f8da 4004 	ldr.w	r4, [sl, #4]
 804aa44:	2c00      	cmp	r4, #0
 804aa46:	d156      	bne.n	804aaf6 <kad_unroll+0x1c6>
		if (v[i]->n_child)
 804aa48:	687b      	ldr	r3, [r7, #4]
		t[i] = kad_dup1(v[i]);
 804aa4a:	f848 a026 	str.w	sl, [r8, r6, lsl #2]
		if (v[i]->n_child)
 804aa4e:	2b00      	cmp	r3, #0
 804aa50:	dc66      	bgt.n	804ab20 <kad_unroll+0x1f0>
	if (w->n == w->m) {
 804aa52:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
 804aa54:	9a05      	ldr	r2, [sp, #20]
 804aa56:	4293      	cmp	r3, r2
 804aa58:	d044      	beq.n	804aae4 <kad_unroll+0x1b4>
	w->v[w->n++] = p;
 804aa5a:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
 804aa5c:	9a04      	ldr	r2, [sp, #16]
	for (i = 0; i < n_v; ++i) { /* copy over the rest of nodes */
 804aa5e:	3504      	adds	r5, #4
	w->v[w->n++] = p;
 804aa60:	f842 a023 	str.w	sl, [r2, r3, lsl #2]
	for (i = 0; i < n_v; ++i) { /* copy over the rest of nodes */
 804aa64:	9a00      	ldr	r2, [sp, #0]
	w->v[w->n++] = p;
 804aa66:	3301      	adds	r3, #1
	for (i = 0; i < n_v; ++i) { /* copy over the rest of nodes */
 804aa68:	42b2      	cmp	r2, r6
	w->v[w->n++] = p;
 804aa6a:	930e      	str	r3, [sp, #56]	@ 0x38
	for (i = 0; i < n_v; ++i) { /* copy over the rest of nodes */
 804aa6c:	f106 0301 	add.w	r3, r6, #1
 804aa70:	d1a7      	bne.n	804a9c2 <kad_unroll+0x92>
 804aa72:	e9dd 7402 	ldrd	r7, r4, [sp, #8]
	free(t);
 804aa76:	4640      	mov	r0, r8
 804aa78:	f8dd a018 	ldr.w	sl, [sp, #24]
 804aa7c:	f000 fef4 	bl	804b868 <free>
	for (i = 0; i < n_v; ++i) v[i]->tmp = 0;
 804aa80:	2200      	movs	r2, #0
 804aa82:	f854 3f04 	ldr.w	r3, [r4, #4]!
 804aa86:	42a7      	cmp	r7, r4
 804aa88:	609a      	str	r2, [r3, #8]
 804aa8a:	d1fa      	bne.n	804aa82 <kad_unroll+0x152>
	for (i = 0; i < w.n; ++i) /* stack may change the output dimension */
 804aa8c:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
 804aa8e:	2b00      	cmp	r3, #0
 804aa90:	dd11      	ble.n	804aab6 <kad_unroll+0x186>
 804aa92:	2400      	movs	r4, #0
 804aa94:	461f      	mov	r7, r3
 804aa96:	9b04      	ldr	r3, [sp, #16]
			kad_op_list[w.v[i]->op](w.v[i], KAD_SYNC_DIM);
 804aa98:	4ead      	ldr	r6, [pc, #692]	@ (804ad50 <kad_unroll+0x420>)
 804aa9a:	1f1d      	subs	r5, r3, #4
		if (w.v[i]->n_child > 0)
 804aa9c:	f855 0f04 	ldr.w	r0, [r5, #4]!
 804aaa0:	6843      	ldr	r3, [r0, #4]
 804aaa2:	2b00      	cmp	r3, #0
 804aaa4:	dd04      	ble.n	804aab0 <kad_unroll+0x180>
			kad_op_list[w.v[i]->op](w.v[i], KAD_SYNC_DIM);
 804aaa6:	8843      	ldrh	r3, [r0, #2]
 804aaa8:	2104      	movs	r1, #4
 804aaaa:	f856 3023 	ldr.w	r3, [r6, r3, lsl #2]
 804aaae:	4798      	blx	r3
	for (i = 0; i < w.n; ++i) /* stack may change the output dimension */
 804aab0:	3401      	adds	r4, #1
 804aab2:	42a7      	cmp	r7, r4
 804aab4:	d1f2      	bne.n	804aa9c <kad_unroll+0x16c>
	kad_allocate_internal(w.n, w.v);
 804aab6:	9c0e      	ldr	r4, [sp, #56]	@ 0x38
 804aab8:	9904      	ldr	r1, [sp, #16]
 804aaba:	4620      	mov	r0, r4
 804aabc:	f7fb ff5e 	bl	804697c <kad_allocate_internal>
}
 804aac0:	9804      	ldr	r0, [sp, #16]
	*new_n = w.n;
 804aac2:	f8ca 4000 	str.w	r4, [sl]
}
 804aac6:	b01b      	add	sp, #108	@ 0x6c
 804aac8:	ecbd 8b02 	vpop	{d8}
 804aacc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (kad_use_rng(p) && !(p->flag & KAD_SHARE_RNG) && p->ptr_size == sizeof(kad_rng_t)) {
 804aad0:	787b      	ldrb	r3, [r7, #1]
 804aad2:	06da      	lsls	r2, r3, #27
 804aad4:	d4a5      	bmi.n	804aa22 <kad_unroll+0xf2>
 804aad6:	2c20      	cmp	r4, #32
 804aad8:	d1a3      	bne.n	804aa22 <kad_unroll+0xf2>
			q->ptr = kad_rng(); /* each time step uses a different RNG */
 804aada:	f7ff fe71 	bl	804a7c0 <kad_rng>
 804aade:	f8ca 0030 	str.w	r0, [sl, #48]	@ 0x30
 804aae2:	e7ad      	b.n	804aa40 <kad_unroll+0x110>
		w->m = w->m? w->m<<1 : 16;
 804aae4:	bb73      	cbnz	r3, 804ab44 <kad_unroll+0x214>
 804aae6:	2310      	movs	r3, #16
 804aae8:	2140      	movs	r1, #64	@ 0x40
 804aaea:	9305      	str	r3, [sp, #20]
		w->v = (kad_node_t**)realloc(w->v, w->m * sizeof(kad_node_t*));
 804aaec:	9804      	ldr	r0, [sp, #16]
 804aaee:	f000 ff9f 	bl	804ba30 <realloc>
 804aaf2:	9004      	str	r0, [sp, #16]
 804aaf4:	e7b1      	b.n	804aa5a <kad_unroll+0x12a>
		q->x = q->g = 0;
 804aaf6:	2300      	movs	r3, #0
 804aaf8:	2200      	movs	r2, #0
		q->child = (kad_node_t**)calloc(q->n_child, sizeof(kad_node_t*));
 804aafa:	2104      	movs	r1, #4
		q->x = q->g = 0;
 804aafc:	e9ca 230a 	strd	r2, r3, [sl, #40]	@ 0x28
		q->child = (kad_node_t**)calloc(q->n_child, sizeof(kad_node_t*));
 804ab00:	4620      	mov	r0, r4
 804ab02:	f000 fe8d 	bl	804b820 <calloc>
		heapSize += q->n_child * sizeof(kad_node_t*);
 804ab06:	f8d9 3000 	ldr.w	r3, [r9]
		q->child = (kad_node_t**)calloc(q->n_child, sizeof(kad_node_t*));
 804ab0a:	f8ca 0038 	str.w	r0, [sl, #56]	@ 0x38
		heapSize += q->n_child * sizeof(kad_node_t*);
 804ab0e:	eb03 0384 	add.w	r3, r3, r4, lsl #2
 804ab12:	f8c9 3000 	str.w	r3, [r9]
		if (v[i]->n_child)
 804ab16:	687b      	ldr	r3, [r7, #4]
		t[i] = kad_dup1(v[i]);
 804ab18:	f848 a026 	str.w	sl, [r8, r6, lsl #2]
		if (v[i]->n_child)
 804ab1c:	2b00      	cmp	r3, #0
 804ab1e:	dd98      	ble.n	804aa52 <kad_unroll+0x122>
			for (j = 0; j < v[i]->n_child; ++j)
 804ab20:	2300      	movs	r3, #0
 804ab22:	f8da 2038 	ldr.w	r2, [sl, #56]	@ 0x38
 804ab26:	3a04      	subs	r2, #4
				t[i]->child[j] = t[v[i]->child[j]->tmp];
 804ab28:	6bb9      	ldr	r1, [r7, #56]	@ 0x38
 804ab2a:	f851 1023 	ldr.w	r1, [r1, r3, lsl #2]
			for (j = 0; j < v[i]->n_child; ++j)
 804ab2e:	3301      	adds	r3, #1
				t[i]->child[j] = t[v[i]->child[j]->tmp];
 804ab30:	6889      	ldr	r1, [r1, #8]
 804ab32:	f858 1021 	ldr.w	r1, [r8, r1, lsl #2]
 804ab36:	f842 1f04 	str.w	r1, [r2, #4]!
			for (j = 0; j < v[i]->n_child; ++j)
 804ab3a:	682f      	ldr	r7, [r5, #0]
 804ab3c:	6879      	ldr	r1, [r7, #4]
 804ab3e:	4299      	cmp	r1, r3
 804ab40:	dcf2      	bgt.n	804ab28 <kad_unroll+0x1f8>
 804ab42:	e786      	b.n	804aa52 <kad_unroll+0x122>
		w->m = w->m? w->m<<1 : 16;
 804ab44:	005a      	lsls	r2, r3, #1
 804ab46:	9205      	str	r2, [sp, #20]
		w->v = (kad_node_t**)realloc(w->v, w->m * sizeof(kad_node_t*));
 804ab48:	00d9      	lsls	r1, r3, #3
 804ab4a:	e7cf      	b.n	804aaec <kad_unroll+0x1bc>
		i_pivots = (int*)calloc(n_pivots, sizeof(int));
 804ab4c:	4618      	mov	r0, r3
 804ab4e:	2104      	movs	r1, #4
 804ab50:	f000 fe66 	bl	804b820 <calloc>
		for (i = k = 0; i < n_v; ++i) /* collect pivots */
 804ab54:	f04f 0c00 	mov.w	ip, #0
		i_pivots = (int*)calloc(n_pivots, sizeof(int));
 804ab58:	4681      	mov	r9, r0
 804ab5a:	4623      	mov	r3, r4
		for (i = k = 0; i < n_v; ++i) /* collect pivots */
 804ab5c:	4660      	mov	r0, ip
			if (kad_is_pivot(v[i])) i_pivots[k++] = i;
 804ab5e:	f853 2f04 	ldr.w	r2, [r3, #4]!
 804ab62:	6851      	ldr	r1, [r2, #4]
 804ab64:	2901      	cmp	r1, #1
 804ab66:	d106      	bne.n	804ab76 <kad_unroll+0x246>
 804ab68:	7852      	ldrb	r2, [r2, #1]
 804ab6a:	0752      	lsls	r2, r2, #29
 804ab6c:	bf44      	itt	mi
 804ab6e:	f849 002c 	strmi.w	r0, [r9, ip, lsl #2]
 804ab72:	f10c 0c01 	addmi.w	ip, ip, #1
		for (i = k = 0; i < n_v; ++i) /* collect pivots */
 804ab76:	429f      	cmp	r7, r3
 804ab78:	f100 0001 	add.w	r0, r0, #1
 804ab7c:	d1ef      	bne.n	804ab5e <kad_unroll+0x22e>
		for (i = 0; i < n_pivots; ++i) /* unroll each pivot, from the lowest to the highest */
 804ab7e:	1f33      	subs	r3, r6, #4
 804ab80:	9311      	str	r3, [sp, #68]	@ 0x44
	nodes_t w = {0,0,0};
 804ab82:	2300      	movs	r3, #0
		q->x = q->g = 0;
 804ab84:	ed9f 8b70 	vldr	d8, [pc, #448]	@ 804ad48 <kad_unroll+0x418>
		for (i = 0; i < n_pivots; ++i) /* unroll each pivot, from the lowest to the highest */
 804ab88:	469b      	mov	fp, r3
 804ab8a:	e9cd 7915 	strd	r7, r9, [sp, #84]	@ 0x54
 804ab8e:	e9cd 5417 	strd	r5, r4, [sp, #92]	@ 0x5c
 804ab92:	f1a9 0204 	sub.w	r2, r9, #4
	nodes_t w = {0,0,0};
 804ab96:	9304      	str	r3, [sp, #16]
 804ab98:	9212      	str	r2, [sp, #72]	@ 0x48
 804ab9a:	9305      	str	r3, [sp, #20]
 804ab9c:	9300      	str	r3, [sp, #0]
		for (i = 0; i < n_pivots; ++i) /* unroll each pivot, from the lowest to the highest */
 804ab9e:	f8cd 803c 	str.w	r8, [sp, #60]	@ 0x3c
 804aba2:	f8cd a064 	str.w	sl, [sp, #100]	@ 0x64
			kad_unroll_helper(n_v, v, i_pivots[i], t, len[i], &w);
 804aba6:	9b12      	ldr	r3, [sp, #72]	@ 0x48
	assert(kad_is_pivot(v[i_pivot]) && t[i_pivot] == 0);
 804aba8:	990d      	ldr	r1, [sp, #52]	@ 0x34
			kad_unroll_helper(n_v, v, i_pivots[i], t, len[i], &w);
 804abaa:	f853 af04 	ldr.w	sl, [r3, #4]!
 804abae:	9312      	str	r3, [sp, #72]	@ 0x48
 804abb0:	9b11      	ldr	r3, [sp, #68]	@ 0x44
	assert(kad_is_pivot(v[i_pivot]) && t[i_pivot] == 0);
 804abb2:	f851 802a 	ldr.w	r8, [r1, sl, lsl #2]
			kad_unroll_helper(n_v, v, i_pivots[i], t, len[i], &w);
 804abb6:	f853 2f04 	ldr.w	r2, [r3, #4]!
	assert(kad_is_pivot(v[i_pivot]) && t[i_pivot] == 0);
 804abba:	eb01 018a 	add.w	r1, r1, sl, lsl #2
			kad_unroll_helper(n_v, v, i_pivots[i], t, len[i], &w);
 804abbe:	920c      	str	r2, [sp, #48]	@ 0x30
	assert(kad_is_pivot(v[i_pivot]) && t[i_pivot] == 0);
 804abc0:	f8d8 2004 	ldr.w	r2, [r8, #4]
			kad_unroll_helper(n_v, v, i_pivots[i], t, len[i], &w);
 804abc4:	9311      	str	r3, [sp, #68]	@ 0x44
	assert(kad_is_pivot(v[i_pivot]) && t[i_pivot] == 0);
 804abc6:	2a01      	cmp	r2, #1
 804abc8:	ea4f 038a 	mov.w	r3, sl, lsl #2
 804abcc:	9101      	str	r1, [sp, #4]
 804abce:	f040 8241 	bne.w	804b054 <kad_unroll+0x724>
 804abd2:	f898 2001 	ldrb.w	r2, [r8, #1]
 804abd6:	0750      	lsls	r0, r2, #29
 804abd8:	f140 823c 	bpl.w	804b054 <kad_unroll+0x724>
 804abdc:	9a0f      	ldr	r2, [sp, #60]	@ 0x3c
 804abde:	18d3      	adds	r3, r2, r3
 804abe0:	9308      	str	r3, [sp, #32]
 804abe2:	f852 302a 	ldr.w	r3, [r2, sl, lsl #2]
 804abe6:	2b00      	cmp	r3, #0
 804abe8:	f040 8234 	bne.w	804b054 <kad_unroll+0x724>
	q = (kad_node_t*)malloc(sizeof(kad_node_t));
 804abec:	2040      	movs	r0, #64	@ 0x40
 804abee:	f000 fe33 	bl	804b858 <malloc>
	memcpy(q, p, sizeof(kad_node_t));
 804abf2:	4644      	mov	r4, r8
	q = (kad_node_t*)malloc(sizeof(kad_node_t));
 804abf4:	4681      	mov	r9, r0
	memcpy(q, p, sizeof(kad_node_t));
 804abf6:	4606      	mov	r6, r0
	heapSize += sizeof(kad_node_t);
 804abf8:	4a56      	ldr	r2, [pc, #344]	@ (804ad54 <kad_unroll+0x424>)
	memcpy(q, p, sizeof(kad_node_t));
 804abfa:	f108 0740 	add.w	r7, r8, #64	@ 0x40
	heapSize += sizeof(kad_node_t);
 804abfe:	6813      	ldr	r3, [r2, #0]
 804ac00:	3340      	adds	r3, #64	@ 0x40
 804ac02:	6013      	str	r3, [r2, #0]
	memcpy(q, p, sizeof(kad_node_t));
 804ac04:	4635      	mov	r5, r6
 804ac06:	6820      	ldr	r0, [r4, #0]
 804ac08:	6861      	ldr	r1, [r4, #4]
 804ac0a:	68a2      	ldr	r2, [r4, #8]
 804ac0c:	68e3      	ldr	r3, [r4, #12]
 804ac0e:	3410      	adds	r4, #16
 804ac10:	42bc      	cmp	r4, r7
 804ac12:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 804ac14:	f106 0610 	add.w	r6, r6, #16
 804ac18:	d1f4      	bne.n	804ac04 <kad_unroll+0x2d4>
	q->pre = 0, q->tmp = 0, q->gtmp = 0;
 804ac1a:	2300      	movs	r3, #0
	if (p->ptr && p->ptr_size > 0) {
 804ac1c:	f8d8 5030 	ldr.w	r5, [r8, #48]	@ 0x30
	q->pre = 0, q->tmp = 0, q->gtmp = 0;
 804ac20:	f8c9 303c 	str.w	r3, [r9, #60]	@ 0x3c
 804ac24:	f8c9 3008 	str.w	r3, [r9, #8]
 804ac28:	f8c9 3034 	str.w	r3, [r9, #52]	@ 0x34
	if (p->ptr && p->ptr_size > 0) {
 804ac2c:	b1c5      	cbz	r5, 804ac60 <kad_unroll+0x330>
 804ac2e:	f8d8 400c 	ldr.w	r4, [r8, #12]
 804ac32:	429c      	cmp	r4, r3
 804ac34:	dd14      	ble.n	804ac60 <kad_unroll+0x330>
		if (kad_use_rng(p) && !(p->flag & KAD_SHARE_RNG) && p->ptr_size == sizeof(kad_rng_t)) {
 804ac36:	f8b8 3002 	ldrh.w	r3, [r8, #2]
 804ac3a:	2b0f      	cmp	r3, #15
 804ac3c:	f000 81f2 	beq.w	804b024 <kad_unroll+0x6f4>
 804ac40:	2b18      	cmp	r3, #24
 804ac42:	f000 81ef 	beq.w	804b024 <kad_unroll+0x6f4>
			q->ptr = malloc(p->ptr_size);
 804ac46:	4620      	mov	r0, r4
 804ac48:	f000 fe06 	bl	804b858 <malloc>
			heapSize += p->ptr_size;
 804ac4c:	4a41      	ldr	r2, [pc, #260]	@ (804ad54 <kad_unroll+0x424>)
			memcpy(q->ptr, p->ptr, p->ptr_size);
 804ac4e:	4629      	mov	r1, r5
			heapSize += p->ptr_size;
 804ac50:	6813      	ldr	r3, [r2, #0]
			q->ptr = malloc(p->ptr_size);
 804ac52:	f8c9 0030 	str.w	r0, [r9, #48]	@ 0x30
			heapSize += p->ptr_size;
 804ac56:	4423      	add	r3, r4
 804ac58:	6013      	str	r3, [r2, #0]
			memcpy(q->ptr, p->ptr, p->ptr_size);
 804ac5a:	4622      	mov	r2, r4
 804ac5c:	f001 f9e7 	bl	804c02e <memcpy>
	if (q->n_child) {
 804ac60:	f8d9 4004 	ldr.w	r4, [r9, #4]
 804ac64:	2c00      	cmp	r4, #0
 804ac66:	f040 81cf 	bne.w	804b008 <kad_unroll+0x6d8>
	t[i_pivot]->child = (kad_node_t**)realloc(t[i_pivot]->child, len * sizeof(kad_node_t*));
 804ac6a:	f8d9 0038 	ldr.w	r0, [r9, #56]	@ 0x38
	t[i_pivot]->n_child = len;
 804ac6e:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
	t[i_pivot] = kad_dup1(v[i_pivot]);
 804ac70:	9a0f      	ldr	r2, [sp, #60]	@ 0x3c
	t[i_pivot]->child = (kad_node_t**)realloc(t[i_pivot]->child, len * sizeof(kad_node_t*));
 804ac72:	0099      	lsls	r1, r3, #2
	t[i_pivot]->n_child = len;
 804ac74:	f8c9 3004 	str.w	r3, [r9, #4]
	t[i_pivot] = kad_dup1(v[i_pivot]);
 804ac78:	f842 902a 	str.w	r9, [r2, sl, lsl #2]
	t[i_pivot]->child = (kad_node_t**)realloc(t[i_pivot]->child, len * sizeof(kad_node_t*));
 804ac7c:	f000 fed8 	bl	804ba30 <realloc>
	flag = (uint8_t*)calloc(n_v, 1);
 804ac80:	2101      	movs	r1, #1
	t[i_pivot]->child = (kad_node_t**)realloc(t[i_pivot]->child, len * sizeof(kad_node_t*));
 804ac82:	f8c9 0038 	str.w	r0, [r9, #56]	@ 0x38
	flag = (uint8_t*)calloc(n_v, 1);
 804ac86:	9810      	ldr	r0, [sp, #64]	@ 0x40
 804ac88:	f000 fdca 	bl	804b820 <calloc>
	for (i = i_pivot, flag[i] = 16; i >= 0; --i) {
 804ac8c:	2510      	movs	r5, #16
 804ac8e:	f1ba 0f00 	cmp.w	sl, #0
	flag = (uint8_t*)calloc(n_v, 1);
 804ac92:	4604      	mov	r4, r0
	for (i = i_pivot, flag[i] = 16; i >= 0; --i) {
 804ac94:	f800 500a 	strb.w	r5, [r0, sl]
 804ac98:	db7d      	blt.n	804ad96 <kad_unroll+0x466>
 804ac9a:	f10a 0701 	add.w	r7, sl, #1
 804ac9e:	4427      	add	r7, r4
		if (flag[i]&16) /* flag 16: nodes to unroll */
 804aca0:	f817 3d01 	ldrb.w	r3, [r7, #-1]!
			kad_unroll_helper(n_v, v, i_pivots[i], t, len[i], &w);
 804aca4:	4650      	mov	r0, sl
		if (flag[i]&16) /* flag 16: nodes to unroll */
 804aca6:	06da      	lsls	r2, r3, #27
 804aca8:	9e01      	ldr	r6, [sp, #4]
 804acaa:	d409      	bmi.n	804acc0 <kad_unroll+0x390>
	for (i = i_pivot, flag[i] = 16; i >= 0; --i) {
 804acac:	1e41      	subs	r1, r0, #1
 804acae:	458a      	cmp	sl, r1
 804acb0:	f1a6 0604 	sub.w	r6, r6, #4
 804acb4:	dc17      	bgt.n	804ace6 <kad_unroll+0x3b6>
		if (flag[i]&16) /* flag 16: nodes to unroll */
 804acb6:	f817 3d01 	ldrb.w	r3, [r7, #-1]!
	for (i = i_pivot, flag[i] = 16; i >= 0; --i) {
 804acba:	4608      	mov	r0, r1
		if (flag[i]&16) /* flag 16: nodes to unroll */
 804acbc:	06da      	lsls	r2, r3, #27
 804acbe:	d5f5      	bpl.n	804acac <kad_unroll+0x37c>
			for (j = 0; j < v[i]->n_child; ++j)
 804acc0:	6833      	ldr	r3, [r6, #0]
 804acc2:	6859      	ldr	r1, [r3, #4]
 804acc4:	2900      	cmp	r1, #0
 804acc6:	ddf1      	ble.n	804acac <kad_unroll+0x37c>
				flag[v[i]->child[j]->tmp] = 16;
 804acc8:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 804acca:	3b04      	subs	r3, #4
 804accc:	eb03 0181 	add.w	r1, r3, r1, lsl #2
 804acd0:	f853 2f04 	ldr.w	r2, [r3, #4]!
 804acd4:	6892      	ldr	r2, [r2, #8]
			for (j = 0; j < v[i]->n_child; ++j)
 804acd6:	4299      	cmp	r1, r3
				flag[v[i]->child[j]->tmp] = 16;
 804acd8:	54a5      	strb	r5, [r4, r2]
			for (j = 0; j < v[i]->n_child; ++j)
 804acda:	d1f9      	bne.n	804acd0 <kad_unroll+0x3a0>
	for (i = i_pivot, flag[i] = 16; i >= 0; --i) {
 804acdc:	1e41      	subs	r1, r0, #1
 804acde:	458a      	cmp	sl, r1
 804ace0:	f1a6 0604 	sub.w	r6, r6, #4
 804ace4:	dde7      	ble.n	804acb6 <kad_unroll+0x386>
 804ace6:	1c4d      	adds	r5, r1, #1
 804ace8:	d023      	beq.n	804ad32 <kad_unroll+0x402>
 804acea:	9b0d      	ldr	r3, [sp, #52]	@ 0x34
				flag[v[i]->child[j]->tmp] = 16;
 804acec:	2610      	movs	r6, #16
 804acee:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 804acf2:	4421      	add	r1, r4
 804acf4:	e004      	b.n	804ad00 <kad_unroll+0x3d0>
	for (i = i_pivot, flag[i] = 16; i >= 0; --i) {
 804acf6:	428c      	cmp	r4, r1
 804acf8:	f101 33ff 	add.w	r3, r1, #4294967295
 804acfc:	d019      	beq.n	804ad32 <kad_unroll+0x402>
 804acfe:	4619      	mov	r1, r3
		if (i < i_pivot && kad_is_pivot(v[i])) continue; /* don't trespass other pivots */
 804ad00:	f850 2d04 	ldr.w	r2, [r0, #-4]!
 804ad04:	6855      	ldr	r5, [r2, #4]
 804ad06:	2d01      	cmp	r5, #1
 804ad08:	f000 816c 	beq.w	804afe4 <kad_unroll+0x6b4>
		if (flag[i]&16) /* flag 16: nodes to unroll */
 804ad0c:	780b      	ldrb	r3, [r1, #0]
 804ad0e:	06df      	lsls	r7, r3, #27
 804ad10:	d5f1      	bpl.n	804acf6 <kad_unroll+0x3c6>
			for (j = 0; j < v[i]->n_child; ++j)
 804ad12:	2d00      	cmp	r5, #0
 804ad14:	ddef      	ble.n	804acf6 <kad_unroll+0x3c6>
				flag[v[i]->child[j]->tmp] = 16;
 804ad16:	6b93      	ldr	r3, [r2, #56]	@ 0x38
 804ad18:	3b04      	subs	r3, #4
 804ad1a:	eb03 0585 	add.w	r5, r3, r5, lsl #2
 804ad1e:	f853 2f04 	ldr.w	r2, [r3, #4]!
 804ad22:	6892      	ldr	r2, [r2, #8]
			for (j = 0; j < v[i]->n_child; ++j)
 804ad24:	429d      	cmp	r5, r3
				flag[v[i]->child[j]->tmp] = 16;
 804ad26:	54a6      	strb	r6, [r4, r2]
			for (j = 0; j < v[i]->n_child; ++j)
 804ad28:	d1f9      	bne.n	804ad1e <kad_unroll+0x3ee>
	for (i = i_pivot, flag[i] = 16; i >= 0; --i) {
 804ad2a:	428c      	cmp	r4, r1
 804ad2c:	f101 33ff 	add.w	r3, r1, #4294967295
 804ad30:	d1e5      	bne.n	804acfe <kad_unroll+0x3ce>
	for (i = 0; i < i_pivot; ++i) {
 804ad32:	f1ba 0f00 	cmp.w	sl, #0
 804ad36:	d02e      	beq.n	804ad96 <kad_unroll+0x466>
 804ad38:	f10a 36ff 	add.w	r6, sl, #4294967295
 804ad3c:	9a0d      	ldr	r2, [sp, #52]	@ 0x34
 804ad3e:	4426      	add	r6, r4
 804ad40:	1e63      	subs	r3, r4, #1
 804ad42:	e01a      	b.n	804ad7a <kad_unroll+0x44a>
 804ad44:	f3af 8000 	nop.w
	...
 804ad50:	20018004 	.word	0x20018004
 804ad54:	20018acc 	.word	0x20018acc
		if (kad_is_var(v[i]) || kad_is_const(v[i]) || kad_is_pivot(v[i])) flag[i] |= 1; /* external nodes that should not be duplicated */
 804ad58:	7845      	ldrb	r5, [r0, #1]
 804ad5a:	07af      	lsls	r7, r5, #30
 804ad5c:	d002      	beq.n	804ad64 <kad_unroll+0x434>
 804ad5e:	f041 0101 	orr.w	r1, r1, #1
 804ad62:	7019      	strb	r1, [r3, #0]
		if (v[i]->pre) flag[v[i]->pre->tmp] |= 2;
 804ad64:	6bc1      	ldr	r1, [r0, #60]	@ 0x3c
 804ad66:	b121      	cbz	r1, 804ad72 <kad_unroll+0x442>
 804ad68:	6888      	ldr	r0, [r1, #8]
 804ad6a:	5c21      	ldrb	r1, [r4, r0]
 804ad6c:	f041 0102 	orr.w	r1, r1, #2
 804ad70:	5421      	strb	r1, [r4, r0]
	for (i = 0; i < i_pivot; ++i) {
 804ad72:	42b3      	cmp	r3, r6
 804ad74:	f102 0204 	add.w	r2, r2, #4
 804ad78:	d00d      	beq.n	804ad96 <kad_unroll+0x466>
		if (!(flag[i]&16)) continue;
 804ad7a:	f813 1f01 	ldrb.w	r1, [r3, #1]!
 804ad7e:	06c8      	lsls	r0, r1, #27
 804ad80:	d5f7      	bpl.n	804ad72 <kad_unroll+0x442>
		if (kad_is_var(v[i]) || kad_is_const(v[i]) || kad_is_pivot(v[i])) flag[i] |= 1; /* external nodes that should not be duplicated */
 804ad82:	6810      	ldr	r0, [r2, #0]
 804ad84:	6845      	ldr	r5, [r0, #4]
 804ad86:	2d00      	cmp	r5, #0
 804ad88:	d0e6      	beq.n	804ad58 <kad_unroll+0x428>
 804ad8a:	2d01      	cmp	r5, #1
 804ad8c:	d1ea      	bne.n	804ad64 <kad_unroll+0x434>
 804ad8e:	7845      	ldrb	r5, [r0, #1]
 804ad90:	076d      	lsls	r5, r5, #29
 804ad92:	d5e7      	bpl.n	804ad64 <kad_unroll+0x434>
 804ad94:	e7e3      	b.n	804ad5e <kad_unroll+0x42e>
	aux = (kad_node_t**)calloc(n_v, sizeof(kad_node_t*));
 804ad96:	2104      	movs	r1, #4
	flag[v[i_pivot]->child[0]->tmp] |= 4;
 804ad98:	9b0d      	ldr	r3, [sp, #52]	@ 0x34
	aux = (kad_node_t**)calloc(n_v, sizeof(kad_node_t*));
 804ad9a:	9810      	ldr	r0, [sp, #64]	@ 0x40
	flag[v[i_pivot]->child[0]->tmp] |= 4;
 804ad9c:	f853 302a 	ldr.w	r3, [r3, sl, lsl #2]
 804ada0:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 804ada2:	681b      	ldr	r3, [r3, #0]
 804ada4:	689a      	ldr	r2, [r3, #8]
 804ada6:	5ca3      	ldrb	r3, [r4, r2]
 804ada8:	430b      	orrs	r3, r1
 804adaa:	54a3      	strb	r3, [r4, r2]
	aux = (kad_node_t**)calloc(n_v, sizeof(kad_node_t*));
 804adac:	f000 fd38 	bl	804b820 <calloc>
	for (l = 0; l < len; ++l) {
 804adb0:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
	aux = (kad_node_t**)calloc(n_v, sizeof(kad_node_t*));
 804adb2:	900b      	str	r0, [sp, #44]	@ 0x2c
	for (l = 0; l < len; ++l) {
 804adb4:	2b00      	cmp	r3, #0
 804adb6:	f340 80ae 	ble.w	804af16 <kad_unroll+0x5e6>
 804adba:	2200      	movs	r2, #0
				if (l == len - 1) t[i]->pre = aux[v[i]->pre->tmp]; /* this forms a cycle! */
 804adbc:	3b01      	subs	r3, #1
 804adbe:	9d0f      	ldr	r5, [sp, #60]	@ 0x3c
 804adc0:	9307      	str	r3, [sp, #28]
 804adc2:	f8cd b04c 	str.w	fp, [sp, #76]	@ 0x4c
		for (i = 0; i < i_pivot; ++i) {
 804adc6:	f1ba 0f00 	cmp.w	sl, #0
 804adca:	f340 809a 	ble.w	804af02 <kad_unroll+0x5d2>
 804adce:	f10a 33ff 	add.w	r3, sl, #4294967295
 804add2:	18e3      	adds	r3, r4, r3
 804add4:	f104 3bff 	add.w	fp, r4, #4294967295
 804add8:	9301      	str	r3, [sp, #4]
 804adda:	0093      	lsls	r3, r2, #2
	q->pre = 0, q->tmp = 0, q->gtmp = 0;
 804addc:	465e      	mov	r6, fp
		for (i = 0; i < i_pivot; ++i) {
 804adde:	f04f 0900 	mov.w	r9, #0
	q->pre = 0, q->tmp = 0, q->gtmp = 0;
 804ade2:	46ab      	mov	fp, r5
 804ade4:	e9cd a409 	strd	sl, r4, [sp, #36]	@ 0x24
				if (l == len - 1) t[i]->pre = aux[v[i]->pre->tmp]; /* this forms a cycle! */
 804ade8:	f8dd 8034 	ldr.w	r8, [sp, #52]	@ 0x34
 804adec:	9306      	str	r3, [sp, #24]
	q->pre = 0, q->tmp = 0, q->gtmp = 0;
 804adee:	9202      	str	r2, [sp, #8]
 804adf0:	e009      	b.n	804ae06 <kad_unroll+0x4d6>
			if (!(flag[i]&16) || ((flag[i]&3) && t[i])) continue;
 804adf2:	f85b 3029 	ldr.w	r3, [fp, r9, lsl #2]
 804adf6:	b173      	cbz	r3, 804ae16 <kad_unroll+0x4e6>
		for (i = 0; i < i_pivot; ++i) {
 804adf8:	9b01      	ldr	r3, [sp, #4]
 804adfa:	f109 0901 	add.w	r9, r9, #1
 804adfe:	429e      	cmp	r6, r3
 804ae00:	f108 0804 	add.w	r8, r8, #4
 804ae04:	d078      	beq.n	804aef8 <kad_unroll+0x5c8>
			if (!(flag[i]&16) || ((flag[i]&3) && t[i])) continue;
 804ae06:	f816 af01 	ldrb.w	sl, [r6, #1]!
 804ae0a:	f01a 0f10 	tst.w	sl, #16
 804ae0e:	d0f3      	beq.n	804adf8 <kad_unroll+0x4c8>
 804ae10:	f01a 0f03 	tst.w	sl, #3
 804ae14:	d1ed      	bne.n	804adf2 <kad_unroll+0x4c2>
	q = (kad_node_t*)malloc(sizeof(kad_node_t));
 804ae16:	2040      	movs	r0, #64	@ 0x40
			t[i] = kad_dup1(v[i]);
 804ae18:	f8d8 7000 	ldr.w	r7, [r8]
	q = (kad_node_t*)malloc(sizeof(kad_node_t));
 804ae1c:	f000 fd1c 	bl	804b858 <malloc>
	memcpy(q, p, sizeof(kad_node_t));
 804ae20:	463c      	mov	r4, r7
	q = (kad_node_t*)malloc(sizeof(kad_node_t));
 804ae22:	4605      	mov	r5, r0
	memcpy(q, p, sizeof(kad_node_t));
 804ae24:	4684      	mov	ip, r0
	heapSize += sizeof(kad_node_t);
 804ae26:	4a8f      	ldr	r2, [pc, #572]	@ (804b064 <kad_unroll+0x734>)
	memcpy(q, p, sizeof(kad_node_t));
 804ae28:	f107 0e40 	add.w	lr, r7, #64	@ 0x40
	heapSize += sizeof(kad_node_t);
 804ae2c:	6813      	ldr	r3, [r2, #0]
	memcpy(q, p, sizeof(kad_node_t));
 804ae2e:	f8cd b00c 	str.w	fp, [sp, #12]
	heapSize += sizeof(kad_node_t);
 804ae32:	3340      	adds	r3, #64	@ 0x40
 804ae34:	6013      	str	r3, [r2, #0]
	memcpy(q, p, sizeof(kad_node_t));
 804ae36:	46e3      	mov	fp, ip
 804ae38:	6820      	ldr	r0, [r4, #0]
 804ae3a:	6861      	ldr	r1, [r4, #4]
 804ae3c:	68a2      	ldr	r2, [r4, #8]
 804ae3e:	68e3      	ldr	r3, [r4, #12]
 804ae40:	3410      	adds	r4, #16
 804ae42:	4574      	cmp	r4, lr
 804ae44:	e8ab 000f 	stmia.w	fp!, {r0, r1, r2, r3}
 804ae48:	f10c 0c10 	add.w	ip, ip, #16
 804ae4c:	d1f3      	bne.n	804ae36 <kad_unroll+0x506>
	q->pre = 0, q->tmp = 0, q->gtmp = 0;
 804ae4e:	2300      	movs	r3, #0
	if (p->ptr && p->ptr_size > 0) {
 804ae50:	6b39      	ldr	r1, [r7, #48]	@ 0x30
	q->pre = 0, q->tmp = 0, q->gtmp = 0;
 804ae52:	f8dd b00c 	ldr.w	fp, [sp, #12]
 804ae56:	63eb      	str	r3, [r5, #60]	@ 0x3c
 804ae58:	60ab      	str	r3, [r5, #8]
 804ae5a:	636b      	str	r3, [r5, #52]	@ 0x34
	if (p->ptr && p->ptr_size > 0) {
 804ae5c:	b1b1      	cbz	r1, 804ae8c <kad_unroll+0x55c>
 804ae5e:	68fc      	ldr	r4, [r7, #12]
 804ae60:	429c      	cmp	r4, r3
 804ae62:	dd13      	ble.n	804ae8c <kad_unroll+0x55c>
		if (kad_use_rng(p) && !(p->flag & KAD_SHARE_RNG) && p->ptr_size == sizeof(kad_rng_t)) {
 804ae64:	887b      	ldrh	r3, [r7, #2]
 804ae66:	2b0f      	cmp	r3, #15
 804ae68:	f000 80ad 	beq.w	804afc6 <kad_unroll+0x696>
 804ae6c:	2b18      	cmp	r3, #24
 804ae6e:	f000 80aa 	beq.w	804afc6 <kad_unroll+0x696>
			q->ptr = malloc(p->ptr_size);
 804ae72:	4620      	mov	r0, r4
 804ae74:	9103      	str	r1, [sp, #12]
 804ae76:	f000 fcef 	bl	804b858 <malloc>
			heapSize += p->ptr_size;
 804ae7a:	4a7a      	ldr	r2, [pc, #488]	@ (804b064 <kad_unroll+0x734>)
			memcpy(q->ptr, p->ptr, p->ptr_size);
 804ae7c:	9903      	ldr	r1, [sp, #12]
			heapSize += p->ptr_size;
 804ae7e:	6813      	ldr	r3, [r2, #0]
			q->ptr = malloc(p->ptr_size);
 804ae80:	6328      	str	r0, [r5, #48]	@ 0x30
			heapSize += p->ptr_size;
 804ae82:	4423      	add	r3, r4
 804ae84:	6013      	str	r3, [r2, #0]
			memcpy(q->ptr, p->ptr, p->ptr_size);
 804ae86:	4622      	mov	r2, r4
 804ae88:	f001 f8d1 	bl	804c02e <memcpy>
	if (q->n_child) {
 804ae8c:	686c      	ldr	r4, [r5, #4]
 804ae8e:	2c00      	cmp	r4, #0
 804ae90:	d16f      	bne.n	804af72 <kad_unroll+0x642>
			if (v[i]->n_child)
 804ae92:	687b      	ldr	r3, [r7, #4]
			t[i] = kad_dup1(v[i]);
 804ae94:	f84b 5029 	str.w	r5, [fp, r9, lsl #2]
			if (v[i]->n_child)
 804ae98:	2b00      	cmp	r3, #0
 804ae9a:	dc7b      	bgt.n	804af94 <kad_unroll+0x664>
			if (flag[i]&4) t[i_pivot]->child[l] = t[i];
 804ae9c:	f01a 0f04 	tst.w	sl, #4
 804aea0:	d006      	beq.n	804aeb0 <kad_unroll+0x580>
 804aea2:	9b08      	ldr	r3, [sp, #32]
 804aea4:	9a06      	ldr	r2, [sp, #24]
 804aea6:	681b      	ldr	r3, [r3, #0]
 804aea8:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 804aeaa:	509d      	str	r5, [r3, r2]
			if (v[i]->pre) {
 804aeac:	f8d8 7000 	ldr.w	r7, [r8]
			if (l == 0 && (flag[i]&2)) aux[i] = t[i];
 804aeb0:	9b02      	ldr	r3, [sp, #8]
 804aeb2:	b92b      	cbnz	r3, 804aec0 <kad_unroll+0x590>
 804aeb4:	f01a 0f02 	tst.w	sl, #2
 804aeb8:	bf1c      	itt	ne
 804aeba:	9b0b      	ldrne	r3, [sp, #44]	@ 0x2c
 804aebc:	f843 5029 	strne.w	r5, [r3, r9, lsl #2]
			if (v[i]->pre) {
 804aec0:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 804aec2:	b143      	cbz	r3, 804aed6 <kad_unroll+0x5a6>
				if (l == len - 1) t[i]->pre = aux[v[i]->pre->tmp]; /* this forms a cycle! */
 804aec4:	9a07      	ldr	r2, [sp, #28]
 804aec6:	9902      	ldr	r1, [sp, #8]
				t[v[i]->pre->tmp] = t[i];
 804aec8:	689b      	ldr	r3, [r3, #8]
				if (l == len - 1) t[i]->pre = aux[v[i]->pre->tmp]; /* this forms a cycle! */
 804aeca:	428a      	cmp	r2, r1
				t[v[i]->pre->tmp] = t[i];
 804aecc:	f84b 5023 	str.w	r5, [fp, r3, lsl #2]
				if (l == len - 1) t[i]->pre = aux[v[i]->pre->tmp]; /* this forms a cycle! */
 804aed0:	d072      	beq.n	804afb8 <kad_unroll+0x688>
 804aed2:	f85b 5029 	ldr.w	r5, [fp, r9, lsl #2]
	if (w->n == w->m) {
 804aed6:	9b05      	ldr	r3, [sp, #20]
 804aed8:	9a00      	ldr	r2, [sp, #0]
 804aeda:	4293      	cmp	r3, r2
 804aedc:	d03f      	beq.n	804af5e <kad_unroll+0x62e>
	w->v[w->n++] = p;
 804aede:	9b00      	ldr	r3, [sp, #0]
 804aee0:	9a04      	ldr	r2, [sp, #16]
		for (i = 0; i < i_pivot; ++i) {
 804aee2:	f109 0901 	add.w	r9, r9, #1
	w->v[w->n++] = p;
 804aee6:	f842 5023 	str.w	r5, [r2, r3, lsl #2]
 804aeea:	3301      	adds	r3, #1
 804aeec:	9300      	str	r3, [sp, #0]
		for (i = 0; i < i_pivot; ++i) {
 804aeee:	9b01      	ldr	r3, [sp, #4]
 804aef0:	f108 0804 	add.w	r8, r8, #4
 804aef4:	429e      	cmp	r6, r3
 804aef6:	d186      	bne.n	804ae06 <kad_unroll+0x4d6>
 804aef8:	465d      	mov	r5, fp
 804aefa:	f8dd a024 	ldr.w	sl, [sp, #36]	@ 0x24
 804aefe:	9c0a      	ldr	r4, [sp, #40]	@ 0x28
 804af00:	9a02      	ldr	r2, [sp, #8]
	for (l = 0; l < len; ++l) {
 804af02:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
 804af04:	3201      	adds	r2, #1
 804af06:	4293      	cmp	r3, r2
 804af08:	f47f af5d 	bne.w	804adc6 <kad_unroll+0x496>
	push_nodes(w, t[i_pivot]);
 804af0c:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
 804af0e:	f8dd b04c 	ldr.w	fp, [sp, #76]	@ 0x4c
 804af12:	f853 902a 	ldr.w	r9, [r3, sl, lsl #2]
 804af16:	9d00      	ldr	r5, [sp, #0]
	if (w->n == w->m) {
 804af18:	9b05      	ldr	r3, [sp, #20]
 804af1a:	42ab      	cmp	r3, r5
 804af1c:	d06b      	beq.n	804aff6 <kad_unroll+0x6c6>
	w->v[w->n++] = p;
 804af1e:	9b04      	ldr	r3, [sp, #16]
	free(aux); free(flag);
 804af20:	980b      	ldr	r0, [sp, #44]	@ 0x2c
	w->v[w->n++] = p;
 804af22:	f843 9025 	str.w	r9, [r3, r5, lsl #2]
	free(aux); free(flag);
 804af26:	f000 fc9f 	bl	804b868 <free>
 804af2a:	4620      	mov	r0, r4
 804af2c:	f000 fc9c 	bl	804b868 <free>
	w->v[w->n++] = p;
 804af30:	9b00      	ldr	r3, [sp, #0]
		for (i = 0; i < n_pivots; ++i) /* unroll each pivot, from the lowest to the highest */
 804af32:	f10b 0b01 	add.w	fp, fp, #1
	w->v[w->n++] = p;
 804af36:	3301      	adds	r3, #1
 804af38:	9300      	str	r3, [sp, #0]
		for (i = 0; i < n_pivots; ++i) /* unroll each pivot, from the lowest to the highest */
 804af3a:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
 804af3c:	459b      	cmp	fp, r3
 804af3e:	f47f ae32 	bne.w	804aba6 <kad_unroll+0x276>
		free(i_pivots);
 804af42:	e9dd 7915 	ldrd	r7, r9, [sp, #84]	@ 0x54
 804af46:	e9dd 5417 	ldrd	r5, r4, [sp, #92]	@ 0x5c
 804af4a:	4648      	mov	r0, r9
 804af4c:	f8dd 803c 	ldr.w	r8, [sp, #60]	@ 0x3c
 804af50:	f8dd a064 	ldr.w	sl, [sp, #100]	@ 0x64
 804af54:	f000 fc88 	bl	804b868 <free>
	w->v[w->n++] = p;
 804af58:	9b00      	ldr	r3, [sp, #0]
 804af5a:	930e      	str	r3, [sp, #56]	@ 0x38
 804af5c:	e520      	b.n	804a9a0 <kad_unroll+0x70>
		w->m = w->m? w->m<<1 : 16;
 804af5e:	2b00      	cmp	r3, #0
 804af60:	d03c      	beq.n	804afdc <kad_unroll+0x6ac>
 804af62:	005b      	lsls	r3, r3, #1
 804af64:	9305      	str	r3, [sp, #20]
		w->v = (kad_node_t**)realloc(w->v, w->m * sizeof(kad_node_t*));
 804af66:	0099      	lsls	r1, r3, #2
 804af68:	9804      	ldr	r0, [sp, #16]
 804af6a:	f000 fd61 	bl	804ba30 <realloc>
 804af6e:	9004      	str	r0, [sp, #16]
 804af70:	e7b5      	b.n	804aede <kad_unroll+0x5ae>
		q->x = q->g = 0;
 804af72:	ed85 8b0a 	vstr	d8, [r5, #40]	@ 0x28
		q->child = (kad_node_t**)calloc(q->n_child, sizeof(kad_node_t*));
 804af76:	2104      	movs	r1, #4
 804af78:	4620      	mov	r0, r4
 804af7a:	f000 fc51 	bl	804b820 <calloc>
		heapSize += q->n_child * sizeof(kad_node_t*);
 804af7e:	4a39      	ldr	r2, [pc, #228]	@ (804b064 <kad_unroll+0x734>)
		q->child = (kad_node_t**)calloc(q->n_child, sizeof(kad_node_t*));
 804af80:	63a8      	str	r0, [r5, #56]	@ 0x38
		heapSize += q->n_child * sizeof(kad_node_t*);
 804af82:	6813      	ldr	r3, [r2, #0]
			t[i] = kad_dup1(v[i]);
 804af84:	f84b 5029 	str.w	r5, [fp, r9, lsl #2]
		heapSize += q->n_child * sizeof(kad_node_t*);
 804af88:	eb03 0384 	add.w	r3, r3, r4, lsl #2
 804af8c:	6013      	str	r3, [r2, #0]
			if (v[i]->n_child)
 804af8e:	687b      	ldr	r3, [r7, #4]
 804af90:	2b00      	cmp	r3, #0
 804af92:	dd83      	ble.n	804ae9c <kad_unroll+0x56c>
				for (j = 0; j < v[i]->n_child; ++j)
 804af94:	2300      	movs	r3, #0
 804af96:	6baa      	ldr	r2, [r5, #56]	@ 0x38
 804af98:	3a04      	subs	r2, #4
					t[i]->child[j] = t[v[i]->child[j]->tmp];
 804af9a:	6bb9      	ldr	r1, [r7, #56]	@ 0x38
 804af9c:	f851 1023 	ldr.w	r1, [r1, r3, lsl #2]
				for (j = 0; j < v[i]->n_child; ++j)
 804afa0:	3301      	adds	r3, #1
					t[i]->child[j] = t[v[i]->child[j]->tmp];
 804afa2:	6889      	ldr	r1, [r1, #8]
 804afa4:	f85b 1021 	ldr.w	r1, [fp, r1, lsl #2]
 804afa8:	f842 1f04 	str.w	r1, [r2, #4]!
				for (j = 0; j < v[i]->n_child; ++j)
 804afac:	f8d8 7000 	ldr.w	r7, [r8]
 804afb0:	6879      	ldr	r1, [r7, #4]
 804afb2:	428b      	cmp	r3, r1
 804afb4:	dbf1      	blt.n	804af9a <kad_unroll+0x66a>
 804afb6:	e771      	b.n	804ae9c <kad_unroll+0x56c>
				if (l == len - 1) t[i]->pre = aux[v[i]->pre->tmp]; /* this forms a cycle! */
 804afb8:	9a0b      	ldr	r2, [sp, #44]	@ 0x2c
 804afba:	f85b 5029 	ldr.w	r5, [fp, r9, lsl #2]
 804afbe:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 804afc2:	63eb      	str	r3, [r5, #60]	@ 0x3c
 804afc4:	e787      	b.n	804aed6 <kad_unroll+0x5a6>
		if (kad_use_rng(p) && !(p->flag & KAD_SHARE_RNG) && p->ptr_size == sizeof(kad_rng_t)) {
 804afc6:	787b      	ldrb	r3, [r7, #1]
 804afc8:	06d8      	lsls	r0, r3, #27
 804afca:	f53f af52 	bmi.w	804ae72 <kad_unroll+0x542>
 804afce:	2c20      	cmp	r4, #32
 804afd0:	f47f af4f 	bne.w	804ae72 <kad_unroll+0x542>
			q->ptr = kad_rng(); /* each time step uses a different RNG */
 804afd4:	f7ff fbf4 	bl	804a7c0 <kad_rng>
 804afd8:	6328      	str	r0, [r5, #48]	@ 0x30
 804afda:	e757      	b.n	804ae8c <kad_unroll+0x55c>
		w->m = w->m? w->m<<1 : 16;
 804afdc:	2310      	movs	r3, #16
 804afde:	2140      	movs	r1, #64	@ 0x40
 804afe0:	9305      	str	r3, [sp, #20]
 804afe2:	e7c1      	b.n	804af68 <kad_unroll+0x638>
		if (i < i_pivot && kad_is_pivot(v[i])) continue; /* don't trespass other pivots */
 804afe4:	7853      	ldrb	r3, [r2, #1]
 804afe6:	075b      	lsls	r3, r3, #29
 804afe8:	f53f ae85 	bmi.w	804acf6 <kad_unroll+0x3c6>
		if (flag[i]&16) /* flag 16: nodes to unroll */
 804afec:	780b      	ldrb	r3, [r1, #0]
 804afee:	06db      	lsls	r3, r3, #27
 804aff0:	f57f ae81 	bpl.w	804acf6 <kad_unroll+0x3c6>
 804aff4:	e68f      	b.n	804ad16 <kad_unroll+0x3e6>
		w->m = w->m? w->m<<1 : 16;
 804aff6:	b313      	cbz	r3, 804b03e <kad_unroll+0x70e>
 804aff8:	005b      	lsls	r3, r3, #1
 804affa:	9305      	str	r3, [sp, #20]
		w->v = (kad_node_t**)realloc(w->v, w->m * sizeof(kad_node_t*));
 804affc:	0099      	lsls	r1, r3, #2
 804affe:	9804      	ldr	r0, [sp, #16]
 804b000:	f000 fd16 	bl	804ba30 <realloc>
 804b004:	9004      	str	r0, [sp, #16]
 804b006:	e78a      	b.n	804af1e <kad_unroll+0x5ee>
		q->x = q->g = 0;
 804b008:	ed89 8b0a 	vstr	d8, [r9, #40]	@ 0x28
		q->child = (kad_node_t**)calloc(q->n_child, sizeof(kad_node_t*));
 804b00c:	2104      	movs	r1, #4
 804b00e:	4620      	mov	r0, r4
 804b010:	f000 fc06 	bl	804b820 <calloc>
		heapSize += q->n_child * sizeof(kad_node_t*);
 804b014:	4a13      	ldr	r2, [pc, #76]	@ (804b064 <kad_unroll+0x734>)
		q->child = (kad_node_t**)calloc(q->n_child, sizeof(kad_node_t*));
 804b016:	f8c9 0038 	str.w	r0, [r9, #56]	@ 0x38
		heapSize += q->n_child * sizeof(kad_node_t*);
 804b01a:	6813      	ldr	r3, [r2, #0]
 804b01c:	eb03 0384 	add.w	r3, r3, r4, lsl #2
 804b020:	6013      	str	r3, [r2, #0]
 804b022:	e624      	b.n	804ac6e <kad_unroll+0x33e>
		if (kad_use_rng(p) && !(p->flag & KAD_SHARE_RNG) && p->ptr_size == sizeof(kad_rng_t)) {
 804b024:	f898 3001 	ldrb.w	r3, [r8, #1]
 804b028:	06d9      	lsls	r1, r3, #27
 804b02a:	f53f ae0c 	bmi.w	804ac46 <kad_unroll+0x316>
 804b02e:	2c20      	cmp	r4, #32
 804b030:	f47f ae09 	bne.w	804ac46 <kad_unroll+0x316>
			q->ptr = kad_rng(); /* each time step uses a different RNG */
 804b034:	f7ff fbc4 	bl	804a7c0 <kad_rng>
 804b038:	f8c9 0030 	str.w	r0, [r9, #48]	@ 0x30
 804b03c:	e610      	b.n	804ac60 <kad_unroll+0x330>
		w->m = w->m? w->m<<1 : 16;
 804b03e:	2310      	movs	r3, #16
 804b040:	2140      	movs	r1, #64	@ 0x40
 804b042:	9305      	str	r3, [sp, #20]
 804b044:	e7db      	b.n	804affe <kad_unroll+0x6ce>
	free(t);
 804b046:	2300      	movs	r3, #0
 804b048:	461c      	mov	r4, r3
 804b04a:	9304      	str	r3, [sp, #16]
 804b04c:	f000 fc0c 	bl	804b868 <free>
 804b050:	940e      	str	r4, [sp, #56]	@ 0x38
 804b052:	e530      	b.n	804aab6 <kad_unroll+0x186>
	assert(kad_is_pivot(v[i_pivot]) && t[i_pivot] == 0);
 804b054:	f240 21ff 	movw	r1, #767	@ 0x2ff
 804b058:	4b03      	ldr	r3, [pc, #12]	@ (804b068 <kad_unroll+0x738>)
 804b05a:	4a04      	ldr	r2, [pc, #16]	@ (804b06c <kad_unroll+0x73c>)
 804b05c:	4804      	ldr	r0, [pc, #16]	@ (804b070 <kad_unroll+0x740>)
 804b05e:	f000 fbc1 	bl	804b7e4 <__assert_func>
 804b062:	bf00      	nop
 804b064:	20018acc 	.word	0x20018acc
 804b068:	0804e4c4 	.word	0x0804e4c4
 804b06c:	0804e5c8 	.word	0x0804e5c8
 804b070:	0804e3dc 	.word	0x0804e3dc

0804b074 <kad_drand>:
	u.i = 0x3FFULL << 52 | kad_xoroshiro128plus_next(d? (kad_rng_t*)d : &kad_rng_dat) >> 12;
 804b074:	4b1f      	ldr	r3, [pc, #124]	@ (804b0f4 <kad_drand+0x80>)
{
 804b076:	b570      	push	{r4, r5, r6, lr}
	u.i = 0x3FFULL << 52 | kad_xoroshiro128plus_next(d? (kad_rng_t*)d : &kad_rng_dat) >> 12;
 804b078:	2800      	cmp	r0, #0
 804b07a:	bf14      	ite	ne
 804b07c:	4602      	movne	r2, r0
 804b07e:	461a      	moveq	r2, r3
	const uint64_t s0 = r->s[0];
 804b080:	6811      	ldr	r1, [r2, #0]
 804b082:	e9d2 3001 	ldrd	r3, r0, [r2, #4]
	s1 ^= s0;
 804b086:	ea81 0c00 	eor.w	ip, r1, r0
	const uint64_t result = s0 + s1;
 804b08a:	180c      	adds	r4, r1, r0
	r->s[0] = (s0 << 55 | s0 >> 9) ^ s1 ^ (s1 << 14);
 804b08c:	ea4f 2051 	mov.w	r0, r1, lsr #9
 804b090:	ea40 50c3 	orr.w	r0, r0, r3, lsl #23
 804b094:	ea80 000c 	eor.w	r0, r0, ip
	uint64_t s1 = r->s[1];
 804b098:	68d6      	ldr	r6, [r2, #12]
	r->s[0] = (s0 << 55 | s0 >> 9) ^ s1 ^ (s1 << 14);
 804b09a:	ea80 308c 	eor.w	r0, r0, ip, lsl #14
 804b09e:	6010      	str	r0, [r2, #0]
 804b0a0:	ea4f 2053 	mov.w	r0, r3, lsr #9
	s1 ^= s0;
 804b0a4:	ea83 0506 	eor.w	r5, r3, r6
	r->s[0] = (s0 << 55 | s0 >> 9) ^ s1 ^ (s1 << 14);
 804b0a8:	ea40 50c1 	orr.w	r0, r0, r1, lsl #23
 804b0ac:	ea80 0005 	eor.w	r0, r0, r5
 804b0b0:	ea4f 3585 	mov.w	r5, r5, lsl #14
 804b0b4:	ea45 459c 	orr.w	r5, r5, ip, lsr #18
 804b0b8:	ea80 0005 	eor.w	r0, r0, r5
	const uint64_t result = s0 + s1;
 804b0bc:	eb43 0e06 	adc.w	lr, r3, r6
	r->s[0] = (s0 << 55 | s0 >> 9) ^ s1 ^ (s1 << 14);
 804b0c0:	6050      	str	r0, [r2, #4]
	r->s[1] = s0 << 36 | s0 >> 28;
 804b0c2:	0f08      	lsrs	r0, r1, #28
	u.i = 0x3FFULL << 52 | kad_xoroshiro128plus_next(d? (kad_rng_t*)d : &kad_rng_dat) >> 12;
 804b0c4:	ea4f 351e 	mov.w	r5, lr, lsr #12
	r->s[1] = s0 << 36 | s0 >> 28;
 804b0c8:	ea40 1003 	orr.w	r0, r0, r3, lsl #4
 804b0cc:	0f1b      	lsrs	r3, r3, #28
 804b0ce:	ea43 1301 	orr.w	r3, r3, r1, lsl #4
	u.i = 0x3FFULL << 52 | kad_xoroshiro128plus_next(d? (kad_rng_t*)d : &kad_rng_dat) >> 12;
 804b0d2:	0b24      	lsrs	r4, r4, #12
 804b0d4:	f045 517f 	orr.w	r1, r5, #1069547520	@ 0x3fc00000
	r->s[1] = s0 << 36 | s0 >> 28;
 804b0d8:	6090      	str	r0, [r2, #8]
 804b0da:	60d3      	str	r3, [r2, #12]
	u.i = 0x3FFULL << 52 | kad_xoroshiro128plus_next(d? (kad_rng_t*)d : &kad_rng_dat) >> 12;
 804b0dc:	ea44 500e 	orr.w	r0, r4, lr, lsl #20
	return u.d - 1.0;
 804b0e0:	2200      	movs	r2, #0
 804b0e2:	4b05      	ldr	r3, [pc, #20]	@ (804b0f8 <kad_drand+0x84>)
	u.i = 0x3FFULL << 52 | kad_xoroshiro128plus_next(d? (kad_rng_t*)d : &kad_rng_dat) >> 12;
 804b0e4:	f441 1140 	orr.w	r1, r1, #3145728	@ 0x300000
	return u.d - 1.0;
 804b0e8:	f7f5 f8aa 	bl	8040240 <__aeabi_dsub>
}
 804b0ec:	ec41 0b10 	vmov	d0, r0, r1
 804b0f0:	bd70      	pop	{r4, r5, r6, pc}
 804b0f2:	bf00      	nop
 804b0f4:	20018108 	.word	0x20018108
 804b0f8:	3ff00000 	.word	0x3ff00000

0804b0fc <kad_drand_normal>:
	kad_rng_t *r = d? (kad_rng_t*)d : &kad_rng_dat;
 804b0fc:	4602      	mov	r2, r0
 804b0fe:	4b6e      	ldr	r3, [pc, #440]	@ (804b2b8 <kad_drand_normal+0x1bc>)
{
 804b100:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	kad_rng_t *r = d? (kad_rng_t*)d : &kad_rng_dat;
 804b104:	2800      	cmp	r0, #0
 804b106:	bf08      	it	eq
 804b108:	461a      	moveq	r2, r3
	if (r->n_iset == 0) {
 804b10a:	6993      	ldr	r3, [r2, #24]
{
 804b10c:	b089      	sub	sp, #36	@ 0x24
	kad_rng_t *r = d? (kad_rng_t*)d : &kad_rng_dat;
 804b10e:	9207      	str	r2, [sp, #28]
	if (r->n_iset == 0) {
 804b110:	2b00      	cmp	r3, #0
 804b112:	f040 80c9 	bne.w	804b2a8 <kad_drand_normal+0x1ac>
 804b116:	e9d2 6500 	ldrd	r6, r5, [r2]
 804b11a:	e9d2 7402 	ldrd	r7, r4, [r2, #8]
	s1 ^= s0;
 804b11e:	ea87 0206 	eor.w	r2, r7, r6
	const uint64_t result = s0 + s1;
 804b122:	19bf      	adds	r7, r7, r6
	s1 ^= s0;
 804b124:	ea84 0305 	eor.w	r3, r4, r5
	u.i = 0x3FFULL << 52 | kad_xoroshiro128plus_next(d? (kad_rng_t*)d : &kad_rng_dat) >> 12;
 804b128:	ea4f 3717 	mov.w	r7, r7, lsr #12
	const uint64_t result = s0 + s1;
 804b12c:	eb45 0404 	adc.w	r4, r5, r4
	u.i = 0x3FFULL << 52 | kad_xoroshiro128plus_next(d? (kad_rng_t*)d : &kad_rng_dat) >> 12;
 804b130:	ea47 5a04 	orr.w	sl, r7, r4, lsl #20
 804b134:	0b24      	lsrs	r4, r4, #12
 804b136:	f044 5b7f 	orr.w	fp, r4, #1069547520	@ 0x3fc00000
	r->s[0] = (s0 << 55 | s0 >> 9) ^ s1 ^ (s1 << 14);
 804b13a:	0a6c      	lsrs	r4, r5, #9
 804b13c:	ea4f 2856 	mov.w	r8, r6, lsr #9
 804b140:	ea44 54c6 	orr.w	r4, r4, r6, lsl #23
 804b144:	ea48 58c5 	orr.w	r8, r8, r5, lsl #23
 804b148:	405c      	eors	r4, r3
 804b14a:	039b      	lsls	r3, r3, #14
 804b14c:	ea43 4392 	orr.w	r3, r3, r2, lsr #18
 804b150:	ea88 0802 	eor.w	r8, r8, r2
	u.i = 0x3FFULL << 52 | kad_xoroshiro128plus_next(d? (kad_rng_t*)d : &kad_rng_dat) >> 12;
 804b154:	f44b 1b40 	orr.w	fp, fp, #3145728	@ 0x300000
	r->s[0] = (s0 << 55 | s0 >> 9) ^ s1 ^ (s1 << 14);
 804b158:	ea88 3882 	eor.w	r8, r8, r2, lsl #14
 804b15c:	405c      	eors	r4, r3
	return u.d - 1.0;
 804b15e:	2200      	movs	r2, #0
 804b160:	4b56      	ldr	r3, [pc, #344]	@ (804b2bc <kad_drand_normal+0x1c0>)
 804b162:	4650      	mov	r0, sl
 804b164:	4659      	mov	r1, fp
 804b166:	f7f5 f86b 	bl	8040240 <__aeabi_dsub>
 804b16a:	4602      	mov	r2, r0
 804b16c:	460b      	mov	r3, r1
			v1 = 2.0 * kad_drand(d) - 1.0;
 804b16e:	f7f5 f869 	bl	8040244 <__adddf3>
 804b172:	2200      	movs	r2, #0
 804b174:	4b51      	ldr	r3, [pc, #324]	@ (804b2bc <kad_drand_normal+0x1c0>)
 804b176:	f7f5 f863 	bl	8040240 <__aeabi_dsub>
	r->s[1] = s0 << 36 | s0 >> 28;
 804b17a:	0f37      	lsrs	r7, r6, #28
 804b17c:	ea47 1705 	orr.w	r7, r7, r5, lsl #4
 804b180:	0f2d      	lsrs	r5, r5, #28
	const uint64_t result = s0 + s1;
 804b182:	eb18 0207 	adds.w	r2, r8, r7
	r->s[1] = s0 << 36 | s0 >> 28;
 804b186:	ea45 1506 	orr.w	r5, r5, r6, lsl #4
	const uint64_t result = s0 + s1;
 804b18a:	eb44 0305 	adc.w	r3, r4, r5
	u.i = 0x3FFULL << 52 | kad_xoroshiro128plus_next(d? (kad_rng_t*)d : &kad_rng_dat) >> 12;
 804b18e:	0b12      	lsrs	r2, r2, #12
 804b190:	ea42 5203 	orr.w	r2, r2, r3, lsl #20
 804b194:	0b1b      	lsrs	r3, r3, #12
 804b196:	f043 537f 	orr.w	r3, r3, #1069547520	@ 0x3fc00000
 804b19a:	f443 1340 	orr.w	r3, r3, #3145728	@ 0x300000
 804b19e:	9301      	str	r3, [sp, #4]
	r->s[0] = (s0 << 55 | s0 >> 9) ^ s1 ^ (s1 << 14);
 804b1a0:	0a63      	lsrs	r3, r4, #9
	s1 ^= s0;
 804b1a2:	4065      	eors	r5, r4
	r->s[0] = (s0 << 55 | s0 >> 9) ^ s1 ^ (s1 << 14);
 804b1a4:	ea43 53c8 	orr.w	r3, r3, r8, lsl #23
	s1 ^= s0;
 804b1a8:	ea88 0707 	eor.w	r7, r8, r7
	r->s[0] = (s0 << 55 | s0 >> 9) ^ s1 ^ (s1 << 14);
 804b1ac:	406b      	eors	r3, r5
 804b1ae:	03ad      	lsls	r5, r5, #14
	u.i = 0x3FFULL << 52 | kad_xoroshiro128plus_next(d? (kad_rng_t*)d : &kad_rng_dat) >> 12;
 804b1b0:	9200      	str	r2, [sp, #0]
	r->s[0] = (s0 << 55 | s0 >> 9) ^ s1 ^ (s1 << 14);
 804b1b2:	ea45 4597 	orr.w	r5, r5, r7, lsr #18
	return u.d - 1.0;
 804b1b6:	2200      	movs	r2, #0
			v1 = 2.0 * kad_drand(d) - 1.0;
 804b1b8:	e9cd 0102 	strd	r0, r1, [sp, #8]
	return u.d - 1.0;
 804b1bc:	e9dd 0100 	ldrd	r0, r1, [sp]
	r->s[0] = (s0 << 55 | s0 >> 9) ^ s1 ^ (s1 << 14);
 804b1c0:	405d      	eors	r5, r3
	return u.d - 1.0;
 804b1c2:	4b3e      	ldr	r3, [pc, #248]	@ (804b2bc <kad_drand_normal+0x1c0>)
 804b1c4:	f7f5 f83c 	bl	8040240 <__aeabi_dsub>
 804b1c8:	4602      	mov	r2, r0
 804b1ca:	460b      	mov	r3, r1
			v2 = 2.0 * kad_drand(d) - 1.0;
 804b1cc:	f7f5 f83a 	bl	8040244 <__adddf3>
 804b1d0:	2200      	movs	r2, #0
 804b1d2:	4b3a      	ldr	r3, [pc, #232]	@ (804b2bc <kad_drand_normal+0x1c0>)
 804b1d4:	f7f5 f834 	bl	8040240 <__aeabi_dsub>
	r->s[0] = (s0 << 55 | s0 >> 9) ^ s1 ^ (s1 << 14);
 804b1d8:	ea4f 2658 	mov.w	r6, r8, lsr #9
 804b1dc:	ea46 56c4 	orr.w	r6, r6, r4, lsl #23
 804b1e0:	407e      	eors	r6, r7
 804b1e2:	ea86 3687 	eor.w	r6, r6, r7, lsl #14
	r->s[1] = s0 << 36 | s0 >> 28;
 804b1e6:	ea4f 7718 	mov.w	r7, r8, lsr #28
 804b1ea:	ea47 1704 	orr.w	r7, r7, r4, lsl #4
 804b1ee:	0f24      	lsrs	r4, r4, #28
			v2 = 2.0 * kad_drand(d) - 1.0;
 804b1f0:	e9cd 0104 	strd	r0, r1, [sp, #16]
	r->s[1] = s0 << 36 | s0 >> 28;
 804b1f4:	ea44 1408 	orr.w	r4, r4, r8, lsl #4
			rsq = v1 * v1 + v2 * v2;
 804b1f8:	e9dd 8902 	ldrd	r8, r9, [sp, #8]
 804b1fc:	4642      	mov	r2, r8
 804b1fe:	464b      	mov	r3, r9
 804b200:	4640      	mov	r0, r8
 804b202:	4649      	mov	r1, r9
 804b204:	f7f5 f9d4 	bl	80405b0 <__aeabi_dmul>
 804b208:	4680      	mov	r8, r0
 804b20a:	4689      	mov	r9, r1
 804b20c:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 804b210:	4602      	mov	r2, r0
 804b212:	460b      	mov	r3, r1
 804b214:	f7f5 f9cc 	bl	80405b0 <__aeabi_dmul>
 804b218:	4602      	mov	r2, r0
 804b21a:	460b      	mov	r3, r1
 804b21c:	4640      	mov	r0, r8
 804b21e:	4649      	mov	r1, r9
 804b220:	f7f5 f810 	bl	8040244 <__adddf3>
		} while (rsq >= 1.0 || rsq == 0.0);
 804b224:	2200      	movs	r2, #0
 804b226:	4b25      	ldr	r3, [pc, #148]	@ (804b2bc <kad_drand_normal+0x1c0>)
			rsq = v1 * v1 + v2 * v2;
 804b228:	4680      	mov	r8, r0
 804b22a:	4689      	mov	r9, r1
		} while (rsq >= 1.0 || rsq == 0.0);
 804b22c:	f7f5 fc46 	bl	8040abc <__aeabi_dcmpge>
 804b230:	2800      	cmp	r0, #0
 804b232:	f47f af74 	bne.w	804b11e <kad_drand_normal+0x22>
 804b236:	2200      	movs	r2, #0
 804b238:	2300      	movs	r3, #0
 804b23a:	4640      	mov	r0, r8
 804b23c:	4649      	mov	r1, r9
 804b23e:	f7f5 fc1f 	bl	8040a80 <__aeabi_dcmpeq>
 804b242:	2800      	cmp	r0, #0
 804b244:	f47f af6b 	bne.w	804b11e <kad_drand_normal+0x22>
 804b248:	9b07      	ldr	r3, [sp, #28]
		fac = sqrt(-2.0 * log(rsq) / rsq);
 804b24a:	ec49 8b10 	vmov	d0, r8, r9
 804b24e:	e9c3 6500 	strd	r6, r5, [r3]
 804b252:	e9c3 7402 	strd	r7, r4, [r3, #8]
 804b256:	461e      	mov	r6, r3
 804b258:	f001 fcda 	bl	804cc10 <log>
 804b25c:	2200      	movs	r2, #0
 804b25e:	ec51 0b10 	vmov	r0, r1, d0
 804b262:	f04f 4340 	mov.w	r3, #3221225472	@ 0xc0000000
 804b266:	f7f5 f9a3 	bl	80405b0 <__aeabi_dmul>
 804b26a:	4642      	mov	r2, r8
 804b26c:	464b      	mov	r3, r9
 804b26e:	f7f5 fac9 	bl	8040804 <__aeabi_ddiv>
 804b272:	ec41 0b10 	vmov	d0, r0, r1
 804b276:	f001 fd09 	bl	804cc8c <sqrt>
		r->n_gset = v1 * fac;
 804b27a:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
		fac = sqrt(-2.0 * log(rsq) / rsq);
 804b27e:	ec55 4b10 	vmov	r4, r5, d0
		r->n_gset = v1 * fac;
 804b282:	4622      	mov	r2, r4
 804b284:	462b      	mov	r3, r5
 804b286:	f7f5 f993 	bl	80405b0 <__aeabi_dmul>
		return v2 * fac;
 804b28a:	4622      	mov	r2, r4
		r->n_iset = 1;
 804b28c:	2401      	movs	r4, #1
		r->n_gset = v1 * fac;
 804b28e:	e9c6 0104 	strd	r0, r1, [r6, #16]
		return v2 * fac;
 804b292:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 804b296:	462b      	mov	r3, r5
		r->n_iset = 1;
 804b298:	61b4      	str	r4, [r6, #24]
		return v2 * fac;
 804b29a:	f7f5 f989 	bl	80405b0 <__aeabi_dmul>
 804b29e:	ec41 0b10 	vmov	d0, r0, r1
}
 804b2a2:	b009      	add	sp, #36	@ 0x24
 804b2a4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		r->n_iset = 0;
 804b2a8:	2300      	movs	r3, #0
		return r->n_gset;
 804b2aa:	ed92 0b04 	vldr	d0, [r2, #16]
		r->n_iset = 0;
 804b2ae:	6193      	str	r3, [r2, #24]
}
 804b2b0:	b009      	add	sp, #36	@ 0x24
 804b2b2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 804b2b6:	bf00      	nop
 804b2b8:	20018108 	.word	0x20018108
 804b2bc:	3ff00000 	.word	0x3ff00000

0804b2c0 <kad_op_sample_normal>:
{
 804b2c0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	kad_node_t *q = p->child[0];
 804b2c4:	6b83      	ldr	r3, [r0, #56]	@ 0x38
{
 804b2c6:	4604      	mov	r4, r0
	kad_node_t *q = p->child[0];
 804b2c8:	681d      	ldr	r5, [r3, #0]
 804b2ca:	782b      	ldrb	r3, [r5, #0]
 804b2cc:	b37b      	cbz	r3, 804b32e <kad_op_sample_normal+0x6e>
 804b2ce:	2b01      	cmp	r3, #1
 804b2d0:	692e      	ldr	r6, [r5, #16]
 804b2d2:	d00c      	beq.n	804b2ee <kad_op_sample_normal+0x2e>
 804b2d4:	696a      	ldr	r2, [r5, #20]
 804b2d6:	2b02      	cmp	r3, #2
 804b2d8:	fb02 f606 	mul.w	r6, r2, r6
 804b2dc:	d007      	beq.n	804b2ee <kad_op_sample_normal+0x2e>
 804b2de:	69aa      	ldr	r2, [r5, #24]
 804b2e0:	2b03      	cmp	r3, #3
 804b2e2:	fb02 f606 	mul.w	r6, r2, r6
 804b2e6:	d002      	beq.n	804b2ee <kad_op_sample_normal+0x2e>
 804b2e8:	69ea      	ldr	r2, [r5, #28]
 804b2ea:	fb02 f606 	mul.w	r6, r2, r6
	if (action == KAD_SYNC_DIM) {
 804b2ee:	2904      	cmp	r1, #4
 804b2f0:	d012      	beq.n	804b318 <kad_op_sample_normal+0x58>
	} else if (action == KAD_ALLOC) {
 804b2f2:	2901      	cmp	r1, #1
 804b2f4:	d007      	beq.n	804b306 <kad_op_sample_normal+0x46>
	} else if (action == KAD_FORWARD) {
 804b2f6:	2902      	cmp	r1, #2
 804b2f8:	d040      	beq.n	804b37c <kad_op_sample_normal+0xbc>
	} else if (action == KAD_BACKWARD && kad_is_back(p->child[0])) {
 804b2fa:	2903      	cmp	r1, #3
 804b2fc:	d025      	beq.n	804b34a <kad_op_sample_normal+0x8a>
}
 804b2fe:	2000      	movs	r0, #0
 804b300:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	int n = 1, i;
 804b304:	460e      	mov	r6, r1
		if (kad_is_back(p->child[0]))
 804b306:	786b      	ldrb	r3, [r5, #1]
 804b308:	07d9      	lsls	r1, r3, #31
 804b30a:	d5f8      	bpl.n	804b2fe <kad_op_sample_normal+0x3e>
			p->gtmp = realloc(p->gtmp, n * sizeof(float));
 804b30c:	6b60      	ldr	r0, [r4, #52]	@ 0x34
 804b30e:	00b1      	lsls	r1, r6, #2
 804b310:	f000 fb8e 	bl	804ba30 <realloc>
 804b314:	6360      	str	r0, [r4, #52]	@ 0x34
 804b316:	e7f2      	b.n	804b2fe <kad_op_sample_normal+0x3e>
	dst->n_d = src->n_d;
 804b318:	4620      	mov	r0, r4
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 804b31a:	009a      	lsls	r2, r3, #2
 804b31c:	f105 0110 	add.w	r1, r5, #16
	dst->n_d = src->n_d;
 804b320:	f800 3b10 	strb.w	r3, [r0], #16
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 804b324:	f000 fe83 	bl	804c02e <memcpy>
}
 804b328:	2000      	movs	r0, #0
 804b32a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	if (action == KAD_SYNC_DIM) {
 804b32e:	2904      	cmp	r1, #4
 804b330:	d022      	beq.n	804b378 <kad_op_sample_normal+0xb8>
	} else if (action == KAD_ALLOC) {
 804b332:	2901      	cmp	r1, #1
 804b334:	d0e6      	beq.n	804b304 <kad_op_sample_normal+0x44>
	} else if (action == KAD_FORWARD) {
 804b336:	2902      	cmp	r1, #2
 804b338:	d05d      	beq.n	804b3f6 <kad_op_sample_normal+0x136>
	} else if (action == KAD_BACKWARD && kad_is_back(p->child[0])) {
 804b33a:	2903      	cmp	r1, #3
 804b33c:	d1df      	bne.n	804b2fe <kad_op_sample_normal+0x3e>
 804b33e:	786b      	ldrb	r3, [r5, #1]
 804b340:	07da      	lsls	r2, r3, #31
 804b342:	d5dc      	bpl.n	804b2fe <kad_op_sample_normal+0x3e>
 804b344:	2601      	movs	r6, #1
		float *r = (float*)p->gtmp;
 804b346:	6b42      	ldr	r2, [r0, #52]	@ 0x34
		for (i = 0; i < n; ++i)
 804b348:	e005      	b.n	804b356 <kad_op_sample_normal+0x96>
	} else if (action == KAD_BACKWARD && kad_is_back(p->child[0])) {
 804b34a:	786b      	ldrb	r3, [r5, #1]
 804b34c:	07db      	lsls	r3, r3, #31
 804b34e:	d5d6      	bpl.n	804b2fe <kad_op_sample_normal+0x3e>
		for (i = 0; i < n; ++i)
 804b350:	2e00      	cmp	r6, #0
		float *r = (float*)p->gtmp;
 804b352:	6b62      	ldr	r2, [r4, #52]	@ 0x34
		for (i = 0; i < n; ++i)
 804b354:	ddd3      	ble.n	804b2fe <kad_op_sample_normal+0x3e>
 804b356:	6aeb      	ldr	r3, [r5, #44]	@ 0x2c
 804b358:	6ae1      	ldr	r1, [r4, #44]	@ 0x2c
 804b35a:	eb03 0686 	add.w	r6, r3, r6, lsl #2
			q->g[i] += p->g[i] * r[i];
 804b35e:	edd3 7a00 	vldr	s15, [r3]
 804b362:	ecf1 6a01 	vldmia	r1!, {s13}
 804b366:	ecb2 7a01 	vldmia	r2!, {s14}
 804b36a:	eee6 7a87 	vfma.f32	s15, s13, s14
 804b36e:	ece3 7a01 	vstmia	r3!, {s15}
		for (i = 0; i < n; ++i)
 804b372:	42b3      	cmp	r3, r6
 804b374:	d1f3      	bne.n	804b35e <kad_op_sample_normal+0x9e>
 804b376:	e7c2      	b.n	804b2fe <kad_op_sample_normal+0x3e>
	dst->n_d = src->n_d;
 804b378:	7003      	strb	r3, [r0, #0]
	if (src->n_d) memcpy(dst->d, src->d, src->n_d * sizeof(int));
 804b37a:	e7c0      	b.n	804b2fe <kad_op_sample_normal+0x3e>
		for (i = 0; i < n; ++i) {
 804b37c:	2e00      	cmp	r6, #0
		float *r = (float*)p->gtmp;
 804b37e:	6b63      	ldr	r3, [r4, #52]	@ 0x34
		for (i = 0; i < n; ++i) {
 804b380:	ddbd      	ble.n	804b2fe <kad_op_sample_normal+0x3e>
 804b382:	4698      	mov	r8, r3
			z = (float)kad_drand_normal(p->ptr);
 804b384:	f8d4 9030 	ldr.w	r9, [r4, #48]	@ 0x30
 804b388:	b1db      	cbz	r3, 804b3c2 <kad_op_sample_normal+0x102>
		for (i = 0; i < n; ++i) {
 804b38a:	2700      	movs	r7, #0
			z = (float)kad_drand_normal(p->ptr);
 804b38c:	4648      	mov	r0, r9
 804b38e:	f7ff feb5 	bl	804b0fc <kad_drand_normal>
 804b392:	ec51 0b10 	vmov	r0, r1, d0
 804b396:	f7f5 fbe3 	bl	8040b60 <__aeabi_d2f>
			p->x[i] = q->x[i] * z;
 804b39a:	6aab      	ldr	r3, [r5, #40]	@ 0x28
			z = (float)kad_drand_normal(p->ptr);
 804b39c:	ee07 0a90 	vmov	s15, r0
			p->x[i] = q->x[i] * z;
 804b3a0:	eb03 0387 	add.w	r3, r3, r7, lsl #2
 804b3a4:	ed93 7a00 	vldr	s14, [r3]
 804b3a8:	ee27 7a27 	vmul.f32	s14, s14, s15
 804b3ac:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
 804b3ae:	eb03 0387 	add.w	r3, r3, r7, lsl #2
		for (i = 0; i < n; ++i) {
 804b3b2:	3701      	adds	r7, #1
 804b3b4:	42b7      	cmp	r7, r6
			p->x[i] = q->x[i] * z;
 804b3b6:	ed83 7a00 	vstr	s14, [r3]
			if (r) r[i] = z;
 804b3ba:	f848 0b04 	str.w	r0, [r8], #4
		for (i = 0; i < n; ++i) {
 804b3be:	d1e5      	bne.n	804b38c <kad_op_sample_normal+0xcc>
 804b3c0:	e79d      	b.n	804b2fe <kad_op_sample_normal+0x3e>
			z = (float)kad_drand_normal(p->ptr);
 804b3c2:	4648      	mov	r0, r9
 804b3c4:	f7ff fe9a 	bl	804b0fc <kad_drand_normal>
			p->x[i] = q->x[i] * z;
 804b3c8:	6aab      	ldr	r3, [r5, #40]	@ 0x28
			z = (float)kad_drand_normal(p->ptr);
 804b3ca:	ec51 0b10 	vmov	r0, r1, d0
			p->x[i] = q->x[i] * z;
 804b3ce:	eb03 0a88 	add.w	sl, r3, r8, lsl #2
 804b3d2:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
 804b3d4:	eb03 0788 	add.w	r7, r3, r8, lsl #2
			z = (float)kad_drand_normal(p->ptr);
 804b3d8:	f7f5 fbc2 	bl	8040b60 <__aeabi_d2f>
			p->x[i] = q->x[i] * z;
 804b3dc:	edda 7a00 	vldr	s15, [sl]
			z = (float)kad_drand_normal(p->ptr);
 804b3e0:	ee07 0a10 	vmov	s14, r0
			p->x[i] = q->x[i] * z;
 804b3e4:	ee67 7a87 	vmul.f32	s15, s15, s14
		for (i = 0; i < n; ++i) {
 804b3e8:	f108 0801 	add.w	r8, r8, #1
 804b3ec:	45b0      	cmp	r8, r6
			p->x[i] = q->x[i] * z;
 804b3ee:	edc7 7a00 	vstr	s15, [r7]
		for (i = 0; i < n; ++i) {
 804b3f2:	d1e6      	bne.n	804b3c2 <kad_op_sample_normal+0x102>
 804b3f4:	e783      	b.n	804b2fe <kad_op_sample_normal+0x3e>
 804b3f6:	2601      	movs	r6, #1
		float *r = (float*)p->gtmp;
 804b3f8:	6b43      	ldr	r3, [r0, #52]	@ 0x34
		for (i = 0; i < n; ++i) {
 804b3fa:	e7c2      	b.n	804b382 <kad_op_sample_normal+0xc2>

0804b3fc <Reset_Handler>:

    .section	.text.Reset_Handler
	.weak	Reset_Handler
	.type	Reset_Handler, %function
Reset_Handler:
  ldr   sp, =_estack    /* set stack pointer */
 804b3fc:	f8df d034 	ldr.w	sp, [pc, #52]	@ 804b434 <LoopForever+0x2>

/* Call the clock system initialization function.*/
  bl  SystemInit
 804b400:	f7f5 ffb4 	bl	804136c <SystemInit>

/* Copy the data segment initializers from flash to SRAM */
  movs	r1, #0
 804b404:	2100      	movs	r1, #0
  b	LoopCopyDataInit
 804b406:	e003      	b.n	804b410 <LoopCopyDataInit>

0804b408 <CopyDataInit>:

CopyDataInit:
	ldr	r3, =_sidata
 804b408:	4b0b      	ldr	r3, [pc, #44]	@ (804b438 <LoopForever+0x6>)
	ldr	r3, [r3, r1]
 804b40a:	585b      	ldr	r3, [r3, r1]
	str	r3, [r0, r1]
 804b40c:	5043      	str	r3, [r0, r1]
	adds	r1, r1, #4
 804b40e:	3104      	adds	r1, #4

0804b410 <LoopCopyDataInit>:

LoopCopyDataInit:
	ldr	r0, =_sdata
 804b410:	480a      	ldr	r0, [pc, #40]	@ (804b43c <LoopForever+0xa>)
	ldr	r3, =_edata
 804b412:	4b0b      	ldr	r3, [pc, #44]	@ (804b440 <LoopForever+0xe>)
	adds	r2, r0, r1
 804b414:	1842      	adds	r2, r0, r1
	cmp	r2, r3
 804b416:	429a      	cmp	r2, r3
	bcc	CopyDataInit
 804b418:	d3f6      	bcc.n	804b408 <CopyDataInit>
	ldr	r2, =_sbss
 804b41a:	4a0a      	ldr	r2, [pc, #40]	@ (804b444 <LoopForever+0x12>)
	b	LoopFillZerobss
 804b41c:	e002      	b.n	804b424 <LoopFillZerobss>

0804b41e <FillZerobss>:
/* Zero fill the bss segment. */
FillZerobss:
	movs	r3, #0
 804b41e:	2300      	movs	r3, #0
	str	r3, [r2], #4
 804b420:	f842 3b04 	str.w	r3, [r2], #4

0804b424 <LoopFillZerobss>:

LoopFillZerobss:
	ldr	r3, = _ebss
 804b424:	4b08      	ldr	r3, [pc, #32]	@ (804b448 <LoopForever+0x16>)
	cmp	r2, r3
 804b426:	429a      	cmp	r2, r3
	bcc	FillZerobss
 804b428:	d3f9      	bcc.n	804b41e <FillZerobss>

/* Call static constructors */
  bl __libc_init_array
 804b42a:	f000 fdd9 	bl	804bfe0 <__libc_init_array>
/* Call the application's entry point.*/
	bl	main
 804b42e:	f7f5 ff01 	bl	8041234 <main>

0804b432 <LoopForever>:

LoopForever:
    b LoopForever
 804b432:	e7fe      	b.n	804b432 <LoopForever>
  ldr   sp, =_estack    /* set stack pointer */
 804b434:	20040000 	.word	0x20040000
	ldr	r3, =_sidata
 804b438:	0804eac8 	.word	0x0804eac8
	ldr	r0, =_sdata
 804b43c:	20018000 	.word	0x20018000
	ldr	r3, =_edata
 804b440:	200181a0 	.word	0x200181a0
	ldr	r2, =_sbss
 804b444:	200181a0 	.word	0x200181a0
	ldr	r3, = _ebss
 804b448:	20018c24 	.word	0x20018c24

0804b44c <ADC1_2_IRQHandler>:
 * @retval : None
*/
    .section	.text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
	b	Infinite_Loop
 804b44c:	e7fe      	b.n	804b44c <ADC1_2_IRQHandler>
	...

0804b450 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority  Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 804b450:	b538      	push	{r3, r4, r5, lr}
  HAL_StatusTypeDef  status = HAL_OK;

  /* Check uwTickFreq for MisraC 2012 (even if uwTickFreq is a enum type that doesn't take the value zero)*/
  if ((uint32_t)uwTickFreq != 0U)
 804b452:	4b0f      	ldr	r3, [pc, #60]	@ (804b490 <HAL_InitTick+0x40>)
 804b454:	781b      	ldrb	r3, [r3, #0]
 804b456:	b90b      	cbnz	r3, 804b45c <HAL_InitTick+0xc>
        status = HAL_ERROR;
      }
    }
    else
    {
      status = HAL_ERROR;
 804b458:	2001      	movs	r0, #1
    status = HAL_ERROR;
  }

  /* Return function status */
  return status;
}
 804b45a:	bd38      	pop	{r3, r4, r5, pc}
    if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / (uint32_t)uwTickFreq)) == 0U)
 804b45c:	f44f 727a 	mov.w	r2, #1000	@ 0x3e8
 804b460:	fbb2 f3f3 	udiv	r3, r2, r3
 804b464:	490b      	ldr	r1, [pc, #44]	@ (804b494 <HAL_InitTick+0x44>)
 804b466:	4605      	mov	r5, r0
 804b468:	6808      	ldr	r0, [r1, #0]
 804b46a:	fbb0 f0f3 	udiv	r0, r0, r3
 804b46e:	f000 f881 	bl	804b574 <HAL_SYSTICK_Config>
 804b472:	4604      	mov	r4, r0
 804b474:	2800      	cmp	r0, #0
 804b476:	d1ef      	bne.n	804b458 <HAL_InitTick+0x8>
      if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 804b478:	2d07      	cmp	r5, #7
 804b47a:	d8ed      	bhi.n	804b458 <HAL_InitTick+0x8>
        HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 804b47c:	4602      	mov	r2, r0
 804b47e:	4629      	mov	r1, r5
 804b480:	f04f 30ff 	mov.w	r0, #4294967295
 804b484:	f000 f83a 	bl	804b4fc <HAL_NVIC_SetPriority>
        uwTickPrio = TickPriority;
 804b488:	4b03      	ldr	r3, [pc, #12]	@ (804b498 <HAL_InitTick+0x48>)
 804b48a:	4620      	mov	r0, r4
 804b48c:	601d      	str	r5, [r3, #0]
}
 804b48e:	bd38      	pop	{r3, r4, r5, pc}
 804b490:	20018128 	.word	0x20018128
 804b494:	20018000 	.word	0x20018000
 804b498:	2001812c 	.word	0x2001812c

0804b49c <HAL_Init>:
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_3);
 804b49c:	2004      	movs	r0, #4
{
 804b49e:	b510      	push	{r4, lr}
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_3);
 804b4a0:	f000 f81a 	bl	804b4d8 <HAL_NVIC_SetPriorityGrouping>
  SystemCoreClockUpdate();
 804b4a4:	f7f5 ff64 	bl	8041370 <SystemCoreClockUpdate>
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
 804b4a8:	2007      	movs	r0, #7
 804b4aa:	f7ff ffd1 	bl	804b450 <HAL_InitTick>
 804b4ae:	b110      	cbz	r0, 804b4b6 <HAL_Init+0x1a>
    status = HAL_ERROR;
 804b4b0:	2401      	movs	r4, #1
}
 804b4b2:	4620      	mov	r0, r4
 804b4b4:	bd10      	pop	{r4, pc}
 804b4b6:	4604      	mov	r4, r0
    HAL_MspInit();
 804b4b8:	f7f5 fed6 	bl	8041268 <HAL_MspInit>
}
 804b4bc:	4620      	mov	r0, r4
 804b4be:	bd10      	pop	{r4, pc}

0804b4c0 <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick += (uint32_t)uwTickFreq;
 804b4c0:	4a03      	ldr	r2, [pc, #12]	@ (804b4d0 <HAL_IncTick+0x10>)
 804b4c2:	4b04      	ldr	r3, [pc, #16]	@ (804b4d4 <HAL_IncTick+0x14>)
 804b4c4:	6811      	ldr	r1, [r2, #0]
 804b4c6:	781b      	ldrb	r3, [r3, #0]
 804b4c8:	440b      	add	r3, r1
 804b4ca:	6013      	str	r3, [r2, #0]
}
 804b4cc:	4770      	bx	lr
 804b4ce:	bf00      	nop
 804b4d0:	20018ad4 	.word	0x20018ad4
 804b4d4:	20018128 	.word	0x20018128

0804b4d8 <HAL_NVIC_SetPriorityGrouping>:
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 804b4d8:	f64f 0cff 	movw	ip, #63743	@ 0xf8ff
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 804b4dc:	4906      	ldr	r1, [pc, #24]	@ (804b4f8 <HAL_NVIC_SetPriorityGrouping+0x20>)
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 804b4de:	0203      	lsls	r3, r0, #8
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 804b4e0:	68ca      	ldr	r2, [r1, #12]
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 804b4e2:	f403 63e0 	and.w	r3, r3, #1792	@ 0x700
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 804b4e6:	ea02 020c 	and.w	r2, r2, ip
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 804b4ea:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
 804b4ec:	f043 63bf 	orr.w	r3, r3, #100139008	@ 0x5f80000
 804b4f0:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
  SCB->AIRCR =  reg_value;
 804b4f4:	60cb      	str	r3, [r1, #12]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
}
 804b4f6:	4770      	bx	lr
 804b4f8:	e000ed00 	.word	0xe000ed00

0804b4fc <HAL_NVIC_SetPriority>:
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 804b4fc:	4b1b      	ldr	r3, [pc, #108]	@ (804b56c <HAL_NVIC_SetPriority+0x70>)
  *         This parameter can be a value between 0 and 7
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
 804b4fe:	b500      	push	{lr}
 804b500:	68db      	ldr	r3, [r3, #12]
 804b502:	f3c3 2302 	ubfx	r3, r3, #8, #3
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 804b506:	f1c3 0e07 	rsb	lr, r3, #7
 804b50a:	f1be 0f03 	cmp.w	lr, #3
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 804b50e:	f103 0c03 	add.w	ip, r3, #3
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 804b512:	bf28      	it	cs
 804b514:	f04f 0e03 	movcs.w	lr, #3
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 804b518:	f1bc 0f06 	cmp.w	ip, #6
 804b51c:	d91c      	bls.n	804b558 <HAL_NVIC_SetPriority+0x5c>
 804b51e:	f1a3 0c04 	sub.w	ip, r3, #4

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 804b522:	f04f 33ff 	mov.w	r3, #4294967295
 804b526:	fa03 f30c 	lsl.w	r3, r3, ip
 804b52a:	ea22 0203 	bic.w	r2, r2, r3
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 804b52e:	f04f 33ff 	mov.w	r3, #4294967295
 804b532:	fa03 f30e 	lsl.w	r3, r3, lr
 804b536:	ea21 0303 	bic.w	r3, r1, r3
 804b53a:	fa03 f30c 	lsl.w	r3, r3, ip
 804b53e:	4313      	orrs	r3, r2
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 804b540:	015b      	lsls	r3, r3, #5
  if ((int32_t)(IRQn) >= 0)
 804b542:	2800      	cmp	r0, #0
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 804b544:	b2db      	uxtb	r3, r3
  if ((int32_t)(IRQn) >= 0)
 804b546:	db0a      	blt.n	804b55e <HAL_NVIC_SetPriority+0x62>
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 804b548:	f100 4060 	add.w	r0, r0, #3758096384	@ 0xe0000000
 804b54c:	f500 4061 	add.w	r0, r0, #57600	@ 0xe100
 804b550:	f880 3300 	strb.w	r3, [r0, #768]	@ 0x300
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));

  prioritygroup = NVIC_GetPriorityGrouping();

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
}
 804b554:	f85d fb04 	ldr.w	pc, [sp], #4
 804b558:	2200      	movs	r2, #0
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 804b55a:	4694      	mov	ip, r2
 804b55c:	e7e7      	b.n	804b52e <HAL_NVIC_SetPriority+0x32>
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 804b55e:	4a04      	ldr	r2, [pc, #16]	@ (804b570 <HAL_NVIC_SetPriority+0x74>)
 804b560:	f000 000f 	and.w	r0, r0, #15
 804b564:	4402      	add	r2, r0
 804b566:	7613      	strb	r3, [r2, #24]
 804b568:	f85d fb04 	ldr.w	pc, [sp], #4
 804b56c:	e000ed00 	.word	0xe000ed00
 804b570:	e000ecfc 	.word	0xe000ecfc

0804b574 <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 804b574:	3801      	subs	r0, #1
 804b576:	f1b0 7f80 	cmp.w	r0, #16777216	@ 0x1000000
 804b57a:	d301      	bcc.n	804b580 <HAL_SYSTICK_Config+0xc>
  {
    return (1UL);                                                   /* Reload value impossible */
 804b57c:	2001      	movs	r0, #1
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
  return SysTick_Config(TicksNumb);
}
 804b57e:	4770      	bx	lr
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 804b580:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 804b584:	f04f 0ce0 	mov.w	ip, #224	@ 0xe0
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 804b588:	2200      	movs	r2, #0
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 804b58a:	2107      	movs	r1, #7
{
 804b58c:	b410      	push	{r4}
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 804b58e:	4c05      	ldr	r4, [pc, #20]	@ (804b5a4 <HAL_SYSTICK_Config+0x30>)
  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 804b590:	6158      	str	r0, [r3, #20]
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 804b592:	f884 c023 	strb.w	ip, [r4, #35]	@ 0x23
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 804b596:	4610      	mov	r0, r2
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 804b598:	619a      	str	r2, [r3, #24]
}
 804b59a:	f85d 4b04 	ldr.w	r4, [sp], #4
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 804b59e:	6119      	str	r1, [r3, #16]
 804b5a0:	4770      	bx	lr
 804b5a2:	bf00      	nop
 804b5a4:	e000ed00 	.word	0xe000ed00

0804b5a8 <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 804b5a8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0U)
 804b5ac:	680c      	ldr	r4, [r1, #0]
 804b5ae:	2c00      	cmp	r4, #0
 804b5b0:	f000 808d 	beq.w	804b6ce <HAL_GPIO_Init+0x126>
  uint32_t position = 0U;
 804b5b4:	2200      	movs	r2, #0
  {
    /* Get current io position */
    iocurrent = (GPIO_Init->Pin) & (1UL << position);
 804b5b6:	f04f 0901 	mov.w	r9, #1
 804b5ba:	fa09 f502 	lsl.w	r5, r9, r2

    if(iocurrent != 0U)
 804b5be:	ea15 0a04 	ands.w	sl, r5, r4
 804b5c2:	d07f      	beq.n	804b6c4 <HAL_GPIO_Init+0x11c>
        GPIOx->OTYPER = temp;
      }

      /* Activate the Pull-up or Pull down resistor for the current IO */
      temp = GPIOx->PUPDR;
      temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 804b5c4:	2603      	movs	r6, #3
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 804b5c6:	684b      	ldr	r3, [r1, #4]
      temp |= ((GPIO_Init->Pull) << (position * 2U));
 804b5c8:	688f      	ldr	r7, [r1, #8]
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 804b5ca:	f023 0e10 	bic.w	lr, r3, #16
 804b5ce:	ea4f 0c42 	mov.w	ip, r2, lsl #1
 804b5d2:	f10e 3bff 	add.w	fp, lr, #4294967295
      temp |= ((GPIO_Init->Pull) << (position * 2U));
 804b5d6:	fa07 f80c 	lsl.w	r8, r7, ip
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 804b5da:	f1bb 0f01 	cmp.w	fp, #1
      temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 804b5de:	fa06 f70c 	lsl.w	r7, r6, ip
 804b5e2:	ea6f 0707 	mvn.w	r7, r7
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 804b5e6:	d974      	bls.n	804b6d2 <HAL_GPIO_Init+0x12a>
      temp = GPIOx->PUPDR;
 804b5e8:	68c5      	ldr	r5, [r0, #12]
      temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 804b5ea:	403d      	ands	r5, r7
      temp |= ((GPIO_Init->Pull) << (position * 2U));
 804b5ec:	ea45 0508 	orr.w	r5, r5, r8
      GPIOx->PUPDR = temp;
 804b5f0:	60c5      	str	r5, [r0, #12]
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
        GPIOx->AFR[position >> 3U] = temp;
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
 804b5f2:	6805      	ldr	r5, [r0, #0]
      temp &= ~(GPIO_MODER_MODE0 << (position * 2U));
 804b5f4:	402f      	ands	r7, r5
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 804b5f6:	ea03 0506 	and.w	r5, r3, r6
 804b5fa:	fa05 f50c 	lsl.w	r5, r5, ip
 804b5fe:	433d      	orrs	r5, r7
      GPIOx->MODER = temp;

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 804b600:	00df      	lsls	r7, r3, #3
      GPIOx->MODER = temp;
 804b602:	6005      	str	r5, [r0, #0]
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 804b604:	d55e      	bpl.n	804b6c4 <HAL_GPIO_Init+0x11c>
      {
        temp = EXTI->EXTICR[position >> 2U];
        temp &= ~((0x0FU) << (8U * (position & 0x03U)));
 804b606:	260f      	movs	r6, #15
 804b608:	f022 0503 	bic.w	r5, r2, #3
 804b60c:	f002 0c03 	and.w	ip, r2, #3
 804b610:	f105 4580 	add.w	r5, r5, #1073741824	@ 0x40000000
 804b614:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
 804b618:	fa06 fe0c 	lsl.w	lr, r6, ip
 804b61c:	f505 353d 	add.w	r5, r5, #193536	@ 0x2f400
        temp |= (GPIO_GET_INDEX(GPIOx) << (8U * (position & 0x03U)));
 804b620:	4e62      	ldr	r6, [pc, #392]	@ (804b7ac <HAL_GPIO_Init+0x204>)
        temp = EXTI->EXTICR[position >> 2U];
 804b622:	6e2f      	ldr	r7, [r5, #96]	@ 0x60
        temp |= (GPIO_GET_INDEX(GPIOx) << (8U * (position & 0x03U)));
 804b624:	42b0      	cmp	r0, r6
        temp &= ~((0x0FU) << (8U * (position & 0x03U)));
 804b626:	ea27 070e 	bic.w	r7, r7, lr
        temp |= (GPIO_GET_INDEX(GPIOx) << (8U * (position & 0x03U)));
 804b62a:	d023      	beq.n	804b674 <HAL_GPIO_Init+0xcc>
 804b62c:	f506 6680 	add.w	r6, r6, #1024	@ 0x400
 804b630:	42b0      	cmp	r0, r6
 804b632:	f000 80a0 	beq.w	804b776 <HAL_GPIO_Init+0x1ce>
 804b636:	4e5e      	ldr	r6, [pc, #376]	@ (804b7b0 <HAL_GPIO_Init+0x208>)
 804b638:	42b0      	cmp	r0, r6
 804b63a:	f000 80a1 	beq.w	804b780 <HAL_GPIO_Init+0x1d8>
 804b63e:	f8df e178 	ldr.w	lr, [pc, #376]	@ 804b7b8 <HAL_GPIO_Init+0x210>
 804b642:	4570      	cmp	r0, lr
 804b644:	f000 8091 	beq.w	804b76a <HAL_GPIO_Init+0x1c2>
 804b648:	f8df e170 	ldr.w	lr, [pc, #368]	@ 804b7bc <HAL_GPIO_Init+0x214>
 804b64c:	4570      	cmp	r0, lr
 804b64e:	f000 809e 	beq.w	804b78e <HAL_GPIO_Init+0x1e6>
 804b652:	f8df e16c 	ldr.w	lr, [pc, #364]	@ 804b7c0 <HAL_GPIO_Init+0x218>
 804b656:	4570      	cmp	r0, lr
 804b658:	f000 80a0 	beq.w	804b79c <HAL_GPIO_Init+0x1f4>
 804b65c:	f8df e164 	ldr.w	lr, [pc, #356]	@ 804b7c4 <HAL_GPIO_Init+0x21c>
 804b660:	4570      	cmp	r0, lr
 804b662:	bf0c      	ite	eq
 804b664:	f04f 0e06 	moveq.w	lr, #6
 804b668:	f04f 0e07 	movne.w	lr, #7
 804b66c:	fa0e fc0c 	lsl.w	ip, lr, ip
 804b670:	ea47 070c 	orr.w	r7, r7, ip
        EXTI->EXTICR[position >> 2U] = temp;
 804b674:	662f      	str	r7, [r5, #96]	@ 0x60

        /* Clear EXTI line configuration */
        temp = EXTI->IMR1;
        temp &= ~(iocurrent);
 804b676:	ea6f 070a 	mvn.w	r7, sl
        temp = EXTI->IMR1;
 804b67a:	4d4e      	ldr	r5, [pc, #312]	@ (804b7b4 <HAL_GPIO_Init+0x20c>)
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 804b67c:	03de      	lsls	r6, r3, #15
        temp = EXTI->IMR1;
 804b67e:	f8d5 5080 	ldr.w	r5, [r5, #128]	@ 0x80
        {
          temp |= iocurrent;
        }
        EXTI->IMR1 = temp;
 804b682:	4e4c      	ldr	r6, [pc, #304]	@ (804b7b4 <HAL_GPIO_Init+0x20c>)
        temp &= ~(iocurrent);
 804b684:	bf54      	ite	pl
 804b686:	403d      	andpl	r5, r7
          temp |= iocurrent;
 804b688:	ea4a 0505 	orrmi.w	r5, sl, r5
        EXTI->IMR1 = temp;
 804b68c:	f8c6 5080 	str.w	r5, [r6, #128]	@ 0x80

        temp = EXTI->EMR1;
 804b690:	f8d6 5084 	ldr.w	r5, [r6, #132]	@ 0x84
        temp &= ~(iocurrent);
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 804b694:	039e      	lsls	r6, r3, #14
        {
          temp |= iocurrent;
        }
        EXTI->EMR1 = temp;
 804b696:	4e47      	ldr	r6, [pc, #284]	@ (804b7b4 <HAL_GPIO_Init+0x20c>)
        temp &= ~(iocurrent);
 804b698:	bf54      	ite	pl
 804b69a:	403d      	andpl	r5, r7
          temp |= iocurrent;
 804b69c:	ea4a 0505 	orrmi.w	r5, sl, r5
        EXTI->EMR1 = temp;
 804b6a0:	f8c6 5084 	str.w	r5, [r6, #132]	@ 0x84

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
 804b6a4:	6835      	ldr	r5, [r6, #0]
        temp &= ~(iocurrent);
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 804b6a6:	02de      	lsls	r6, r3, #11
        {
          temp |= iocurrent;
        }
        EXTI->RTSR1 = temp;
 804b6a8:	4e42      	ldr	r6, [pc, #264]	@ (804b7b4 <HAL_GPIO_Init+0x20c>)
        temp &= ~(iocurrent);
 804b6aa:	bf54      	ite	pl
 804b6ac:	403d      	andpl	r5, r7
          temp |= iocurrent;
 804b6ae:	ea4a 0505 	orrmi.w	r5, sl, r5
        EXTI->RTSR1 = temp;
 804b6b2:	6035      	str	r5, [r6, #0]

        temp = EXTI->FTSR1;
 804b6b4:	6875      	ldr	r5, [r6, #4]
        temp &= ~(iocurrent);
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 804b6b6:	029b      	lsls	r3, r3, #10
        {
          temp |= iocurrent;
        }
        EXTI->FTSR1 = temp;
 804b6b8:	4b3e      	ldr	r3, [pc, #248]	@ (804b7b4 <HAL_GPIO_Init+0x20c>)
        temp &= ~(iocurrent);
 804b6ba:	bf54      	ite	pl
 804b6bc:	403d      	andpl	r5, r7
          temp |= iocurrent;
 804b6be:	ea4a 0505 	orrmi.w	r5, sl, r5
        EXTI->FTSR1 = temp;
 804b6c2:	605d      	str	r5, [r3, #4]
      }
    }

    position++;
 804b6c4:	3201      	adds	r2, #1
  while (((GPIO_Init->Pin) >> position) != 0U)
 804b6c6:	fa34 f302 	lsrs.w	r3, r4, r2
 804b6ca:	f47f af76 	bne.w	804b5ba <HAL_GPIO_Init+0x12>
  }
}
 804b6ce:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        temp = GPIOx->OSPEEDR;
 804b6d2:	f8d0 b008 	ldr.w	fp, [r0, #8]
        temp |= (GPIO_Init->Speed << (position * 2U));
 804b6d6:	68ce      	ldr	r6, [r1, #12]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 804b6d8:	ea0b 0b07 	and.w	fp, fp, r7
        temp |= (GPIO_Init->Speed << (position * 2U));
 804b6dc:	fa06 fa0c 	lsl.w	sl, r6, ip
 804b6e0:	ea4a 0a0b 	orr.w	sl, sl, fp
        GPIOx->OSPEEDR = temp;
 804b6e4:	f8c0 a008 	str.w	sl, [r0, #8]
        temp = GPIOx->OTYPER;
 804b6e8:	f8d0 a004 	ldr.w	sl, [r0, #4]
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 804b6ec:	f1be 0f02 	cmp.w	lr, #2
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
 804b6f0:	ea2a 0a05 	bic.w	sl, sl, r5
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4) << position);
 804b6f4:	ea4f 1513 	mov.w	r5, r3, lsr #4
 804b6f8:	fa05 f502 	lsl.w	r5, r5, r2
 804b6fc:	ea45 050a 	orr.w	r5, r5, sl
        GPIOx->OTYPER = temp;
 804b700:	6045      	str	r5, [r0, #4]
      temp = GPIOx->PUPDR;
 804b702:	68c5      	ldr	r5, [r0, #12]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 804b704:	f003 0303 	and.w	r3, r3, #3
      temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 804b708:	ea05 0507 	and.w	r5, r5, r7
      temp |= ((GPIO_Init->Pull) << (position * 2U));
 804b70c:	ea45 0508 	orr.w	r5, r5, r8
      GPIOx->PUPDR = temp;
 804b710:	60c5      	str	r5, [r0, #12]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 804b712:	fa03 f30c 	lsl.w	r3, r3, ip
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 804b716:	d009      	beq.n	804b72c <HAL_GPIO_Init+0x184>
      temp = GPIOx->MODER;
 804b718:	6805      	ldr	r5, [r0, #0]
    position++;
 804b71a:	3201      	adds	r2, #1
      temp &= ~(GPIO_MODER_MODE0 << (position * 2U));
 804b71c:	403d      	ands	r5, r7
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 804b71e:	432b      	orrs	r3, r5
      GPIOx->MODER = temp;
 804b720:	6003      	str	r3, [r0, #0]
  while (((GPIO_Init->Pin) >> position) != 0U)
 804b722:	fa34 f302 	lsrs.w	r3, r4, r2
 804b726:	f47f af48 	bne.w	804b5ba <HAL_GPIO_Init+0x12>
 804b72a:	e7d0      	b.n	804b6ce <HAL_GPIO_Init+0x126>
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
 804b72c:	690e      	ldr	r6, [r1, #16]
        temp &= ~(0x0FUL << ((position & 0x07U) * 4U)) ;
 804b72e:	f002 0507 	and.w	r5, r2, #7
 804b732:	00ad      	lsls	r5, r5, #2
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
 804b734:	fa06 fe05 	lsl.w	lr, r6, r5
        temp &= ~(0x0FUL << ((position & 0x07U) * 4U)) ;
 804b738:	260f      	movs	r6, #15
        temp = GPIOx->AFR[position >> 3U];
 804b73a:	ea4f 0cd2 	mov.w	ip, r2, lsr #3
 804b73e:	eb00 0c8c 	add.w	ip, r0, ip, lsl #2
 804b742:	f8dc 8020 	ldr.w	r8, [ip, #32]
        temp &= ~(0x0FUL << ((position & 0x07U) * 4U)) ;
 804b746:	fa06 f505 	lsl.w	r5, r6, r5
 804b74a:	ea28 0505 	bic.w	r5, r8, r5
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
 804b74e:	ea4e 0505 	orr.w	r5, lr, r5
        GPIOx->AFR[position >> 3U] = temp;
 804b752:	f8cc 5020 	str.w	r5, [ip, #32]
      temp = GPIOx->MODER;
 804b756:	6805      	ldr	r5, [r0, #0]
    position++;
 804b758:	3201      	adds	r2, #1
      temp &= ~(GPIO_MODER_MODE0 << (position * 2U));
 804b75a:	403d      	ands	r5, r7
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 804b75c:	432b      	orrs	r3, r5
      GPIOx->MODER = temp;
 804b75e:	6003      	str	r3, [r0, #0]
  while (((GPIO_Init->Pin) >> position) != 0U)
 804b760:	fa34 f302 	lsrs.w	r3, r4, r2
 804b764:	f47f af29 	bne.w	804b5ba <HAL_GPIO_Init+0x12>
 804b768:	e7b1      	b.n	804b6ce <HAL_GPIO_Init+0x126>
        temp |= (GPIO_GET_INDEX(GPIOx) << (8U * (position & 0x03U)));
 804b76a:	2603      	movs	r6, #3
 804b76c:	fa06 fc0c 	lsl.w	ip, r6, ip
 804b770:	ea47 070c 	orr.w	r7, r7, ip
 804b774:	e77e      	b.n	804b674 <HAL_GPIO_Init+0xcc>
 804b776:	fa09 fc0c 	lsl.w	ip, r9, ip
 804b77a:	ea47 070c 	orr.w	r7, r7, ip
 804b77e:	e779      	b.n	804b674 <HAL_GPIO_Init+0xcc>
 804b780:	f04f 0e02 	mov.w	lr, #2
 804b784:	fa0e fc0c 	lsl.w	ip, lr, ip
 804b788:	ea47 070c 	orr.w	r7, r7, ip
 804b78c:	e772      	b.n	804b674 <HAL_GPIO_Init+0xcc>
 804b78e:	f04f 0e04 	mov.w	lr, #4
 804b792:	fa0e fc0c 	lsl.w	ip, lr, ip
 804b796:	ea47 070c 	orr.w	r7, r7, ip
 804b79a:	e76b      	b.n	804b674 <HAL_GPIO_Init+0xcc>
 804b79c:	f04f 0e05 	mov.w	lr, #5
 804b7a0:	fa0e fc0c 	lsl.w	ip, lr, ip
 804b7a4:	ea47 070c 	orr.w	r7, r7, ip
 804b7a8:	e764      	b.n	804b674 <HAL_GPIO_Init+0xcc>
 804b7aa:	bf00      	nop
 804b7ac:	42020000 	.word	0x42020000
 804b7b0:	42020800 	.word	0x42020800
 804b7b4:	4002f400 	.word	0x4002f400
 804b7b8:	42020c00 	.word	0x42020c00
 804b7bc:	42021000 	.word	0x42021000
 804b7c0:	42021400 	.word	0x42021400
 804b7c4:	42021800 	.word	0x42021800

0804b7c8 <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if (PinState != GPIO_PIN_RESET)
 804b7c8:	b10a      	cbz	r2, 804b7ce <HAL_GPIO_WritePin+0x6>
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
 804b7ca:	6181      	str	r1, [r0, #24]
 804b7cc:	4770      	bx	lr
  }
  else
  {
    GPIOx->BRR = (uint32_t)GPIO_Pin;
 804b7ce:	6281      	str	r1, [r0, #40]	@ 0x28
  }
}
 804b7d0:	4770      	bx	lr
 804b7d2:	bf00      	nop

0804b7d4 <abort>:
 804b7d4:	2006      	movs	r0, #6
 804b7d6:	b508      	push	{r3, lr}
 804b7d8:	f000 fb5c 	bl	804be94 <raise>
 804b7dc:	2001      	movs	r0, #1
 804b7de:	f7f5 fd71 	bl	80412c4 <_exit>
	...

0804b7e4 <__assert_func>:
 804b7e4:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 804b7e6:	4614      	mov	r4, r2
 804b7e8:	461a      	mov	r2, r3
 804b7ea:	4b09      	ldr	r3, [pc, #36]	@ (804b810 <__assert_func+0x2c>)
 804b7ec:	4605      	mov	r5, r0
 804b7ee:	681b      	ldr	r3, [r3, #0]
 804b7f0:	68d8      	ldr	r0, [r3, #12]
 804b7f2:	b954      	cbnz	r4, 804b80a <__assert_func+0x26>
 804b7f4:	4b07      	ldr	r3, [pc, #28]	@ (804b814 <__assert_func+0x30>)
 804b7f6:	461c      	mov	r4, r3
 804b7f8:	9100      	str	r1, [sp, #0]
 804b7fa:	4907      	ldr	r1, [pc, #28]	@ (804b818 <__assert_func+0x34>)
 804b7fc:	e9cd 3401 	strd	r3, r4, [sp, #4]
 804b800:	462b      	mov	r3, r5
 804b802:	f000 f9ef 	bl	804bbe4 <fiprintf>
 804b806:	f7ff ffe5 	bl	804b7d4 <abort>
 804b80a:	4b04      	ldr	r3, [pc, #16]	@ (804b81c <__assert_func+0x38>)
 804b80c:	e7f4      	b.n	804b7f8 <__assert_func+0x14>
 804b80e:	bf00      	nop
 804b810:	2001813c 	.word	0x2001813c
 804b814:	0804e635 	.word	0x0804e635
 804b818:	0804e607 	.word	0x0804e607
 804b81c:	0804e5fa 	.word	0x0804e5fa

0804b820 <calloc>:
 804b820:	4b02      	ldr	r3, [pc, #8]	@ (804b82c <calloc+0xc>)
 804b822:	460a      	mov	r2, r1
 804b824:	4601      	mov	r1, r0
 804b826:	6818      	ldr	r0, [r3, #0]
 804b828:	f000 b802 	b.w	804b830 <_calloc_r>
 804b82c:	2001813c 	.word	0x2001813c

0804b830 <_calloc_r>:
 804b830:	b570      	push	{r4, r5, r6, lr}
 804b832:	fba1 5402 	umull	r5, r4, r1, r2
 804b836:	b93c      	cbnz	r4, 804b848 <_calloc_r+0x18>
 804b838:	4629      	mov	r1, r5
 804b83a:	f000 f83f 	bl	804b8bc <_malloc_r>
 804b83e:	4606      	mov	r6, r0
 804b840:	b928      	cbnz	r0, 804b84e <_calloc_r+0x1e>
 804b842:	2600      	movs	r6, #0
 804b844:	4630      	mov	r0, r6
 804b846:	bd70      	pop	{r4, r5, r6, pc}
 804b848:	220c      	movs	r2, #12
 804b84a:	6002      	str	r2, [r0, #0]
 804b84c:	e7f9      	b.n	804b842 <_calloc_r+0x12>
 804b84e:	462a      	mov	r2, r5
 804b850:	4621      	mov	r1, r4
 804b852:	f000 faef 	bl	804be34 <memset>
 804b856:	e7f5      	b.n	804b844 <_calloc_r+0x14>

0804b858 <malloc>:
 804b858:	4b02      	ldr	r3, [pc, #8]	@ (804b864 <malloc+0xc>)
 804b85a:	4601      	mov	r1, r0
 804b85c:	6818      	ldr	r0, [r3, #0]
 804b85e:	f000 b82d 	b.w	804b8bc <_malloc_r>
 804b862:	bf00      	nop
 804b864:	2001813c 	.word	0x2001813c

0804b868 <free>:
 804b868:	4b02      	ldr	r3, [pc, #8]	@ (804b874 <free+0xc>)
 804b86a:	4601      	mov	r1, r0
 804b86c:	6818      	ldr	r0, [r3, #0]
 804b86e:	f000 bbf9 	b.w	804c064 <_free_r>
 804b872:	bf00      	nop
 804b874:	2001813c 	.word	0x2001813c

0804b878 <sbrk_aligned>:
 804b878:	b570      	push	{r4, r5, r6, lr}
 804b87a:	4e0f      	ldr	r6, [pc, #60]	@ (804b8b8 <sbrk_aligned+0x40>)
 804b87c:	460c      	mov	r4, r1
 804b87e:	4605      	mov	r5, r0
 804b880:	6831      	ldr	r1, [r6, #0]
 804b882:	b911      	cbnz	r1, 804b88a <sbrk_aligned+0x12>
 804b884:	f000 fb84 	bl	804bf90 <_sbrk_r>
 804b888:	6030      	str	r0, [r6, #0]
 804b88a:	4621      	mov	r1, r4
 804b88c:	4628      	mov	r0, r5
 804b88e:	f000 fb7f 	bl	804bf90 <_sbrk_r>
 804b892:	1c43      	adds	r3, r0, #1
 804b894:	d103      	bne.n	804b89e <sbrk_aligned+0x26>
 804b896:	f04f 34ff 	mov.w	r4, #4294967295
 804b89a:	4620      	mov	r0, r4
 804b89c:	bd70      	pop	{r4, r5, r6, pc}
 804b89e:	1cc4      	adds	r4, r0, #3
 804b8a0:	f024 0403 	bic.w	r4, r4, #3
 804b8a4:	42a0      	cmp	r0, r4
 804b8a6:	d0f8      	beq.n	804b89a <sbrk_aligned+0x22>
 804b8a8:	1a21      	subs	r1, r4, r0
 804b8aa:	4628      	mov	r0, r5
 804b8ac:	f000 fb70 	bl	804bf90 <_sbrk_r>
 804b8b0:	3001      	adds	r0, #1
 804b8b2:	d1f2      	bne.n	804b89a <sbrk_aligned+0x22>
 804b8b4:	e7ef      	b.n	804b896 <sbrk_aligned+0x1e>
 804b8b6:	bf00      	nop
 804b8b8:	20018ad8 	.word	0x20018ad8

0804b8bc <_malloc_r>:
 804b8bc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 804b8c0:	1ccd      	adds	r5, r1, #3
 804b8c2:	4606      	mov	r6, r0
 804b8c4:	f025 0503 	bic.w	r5, r5, #3
 804b8c8:	3508      	adds	r5, #8
 804b8ca:	2d0c      	cmp	r5, #12
 804b8cc:	bf38      	it	cc
 804b8ce:	250c      	movcc	r5, #12
 804b8d0:	2d00      	cmp	r5, #0
 804b8d2:	db01      	blt.n	804b8d8 <_malloc_r+0x1c>
 804b8d4:	42a9      	cmp	r1, r5
 804b8d6:	d904      	bls.n	804b8e2 <_malloc_r+0x26>
 804b8d8:	230c      	movs	r3, #12
 804b8da:	6033      	str	r3, [r6, #0]
 804b8dc:	2000      	movs	r0, #0
 804b8de:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 804b8e2:	f8df 80d4 	ldr.w	r8, [pc, #212]	@ 804b9b8 <_malloc_r+0xfc>
 804b8e6:	f000 f869 	bl	804b9bc <__malloc_lock>
 804b8ea:	f8d8 3000 	ldr.w	r3, [r8]
 804b8ee:	461c      	mov	r4, r3
 804b8f0:	bb44      	cbnz	r4, 804b944 <_malloc_r+0x88>
 804b8f2:	4629      	mov	r1, r5
 804b8f4:	4630      	mov	r0, r6
 804b8f6:	f7ff ffbf 	bl	804b878 <sbrk_aligned>
 804b8fa:	1c43      	adds	r3, r0, #1
 804b8fc:	4604      	mov	r4, r0
 804b8fe:	d158      	bne.n	804b9b2 <_malloc_r+0xf6>
 804b900:	f8d8 4000 	ldr.w	r4, [r8]
 804b904:	4627      	mov	r7, r4
 804b906:	2f00      	cmp	r7, #0
 804b908:	d143      	bne.n	804b992 <_malloc_r+0xd6>
 804b90a:	2c00      	cmp	r4, #0
 804b90c:	d04b      	beq.n	804b9a6 <_malloc_r+0xea>
 804b90e:	6823      	ldr	r3, [r4, #0]
 804b910:	4639      	mov	r1, r7
 804b912:	4630      	mov	r0, r6
 804b914:	eb04 0903 	add.w	r9, r4, r3
 804b918:	f000 fb3a 	bl	804bf90 <_sbrk_r>
 804b91c:	4581      	cmp	r9, r0
 804b91e:	d142      	bne.n	804b9a6 <_malloc_r+0xea>
 804b920:	6821      	ldr	r1, [r4, #0]
 804b922:	4630      	mov	r0, r6
 804b924:	1a6d      	subs	r5, r5, r1
 804b926:	4629      	mov	r1, r5
 804b928:	f7ff ffa6 	bl	804b878 <sbrk_aligned>
 804b92c:	3001      	adds	r0, #1
 804b92e:	d03a      	beq.n	804b9a6 <_malloc_r+0xea>
 804b930:	6823      	ldr	r3, [r4, #0]
 804b932:	442b      	add	r3, r5
 804b934:	6023      	str	r3, [r4, #0]
 804b936:	f8d8 3000 	ldr.w	r3, [r8]
 804b93a:	685a      	ldr	r2, [r3, #4]
 804b93c:	bb62      	cbnz	r2, 804b998 <_malloc_r+0xdc>
 804b93e:	f8c8 7000 	str.w	r7, [r8]
 804b942:	e00f      	b.n	804b964 <_malloc_r+0xa8>
 804b944:	6822      	ldr	r2, [r4, #0]
 804b946:	1b52      	subs	r2, r2, r5
 804b948:	d420      	bmi.n	804b98c <_malloc_r+0xd0>
 804b94a:	2a0b      	cmp	r2, #11
 804b94c:	d917      	bls.n	804b97e <_malloc_r+0xc2>
 804b94e:	1961      	adds	r1, r4, r5
 804b950:	42a3      	cmp	r3, r4
 804b952:	6025      	str	r5, [r4, #0]
 804b954:	bf18      	it	ne
 804b956:	6059      	strne	r1, [r3, #4]
 804b958:	6863      	ldr	r3, [r4, #4]
 804b95a:	bf08      	it	eq
 804b95c:	f8c8 1000 	streq.w	r1, [r8]
 804b960:	5162      	str	r2, [r4, r5]
 804b962:	604b      	str	r3, [r1, #4]
 804b964:	4630      	mov	r0, r6
 804b966:	f000 f82f 	bl	804b9c8 <__malloc_unlock>
 804b96a:	f104 000b 	add.w	r0, r4, #11
 804b96e:	1d23      	adds	r3, r4, #4
 804b970:	f020 0007 	bic.w	r0, r0, #7
 804b974:	1ac2      	subs	r2, r0, r3
 804b976:	bf1c      	itt	ne
 804b978:	1a1b      	subne	r3, r3, r0
 804b97a:	50a3      	strne	r3, [r4, r2]
 804b97c:	e7af      	b.n	804b8de <_malloc_r+0x22>
 804b97e:	6862      	ldr	r2, [r4, #4]
 804b980:	42a3      	cmp	r3, r4
 804b982:	bf0c      	ite	eq
 804b984:	f8c8 2000 	streq.w	r2, [r8]
 804b988:	605a      	strne	r2, [r3, #4]
 804b98a:	e7eb      	b.n	804b964 <_malloc_r+0xa8>
 804b98c:	4623      	mov	r3, r4
 804b98e:	6864      	ldr	r4, [r4, #4]
 804b990:	e7ae      	b.n	804b8f0 <_malloc_r+0x34>
 804b992:	463c      	mov	r4, r7
 804b994:	687f      	ldr	r7, [r7, #4]
 804b996:	e7b6      	b.n	804b906 <_malloc_r+0x4a>
 804b998:	461a      	mov	r2, r3
 804b99a:	685b      	ldr	r3, [r3, #4]
 804b99c:	42a3      	cmp	r3, r4
 804b99e:	d1fb      	bne.n	804b998 <_malloc_r+0xdc>
 804b9a0:	2300      	movs	r3, #0
 804b9a2:	6053      	str	r3, [r2, #4]
 804b9a4:	e7de      	b.n	804b964 <_malloc_r+0xa8>
 804b9a6:	230c      	movs	r3, #12
 804b9a8:	4630      	mov	r0, r6
 804b9aa:	6033      	str	r3, [r6, #0]
 804b9ac:	f000 f80c 	bl	804b9c8 <__malloc_unlock>
 804b9b0:	e794      	b.n	804b8dc <_malloc_r+0x20>
 804b9b2:	6005      	str	r5, [r0, #0]
 804b9b4:	e7d6      	b.n	804b964 <_malloc_r+0xa8>
 804b9b6:	bf00      	nop
 804b9b8:	20018adc 	.word	0x20018adc

0804b9bc <__malloc_lock>:
 804b9bc:	4801      	ldr	r0, [pc, #4]	@ (804b9c4 <__malloc_lock+0x8>)
 804b9be:	f000 bb34 	b.w	804c02a <__retarget_lock_acquire_recursive>
 804b9c2:	bf00      	nop
 804b9c4:	20018c20 	.word	0x20018c20

0804b9c8 <__malloc_unlock>:
 804b9c8:	4801      	ldr	r0, [pc, #4]	@ (804b9d0 <__malloc_unlock+0x8>)
 804b9ca:	f000 bb2f 	b.w	804c02c <__retarget_lock_release_recursive>
 804b9ce:	bf00      	nop
 804b9d0:	20018c20 	.word	0x20018c20

0804b9d4 <srand>:
 804b9d4:	b538      	push	{r3, r4, r5, lr}
 804b9d6:	4b10      	ldr	r3, [pc, #64]	@ (804ba18 <srand+0x44>)
 804b9d8:	4604      	mov	r4, r0
 804b9da:	681d      	ldr	r5, [r3, #0]
 804b9dc:	6b2b      	ldr	r3, [r5, #48]	@ 0x30
 804b9de:	b9b3      	cbnz	r3, 804ba0e <srand+0x3a>
 804b9e0:	2018      	movs	r0, #24
 804b9e2:	f7ff ff39 	bl	804b858 <malloc>
 804b9e6:	4602      	mov	r2, r0
 804b9e8:	6328      	str	r0, [r5, #48]	@ 0x30
 804b9ea:	b920      	cbnz	r0, 804b9f6 <srand+0x22>
 804b9ec:	4b0b      	ldr	r3, [pc, #44]	@ (804ba1c <srand+0x48>)
 804b9ee:	2146      	movs	r1, #70	@ 0x46
 804b9f0:	480b      	ldr	r0, [pc, #44]	@ (804ba20 <srand+0x4c>)
 804b9f2:	f7ff fef7 	bl	804b7e4 <__assert_func>
 804b9f6:	490b      	ldr	r1, [pc, #44]	@ (804ba24 <srand+0x50>)
 804b9f8:	4b0b      	ldr	r3, [pc, #44]	@ (804ba28 <srand+0x54>)
 804b9fa:	e9c0 1300 	strd	r1, r3, [r0]
 804b9fe:	4b0b      	ldr	r3, [pc, #44]	@ (804ba2c <srand+0x58>)
 804ba00:	2100      	movs	r1, #0
 804ba02:	6083      	str	r3, [r0, #8]
 804ba04:	230b      	movs	r3, #11
 804ba06:	8183      	strh	r3, [r0, #12]
 804ba08:	2001      	movs	r0, #1
 804ba0a:	e9c2 0104 	strd	r0, r1, [r2, #16]
 804ba0e:	6b2b      	ldr	r3, [r5, #48]	@ 0x30
 804ba10:	2200      	movs	r2, #0
 804ba12:	611c      	str	r4, [r3, #16]
 804ba14:	615a      	str	r2, [r3, #20]
 804ba16:	bd38      	pop	{r3, r4, r5, pc}
 804ba18:	2001813c 	.word	0x2001813c
 804ba1c:	0804e636 	.word	0x0804e636
 804ba20:	0804e64d 	.word	0x0804e64d
 804ba24:	abcd330e 	.word	0xabcd330e
 804ba28:	e66d1234 	.word	0xe66d1234
 804ba2c:	0005deec 	.word	0x0005deec

0804ba30 <realloc>:
 804ba30:	4b02      	ldr	r3, [pc, #8]	@ (804ba3c <realloc+0xc>)
 804ba32:	460a      	mov	r2, r1
 804ba34:	4601      	mov	r1, r0
 804ba36:	6818      	ldr	r0, [r3, #0]
 804ba38:	f000 b802 	b.w	804ba40 <_realloc_r>
 804ba3c:	2001813c 	.word	0x2001813c

0804ba40 <_realloc_r>:
 804ba40:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 804ba44:	4680      	mov	r8, r0
 804ba46:	4615      	mov	r5, r2
 804ba48:	460c      	mov	r4, r1
 804ba4a:	b921      	cbnz	r1, 804ba56 <_realloc_r+0x16>
 804ba4c:	4611      	mov	r1, r2
 804ba4e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 804ba52:	f7ff bf33 	b.w	804b8bc <_malloc_r>
 804ba56:	b92a      	cbnz	r2, 804ba64 <_realloc_r+0x24>
 804ba58:	f000 fb04 	bl	804c064 <_free_r>
 804ba5c:	2400      	movs	r4, #0
 804ba5e:	4620      	mov	r0, r4
 804ba60:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 804ba64:	f000 fb48 	bl	804c0f8 <_malloc_usable_size_r>
 804ba68:	4285      	cmp	r5, r0
 804ba6a:	4606      	mov	r6, r0
 804ba6c:	d802      	bhi.n	804ba74 <_realloc_r+0x34>
 804ba6e:	ebb5 0f50 	cmp.w	r5, r0, lsr #1
 804ba72:	d8f4      	bhi.n	804ba5e <_realloc_r+0x1e>
 804ba74:	4629      	mov	r1, r5
 804ba76:	4640      	mov	r0, r8
 804ba78:	f7ff ff20 	bl	804b8bc <_malloc_r>
 804ba7c:	4607      	mov	r7, r0
 804ba7e:	2800      	cmp	r0, #0
 804ba80:	d0ec      	beq.n	804ba5c <_realloc_r+0x1c>
 804ba82:	42b5      	cmp	r5, r6
 804ba84:	462a      	mov	r2, r5
 804ba86:	4621      	mov	r1, r4
 804ba88:	bf28      	it	cs
 804ba8a:	4632      	movcs	r2, r6
 804ba8c:	f000 facf 	bl	804c02e <memcpy>
 804ba90:	4621      	mov	r1, r4
 804ba92:	4640      	mov	r0, r8
 804ba94:	463c      	mov	r4, r7
 804ba96:	f000 fae5 	bl	804c064 <_free_r>
 804ba9a:	e7e0      	b.n	804ba5e <_realloc_r+0x1e>

0804ba9c <std>:
 804ba9c:	2300      	movs	r3, #0
 804ba9e:	b510      	push	{r4, lr}
 804baa0:	4604      	mov	r4, r0
 804baa2:	6083      	str	r3, [r0, #8]
 804baa4:	8181      	strh	r1, [r0, #12]
 804baa6:	4619      	mov	r1, r3
 804baa8:	6643      	str	r3, [r0, #100]	@ 0x64
 804baaa:	81c2      	strh	r2, [r0, #14]
 804baac:	2208      	movs	r2, #8
 804baae:	6183      	str	r3, [r0, #24]
 804bab0:	e9c0 3300 	strd	r3, r3, [r0]
 804bab4:	e9c0 3304 	strd	r3, r3, [r0, #16]
 804bab8:	305c      	adds	r0, #92	@ 0x5c
 804baba:	f000 f9bb 	bl	804be34 <memset>
 804babe:	4b0d      	ldr	r3, [pc, #52]	@ (804baf4 <std+0x58>)
 804bac0:	6224      	str	r4, [r4, #32]
 804bac2:	6263      	str	r3, [r4, #36]	@ 0x24
 804bac4:	4b0c      	ldr	r3, [pc, #48]	@ (804baf8 <std+0x5c>)
 804bac6:	62a3      	str	r3, [r4, #40]	@ 0x28
 804bac8:	4b0c      	ldr	r3, [pc, #48]	@ (804bafc <std+0x60>)
 804baca:	62e3      	str	r3, [r4, #44]	@ 0x2c
 804bacc:	4b0c      	ldr	r3, [pc, #48]	@ (804bb00 <std+0x64>)
 804bace:	6323      	str	r3, [r4, #48]	@ 0x30
 804bad0:	4b0c      	ldr	r3, [pc, #48]	@ (804bb04 <std+0x68>)
 804bad2:	429c      	cmp	r4, r3
 804bad4:	d006      	beq.n	804bae4 <std+0x48>
 804bad6:	f103 0268 	add.w	r2, r3, #104	@ 0x68
 804bada:	4294      	cmp	r4, r2
 804badc:	d002      	beq.n	804bae4 <std+0x48>
 804bade:	33d0      	adds	r3, #208	@ 0xd0
 804bae0:	429c      	cmp	r4, r3
 804bae2:	d105      	bne.n	804baf0 <std+0x54>
 804bae4:	f104 0058 	add.w	r0, r4, #88	@ 0x58
 804bae8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 804baec:	f000 ba9c 	b.w	804c028 <__retarget_lock_init_recursive>
 804baf0:	bd10      	pop	{r4, pc}
 804baf2:	bf00      	nop
 804baf4:	0804bc85 	.word	0x0804bc85
 804baf8:	0804bca7 	.word	0x0804bca7
 804bafc:	0804bcdf 	.word	0x0804bcdf
 804bb00:	0804bd03 	.word	0x0804bd03
 804bb04:	20018ae0 	.word	0x20018ae0

0804bb08 <stdio_exit_handler>:
 804bb08:	4a02      	ldr	r2, [pc, #8]	@ (804bb14 <stdio_exit_handler+0xc>)
 804bb0a:	4903      	ldr	r1, [pc, #12]	@ (804bb18 <stdio_exit_handler+0x10>)
 804bb0c:	4803      	ldr	r0, [pc, #12]	@ (804bb1c <stdio_exit_handler+0x14>)
 804bb0e:	f000 b87b 	b.w	804bc08 <_fwalk_sglue>
 804bb12:	bf00      	nop
 804bb14:	20018130 	.word	0x20018130
 804bb18:	0804ca69 	.word	0x0804ca69
 804bb1c:	20018140 	.word	0x20018140

0804bb20 <cleanup_stdio>:
 804bb20:	6841      	ldr	r1, [r0, #4]
 804bb22:	4b0c      	ldr	r3, [pc, #48]	@ (804bb54 <cleanup_stdio+0x34>)
 804bb24:	4299      	cmp	r1, r3
 804bb26:	b510      	push	{r4, lr}
 804bb28:	4604      	mov	r4, r0
 804bb2a:	d001      	beq.n	804bb30 <cleanup_stdio+0x10>
 804bb2c:	f000 ff9c 	bl	804ca68 <_fflush_r>
 804bb30:	68a1      	ldr	r1, [r4, #8]
 804bb32:	4b09      	ldr	r3, [pc, #36]	@ (804bb58 <cleanup_stdio+0x38>)
 804bb34:	4299      	cmp	r1, r3
 804bb36:	d002      	beq.n	804bb3e <cleanup_stdio+0x1e>
 804bb38:	4620      	mov	r0, r4
 804bb3a:	f000 ff95 	bl	804ca68 <_fflush_r>
 804bb3e:	68e1      	ldr	r1, [r4, #12]
 804bb40:	4b06      	ldr	r3, [pc, #24]	@ (804bb5c <cleanup_stdio+0x3c>)
 804bb42:	4299      	cmp	r1, r3
 804bb44:	d004      	beq.n	804bb50 <cleanup_stdio+0x30>
 804bb46:	4620      	mov	r0, r4
 804bb48:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 804bb4c:	f000 bf8c 	b.w	804ca68 <_fflush_r>
 804bb50:	bd10      	pop	{r4, pc}
 804bb52:	bf00      	nop
 804bb54:	20018ae0 	.word	0x20018ae0
 804bb58:	20018b48 	.word	0x20018b48
 804bb5c:	20018bb0 	.word	0x20018bb0

0804bb60 <global_stdio_init.part.0>:
 804bb60:	b510      	push	{r4, lr}
 804bb62:	4b0b      	ldr	r3, [pc, #44]	@ (804bb90 <global_stdio_init.part.0+0x30>)
 804bb64:	2104      	movs	r1, #4
 804bb66:	4c0b      	ldr	r4, [pc, #44]	@ (804bb94 <global_stdio_init.part.0+0x34>)
 804bb68:	4a0b      	ldr	r2, [pc, #44]	@ (804bb98 <global_stdio_init.part.0+0x38>)
 804bb6a:	4620      	mov	r0, r4
 804bb6c:	601a      	str	r2, [r3, #0]
 804bb6e:	2200      	movs	r2, #0
 804bb70:	f7ff ff94 	bl	804ba9c <std>
 804bb74:	f104 0068 	add.w	r0, r4, #104	@ 0x68
 804bb78:	2201      	movs	r2, #1
 804bb7a:	2109      	movs	r1, #9
 804bb7c:	f7ff ff8e 	bl	804ba9c <std>
 804bb80:	f104 00d0 	add.w	r0, r4, #208	@ 0xd0
 804bb84:	2202      	movs	r2, #2
 804bb86:	2112      	movs	r1, #18
 804bb88:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 804bb8c:	f7ff bf86 	b.w	804ba9c <std>
 804bb90:	20018c18 	.word	0x20018c18
 804bb94:	20018ae0 	.word	0x20018ae0
 804bb98:	0804bb09 	.word	0x0804bb09

0804bb9c <__sfp_lock_acquire>:
 804bb9c:	4801      	ldr	r0, [pc, #4]	@ (804bba4 <__sfp_lock_acquire+0x8>)
 804bb9e:	f000 ba44 	b.w	804c02a <__retarget_lock_acquire_recursive>
 804bba2:	bf00      	nop
 804bba4:	20018c21 	.word	0x20018c21

0804bba8 <__sfp_lock_release>:
 804bba8:	4801      	ldr	r0, [pc, #4]	@ (804bbb0 <__sfp_lock_release+0x8>)
 804bbaa:	f000 ba3f 	b.w	804c02c <__retarget_lock_release_recursive>
 804bbae:	bf00      	nop
 804bbb0:	20018c21 	.word	0x20018c21

0804bbb4 <__sinit>:
 804bbb4:	b510      	push	{r4, lr}
 804bbb6:	4604      	mov	r4, r0
 804bbb8:	f7ff fff0 	bl	804bb9c <__sfp_lock_acquire>
 804bbbc:	6a23      	ldr	r3, [r4, #32]
 804bbbe:	b11b      	cbz	r3, 804bbc8 <__sinit+0x14>
 804bbc0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 804bbc4:	f7ff bff0 	b.w	804bba8 <__sfp_lock_release>
 804bbc8:	4b04      	ldr	r3, [pc, #16]	@ (804bbdc <__sinit+0x28>)
 804bbca:	6223      	str	r3, [r4, #32]
 804bbcc:	4b04      	ldr	r3, [pc, #16]	@ (804bbe0 <__sinit+0x2c>)
 804bbce:	681b      	ldr	r3, [r3, #0]
 804bbd0:	2b00      	cmp	r3, #0
 804bbd2:	d1f5      	bne.n	804bbc0 <__sinit+0xc>
 804bbd4:	f7ff ffc4 	bl	804bb60 <global_stdio_init.part.0>
 804bbd8:	e7f2      	b.n	804bbc0 <__sinit+0xc>
 804bbda:	bf00      	nop
 804bbdc:	0804bb21 	.word	0x0804bb21
 804bbe0:	20018c18 	.word	0x20018c18

0804bbe4 <fiprintf>:
 804bbe4:	b40e      	push	{r1, r2, r3}
 804bbe6:	b503      	push	{r0, r1, lr}
 804bbe8:	ab03      	add	r3, sp, #12
 804bbea:	4601      	mov	r1, r0
 804bbec:	4805      	ldr	r0, [pc, #20]	@ (804bc04 <fiprintf+0x20>)
 804bbee:	f853 2b04 	ldr.w	r2, [r3], #4
 804bbf2:	6800      	ldr	r0, [r0, #0]
 804bbf4:	9301      	str	r3, [sp, #4]
 804bbf6:	f000 fc09 	bl	804c40c <_vfiprintf_r>
 804bbfa:	b002      	add	sp, #8
 804bbfc:	f85d eb04 	ldr.w	lr, [sp], #4
 804bc00:	b003      	add	sp, #12
 804bc02:	4770      	bx	lr
 804bc04:	2001813c 	.word	0x2001813c

0804bc08 <_fwalk_sglue>:
 804bc08:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 804bc0c:	4607      	mov	r7, r0
 804bc0e:	4688      	mov	r8, r1
 804bc10:	4614      	mov	r4, r2
 804bc12:	2600      	movs	r6, #0
 804bc14:	e9d4 9501 	ldrd	r9, r5, [r4, #4]
 804bc18:	f1b9 0901 	subs.w	r9, r9, #1
 804bc1c:	d505      	bpl.n	804bc2a <_fwalk_sglue+0x22>
 804bc1e:	6824      	ldr	r4, [r4, #0]
 804bc20:	2c00      	cmp	r4, #0
 804bc22:	d1f7      	bne.n	804bc14 <_fwalk_sglue+0xc>
 804bc24:	4630      	mov	r0, r6
 804bc26:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 804bc2a:	89ab      	ldrh	r3, [r5, #12]
 804bc2c:	2b01      	cmp	r3, #1
 804bc2e:	d907      	bls.n	804bc40 <_fwalk_sglue+0x38>
 804bc30:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
 804bc34:	3301      	adds	r3, #1
 804bc36:	d003      	beq.n	804bc40 <_fwalk_sglue+0x38>
 804bc38:	4629      	mov	r1, r5
 804bc3a:	4638      	mov	r0, r7
 804bc3c:	47c0      	blx	r8
 804bc3e:	4306      	orrs	r6, r0
 804bc40:	3568      	adds	r5, #104	@ 0x68
 804bc42:	e7e9      	b.n	804bc18 <_fwalk_sglue+0x10>

0804bc44 <siprintf>:
 804bc44:	b40e      	push	{r1, r2, r3}
 804bc46:	b500      	push	{lr}
 804bc48:	b09c      	sub	sp, #112	@ 0x70
 804bc4a:	f06f 4100 	mvn.w	r1, #2147483648	@ 0x80000000
 804bc4e:	ab1d      	add	r3, sp, #116	@ 0x74
 804bc50:	9002      	str	r0, [sp, #8]
 804bc52:	9006      	str	r0, [sp, #24]
 804bc54:	9107      	str	r1, [sp, #28]
 804bc56:	9104      	str	r1, [sp, #16]
 804bc58:	4808      	ldr	r0, [pc, #32]	@ (804bc7c <siprintf+0x38>)
 804bc5a:	4909      	ldr	r1, [pc, #36]	@ (804bc80 <siprintf+0x3c>)
 804bc5c:	f853 2b04 	ldr.w	r2, [r3], #4
 804bc60:	9105      	str	r1, [sp, #20]
 804bc62:	a902      	add	r1, sp, #8
 804bc64:	6800      	ldr	r0, [r0, #0]
 804bc66:	9301      	str	r3, [sp, #4]
 804bc68:	f000 faaa 	bl	804c1c0 <_svfiprintf_r>
 804bc6c:	9b02      	ldr	r3, [sp, #8]
 804bc6e:	2200      	movs	r2, #0
 804bc70:	701a      	strb	r2, [r3, #0]
 804bc72:	b01c      	add	sp, #112	@ 0x70
 804bc74:	f85d eb04 	ldr.w	lr, [sp], #4
 804bc78:	b003      	add	sp, #12
 804bc7a:	4770      	bx	lr
 804bc7c:	2001813c 	.word	0x2001813c
 804bc80:	ffff0208 	.word	0xffff0208

0804bc84 <__sread>:
 804bc84:	b510      	push	{r4, lr}
 804bc86:	460c      	mov	r4, r1
 804bc88:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 804bc8c:	f000 f95a 	bl	804bf44 <_read_r>
 804bc90:	2800      	cmp	r0, #0
 804bc92:	bfab      	itete	ge
 804bc94:	6d63      	ldrge	r3, [r4, #84]	@ 0x54
 804bc96:	89a3      	ldrhlt	r3, [r4, #12]
 804bc98:	181b      	addge	r3, r3, r0
 804bc9a:	f423 5380 	biclt.w	r3, r3, #4096	@ 0x1000
 804bc9e:	bfac      	ite	ge
 804bca0:	6563      	strge	r3, [r4, #84]	@ 0x54
 804bca2:	81a3      	strhlt	r3, [r4, #12]
 804bca4:	bd10      	pop	{r4, pc}

0804bca6 <__swrite>:
 804bca6:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 804bcaa:	461f      	mov	r7, r3
 804bcac:	898b      	ldrh	r3, [r1, #12]
 804bcae:	4605      	mov	r5, r0
 804bcb0:	460c      	mov	r4, r1
 804bcb2:	05db      	lsls	r3, r3, #23
 804bcb4:	4616      	mov	r6, r2
 804bcb6:	d505      	bpl.n	804bcc4 <__swrite+0x1e>
 804bcb8:	2302      	movs	r3, #2
 804bcba:	2200      	movs	r2, #0
 804bcbc:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 804bcc0:	f000 f92e 	bl	804bf20 <_lseek_r>
 804bcc4:	89a3      	ldrh	r3, [r4, #12]
 804bcc6:	4632      	mov	r2, r6
 804bcc8:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 804bccc:	4628      	mov	r0, r5
 804bcce:	f423 5380 	bic.w	r3, r3, #4096	@ 0x1000
 804bcd2:	81a3      	strh	r3, [r4, #12]
 804bcd4:	463b      	mov	r3, r7
 804bcd6:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 804bcda:	f000 b969 	b.w	804bfb0 <_write_r>

0804bcde <__sseek>:
 804bcde:	b510      	push	{r4, lr}
 804bce0:	460c      	mov	r4, r1
 804bce2:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 804bce6:	f000 f91b 	bl	804bf20 <_lseek_r>
 804bcea:	1c43      	adds	r3, r0, #1
 804bcec:	89a3      	ldrh	r3, [r4, #12]
 804bcee:	bf15      	itete	ne
 804bcf0:	6560      	strne	r0, [r4, #84]	@ 0x54
 804bcf2:	f423 5380 	biceq.w	r3, r3, #4096	@ 0x1000
 804bcf6:	f443 5380 	orrne.w	r3, r3, #4096	@ 0x1000
 804bcfa:	81a3      	strheq	r3, [r4, #12]
 804bcfc:	bf18      	it	ne
 804bcfe:	81a3      	strhne	r3, [r4, #12]
 804bd00:	bd10      	pop	{r4, pc}

0804bd02 <__sclose>:
 804bd02:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 804bd06:	f000 b8e9 	b.w	804bedc <_close_r>

0804bd0a <__swbuf_r>:
 804bd0a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 804bd0c:	460e      	mov	r6, r1
 804bd0e:	4614      	mov	r4, r2
 804bd10:	4605      	mov	r5, r0
 804bd12:	b118      	cbz	r0, 804bd1c <__swbuf_r+0x12>
 804bd14:	6a03      	ldr	r3, [r0, #32]
 804bd16:	b90b      	cbnz	r3, 804bd1c <__swbuf_r+0x12>
 804bd18:	f7ff ff4c 	bl	804bbb4 <__sinit>
 804bd1c:	69a3      	ldr	r3, [r4, #24]
 804bd1e:	60a3      	str	r3, [r4, #8]
 804bd20:	89a3      	ldrh	r3, [r4, #12]
 804bd22:	071a      	lsls	r2, r3, #28
 804bd24:	d501      	bpl.n	804bd2a <__swbuf_r+0x20>
 804bd26:	6923      	ldr	r3, [r4, #16]
 804bd28:	b943      	cbnz	r3, 804bd3c <__swbuf_r+0x32>
 804bd2a:	4621      	mov	r1, r4
 804bd2c:	4628      	mov	r0, r5
 804bd2e:	f000 f82b 	bl	804bd88 <__swsetup_r>
 804bd32:	b118      	cbz	r0, 804bd3c <__swbuf_r+0x32>
 804bd34:	f04f 37ff 	mov.w	r7, #4294967295
 804bd38:	4638      	mov	r0, r7
 804bd3a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 804bd3c:	6823      	ldr	r3, [r4, #0]
 804bd3e:	b2f6      	uxtb	r6, r6
 804bd40:	6922      	ldr	r2, [r4, #16]
 804bd42:	4637      	mov	r7, r6
 804bd44:	1a98      	subs	r0, r3, r2
 804bd46:	6963      	ldr	r3, [r4, #20]
 804bd48:	4283      	cmp	r3, r0
 804bd4a:	dc05      	bgt.n	804bd58 <__swbuf_r+0x4e>
 804bd4c:	4621      	mov	r1, r4
 804bd4e:	4628      	mov	r0, r5
 804bd50:	f000 fe8a 	bl	804ca68 <_fflush_r>
 804bd54:	2800      	cmp	r0, #0
 804bd56:	d1ed      	bne.n	804bd34 <__swbuf_r+0x2a>
 804bd58:	68a3      	ldr	r3, [r4, #8]
 804bd5a:	3b01      	subs	r3, #1
 804bd5c:	60a3      	str	r3, [r4, #8]
 804bd5e:	6823      	ldr	r3, [r4, #0]
 804bd60:	1c5a      	adds	r2, r3, #1
 804bd62:	6022      	str	r2, [r4, #0]
 804bd64:	701e      	strb	r6, [r3, #0]
 804bd66:	1c43      	adds	r3, r0, #1
 804bd68:	6962      	ldr	r2, [r4, #20]
 804bd6a:	429a      	cmp	r2, r3
 804bd6c:	d004      	beq.n	804bd78 <__swbuf_r+0x6e>
 804bd6e:	89a3      	ldrh	r3, [r4, #12]
 804bd70:	07db      	lsls	r3, r3, #31
 804bd72:	d5e1      	bpl.n	804bd38 <__swbuf_r+0x2e>
 804bd74:	2e0a      	cmp	r6, #10
 804bd76:	d1df      	bne.n	804bd38 <__swbuf_r+0x2e>
 804bd78:	4621      	mov	r1, r4
 804bd7a:	4628      	mov	r0, r5
 804bd7c:	f000 fe74 	bl	804ca68 <_fflush_r>
 804bd80:	2800      	cmp	r0, #0
 804bd82:	d0d9      	beq.n	804bd38 <__swbuf_r+0x2e>
 804bd84:	e7d6      	b.n	804bd34 <__swbuf_r+0x2a>
	...

0804bd88 <__swsetup_r>:
 804bd88:	b538      	push	{r3, r4, r5, lr}
 804bd8a:	4b29      	ldr	r3, [pc, #164]	@ (804be30 <__swsetup_r+0xa8>)
 804bd8c:	4605      	mov	r5, r0
 804bd8e:	460c      	mov	r4, r1
 804bd90:	6818      	ldr	r0, [r3, #0]
 804bd92:	b118      	cbz	r0, 804bd9c <__swsetup_r+0x14>
 804bd94:	6a03      	ldr	r3, [r0, #32]
 804bd96:	b90b      	cbnz	r3, 804bd9c <__swsetup_r+0x14>
 804bd98:	f7ff ff0c 	bl	804bbb4 <__sinit>
 804bd9c:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 804bda0:	0719      	lsls	r1, r3, #28
 804bda2:	d422      	bmi.n	804bdea <__swsetup_r+0x62>
 804bda4:	06da      	lsls	r2, r3, #27
 804bda6:	d407      	bmi.n	804bdb8 <__swsetup_r+0x30>
 804bda8:	2209      	movs	r2, #9
 804bdaa:	602a      	str	r2, [r5, #0]
 804bdac:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 804bdb0:	f04f 30ff 	mov.w	r0, #4294967295
 804bdb4:	81a3      	strh	r3, [r4, #12]
 804bdb6:	e033      	b.n	804be20 <__swsetup_r+0x98>
 804bdb8:	0758      	lsls	r0, r3, #29
 804bdba:	d512      	bpl.n	804bde2 <__swsetup_r+0x5a>
 804bdbc:	6b61      	ldr	r1, [r4, #52]	@ 0x34
 804bdbe:	b141      	cbz	r1, 804bdd2 <__swsetup_r+0x4a>
 804bdc0:	f104 0344 	add.w	r3, r4, #68	@ 0x44
 804bdc4:	4299      	cmp	r1, r3
 804bdc6:	d002      	beq.n	804bdce <__swsetup_r+0x46>
 804bdc8:	4628      	mov	r0, r5
 804bdca:	f000 f94b 	bl	804c064 <_free_r>
 804bdce:	2300      	movs	r3, #0
 804bdd0:	6363      	str	r3, [r4, #52]	@ 0x34
 804bdd2:	89a3      	ldrh	r3, [r4, #12]
 804bdd4:	f023 0324 	bic.w	r3, r3, #36	@ 0x24
 804bdd8:	81a3      	strh	r3, [r4, #12]
 804bdda:	2300      	movs	r3, #0
 804bddc:	6063      	str	r3, [r4, #4]
 804bdde:	6923      	ldr	r3, [r4, #16]
 804bde0:	6023      	str	r3, [r4, #0]
 804bde2:	89a3      	ldrh	r3, [r4, #12]
 804bde4:	f043 0308 	orr.w	r3, r3, #8
 804bde8:	81a3      	strh	r3, [r4, #12]
 804bdea:	6923      	ldr	r3, [r4, #16]
 804bdec:	b94b      	cbnz	r3, 804be02 <__swsetup_r+0x7a>
 804bdee:	89a3      	ldrh	r3, [r4, #12]
 804bdf0:	f403 7320 	and.w	r3, r3, #640	@ 0x280
 804bdf4:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 804bdf8:	d003      	beq.n	804be02 <__swsetup_r+0x7a>
 804bdfa:	4621      	mov	r1, r4
 804bdfc:	4628      	mov	r0, r5
 804bdfe:	f000 fe80 	bl	804cb02 <__smakebuf_r>
 804be02:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 804be06:	f013 0201 	ands.w	r2, r3, #1
 804be0a:	d00a      	beq.n	804be22 <__swsetup_r+0x9a>
 804be0c:	2200      	movs	r2, #0
 804be0e:	60a2      	str	r2, [r4, #8]
 804be10:	6962      	ldr	r2, [r4, #20]
 804be12:	4252      	negs	r2, r2
 804be14:	61a2      	str	r2, [r4, #24]
 804be16:	6922      	ldr	r2, [r4, #16]
 804be18:	b942      	cbnz	r2, 804be2c <__swsetup_r+0xa4>
 804be1a:	f013 0080 	ands.w	r0, r3, #128	@ 0x80
 804be1e:	d1c5      	bne.n	804bdac <__swsetup_r+0x24>
 804be20:	bd38      	pop	{r3, r4, r5, pc}
 804be22:	0799      	lsls	r1, r3, #30
 804be24:	bf58      	it	pl
 804be26:	6962      	ldrpl	r2, [r4, #20]
 804be28:	60a2      	str	r2, [r4, #8]
 804be2a:	e7f4      	b.n	804be16 <__swsetup_r+0x8e>
 804be2c:	2000      	movs	r0, #0
 804be2e:	e7f7      	b.n	804be20 <__swsetup_r+0x98>
 804be30:	2001813c 	.word	0x2001813c

0804be34 <memset>:
 804be34:	4402      	add	r2, r0
 804be36:	4603      	mov	r3, r0
 804be38:	4293      	cmp	r3, r2
 804be3a:	d100      	bne.n	804be3e <memset+0xa>
 804be3c:	4770      	bx	lr
 804be3e:	f803 1b01 	strb.w	r1, [r3], #1
 804be42:	e7f9      	b.n	804be38 <memset+0x4>

0804be44 <_raise_r>:
 804be44:	291f      	cmp	r1, #31
 804be46:	b538      	push	{r3, r4, r5, lr}
 804be48:	4605      	mov	r5, r0
 804be4a:	460c      	mov	r4, r1
 804be4c:	d904      	bls.n	804be58 <_raise_r+0x14>
 804be4e:	2316      	movs	r3, #22
 804be50:	6003      	str	r3, [r0, #0]
 804be52:	f04f 30ff 	mov.w	r0, #4294967295
 804be56:	bd38      	pop	{r3, r4, r5, pc}
 804be58:	6bc2      	ldr	r2, [r0, #60]	@ 0x3c
 804be5a:	b112      	cbz	r2, 804be62 <_raise_r+0x1e>
 804be5c:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
 804be60:	b94b      	cbnz	r3, 804be76 <_raise_r+0x32>
 804be62:	4628      	mov	r0, r5
 804be64:	f000 f892 	bl	804bf8c <_getpid_r>
 804be68:	4622      	mov	r2, r4
 804be6a:	4601      	mov	r1, r0
 804be6c:	4628      	mov	r0, r5
 804be6e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 804be72:	f000 b879 	b.w	804bf68 <_kill_r>
 804be76:	2b01      	cmp	r3, #1
 804be78:	d00a      	beq.n	804be90 <_raise_r+0x4c>
 804be7a:	1c59      	adds	r1, r3, #1
 804be7c:	d103      	bne.n	804be86 <_raise_r+0x42>
 804be7e:	2316      	movs	r3, #22
 804be80:	6003      	str	r3, [r0, #0]
 804be82:	2001      	movs	r0, #1
 804be84:	e7e7      	b.n	804be56 <_raise_r+0x12>
 804be86:	2100      	movs	r1, #0
 804be88:	4620      	mov	r0, r4
 804be8a:	f842 1024 	str.w	r1, [r2, r4, lsl #2]
 804be8e:	4798      	blx	r3
 804be90:	2000      	movs	r0, #0
 804be92:	e7e0      	b.n	804be56 <_raise_r+0x12>

0804be94 <raise>:
 804be94:	4b02      	ldr	r3, [pc, #8]	@ (804bea0 <raise+0xc>)
 804be96:	4601      	mov	r1, r0
 804be98:	6818      	ldr	r0, [r3, #0]
 804be9a:	f7ff bfd3 	b.w	804be44 <_raise_r>
 804be9e:	bf00      	nop
 804bea0:	2001813c 	.word	0x2001813c

0804bea4 <time>:
 804bea4:	b5df      	push	{r0, r1, r2, r3, r4, r6, r7, lr}
 804bea6:	4b0c      	ldr	r3, [pc, #48]	@ (804bed8 <time+0x34>)
 804bea8:	f04f 36ff 	mov.w	r6, #4294967295
 804beac:	f04f 37ff 	mov.w	r7, #4294967295
 804beb0:	4669      	mov	r1, sp
 804beb2:	4604      	mov	r4, r0
 804beb4:	2200      	movs	r2, #0
 804beb6:	6818      	ldr	r0, [r3, #0]
 804beb8:	e9cd 6700 	strd	r6, r7, [sp]
 804bebc:	f000 f81e 	bl	804befc <_gettimeofday_r>
 804bec0:	2800      	cmp	r0, #0
 804bec2:	bfb8      	it	lt
 804bec4:	e9cd 6700 	strdlt	r6, r7, [sp]
 804bec8:	e9dd 0100 	ldrd	r0, r1, [sp]
 804becc:	b10c      	cbz	r4, 804bed2 <time+0x2e>
 804bece:	e9c4 0100 	strd	r0, r1, [r4]
 804bed2:	b004      	add	sp, #16
 804bed4:	bdd0      	pop	{r4, r6, r7, pc}
 804bed6:	bf00      	nop
 804bed8:	2001813c 	.word	0x2001813c

0804bedc <_close_r>:
 804bedc:	b538      	push	{r3, r4, r5, lr}
 804bede:	2300      	movs	r3, #0
 804bee0:	4d05      	ldr	r5, [pc, #20]	@ (804bef8 <_close_r+0x1c>)
 804bee2:	4604      	mov	r4, r0
 804bee4:	4608      	mov	r0, r1
 804bee6:	602b      	str	r3, [r5, #0]
 804bee8:	f7f5 fa0e 	bl	8041308 <_close>
 804beec:	1c43      	adds	r3, r0, #1
 804beee:	d102      	bne.n	804bef6 <_close_r+0x1a>
 804bef0:	682b      	ldr	r3, [r5, #0]
 804bef2:	b103      	cbz	r3, 804bef6 <_close_r+0x1a>
 804bef4:	6023      	str	r3, [r4, #0]
 804bef6:	bd38      	pop	{r3, r4, r5, pc}
 804bef8:	20018c1c 	.word	0x20018c1c

0804befc <_gettimeofday_r>:
 804befc:	b538      	push	{r3, r4, r5, lr}
 804befe:	2300      	movs	r3, #0
 804bf00:	4d06      	ldr	r5, [pc, #24]	@ (804bf1c <_gettimeofday_r+0x20>)
 804bf02:	4604      	mov	r4, r0
 804bf04:	4608      	mov	r0, r1
 804bf06:	4611      	mov	r1, r2
 804bf08:	602b      	str	r3, [r5, #0]
 804bf0a:	f002 f92b 	bl	804e164 <_gettimeofday>
 804bf0e:	1c43      	adds	r3, r0, #1
 804bf10:	d102      	bne.n	804bf18 <_gettimeofday_r+0x1c>
 804bf12:	682b      	ldr	r3, [r5, #0]
 804bf14:	b103      	cbz	r3, 804bf18 <_gettimeofday_r+0x1c>
 804bf16:	6023      	str	r3, [r4, #0]
 804bf18:	bd38      	pop	{r3, r4, r5, pc}
 804bf1a:	bf00      	nop
 804bf1c:	20018c1c 	.word	0x20018c1c

0804bf20 <_lseek_r>:
 804bf20:	b538      	push	{r3, r4, r5, lr}
 804bf22:	4604      	mov	r4, r0
 804bf24:	4d06      	ldr	r5, [pc, #24]	@ (804bf40 <_lseek_r+0x20>)
 804bf26:	4608      	mov	r0, r1
 804bf28:	4611      	mov	r1, r2
 804bf2a:	2200      	movs	r2, #0
 804bf2c:	602a      	str	r2, [r5, #0]
 804bf2e:	461a      	mov	r2, r3
 804bf30:	f7f5 f9f6 	bl	8041320 <_lseek>
 804bf34:	1c43      	adds	r3, r0, #1
 804bf36:	d102      	bne.n	804bf3e <_lseek_r+0x1e>
 804bf38:	682b      	ldr	r3, [r5, #0]
 804bf3a:	b103      	cbz	r3, 804bf3e <_lseek_r+0x1e>
 804bf3c:	6023      	str	r3, [r4, #0]
 804bf3e:	bd38      	pop	{r3, r4, r5, pc}
 804bf40:	20018c1c 	.word	0x20018c1c

0804bf44 <_read_r>:
 804bf44:	b538      	push	{r3, r4, r5, lr}
 804bf46:	4604      	mov	r4, r0
 804bf48:	4d06      	ldr	r5, [pc, #24]	@ (804bf64 <_read_r+0x20>)
 804bf4a:	4608      	mov	r0, r1
 804bf4c:	4611      	mov	r1, r2
 804bf4e:	2200      	movs	r2, #0
 804bf50:	602a      	str	r2, [r5, #0]
 804bf52:	461a      	mov	r2, r3
 804bf54:	f7f5 f9bc 	bl	80412d0 <_read>
 804bf58:	1c43      	adds	r3, r0, #1
 804bf5a:	d102      	bne.n	804bf62 <_read_r+0x1e>
 804bf5c:	682b      	ldr	r3, [r5, #0]
 804bf5e:	b103      	cbz	r3, 804bf62 <_read_r+0x1e>
 804bf60:	6023      	str	r3, [r4, #0]
 804bf62:	bd38      	pop	{r3, r4, r5, pc}
 804bf64:	20018c1c 	.word	0x20018c1c

0804bf68 <_kill_r>:
 804bf68:	b538      	push	{r3, r4, r5, lr}
 804bf6a:	2300      	movs	r3, #0
 804bf6c:	4d06      	ldr	r5, [pc, #24]	@ (804bf88 <_kill_r+0x20>)
 804bf6e:	4604      	mov	r4, r0
 804bf70:	4608      	mov	r0, r1
 804bf72:	4611      	mov	r1, r2
 804bf74:	602b      	str	r3, [r5, #0]
 804bf76:	f7f5 f99b 	bl	80412b0 <_kill>
 804bf7a:	1c43      	adds	r3, r0, #1
 804bf7c:	d102      	bne.n	804bf84 <_kill_r+0x1c>
 804bf7e:	682b      	ldr	r3, [r5, #0]
 804bf80:	b103      	cbz	r3, 804bf84 <_kill_r+0x1c>
 804bf82:	6023      	str	r3, [r4, #0]
 804bf84:	bd38      	pop	{r3, r4, r5, pc}
 804bf86:	bf00      	nop
 804bf88:	20018c1c 	.word	0x20018c1c

0804bf8c <_getpid_r>:
 804bf8c:	f7f5 b98e 	b.w	80412ac <_getpid>

0804bf90 <_sbrk_r>:
 804bf90:	b538      	push	{r3, r4, r5, lr}
 804bf92:	2300      	movs	r3, #0
 804bf94:	4d05      	ldr	r5, [pc, #20]	@ (804bfac <_sbrk_r+0x1c>)
 804bf96:	4604      	mov	r4, r0
 804bf98:	4608      	mov	r0, r1
 804bf9a:	602b      	str	r3, [r5, #0]
 804bf9c:	f7f5 f9c2 	bl	8041324 <_sbrk>
 804bfa0:	1c43      	adds	r3, r0, #1
 804bfa2:	d102      	bne.n	804bfaa <_sbrk_r+0x1a>
 804bfa4:	682b      	ldr	r3, [r5, #0]
 804bfa6:	b103      	cbz	r3, 804bfaa <_sbrk_r+0x1a>
 804bfa8:	6023      	str	r3, [r4, #0]
 804bfaa:	bd38      	pop	{r3, r4, r5, pc}
 804bfac:	20018c1c 	.word	0x20018c1c

0804bfb0 <_write_r>:
 804bfb0:	b538      	push	{r3, r4, r5, lr}
 804bfb2:	4604      	mov	r4, r0
 804bfb4:	4d06      	ldr	r5, [pc, #24]	@ (804bfd0 <_write_r+0x20>)
 804bfb6:	4608      	mov	r0, r1
 804bfb8:	4611      	mov	r1, r2
 804bfba:	2200      	movs	r2, #0
 804bfbc:	602a      	str	r2, [r5, #0]
 804bfbe:	461a      	mov	r2, r3
 804bfc0:	f7f5 f994 	bl	80412ec <_write>
 804bfc4:	1c43      	adds	r3, r0, #1
 804bfc6:	d102      	bne.n	804bfce <_write_r+0x1e>
 804bfc8:	682b      	ldr	r3, [r5, #0]
 804bfca:	b103      	cbz	r3, 804bfce <_write_r+0x1e>
 804bfcc:	6023      	str	r3, [r4, #0]
 804bfce:	bd38      	pop	{r3, r4, r5, pc}
 804bfd0:	20018c1c 	.word	0x20018c1c

0804bfd4 <__errno>:
 804bfd4:	4b01      	ldr	r3, [pc, #4]	@ (804bfdc <__errno+0x8>)
 804bfd6:	6818      	ldr	r0, [r3, #0]
 804bfd8:	4770      	bx	lr
 804bfda:	bf00      	nop
 804bfdc:	2001813c 	.word	0x2001813c

0804bfe0 <__libc_init_array>:
 804bfe0:	b570      	push	{r4, r5, r6, lr}
 804bfe2:	4d0d      	ldr	r5, [pc, #52]	@ (804c018 <__libc_init_array+0x38>)
 804bfe4:	2600      	movs	r6, #0
 804bfe6:	4c0d      	ldr	r4, [pc, #52]	@ (804c01c <__libc_init_array+0x3c>)
 804bfe8:	1b64      	subs	r4, r4, r5
 804bfea:	10a4      	asrs	r4, r4, #2
 804bfec:	42a6      	cmp	r6, r4
 804bfee:	d109      	bne.n	804c004 <__libc_init_array+0x24>
 804bff0:	4d0b      	ldr	r5, [pc, #44]	@ (804c020 <__libc_init_array+0x40>)
 804bff2:	2600      	movs	r6, #0
 804bff4:	4c0b      	ldr	r4, [pc, #44]	@ (804c024 <__libc_init_array+0x44>)
 804bff6:	f002 f8bd 	bl	804e174 <_init>
 804bffa:	1b64      	subs	r4, r4, r5
 804bffc:	10a4      	asrs	r4, r4, #2
 804bffe:	42a6      	cmp	r6, r4
 804c000:	d105      	bne.n	804c00e <__libc_init_array+0x2e>
 804c002:	bd70      	pop	{r4, r5, r6, pc}
 804c004:	f855 3b04 	ldr.w	r3, [r5], #4
 804c008:	3601      	adds	r6, #1
 804c00a:	4798      	blx	r3
 804c00c:	e7ee      	b.n	804bfec <__libc_init_array+0xc>
 804c00e:	f855 3b04 	ldr.w	r3, [r5], #4
 804c012:	3601      	adds	r6, #1
 804c014:	4798      	blx	r3
 804c016:	e7f2      	b.n	804bffe <__libc_init_array+0x1e>
 804c018:	0804eac0 	.word	0x0804eac0
 804c01c:	0804eac0 	.word	0x0804eac0
 804c020:	0804eac0 	.word	0x0804eac0
 804c024:	0804eac4 	.word	0x0804eac4

0804c028 <__retarget_lock_init_recursive>:
 804c028:	4770      	bx	lr

0804c02a <__retarget_lock_acquire_recursive>:
 804c02a:	4770      	bx	lr

0804c02c <__retarget_lock_release_recursive>:
 804c02c:	4770      	bx	lr

0804c02e <memcpy>:
 804c02e:	440a      	add	r2, r1
 804c030:	1e43      	subs	r3, r0, #1
 804c032:	4291      	cmp	r1, r2
 804c034:	d100      	bne.n	804c038 <memcpy+0xa>
 804c036:	4770      	bx	lr
 804c038:	b510      	push	{r4, lr}
 804c03a:	f811 4b01 	ldrb.w	r4, [r1], #1
 804c03e:	4291      	cmp	r1, r2
 804c040:	f803 4f01 	strb.w	r4, [r3, #1]!
 804c044:	d1f9      	bne.n	804c03a <memcpy+0xc>
 804c046:	bd10      	pop	{r4, pc}

0804c048 <nan>:
 804c048:	ed9f 0b01 	vldr	d0, [pc, #4]	@ 804c050 <nan+0x8>
 804c04c:	4770      	bx	lr
 804c04e:	bf00      	nop
 804c050:	00000000 	.word	0x00000000
 804c054:	7ff80000 	.word	0x7ff80000

0804c058 <nanf>:
 804c058:	ed9f 0a01 	vldr	s0, [pc, #4]	@ 804c060 <nanf+0x8>
 804c05c:	4770      	bx	lr
 804c05e:	bf00      	nop
 804c060:	7fc00000 	.word	0x7fc00000

0804c064 <_free_r>:
 804c064:	b538      	push	{r3, r4, r5, lr}
 804c066:	4605      	mov	r5, r0
 804c068:	2900      	cmp	r1, #0
 804c06a:	d041      	beq.n	804c0f0 <_free_r+0x8c>
 804c06c:	f851 3c04 	ldr.w	r3, [r1, #-4]
 804c070:	1f0c      	subs	r4, r1, #4
 804c072:	2b00      	cmp	r3, #0
 804c074:	bfb8      	it	lt
 804c076:	18e4      	addlt	r4, r4, r3
 804c078:	f7ff fca0 	bl	804b9bc <__malloc_lock>
 804c07c:	4a1d      	ldr	r2, [pc, #116]	@ (804c0f4 <_free_r+0x90>)
 804c07e:	6813      	ldr	r3, [r2, #0]
 804c080:	b933      	cbnz	r3, 804c090 <_free_r+0x2c>
 804c082:	6063      	str	r3, [r4, #4]
 804c084:	6014      	str	r4, [r2, #0]
 804c086:	4628      	mov	r0, r5
 804c088:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 804c08c:	f7ff bc9c 	b.w	804b9c8 <__malloc_unlock>
 804c090:	42a3      	cmp	r3, r4
 804c092:	d908      	bls.n	804c0a6 <_free_r+0x42>
 804c094:	6820      	ldr	r0, [r4, #0]
 804c096:	1821      	adds	r1, r4, r0
 804c098:	428b      	cmp	r3, r1
 804c09a:	bf01      	itttt	eq
 804c09c:	6819      	ldreq	r1, [r3, #0]
 804c09e:	685b      	ldreq	r3, [r3, #4]
 804c0a0:	1809      	addeq	r1, r1, r0
 804c0a2:	6021      	streq	r1, [r4, #0]
 804c0a4:	e7ed      	b.n	804c082 <_free_r+0x1e>
 804c0a6:	461a      	mov	r2, r3
 804c0a8:	685b      	ldr	r3, [r3, #4]
 804c0aa:	b10b      	cbz	r3, 804c0b0 <_free_r+0x4c>
 804c0ac:	42a3      	cmp	r3, r4
 804c0ae:	d9fa      	bls.n	804c0a6 <_free_r+0x42>
 804c0b0:	6811      	ldr	r1, [r2, #0]
 804c0b2:	1850      	adds	r0, r2, r1
 804c0b4:	42a0      	cmp	r0, r4
 804c0b6:	d10b      	bne.n	804c0d0 <_free_r+0x6c>
 804c0b8:	6820      	ldr	r0, [r4, #0]
 804c0ba:	4401      	add	r1, r0
 804c0bc:	1850      	adds	r0, r2, r1
 804c0be:	6011      	str	r1, [r2, #0]
 804c0c0:	4283      	cmp	r3, r0
 804c0c2:	d1e0      	bne.n	804c086 <_free_r+0x22>
 804c0c4:	6818      	ldr	r0, [r3, #0]
 804c0c6:	685b      	ldr	r3, [r3, #4]
 804c0c8:	4408      	add	r0, r1
 804c0ca:	6053      	str	r3, [r2, #4]
 804c0cc:	6010      	str	r0, [r2, #0]
 804c0ce:	e7da      	b.n	804c086 <_free_r+0x22>
 804c0d0:	d902      	bls.n	804c0d8 <_free_r+0x74>
 804c0d2:	230c      	movs	r3, #12
 804c0d4:	602b      	str	r3, [r5, #0]
 804c0d6:	e7d6      	b.n	804c086 <_free_r+0x22>
 804c0d8:	6820      	ldr	r0, [r4, #0]
 804c0da:	1821      	adds	r1, r4, r0
 804c0dc:	428b      	cmp	r3, r1
 804c0de:	bf02      	ittt	eq
 804c0e0:	6819      	ldreq	r1, [r3, #0]
 804c0e2:	685b      	ldreq	r3, [r3, #4]
 804c0e4:	1809      	addeq	r1, r1, r0
 804c0e6:	6063      	str	r3, [r4, #4]
 804c0e8:	bf08      	it	eq
 804c0ea:	6021      	streq	r1, [r4, #0]
 804c0ec:	6054      	str	r4, [r2, #4]
 804c0ee:	e7ca      	b.n	804c086 <_free_r+0x22>
 804c0f0:	bd38      	pop	{r3, r4, r5, pc}
 804c0f2:	bf00      	nop
 804c0f4:	20018adc 	.word	0x20018adc

0804c0f8 <_malloc_usable_size_r>:
 804c0f8:	f851 3c04 	ldr.w	r3, [r1, #-4]
 804c0fc:	1f18      	subs	r0, r3, #4
 804c0fe:	2b00      	cmp	r3, #0
 804c100:	bfbc      	itt	lt
 804c102:	580b      	ldrlt	r3, [r1, r0]
 804c104:	18c0      	addlt	r0, r0, r3
 804c106:	4770      	bx	lr

0804c108 <__ssputs_r>:
 804c108:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 804c10c:	461f      	mov	r7, r3
 804c10e:	688e      	ldr	r6, [r1, #8]
 804c110:	4682      	mov	sl, r0
 804c112:	460c      	mov	r4, r1
 804c114:	42be      	cmp	r6, r7
 804c116:	4690      	mov	r8, r2
 804c118:	680b      	ldr	r3, [r1, #0]
 804c11a:	d82d      	bhi.n	804c178 <__ssputs_r+0x70>
 804c11c:	f9b1 200c 	ldrsh.w	r2, [r1, #12]
 804c120:	f412 6f90 	tst.w	r2, #1152	@ 0x480
 804c124:	d026      	beq.n	804c174 <__ssputs_r+0x6c>
 804c126:	6965      	ldr	r5, [r4, #20]
 804c128:	6909      	ldr	r1, [r1, #16]
 804c12a:	eb05 0545 	add.w	r5, r5, r5, lsl #1
 804c12e:	eba3 0901 	sub.w	r9, r3, r1
 804c132:	1c7b      	adds	r3, r7, #1
 804c134:	eb05 75d5 	add.w	r5, r5, r5, lsr #31
 804c138:	444b      	add	r3, r9
 804c13a:	106d      	asrs	r5, r5, #1
 804c13c:	429d      	cmp	r5, r3
 804c13e:	bf38      	it	cc
 804c140:	461d      	movcc	r5, r3
 804c142:	0553      	lsls	r3, r2, #21
 804c144:	d527      	bpl.n	804c196 <__ssputs_r+0x8e>
 804c146:	4629      	mov	r1, r5
 804c148:	f7ff fbb8 	bl	804b8bc <_malloc_r>
 804c14c:	4606      	mov	r6, r0
 804c14e:	b360      	cbz	r0, 804c1aa <__ssputs_r+0xa2>
 804c150:	464a      	mov	r2, r9
 804c152:	6921      	ldr	r1, [r4, #16]
 804c154:	f7ff ff6b 	bl	804c02e <memcpy>
 804c158:	89a3      	ldrh	r3, [r4, #12]
 804c15a:	f423 6390 	bic.w	r3, r3, #1152	@ 0x480
 804c15e:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 804c162:	81a3      	strh	r3, [r4, #12]
 804c164:	6126      	str	r6, [r4, #16]
 804c166:	444e      	add	r6, r9
 804c168:	6165      	str	r5, [r4, #20]
 804c16a:	eba5 0509 	sub.w	r5, r5, r9
 804c16e:	6026      	str	r6, [r4, #0]
 804c170:	463e      	mov	r6, r7
 804c172:	60a5      	str	r5, [r4, #8]
 804c174:	42be      	cmp	r6, r7
 804c176:	d900      	bls.n	804c17a <__ssputs_r+0x72>
 804c178:	463e      	mov	r6, r7
 804c17a:	4632      	mov	r2, r6
 804c17c:	4641      	mov	r1, r8
 804c17e:	6820      	ldr	r0, [r4, #0]
 804c180:	f000 fcfb 	bl	804cb7a <memmove>
 804c184:	68a3      	ldr	r3, [r4, #8]
 804c186:	2000      	movs	r0, #0
 804c188:	1b9b      	subs	r3, r3, r6
 804c18a:	60a3      	str	r3, [r4, #8]
 804c18c:	6823      	ldr	r3, [r4, #0]
 804c18e:	4433      	add	r3, r6
 804c190:	6023      	str	r3, [r4, #0]
 804c192:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 804c196:	462a      	mov	r2, r5
 804c198:	f7ff fc52 	bl	804ba40 <_realloc_r>
 804c19c:	4606      	mov	r6, r0
 804c19e:	2800      	cmp	r0, #0
 804c1a0:	d1e0      	bne.n	804c164 <__ssputs_r+0x5c>
 804c1a2:	6921      	ldr	r1, [r4, #16]
 804c1a4:	4650      	mov	r0, sl
 804c1a6:	f7ff ff5d 	bl	804c064 <_free_r>
 804c1aa:	230c      	movs	r3, #12
 804c1ac:	f04f 30ff 	mov.w	r0, #4294967295
 804c1b0:	f8ca 3000 	str.w	r3, [sl]
 804c1b4:	89a3      	ldrh	r3, [r4, #12]
 804c1b6:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 804c1ba:	81a3      	strh	r3, [r4, #12]
 804c1bc:	e7e9      	b.n	804c192 <__ssputs_r+0x8a>
	...

0804c1c0 <_svfiprintf_r>:
 804c1c0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 804c1c4:	4698      	mov	r8, r3
 804c1c6:	898b      	ldrh	r3, [r1, #12]
 804c1c8:	b09d      	sub	sp, #116	@ 0x74
 804c1ca:	4607      	mov	r7, r0
 804c1cc:	061b      	lsls	r3, r3, #24
 804c1ce:	460d      	mov	r5, r1
 804c1d0:	4614      	mov	r4, r2
 804c1d2:	d510      	bpl.n	804c1f6 <_svfiprintf_r+0x36>
 804c1d4:	690b      	ldr	r3, [r1, #16]
 804c1d6:	b973      	cbnz	r3, 804c1f6 <_svfiprintf_r+0x36>
 804c1d8:	2140      	movs	r1, #64	@ 0x40
 804c1da:	f7ff fb6f 	bl	804b8bc <_malloc_r>
 804c1de:	6028      	str	r0, [r5, #0]
 804c1e0:	6128      	str	r0, [r5, #16]
 804c1e2:	b930      	cbnz	r0, 804c1f2 <_svfiprintf_r+0x32>
 804c1e4:	230c      	movs	r3, #12
 804c1e6:	603b      	str	r3, [r7, #0]
 804c1e8:	f04f 30ff 	mov.w	r0, #4294967295
 804c1ec:	b01d      	add	sp, #116	@ 0x74
 804c1ee:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 804c1f2:	2340      	movs	r3, #64	@ 0x40
 804c1f4:	616b      	str	r3, [r5, #20]
 804c1f6:	2300      	movs	r3, #0
 804c1f8:	f8cd 800c 	str.w	r8, [sp, #12]
 804c1fc:	f04f 0901 	mov.w	r9, #1
 804c200:	f8df 81a0 	ldr.w	r8, [pc, #416]	@ 804c3a4 <_svfiprintf_r+0x1e4>
 804c204:	9309      	str	r3, [sp, #36]	@ 0x24
 804c206:	2320      	movs	r3, #32
 804c208:	f88d 3029 	strb.w	r3, [sp, #41]	@ 0x29
 804c20c:	2330      	movs	r3, #48	@ 0x30
 804c20e:	f88d 302a 	strb.w	r3, [sp, #42]	@ 0x2a
 804c212:	4623      	mov	r3, r4
 804c214:	469a      	mov	sl, r3
 804c216:	f813 2b01 	ldrb.w	r2, [r3], #1
 804c21a:	b10a      	cbz	r2, 804c220 <_svfiprintf_r+0x60>
 804c21c:	2a25      	cmp	r2, #37	@ 0x25
 804c21e:	d1f9      	bne.n	804c214 <_svfiprintf_r+0x54>
 804c220:	ebba 0b04 	subs.w	fp, sl, r4
 804c224:	d00b      	beq.n	804c23e <_svfiprintf_r+0x7e>
 804c226:	465b      	mov	r3, fp
 804c228:	4622      	mov	r2, r4
 804c22a:	4629      	mov	r1, r5
 804c22c:	4638      	mov	r0, r7
 804c22e:	f7ff ff6b 	bl	804c108 <__ssputs_r>
 804c232:	3001      	adds	r0, #1
 804c234:	f000 80a7 	beq.w	804c386 <_svfiprintf_r+0x1c6>
 804c238:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 804c23a:	445a      	add	r2, fp
 804c23c:	9209      	str	r2, [sp, #36]	@ 0x24
 804c23e:	f89a 3000 	ldrb.w	r3, [sl]
 804c242:	2b00      	cmp	r3, #0
 804c244:	f000 809f 	beq.w	804c386 <_svfiprintf_r+0x1c6>
 804c248:	2300      	movs	r3, #0
 804c24a:	f04f 32ff 	mov.w	r2, #4294967295
 804c24e:	f10a 0a01 	add.w	sl, sl, #1
 804c252:	9304      	str	r3, [sp, #16]
 804c254:	9307      	str	r3, [sp, #28]
 804c256:	f88d 3053 	strb.w	r3, [sp, #83]	@ 0x53
 804c25a:	931a      	str	r3, [sp, #104]	@ 0x68
 804c25c:	e9cd 2305 	strd	r2, r3, [sp, #20]
 804c260:	4654      	mov	r4, sl
 804c262:	2205      	movs	r2, #5
 804c264:	484f      	ldr	r0, [pc, #316]	@ (804c3a4 <_svfiprintf_r+0x1e4>)
 804c266:	f814 1b01 	ldrb.w	r1, [r4], #1
 804c26a:	f000 fcc3 	bl	804cbf4 <memchr>
 804c26e:	9a04      	ldr	r2, [sp, #16]
 804c270:	b9d8      	cbnz	r0, 804c2aa <_svfiprintf_r+0xea>
 804c272:	06d0      	lsls	r0, r2, #27
 804c274:	bf44      	itt	mi
 804c276:	2320      	movmi	r3, #32
 804c278:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
 804c27c:	0711      	lsls	r1, r2, #28
 804c27e:	bf44      	itt	mi
 804c280:	232b      	movmi	r3, #43	@ 0x2b
 804c282:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
 804c286:	f89a 3000 	ldrb.w	r3, [sl]
 804c28a:	2b2a      	cmp	r3, #42	@ 0x2a
 804c28c:	d015      	beq.n	804c2ba <_svfiprintf_r+0xfa>
 804c28e:	9a07      	ldr	r2, [sp, #28]
 804c290:	4654      	mov	r4, sl
 804c292:	2000      	movs	r0, #0
 804c294:	f04f 0c0a 	mov.w	ip, #10
 804c298:	4621      	mov	r1, r4
 804c29a:	f811 3b01 	ldrb.w	r3, [r1], #1
 804c29e:	3b30      	subs	r3, #48	@ 0x30
 804c2a0:	2b09      	cmp	r3, #9
 804c2a2:	d94b      	bls.n	804c33c <_svfiprintf_r+0x17c>
 804c2a4:	b1b0      	cbz	r0, 804c2d4 <_svfiprintf_r+0x114>
 804c2a6:	9207      	str	r2, [sp, #28]
 804c2a8:	e014      	b.n	804c2d4 <_svfiprintf_r+0x114>
 804c2aa:	eba0 0308 	sub.w	r3, r0, r8
 804c2ae:	46a2      	mov	sl, r4
 804c2b0:	fa09 f303 	lsl.w	r3, r9, r3
 804c2b4:	4313      	orrs	r3, r2
 804c2b6:	9304      	str	r3, [sp, #16]
 804c2b8:	e7d2      	b.n	804c260 <_svfiprintf_r+0xa0>
 804c2ba:	9b03      	ldr	r3, [sp, #12]
 804c2bc:	1d19      	adds	r1, r3, #4
 804c2be:	681b      	ldr	r3, [r3, #0]
 804c2c0:	2b00      	cmp	r3, #0
 804c2c2:	9103      	str	r1, [sp, #12]
 804c2c4:	bfbb      	ittet	lt
 804c2c6:	425b      	neglt	r3, r3
 804c2c8:	f042 0202 	orrlt.w	r2, r2, #2
 804c2cc:	9307      	strge	r3, [sp, #28]
 804c2ce:	9307      	strlt	r3, [sp, #28]
 804c2d0:	bfb8      	it	lt
 804c2d2:	9204      	strlt	r2, [sp, #16]
 804c2d4:	7823      	ldrb	r3, [r4, #0]
 804c2d6:	2b2e      	cmp	r3, #46	@ 0x2e
 804c2d8:	d10a      	bne.n	804c2f0 <_svfiprintf_r+0x130>
 804c2da:	7863      	ldrb	r3, [r4, #1]
 804c2dc:	2b2a      	cmp	r3, #42	@ 0x2a
 804c2de:	d132      	bne.n	804c346 <_svfiprintf_r+0x186>
 804c2e0:	9b03      	ldr	r3, [sp, #12]
 804c2e2:	3402      	adds	r4, #2
 804c2e4:	1d1a      	adds	r2, r3, #4
 804c2e6:	681b      	ldr	r3, [r3, #0]
 804c2e8:	ea43 73e3 	orr.w	r3, r3, r3, asr #31
 804c2ec:	9203      	str	r2, [sp, #12]
 804c2ee:	9305      	str	r3, [sp, #20]
 804c2f0:	f8df a0c0 	ldr.w	sl, [pc, #192]	@ 804c3b4 <_svfiprintf_r+0x1f4>
 804c2f4:	2203      	movs	r2, #3
 804c2f6:	7821      	ldrb	r1, [r4, #0]
 804c2f8:	4650      	mov	r0, sl
 804c2fa:	f000 fc7b 	bl	804cbf4 <memchr>
 804c2fe:	b138      	cbz	r0, 804c310 <_svfiprintf_r+0x150>
 804c300:	eba0 000a 	sub.w	r0, r0, sl
 804c304:	2240      	movs	r2, #64	@ 0x40
 804c306:	9b04      	ldr	r3, [sp, #16]
 804c308:	3401      	adds	r4, #1
 804c30a:	4082      	lsls	r2, r0
 804c30c:	4313      	orrs	r3, r2
 804c30e:	9304      	str	r3, [sp, #16]
 804c310:	f814 1b01 	ldrb.w	r1, [r4], #1
 804c314:	2206      	movs	r2, #6
 804c316:	4824      	ldr	r0, [pc, #144]	@ (804c3a8 <_svfiprintf_r+0x1e8>)
 804c318:	f88d 1028 	strb.w	r1, [sp, #40]	@ 0x28
 804c31c:	f000 fc6a 	bl	804cbf4 <memchr>
 804c320:	2800      	cmp	r0, #0
 804c322:	d036      	beq.n	804c392 <_svfiprintf_r+0x1d2>
 804c324:	4b21      	ldr	r3, [pc, #132]	@ (804c3ac <_svfiprintf_r+0x1ec>)
 804c326:	bb1b      	cbnz	r3, 804c370 <_svfiprintf_r+0x1b0>
 804c328:	9b03      	ldr	r3, [sp, #12]
 804c32a:	3307      	adds	r3, #7
 804c32c:	f023 0307 	bic.w	r3, r3, #7
 804c330:	3308      	adds	r3, #8
 804c332:	9303      	str	r3, [sp, #12]
 804c334:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 804c336:	4433      	add	r3, r6
 804c338:	9309      	str	r3, [sp, #36]	@ 0x24
 804c33a:	e76a      	b.n	804c212 <_svfiprintf_r+0x52>
 804c33c:	fb0c 3202 	mla	r2, ip, r2, r3
 804c340:	460c      	mov	r4, r1
 804c342:	2001      	movs	r0, #1
 804c344:	e7a8      	b.n	804c298 <_svfiprintf_r+0xd8>
 804c346:	2300      	movs	r3, #0
 804c348:	3401      	adds	r4, #1
 804c34a:	f04f 0c0a 	mov.w	ip, #10
 804c34e:	4619      	mov	r1, r3
 804c350:	9305      	str	r3, [sp, #20]
 804c352:	4620      	mov	r0, r4
 804c354:	f810 2b01 	ldrb.w	r2, [r0], #1
 804c358:	3a30      	subs	r2, #48	@ 0x30
 804c35a:	2a09      	cmp	r2, #9
 804c35c:	d903      	bls.n	804c366 <_svfiprintf_r+0x1a6>
 804c35e:	2b00      	cmp	r3, #0
 804c360:	d0c6      	beq.n	804c2f0 <_svfiprintf_r+0x130>
 804c362:	9105      	str	r1, [sp, #20]
 804c364:	e7c4      	b.n	804c2f0 <_svfiprintf_r+0x130>
 804c366:	fb0c 2101 	mla	r1, ip, r1, r2
 804c36a:	4604      	mov	r4, r0
 804c36c:	2301      	movs	r3, #1
 804c36e:	e7f0      	b.n	804c352 <_svfiprintf_r+0x192>
 804c370:	ab03      	add	r3, sp, #12
 804c372:	462a      	mov	r2, r5
 804c374:	a904      	add	r1, sp, #16
 804c376:	4638      	mov	r0, r7
 804c378:	9300      	str	r3, [sp, #0]
 804c37a:	4b0d      	ldr	r3, [pc, #52]	@ (804c3b0 <_svfiprintf_r+0x1f0>)
 804c37c:	f3af 8000 	nop.w
 804c380:	1c42      	adds	r2, r0, #1
 804c382:	4606      	mov	r6, r0
 804c384:	d1d6      	bne.n	804c334 <_svfiprintf_r+0x174>
 804c386:	89ab      	ldrh	r3, [r5, #12]
 804c388:	065b      	lsls	r3, r3, #25
 804c38a:	f53f af2d 	bmi.w	804c1e8 <_svfiprintf_r+0x28>
 804c38e:	9809      	ldr	r0, [sp, #36]	@ 0x24
 804c390:	e72c      	b.n	804c1ec <_svfiprintf_r+0x2c>
 804c392:	ab03      	add	r3, sp, #12
 804c394:	462a      	mov	r2, r5
 804c396:	a904      	add	r1, sp, #16
 804c398:	4638      	mov	r0, r7
 804c39a:	9300      	str	r3, [sp, #0]
 804c39c:	4b04      	ldr	r3, [pc, #16]	@ (804c3b0 <_svfiprintf_r+0x1f0>)
 804c39e:	f000 f9bf 	bl	804c720 <_printf_i>
 804c3a2:	e7ed      	b.n	804c380 <_svfiprintf_r+0x1c0>
 804c3a4:	0804e6a5 	.word	0x0804e6a5
 804c3a8:	0804e6af 	.word	0x0804e6af
 804c3ac:	00000000 	.word	0x00000000
 804c3b0:	0804c109 	.word	0x0804c109
 804c3b4:	0804e6ab 	.word	0x0804e6ab

0804c3b8 <__sfputc_r>:
 804c3b8:	6893      	ldr	r3, [r2, #8]
 804c3ba:	3b01      	subs	r3, #1
 804c3bc:	2b00      	cmp	r3, #0
 804c3be:	6093      	str	r3, [r2, #8]
 804c3c0:	b410      	push	{r4}
 804c3c2:	da08      	bge.n	804c3d6 <__sfputc_r+0x1e>
 804c3c4:	6994      	ldr	r4, [r2, #24]
 804c3c6:	42a3      	cmp	r3, r4
 804c3c8:	db01      	blt.n	804c3ce <__sfputc_r+0x16>
 804c3ca:	290a      	cmp	r1, #10
 804c3cc:	d103      	bne.n	804c3d6 <__sfputc_r+0x1e>
 804c3ce:	f85d 4b04 	ldr.w	r4, [sp], #4
 804c3d2:	f7ff bc9a 	b.w	804bd0a <__swbuf_r>
 804c3d6:	6813      	ldr	r3, [r2, #0]
 804c3d8:	1c58      	adds	r0, r3, #1
 804c3da:	6010      	str	r0, [r2, #0]
 804c3dc:	4608      	mov	r0, r1
 804c3de:	7019      	strb	r1, [r3, #0]
 804c3e0:	f85d 4b04 	ldr.w	r4, [sp], #4
 804c3e4:	4770      	bx	lr

0804c3e6 <__sfputs_r>:
 804c3e6:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 804c3e8:	4606      	mov	r6, r0
 804c3ea:	460f      	mov	r7, r1
 804c3ec:	4614      	mov	r4, r2
 804c3ee:	18d5      	adds	r5, r2, r3
 804c3f0:	42ac      	cmp	r4, r5
 804c3f2:	d101      	bne.n	804c3f8 <__sfputs_r+0x12>
 804c3f4:	2000      	movs	r0, #0
 804c3f6:	e007      	b.n	804c408 <__sfputs_r+0x22>
 804c3f8:	463a      	mov	r2, r7
 804c3fa:	f814 1b01 	ldrb.w	r1, [r4], #1
 804c3fe:	4630      	mov	r0, r6
 804c400:	f7ff ffda 	bl	804c3b8 <__sfputc_r>
 804c404:	1c43      	adds	r3, r0, #1
 804c406:	d1f3      	bne.n	804c3f0 <__sfputs_r+0xa>
 804c408:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

0804c40c <_vfiprintf_r>:
 804c40c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 804c410:	460d      	mov	r5, r1
 804c412:	b09d      	sub	sp, #116	@ 0x74
 804c414:	4614      	mov	r4, r2
 804c416:	4698      	mov	r8, r3
 804c418:	4606      	mov	r6, r0
 804c41a:	b118      	cbz	r0, 804c424 <_vfiprintf_r+0x18>
 804c41c:	6a03      	ldr	r3, [r0, #32]
 804c41e:	b90b      	cbnz	r3, 804c424 <_vfiprintf_r+0x18>
 804c420:	f7ff fbc8 	bl	804bbb4 <__sinit>
 804c424:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
 804c426:	07d9      	lsls	r1, r3, #31
 804c428:	d405      	bmi.n	804c436 <_vfiprintf_r+0x2a>
 804c42a:	89ab      	ldrh	r3, [r5, #12]
 804c42c:	059a      	lsls	r2, r3, #22
 804c42e:	d402      	bmi.n	804c436 <_vfiprintf_r+0x2a>
 804c430:	6da8      	ldr	r0, [r5, #88]	@ 0x58
 804c432:	f7ff fdfa 	bl	804c02a <__retarget_lock_acquire_recursive>
 804c436:	89ab      	ldrh	r3, [r5, #12]
 804c438:	071b      	lsls	r3, r3, #28
 804c43a:	d501      	bpl.n	804c440 <_vfiprintf_r+0x34>
 804c43c:	692b      	ldr	r3, [r5, #16]
 804c43e:	b99b      	cbnz	r3, 804c468 <_vfiprintf_r+0x5c>
 804c440:	4629      	mov	r1, r5
 804c442:	4630      	mov	r0, r6
 804c444:	f7ff fca0 	bl	804bd88 <__swsetup_r>
 804c448:	b170      	cbz	r0, 804c468 <_vfiprintf_r+0x5c>
 804c44a:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
 804c44c:	07dc      	lsls	r4, r3, #31
 804c44e:	d504      	bpl.n	804c45a <_vfiprintf_r+0x4e>
 804c450:	f04f 30ff 	mov.w	r0, #4294967295
 804c454:	b01d      	add	sp, #116	@ 0x74
 804c456:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 804c45a:	89ab      	ldrh	r3, [r5, #12]
 804c45c:	0598      	lsls	r0, r3, #22
 804c45e:	d4f7      	bmi.n	804c450 <_vfiprintf_r+0x44>
 804c460:	6da8      	ldr	r0, [r5, #88]	@ 0x58
 804c462:	f7ff fde3 	bl	804c02c <__retarget_lock_release_recursive>
 804c466:	e7f3      	b.n	804c450 <_vfiprintf_r+0x44>
 804c468:	2300      	movs	r3, #0
 804c46a:	f8cd 800c 	str.w	r8, [sp, #12]
 804c46e:	f04f 0901 	mov.w	r9, #1
 804c472:	f8df 81b4 	ldr.w	r8, [pc, #436]	@ 804c628 <_vfiprintf_r+0x21c>
 804c476:	9309      	str	r3, [sp, #36]	@ 0x24
 804c478:	2320      	movs	r3, #32
 804c47a:	f88d 3029 	strb.w	r3, [sp, #41]	@ 0x29
 804c47e:	2330      	movs	r3, #48	@ 0x30
 804c480:	f88d 302a 	strb.w	r3, [sp, #42]	@ 0x2a
 804c484:	4623      	mov	r3, r4
 804c486:	469a      	mov	sl, r3
 804c488:	f813 2b01 	ldrb.w	r2, [r3], #1
 804c48c:	b10a      	cbz	r2, 804c492 <_vfiprintf_r+0x86>
 804c48e:	2a25      	cmp	r2, #37	@ 0x25
 804c490:	d1f9      	bne.n	804c486 <_vfiprintf_r+0x7a>
 804c492:	ebba 0b04 	subs.w	fp, sl, r4
 804c496:	d00b      	beq.n	804c4b0 <_vfiprintf_r+0xa4>
 804c498:	465b      	mov	r3, fp
 804c49a:	4622      	mov	r2, r4
 804c49c:	4629      	mov	r1, r5
 804c49e:	4630      	mov	r0, r6
 804c4a0:	f7ff ffa1 	bl	804c3e6 <__sfputs_r>
 804c4a4:	3001      	adds	r0, #1
 804c4a6:	f000 80a7 	beq.w	804c5f8 <_vfiprintf_r+0x1ec>
 804c4aa:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 804c4ac:	445a      	add	r2, fp
 804c4ae:	9209      	str	r2, [sp, #36]	@ 0x24
 804c4b0:	f89a 3000 	ldrb.w	r3, [sl]
 804c4b4:	2b00      	cmp	r3, #0
 804c4b6:	f000 809f 	beq.w	804c5f8 <_vfiprintf_r+0x1ec>
 804c4ba:	2300      	movs	r3, #0
 804c4bc:	f04f 32ff 	mov.w	r2, #4294967295
 804c4c0:	f10a 0a01 	add.w	sl, sl, #1
 804c4c4:	9304      	str	r3, [sp, #16]
 804c4c6:	9307      	str	r3, [sp, #28]
 804c4c8:	f88d 3053 	strb.w	r3, [sp, #83]	@ 0x53
 804c4cc:	931a      	str	r3, [sp, #104]	@ 0x68
 804c4ce:	e9cd 2305 	strd	r2, r3, [sp, #20]
 804c4d2:	4654      	mov	r4, sl
 804c4d4:	2205      	movs	r2, #5
 804c4d6:	4854      	ldr	r0, [pc, #336]	@ (804c628 <_vfiprintf_r+0x21c>)
 804c4d8:	f814 1b01 	ldrb.w	r1, [r4], #1
 804c4dc:	f000 fb8a 	bl	804cbf4 <memchr>
 804c4e0:	9a04      	ldr	r2, [sp, #16]
 804c4e2:	b9d8      	cbnz	r0, 804c51c <_vfiprintf_r+0x110>
 804c4e4:	06d1      	lsls	r1, r2, #27
 804c4e6:	bf44      	itt	mi
 804c4e8:	2320      	movmi	r3, #32
 804c4ea:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
 804c4ee:	0713      	lsls	r3, r2, #28
 804c4f0:	bf44      	itt	mi
 804c4f2:	232b      	movmi	r3, #43	@ 0x2b
 804c4f4:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
 804c4f8:	f89a 3000 	ldrb.w	r3, [sl]
 804c4fc:	2b2a      	cmp	r3, #42	@ 0x2a
 804c4fe:	d015      	beq.n	804c52c <_vfiprintf_r+0x120>
 804c500:	9a07      	ldr	r2, [sp, #28]
 804c502:	4654      	mov	r4, sl
 804c504:	2000      	movs	r0, #0
 804c506:	f04f 0c0a 	mov.w	ip, #10
 804c50a:	4621      	mov	r1, r4
 804c50c:	f811 3b01 	ldrb.w	r3, [r1], #1
 804c510:	3b30      	subs	r3, #48	@ 0x30
 804c512:	2b09      	cmp	r3, #9
 804c514:	d94b      	bls.n	804c5ae <_vfiprintf_r+0x1a2>
 804c516:	b1b0      	cbz	r0, 804c546 <_vfiprintf_r+0x13a>
 804c518:	9207      	str	r2, [sp, #28]
 804c51a:	e014      	b.n	804c546 <_vfiprintf_r+0x13a>
 804c51c:	eba0 0308 	sub.w	r3, r0, r8
 804c520:	46a2      	mov	sl, r4
 804c522:	fa09 f303 	lsl.w	r3, r9, r3
 804c526:	4313      	orrs	r3, r2
 804c528:	9304      	str	r3, [sp, #16]
 804c52a:	e7d2      	b.n	804c4d2 <_vfiprintf_r+0xc6>
 804c52c:	9b03      	ldr	r3, [sp, #12]
 804c52e:	1d19      	adds	r1, r3, #4
 804c530:	681b      	ldr	r3, [r3, #0]
 804c532:	2b00      	cmp	r3, #0
 804c534:	9103      	str	r1, [sp, #12]
 804c536:	bfbb      	ittet	lt
 804c538:	425b      	neglt	r3, r3
 804c53a:	f042 0202 	orrlt.w	r2, r2, #2
 804c53e:	9307      	strge	r3, [sp, #28]
 804c540:	9307      	strlt	r3, [sp, #28]
 804c542:	bfb8      	it	lt
 804c544:	9204      	strlt	r2, [sp, #16]
 804c546:	7823      	ldrb	r3, [r4, #0]
 804c548:	2b2e      	cmp	r3, #46	@ 0x2e
 804c54a:	d10a      	bne.n	804c562 <_vfiprintf_r+0x156>
 804c54c:	7863      	ldrb	r3, [r4, #1]
 804c54e:	2b2a      	cmp	r3, #42	@ 0x2a
 804c550:	d132      	bne.n	804c5b8 <_vfiprintf_r+0x1ac>
 804c552:	9b03      	ldr	r3, [sp, #12]
 804c554:	3402      	adds	r4, #2
 804c556:	1d1a      	adds	r2, r3, #4
 804c558:	681b      	ldr	r3, [r3, #0]
 804c55a:	ea43 73e3 	orr.w	r3, r3, r3, asr #31
 804c55e:	9203      	str	r2, [sp, #12]
 804c560:	9305      	str	r3, [sp, #20]
 804c562:	f8df a0d4 	ldr.w	sl, [pc, #212]	@ 804c638 <_vfiprintf_r+0x22c>
 804c566:	2203      	movs	r2, #3
 804c568:	7821      	ldrb	r1, [r4, #0]
 804c56a:	4650      	mov	r0, sl
 804c56c:	f000 fb42 	bl	804cbf4 <memchr>
 804c570:	b138      	cbz	r0, 804c582 <_vfiprintf_r+0x176>
 804c572:	eba0 000a 	sub.w	r0, r0, sl
 804c576:	2240      	movs	r2, #64	@ 0x40
 804c578:	9b04      	ldr	r3, [sp, #16]
 804c57a:	3401      	adds	r4, #1
 804c57c:	4082      	lsls	r2, r0
 804c57e:	4313      	orrs	r3, r2
 804c580:	9304      	str	r3, [sp, #16]
 804c582:	f814 1b01 	ldrb.w	r1, [r4], #1
 804c586:	2206      	movs	r2, #6
 804c588:	4828      	ldr	r0, [pc, #160]	@ (804c62c <_vfiprintf_r+0x220>)
 804c58a:	f88d 1028 	strb.w	r1, [sp, #40]	@ 0x28
 804c58e:	f000 fb31 	bl	804cbf4 <memchr>
 804c592:	2800      	cmp	r0, #0
 804c594:	d03f      	beq.n	804c616 <_vfiprintf_r+0x20a>
 804c596:	4b26      	ldr	r3, [pc, #152]	@ (804c630 <_vfiprintf_r+0x224>)
 804c598:	bb1b      	cbnz	r3, 804c5e2 <_vfiprintf_r+0x1d6>
 804c59a:	9b03      	ldr	r3, [sp, #12]
 804c59c:	3307      	adds	r3, #7
 804c59e:	f023 0307 	bic.w	r3, r3, #7
 804c5a2:	3308      	adds	r3, #8
 804c5a4:	9303      	str	r3, [sp, #12]
 804c5a6:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 804c5a8:	443b      	add	r3, r7
 804c5aa:	9309      	str	r3, [sp, #36]	@ 0x24
 804c5ac:	e76a      	b.n	804c484 <_vfiprintf_r+0x78>
 804c5ae:	fb0c 3202 	mla	r2, ip, r2, r3
 804c5b2:	460c      	mov	r4, r1
 804c5b4:	2001      	movs	r0, #1
 804c5b6:	e7a8      	b.n	804c50a <_vfiprintf_r+0xfe>
 804c5b8:	2300      	movs	r3, #0
 804c5ba:	3401      	adds	r4, #1
 804c5bc:	f04f 0c0a 	mov.w	ip, #10
 804c5c0:	4619      	mov	r1, r3
 804c5c2:	9305      	str	r3, [sp, #20]
 804c5c4:	4620      	mov	r0, r4
 804c5c6:	f810 2b01 	ldrb.w	r2, [r0], #1
 804c5ca:	3a30      	subs	r2, #48	@ 0x30
 804c5cc:	2a09      	cmp	r2, #9
 804c5ce:	d903      	bls.n	804c5d8 <_vfiprintf_r+0x1cc>
 804c5d0:	2b00      	cmp	r3, #0
 804c5d2:	d0c6      	beq.n	804c562 <_vfiprintf_r+0x156>
 804c5d4:	9105      	str	r1, [sp, #20]
 804c5d6:	e7c4      	b.n	804c562 <_vfiprintf_r+0x156>
 804c5d8:	fb0c 2101 	mla	r1, ip, r1, r2
 804c5dc:	4604      	mov	r4, r0
 804c5de:	2301      	movs	r3, #1
 804c5e0:	e7f0      	b.n	804c5c4 <_vfiprintf_r+0x1b8>
 804c5e2:	ab03      	add	r3, sp, #12
 804c5e4:	462a      	mov	r2, r5
 804c5e6:	a904      	add	r1, sp, #16
 804c5e8:	4630      	mov	r0, r6
 804c5ea:	9300      	str	r3, [sp, #0]
 804c5ec:	4b11      	ldr	r3, [pc, #68]	@ (804c634 <_vfiprintf_r+0x228>)
 804c5ee:	f3af 8000 	nop.w
 804c5f2:	4607      	mov	r7, r0
 804c5f4:	1c78      	adds	r0, r7, #1
 804c5f6:	d1d6      	bne.n	804c5a6 <_vfiprintf_r+0x19a>
 804c5f8:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
 804c5fa:	07d9      	lsls	r1, r3, #31
 804c5fc:	d405      	bmi.n	804c60a <_vfiprintf_r+0x1fe>
 804c5fe:	89ab      	ldrh	r3, [r5, #12]
 804c600:	059a      	lsls	r2, r3, #22
 804c602:	d402      	bmi.n	804c60a <_vfiprintf_r+0x1fe>
 804c604:	6da8      	ldr	r0, [r5, #88]	@ 0x58
 804c606:	f7ff fd11 	bl	804c02c <__retarget_lock_release_recursive>
 804c60a:	89ab      	ldrh	r3, [r5, #12]
 804c60c:	065b      	lsls	r3, r3, #25
 804c60e:	f53f af1f 	bmi.w	804c450 <_vfiprintf_r+0x44>
 804c612:	9809      	ldr	r0, [sp, #36]	@ 0x24
 804c614:	e71e      	b.n	804c454 <_vfiprintf_r+0x48>
 804c616:	ab03      	add	r3, sp, #12
 804c618:	462a      	mov	r2, r5
 804c61a:	a904      	add	r1, sp, #16
 804c61c:	4630      	mov	r0, r6
 804c61e:	9300      	str	r3, [sp, #0]
 804c620:	4b04      	ldr	r3, [pc, #16]	@ (804c634 <_vfiprintf_r+0x228>)
 804c622:	f000 f87d 	bl	804c720 <_printf_i>
 804c626:	e7e4      	b.n	804c5f2 <_vfiprintf_r+0x1e6>
 804c628:	0804e6a5 	.word	0x0804e6a5
 804c62c:	0804e6af 	.word	0x0804e6af
 804c630:	00000000 	.word	0x00000000
 804c634:	0804c3e7 	.word	0x0804c3e7
 804c638:	0804e6ab 	.word	0x0804e6ab

0804c63c <_printf_common>:
 804c63c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 804c640:	4616      	mov	r6, r2
 804c642:	4698      	mov	r8, r3
 804c644:	688a      	ldr	r2, [r1, #8]
 804c646:	4607      	mov	r7, r0
 804c648:	690b      	ldr	r3, [r1, #16]
 804c64a:	460c      	mov	r4, r1
 804c64c:	f8dd 9020 	ldr.w	r9, [sp, #32]
 804c650:	4293      	cmp	r3, r2
 804c652:	bfb8      	it	lt
 804c654:	4613      	movlt	r3, r2
 804c656:	6033      	str	r3, [r6, #0]
 804c658:	f891 2043 	ldrb.w	r2, [r1, #67]	@ 0x43
 804c65c:	b10a      	cbz	r2, 804c662 <_printf_common+0x26>
 804c65e:	3301      	adds	r3, #1
 804c660:	6033      	str	r3, [r6, #0]
 804c662:	6823      	ldr	r3, [r4, #0]
 804c664:	0699      	lsls	r1, r3, #26
 804c666:	bf42      	ittt	mi
 804c668:	6833      	ldrmi	r3, [r6, #0]
 804c66a:	3302      	addmi	r3, #2
 804c66c:	6033      	strmi	r3, [r6, #0]
 804c66e:	6825      	ldr	r5, [r4, #0]
 804c670:	f015 0506 	ands.w	r5, r5, #6
 804c674:	d106      	bne.n	804c684 <_printf_common+0x48>
 804c676:	f104 0a19 	add.w	sl, r4, #25
 804c67a:	68e3      	ldr	r3, [r4, #12]
 804c67c:	6832      	ldr	r2, [r6, #0]
 804c67e:	1a9b      	subs	r3, r3, r2
 804c680:	42ab      	cmp	r3, r5
 804c682:	dc2b      	bgt.n	804c6dc <_printf_common+0xa0>
 804c684:	f894 3043 	ldrb.w	r3, [r4, #67]	@ 0x43
 804c688:	6822      	ldr	r2, [r4, #0]
 804c68a:	3b00      	subs	r3, #0
 804c68c:	bf18      	it	ne
 804c68e:	2301      	movne	r3, #1
 804c690:	0692      	lsls	r2, r2, #26
 804c692:	d430      	bmi.n	804c6f6 <_printf_common+0xba>
 804c694:	f104 0243 	add.w	r2, r4, #67	@ 0x43
 804c698:	4641      	mov	r1, r8
 804c69a:	4638      	mov	r0, r7
 804c69c:	47c8      	blx	r9
 804c69e:	3001      	adds	r0, #1
 804c6a0:	d023      	beq.n	804c6ea <_printf_common+0xae>
 804c6a2:	6823      	ldr	r3, [r4, #0]
 804c6a4:	341a      	adds	r4, #26
 804c6a6:	f854 2c0a 	ldr.w	r2, [r4, #-10]
 804c6aa:	f003 0306 	and.w	r3, r3, #6
 804c6ae:	2b04      	cmp	r3, #4
 804c6b0:	bf0a      	itet	eq
 804c6b2:	f854 5c0e 	ldreq.w	r5, [r4, #-14]
 804c6b6:	2500      	movne	r5, #0
 804c6b8:	6833      	ldreq	r3, [r6, #0]
 804c6ba:	f04f 0600 	mov.w	r6, #0
 804c6be:	bf08      	it	eq
 804c6c0:	1aed      	subeq	r5, r5, r3
 804c6c2:	f854 3c12 	ldr.w	r3, [r4, #-18]
 804c6c6:	bf08      	it	eq
 804c6c8:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
 804c6cc:	4293      	cmp	r3, r2
 804c6ce:	bfc4      	itt	gt
 804c6d0:	1a9b      	subgt	r3, r3, r2
 804c6d2:	18ed      	addgt	r5, r5, r3
 804c6d4:	42b5      	cmp	r5, r6
 804c6d6:	d11a      	bne.n	804c70e <_printf_common+0xd2>
 804c6d8:	2000      	movs	r0, #0
 804c6da:	e008      	b.n	804c6ee <_printf_common+0xb2>
 804c6dc:	2301      	movs	r3, #1
 804c6de:	4652      	mov	r2, sl
 804c6e0:	4641      	mov	r1, r8
 804c6e2:	4638      	mov	r0, r7
 804c6e4:	47c8      	blx	r9
 804c6e6:	3001      	adds	r0, #1
 804c6e8:	d103      	bne.n	804c6f2 <_printf_common+0xb6>
 804c6ea:	f04f 30ff 	mov.w	r0, #4294967295
 804c6ee:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 804c6f2:	3501      	adds	r5, #1
 804c6f4:	e7c1      	b.n	804c67a <_printf_common+0x3e>
 804c6f6:	18e1      	adds	r1, r4, r3
 804c6f8:	1c5a      	adds	r2, r3, #1
 804c6fa:	2030      	movs	r0, #48	@ 0x30
 804c6fc:	3302      	adds	r3, #2
 804c6fe:	4422      	add	r2, r4
 804c700:	f881 0043 	strb.w	r0, [r1, #67]	@ 0x43
 804c704:	f894 1045 	ldrb.w	r1, [r4, #69]	@ 0x45
 804c708:	f882 1043 	strb.w	r1, [r2, #67]	@ 0x43
 804c70c:	e7c2      	b.n	804c694 <_printf_common+0x58>
 804c70e:	2301      	movs	r3, #1
 804c710:	4622      	mov	r2, r4
 804c712:	4641      	mov	r1, r8
 804c714:	4638      	mov	r0, r7
 804c716:	47c8      	blx	r9
 804c718:	3001      	adds	r0, #1
 804c71a:	d0e6      	beq.n	804c6ea <_printf_common+0xae>
 804c71c:	3601      	adds	r6, #1
 804c71e:	e7d9      	b.n	804c6d4 <_printf_common+0x98>

0804c720 <_printf_i>:
 804c720:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 804c724:	7e0f      	ldrb	r7, [r1, #24]
 804c726:	4691      	mov	r9, r2
 804c728:	4680      	mov	r8, r0
 804c72a:	460c      	mov	r4, r1
 804c72c:	2f78      	cmp	r7, #120	@ 0x78
 804c72e:	469a      	mov	sl, r3
 804c730:	9e0c      	ldr	r6, [sp, #48]	@ 0x30
 804c732:	f101 0243 	add.w	r2, r1, #67	@ 0x43
 804c736:	d807      	bhi.n	804c748 <_printf_i+0x28>
 804c738:	2f62      	cmp	r7, #98	@ 0x62
 804c73a:	d80a      	bhi.n	804c752 <_printf_i+0x32>
 804c73c:	2f00      	cmp	r7, #0
 804c73e:	f000 80d2 	beq.w	804c8e6 <_printf_i+0x1c6>
 804c742:	2f58      	cmp	r7, #88	@ 0x58
 804c744:	f000 80b9 	beq.w	804c8ba <_printf_i+0x19a>
 804c748:	f104 0642 	add.w	r6, r4, #66	@ 0x42
 804c74c:	f884 7042 	strb.w	r7, [r4, #66]	@ 0x42
 804c750:	e03a      	b.n	804c7c8 <_printf_i+0xa8>
 804c752:	f1a7 0363 	sub.w	r3, r7, #99	@ 0x63
 804c756:	2b15      	cmp	r3, #21
 804c758:	d8f6      	bhi.n	804c748 <_printf_i+0x28>
 804c75a:	a101      	add	r1, pc, #4	@ (adr r1, 804c760 <_printf_i+0x40>)
 804c75c:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
 804c760:	0804c7b9 	.word	0x0804c7b9
 804c764:	0804c7cd 	.word	0x0804c7cd
 804c768:	0804c749 	.word	0x0804c749
 804c76c:	0804c749 	.word	0x0804c749
 804c770:	0804c749 	.word	0x0804c749
 804c774:	0804c749 	.word	0x0804c749
 804c778:	0804c7cd 	.word	0x0804c7cd
 804c77c:	0804c749 	.word	0x0804c749
 804c780:	0804c749 	.word	0x0804c749
 804c784:	0804c749 	.word	0x0804c749
 804c788:	0804c749 	.word	0x0804c749
 804c78c:	0804c8cd 	.word	0x0804c8cd
 804c790:	0804c7f7 	.word	0x0804c7f7
 804c794:	0804c887 	.word	0x0804c887
 804c798:	0804c749 	.word	0x0804c749
 804c79c:	0804c749 	.word	0x0804c749
 804c7a0:	0804c8ef 	.word	0x0804c8ef
 804c7a4:	0804c749 	.word	0x0804c749
 804c7a8:	0804c7f7 	.word	0x0804c7f7
 804c7ac:	0804c749 	.word	0x0804c749
 804c7b0:	0804c749 	.word	0x0804c749
 804c7b4:	0804c88f 	.word	0x0804c88f
 804c7b8:	6833      	ldr	r3, [r6, #0]
 804c7ba:	1d1a      	adds	r2, r3, #4
 804c7bc:	681b      	ldr	r3, [r3, #0]
 804c7be:	6032      	str	r2, [r6, #0]
 804c7c0:	f104 0642 	add.w	r6, r4, #66	@ 0x42
 804c7c4:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
 804c7c8:	2301      	movs	r3, #1
 804c7ca:	e09d      	b.n	804c908 <_printf_i+0x1e8>
 804c7cc:	6833      	ldr	r3, [r6, #0]
 804c7ce:	6820      	ldr	r0, [r4, #0]
 804c7d0:	1d19      	adds	r1, r3, #4
 804c7d2:	6031      	str	r1, [r6, #0]
 804c7d4:	0606      	lsls	r6, r0, #24
 804c7d6:	d501      	bpl.n	804c7dc <_printf_i+0xbc>
 804c7d8:	681d      	ldr	r5, [r3, #0]
 804c7da:	e003      	b.n	804c7e4 <_printf_i+0xc4>
 804c7dc:	0645      	lsls	r5, r0, #25
 804c7de:	d5fb      	bpl.n	804c7d8 <_printf_i+0xb8>
 804c7e0:	f9b3 5000 	ldrsh.w	r5, [r3]
 804c7e4:	2d00      	cmp	r5, #0
 804c7e6:	da03      	bge.n	804c7f0 <_printf_i+0xd0>
 804c7e8:	232d      	movs	r3, #45	@ 0x2d
 804c7ea:	426d      	negs	r5, r5
 804c7ec:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
 804c7f0:	4859      	ldr	r0, [pc, #356]	@ (804c958 <_printf_i+0x238>)
 804c7f2:	230a      	movs	r3, #10
 804c7f4:	e011      	b.n	804c81a <_printf_i+0xfa>
 804c7f6:	6821      	ldr	r1, [r4, #0]
 804c7f8:	6833      	ldr	r3, [r6, #0]
 804c7fa:	0608      	lsls	r0, r1, #24
 804c7fc:	f853 5b04 	ldr.w	r5, [r3], #4
 804c800:	d402      	bmi.n	804c808 <_printf_i+0xe8>
 804c802:	0649      	lsls	r1, r1, #25
 804c804:	bf48      	it	mi
 804c806:	b2ad      	uxthmi	r5, r5
 804c808:	2f6f      	cmp	r7, #111	@ 0x6f
 804c80a:	6033      	str	r3, [r6, #0]
 804c80c:	4852      	ldr	r0, [pc, #328]	@ (804c958 <_printf_i+0x238>)
 804c80e:	bf14      	ite	ne
 804c810:	230a      	movne	r3, #10
 804c812:	2308      	moveq	r3, #8
 804c814:	2100      	movs	r1, #0
 804c816:	f884 1043 	strb.w	r1, [r4, #67]	@ 0x43
 804c81a:	6866      	ldr	r6, [r4, #4]
 804c81c:	2e00      	cmp	r6, #0
 804c81e:	60a6      	str	r6, [r4, #8]
 804c820:	bfa2      	ittt	ge
 804c822:	6821      	ldrge	r1, [r4, #0]
 804c824:	f021 0104 	bicge.w	r1, r1, #4
 804c828:	6021      	strge	r1, [r4, #0]
 804c82a:	b90d      	cbnz	r5, 804c830 <_printf_i+0x110>
 804c82c:	2e00      	cmp	r6, #0
 804c82e:	d04b      	beq.n	804c8c8 <_printf_i+0x1a8>
 804c830:	4616      	mov	r6, r2
 804c832:	fbb5 f1f3 	udiv	r1, r5, r3
 804c836:	fb03 5711 	mls	r7, r3, r1, r5
 804c83a:	5dc7      	ldrb	r7, [r0, r7]
 804c83c:	f806 7d01 	strb.w	r7, [r6, #-1]!
 804c840:	462f      	mov	r7, r5
 804c842:	460d      	mov	r5, r1
 804c844:	42bb      	cmp	r3, r7
 804c846:	d9f4      	bls.n	804c832 <_printf_i+0x112>
 804c848:	2b08      	cmp	r3, #8
 804c84a:	d10b      	bne.n	804c864 <_printf_i+0x144>
 804c84c:	6823      	ldr	r3, [r4, #0]
 804c84e:	07df      	lsls	r7, r3, #31
 804c850:	d508      	bpl.n	804c864 <_printf_i+0x144>
 804c852:	6923      	ldr	r3, [r4, #16]
 804c854:	6861      	ldr	r1, [r4, #4]
 804c856:	4299      	cmp	r1, r3
 804c858:	bfde      	ittt	le
 804c85a:	2330      	movle	r3, #48	@ 0x30
 804c85c:	f806 3c01 	strble.w	r3, [r6, #-1]
 804c860:	f106 36ff 	addle.w	r6, r6, #4294967295
 804c864:	1b92      	subs	r2, r2, r6
 804c866:	6122      	str	r2, [r4, #16]
 804c868:	464b      	mov	r3, r9
 804c86a:	aa03      	add	r2, sp, #12
 804c86c:	4621      	mov	r1, r4
 804c86e:	4640      	mov	r0, r8
 804c870:	f8cd a000 	str.w	sl, [sp]
 804c874:	f7ff fee2 	bl	804c63c <_printf_common>
 804c878:	3001      	adds	r0, #1
 804c87a:	d14a      	bne.n	804c912 <_printf_i+0x1f2>
 804c87c:	f04f 30ff 	mov.w	r0, #4294967295
 804c880:	b004      	add	sp, #16
 804c882:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 804c886:	6823      	ldr	r3, [r4, #0]
 804c888:	f043 0320 	orr.w	r3, r3, #32
 804c88c:	6023      	str	r3, [r4, #0]
 804c88e:	2778      	movs	r7, #120	@ 0x78
 804c890:	4832      	ldr	r0, [pc, #200]	@ (804c95c <_printf_i+0x23c>)
 804c892:	6823      	ldr	r3, [r4, #0]
 804c894:	f884 7045 	strb.w	r7, [r4, #69]	@ 0x45
 804c898:	061f      	lsls	r7, r3, #24
 804c89a:	6831      	ldr	r1, [r6, #0]
 804c89c:	f851 5b04 	ldr.w	r5, [r1], #4
 804c8a0:	d402      	bmi.n	804c8a8 <_printf_i+0x188>
 804c8a2:	065f      	lsls	r7, r3, #25
 804c8a4:	bf48      	it	mi
 804c8a6:	b2ad      	uxthmi	r5, r5
 804c8a8:	6031      	str	r1, [r6, #0]
 804c8aa:	07d9      	lsls	r1, r3, #31
 804c8ac:	bf44      	itt	mi
 804c8ae:	f043 0320 	orrmi.w	r3, r3, #32
 804c8b2:	6023      	strmi	r3, [r4, #0]
 804c8b4:	b11d      	cbz	r5, 804c8be <_printf_i+0x19e>
 804c8b6:	2310      	movs	r3, #16
 804c8b8:	e7ac      	b.n	804c814 <_printf_i+0xf4>
 804c8ba:	4827      	ldr	r0, [pc, #156]	@ (804c958 <_printf_i+0x238>)
 804c8bc:	e7e9      	b.n	804c892 <_printf_i+0x172>
 804c8be:	6823      	ldr	r3, [r4, #0]
 804c8c0:	f023 0320 	bic.w	r3, r3, #32
 804c8c4:	6023      	str	r3, [r4, #0]
 804c8c6:	e7f6      	b.n	804c8b6 <_printf_i+0x196>
 804c8c8:	4616      	mov	r6, r2
 804c8ca:	e7bd      	b.n	804c848 <_printf_i+0x128>
 804c8cc:	6833      	ldr	r3, [r6, #0]
 804c8ce:	6825      	ldr	r5, [r4, #0]
 804c8d0:	1d18      	adds	r0, r3, #4
 804c8d2:	6961      	ldr	r1, [r4, #20]
 804c8d4:	6030      	str	r0, [r6, #0]
 804c8d6:	062e      	lsls	r6, r5, #24
 804c8d8:	681b      	ldr	r3, [r3, #0]
 804c8da:	d501      	bpl.n	804c8e0 <_printf_i+0x1c0>
 804c8dc:	6019      	str	r1, [r3, #0]
 804c8de:	e002      	b.n	804c8e6 <_printf_i+0x1c6>
 804c8e0:	0668      	lsls	r0, r5, #25
 804c8e2:	d5fb      	bpl.n	804c8dc <_printf_i+0x1bc>
 804c8e4:	8019      	strh	r1, [r3, #0]
 804c8e6:	2300      	movs	r3, #0
 804c8e8:	4616      	mov	r6, r2
 804c8ea:	6123      	str	r3, [r4, #16]
 804c8ec:	e7bc      	b.n	804c868 <_printf_i+0x148>
 804c8ee:	6833      	ldr	r3, [r6, #0]
 804c8f0:	2100      	movs	r1, #0
 804c8f2:	1d1a      	adds	r2, r3, #4
 804c8f4:	6032      	str	r2, [r6, #0]
 804c8f6:	681e      	ldr	r6, [r3, #0]
 804c8f8:	6862      	ldr	r2, [r4, #4]
 804c8fa:	4630      	mov	r0, r6
 804c8fc:	f000 f97a 	bl	804cbf4 <memchr>
 804c900:	b108      	cbz	r0, 804c906 <_printf_i+0x1e6>
 804c902:	1b80      	subs	r0, r0, r6
 804c904:	6060      	str	r0, [r4, #4]
 804c906:	6863      	ldr	r3, [r4, #4]
 804c908:	6123      	str	r3, [r4, #16]
 804c90a:	2300      	movs	r3, #0
 804c90c:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
 804c910:	e7aa      	b.n	804c868 <_printf_i+0x148>
 804c912:	6923      	ldr	r3, [r4, #16]
 804c914:	4632      	mov	r2, r6
 804c916:	4649      	mov	r1, r9
 804c918:	4640      	mov	r0, r8
 804c91a:	47d0      	blx	sl
 804c91c:	3001      	adds	r0, #1
 804c91e:	d0ad      	beq.n	804c87c <_printf_i+0x15c>
 804c920:	6823      	ldr	r3, [r4, #0]
 804c922:	079b      	lsls	r3, r3, #30
 804c924:	d413      	bmi.n	804c94e <_printf_i+0x22e>
 804c926:	68e0      	ldr	r0, [r4, #12]
 804c928:	9b03      	ldr	r3, [sp, #12]
 804c92a:	4298      	cmp	r0, r3
 804c92c:	bfb8      	it	lt
 804c92e:	4618      	movlt	r0, r3
 804c930:	e7a6      	b.n	804c880 <_printf_i+0x160>
 804c932:	2301      	movs	r3, #1
 804c934:	4632      	mov	r2, r6
 804c936:	4649      	mov	r1, r9
 804c938:	4640      	mov	r0, r8
 804c93a:	47d0      	blx	sl
 804c93c:	3001      	adds	r0, #1
 804c93e:	d09d      	beq.n	804c87c <_printf_i+0x15c>
 804c940:	3501      	adds	r5, #1
 804c942:	68e3      	ldr	r3, [r4, #12]
 804c944:	9903      	ldr	r1, [sp, #12]
 804c946:	1a5b      	subs	r3, r3, r1
 804c948:	42ab      	cmp	r3, r5
 804c94a:	dcf2      	bgt.n	804c932 <_printf_i+0x212>
 804c94c:	e7eb      	b.n	804c926 <_printf_i+0x206>
 804c94e:	2500      	movs	r5, #0
 804c950:	f104 0619 	add.w	r6, r4, #25
 804c954:	e7f5      	b.n	804c942 <_printf_i+0x222>
 804c956:	bf00      	nop
 804c958:	0804e6b6 	.word	0x0804e6b6
 804c95c:	0804e6c7 	.word	0x0804e6c7

0804c960 <__sflush_r>:
 804c960:	f9b1 200c 	ldrsh.w	r2, [r1, #12]
 804c964:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 804c968:	0716      	lsls	r6, r2, #28
 804c96a:	4605      	mov	r5, r0
 804c96c:	460c      	mov	r4, r1
 804c96e:	d454      	bmi.n	804ca1a <__sflush_r+0xba>
 804c970:	684b      	ldr	r3, [r1, #4]
 804c972:	2b00      	cmp	r3, #0
 804c974:	dc02      	bgt.n	804c97c <__sflush_r+0x1c>
 804c976:	6c0b      	ldr	r3, [r1, #64]	@ 0x40
 804c978:	2b00      	cmp	r3, #0
 804c97a:	dd48      	ble.n	804ca0e <__sflush_r+0xae>
 804c97c:	6ae6      	ldr	r6, [r4, #44]	@ 0x2c
 804c97e:	2e00      	cmp	r6, #0
 804c980:	d045      	beq.n	804ca0e <__sflush_r+0xae>
 804c982:	2300      	movs	r3, #0
 804c984:	f412 5280 	ands.w	r2, r2, #4096	@ 0x1000
 804c988:	682f      	ldr	r7, [r5, #0]
 804c98a:	6a21      	ldr	r1, [r4, #32]
 804c98c:	602b      	str	r3, [r5, #0]
 804c98e:	d030      	beq.n	804c9f2 <__sflush_r+0x92>
 804c990:	6d62      	ldr	r2, [r4, #84]	@ 0x54
 804c992:	89a3      	ldrh	r3, [r4, #12]
 804c994:	0759      	lsls	r1, r3, #29
 804c996:	d505      	bpl.n	804c9a4 <__sflush_r+0x44>
 804c998:	6863      	ldr	r3, [r4, #4]
 804c99a:	1ad2      	subs	r2, r2, r3
 804c99c:	6b63      	ldr	r3, [r4, #52]	@ 0x34
 804c99e:	b10b      	cbz	r3, 804c9a4 <__sflush_r+0x44>
 804c9a0:	6c23      	ldr	r3, [r4, #64]	@ 0x40
 804c9a2:	1ad2      	subs	r2, r2, r3
 804c9a4:	2300      	movs	r3, #0
 804c9a6:	6ae6      	ldr	r6, [r4, #44]	@ 0x2c
 804c9a8:	6a21      	ldr	r1, [r4, #32]
 804c9aa:	4628      	mov	r0, r5
 804c9ac:	47b0      	blx	r6
 804c9ae:	1c43      	adds	r3, r0, #1
 804c9b0:	89a3      	ldrh	r3, [r4, #12]
 804c9b2:	d106      	bne.n	804c9c2 <__sflush_r+0x62>
 804c9b4:	6829      	ldr	r1, [r5, #0]
 804c9b6:	291d      	cmp	r1, #29
 804c9b8:	d82b      	bhi.n	804ca12 <__sflush_r+0xb2>
 804c9ba:	4a2a      	ldr	r2, [pc, #168]	@ (804ca64 <__sflush_r+0x104>)
 804c9bc:	410a      	asrs	r2, r1
 804c9be:	07d6      	lsls	r6, r2, #31
 804c9c0:	d427      	bmi.n	804ca12 <__sflush_r+0xb2>
 804c9c2:	2200      	movs	r2, #0
 804c9c4:	04d9      	lsls	r1, r3, #19
 804c9c6:	6062      	str	r2, [r4, #4]
 804c9c8:	6922      	ldr	r2, [r4, #16]
 804c9ca:	6022      	str	r2, [r4, #0]
 804c9cc:	d504      	bpl.n	804c9d8 <__sflush_r+0x78>
 804c9ce:	1c42      	adds	r2, r0, #1
 804c9d0:	d101      	bne.n	804c9d6 <__sflush_r+0x76>
 804c9d2:	682b      	ldr	r3, [r5, #0]
 804c9d4:	b903      	cbnz	r3, 804c9d8 <__sflush_r+0x78>
 804c9d6:	6560      	str	r0, [r4, #84]	@ 0x54
 804c9d8:	6b61      	ldr	r1, [r4, #52]	@ 0x34
 804c9da:	602f      	str	r7, [r5, #0]
 804c9dc:	b1b9      	cbz	r1, 804ca0e <__sflush_r+0xae>
 804c9de:	f104 0344 	add.w	r3, r4, #68	@ 0x44
 804c9e2:	4299      	cmp	r1, r3
 804c9e4:	d002      	beq.n	804c9ec <__sflush_r+0x8c>
 804c9e6:	4628      	mov	r0, r5
 804c9e8:	f7ff fb3c 	bl	804c064 <_free_r>
 804c9ec:	2300      	movs	r3, #0
 804c9ee:	6363      	str	r3, [r4, #52]	@ 0x34
 804c9f0:	e00d      	b.n	804ca0e <__sflush_r+0xae>
 804c9f2:	2301      	movs	r3, #1
 804c9f4:	4628      	mov	r0, r5
 804c9f6:	47b0      	blx	r6
 804c9f8:	4602      	mov	r2, r0
 804c9fa:	1c50      	adds	r0, r2, #1
 804c9fc:	d1c9      	bne.n	804c992 <__sflush_r+0x32>
 804c9fe:	682b      	ldr	r3, [r5, #0]
 804ca00:	2b00      	cmp	r3, #0
 804ca02:	d0c6      	beq.n	804c992 <__sflush_r+0x32>
 804ca04:	2b1d      	cmp	r3, #29
 804ca06:	d001      	beq.n	804ca0c <__sflush_r+0xac>
 804ca08:	2b16      	cmp	r3, #22
 804ca0a:	d11d      	bne.n	804ca48 <__sflush_r+0xe8>
 804ca0c:	602f      	str	r7, [r5, #0]
 804ca0e:	2000      	movs	r0, #0
 804ca10:	e021      	b.n	804ca56 <__sflush_r+0xf6>
 804ca12:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 804ca16:	b21b      	sxth	r3, r3
 804ca18:	e01a      	b.n	804ca50 <__sflush_r+0xf0>
 804ca1a:	690f      	ldr	r7, [r1, #16]
 804ca1c:	2f00      	cmp	r7, #0
 804ca1e:	d0f6      	beq.n	804ca0e <__sflush_r+0xae>
 804ca20:	0793      	lsls	r3, r2, #30
 804ca22:	680e      	ldr	r6, [r1, #0]
 804ca24:	600f      	str	r7, [r1, #0]
 804ca26:	bf0c      	ite	eq
 804ca28:	694b      	ldreq	r3, [r1, #20]
 804ca2a:	2300      	movne	r3, #0
 804ca2c:	eba6 0807 	sub.w	r8, r6, r7
 804ca30:	608b      	str	r3, [r1, #8]
 804ca32:	f1b8 0f00 	cmp.w	r8, #0
 804ca36:	ddea      	ble.n	804ca0e <__sflush_r+0xae>
 804ca38:	4643      	mov	r3, r8
 804ca3a:	463a      	mov	r2, r7
 804ca3c:	6a21      	ldr	r1, [r4, #32]
 804ca3e:	4628      	mov	r0, r5
 804ca40:	6aa6      	ldr	r6, [r4, #40]	@ 0x28
 804ca42:	47b0      	blx	r6
 804ca44:	2800      	cmp	r0, #0
 804ca46:	dc08      	bgt.n	804ca5a <__sflush_r+0xfa>
 804ca48:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 804ca4c:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 804ca50:	f04f 30ff 	mov.w	r0, #4294967295
 804ca54:	81a3      	strh	r3, [r4, #12]
 804ca56:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 804ca5a:	4407      	add	r7, r0
 804ca5c:	eba8 0800 	sub.w	r8, r8, r0
 804ca60:	e7e7      	b.n	804ca32 <__sflush_r+0xd2>
 804ca62:	bf00      	nop
 804ca64:	dfbffffe 	.word	0xdfbffffe

0804ca68 <_fflush_r>:
 804ca68:	b538      	push	{r3, r4, r5, lr}
 804ca6a:	690b      	ldr	r3, [r1, #16]
 804ca6c:	4605      	mov	r5, r0
 804ca6e:	460c      	mov	r4, r1
 804ca70:	b913      	cbnz	r3, 804ca78 <_fflush_r+0x10>
 804ca72:	2500      	movs	r5, #0
 804ca74:	4628      	mov	r0, r5
 804ca76:	bd38      	pop	{r3, r4, r5, pc}
 804ca78:	b118      	cbz	r0, 804ca82 <_fflush_r+0x1a>
 804ca7a:	6a03      	ldr	r3, [r0, #32]
 804ca7c:	b90b      	cbnz	r3, 804ca82 <_fflush_r+0x1a>
 804ca7e:	f7ff f899 	bl	804bbb4 <__sinit>
 804ca82:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 804ca86:	2b00      	cmp	r3, #0
 804ca88:	d0f3      	beq.n	804ca72 <_fflush_r+0xa>
 804ca8a:	6e62      	ldr	r2, [r4, #100]	@ 0x64
 804ca8c:	07d0      	lsls	r0, r2, #31
 804ca8e:	d404      	bmi.n	804ca9a <_fflush_r+0x32>
 804ca90:	0599      	lsls	r1, r3, #22
 804ca92:	d402      	bmi.n	804ca9a <_fflush_r+0x32>
 804ca94:	6da0      	ldr	r0, [r4, #88]	@ 0x58
 804ca96:	f7ff fac8 	bl	804c02a <__retarget_lock_acquire_recursive>
 804ca9a:	4628      	mov	r0, r5
 804ca9c:	4621      	mov	r1, r4
 804ca9e:	f7ff ff5f 	bl	804c960 <__sflush_r>
 804caa2:	6e63      	ldr	r3, [r4, #100]	@ 0x64
 804caa4:	4605      	mov	r5, r0
 804caa6:	07da      	lsls	r2, r3, #31
 804caa8:	d4e4      	bmi.n	804ca74 <_fflush_r+0xc>
 804caaa:	89a3      	ldrh	r3, [r4, #12]
 804caac:	059b      	lsls	r3, r3, #22
 804caae:	d4e1      	bmi.n	804ca74 <_fflush_r+0xc>
 804cab0:	6da0      	ldr	r0, [r4, #88]	@ 0x58
 804cab2:	f7ff fabb 	bl	804c02c <__retarget_lock_release_recursive>
 804cab6:	e7dd      	b.n	804ca74 <_fflush_r+0xc>

0804cab8 <__swhatbuf_r>:
 804cab8:	b570      	push	{r4, r5, r6, lr}
 804caba:	460c      	mov	r4, r1
 804cabc:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 804cac0:	b096      	sub	sp, #88	@ 0x58
 804cac2:	4615      	mov	r5, r2
 804cac4:	2900      	cmp	r1, #0
 804cac6:	461e      	mov	r6, r3
 804cac8:	da0c      	bge.n	804cae4 <__swhatbuf_r+0x2c>
 804caca:	89a3      	ldrh	r3, [r4, #12]
 804cacc:	2100      	movs	r1, #0
 804cace:	f013 0f80 	tst.w	r3, #128	@ 0x80
 804cad2:	bf14      	ite	ne
 804cad4:	2340      	movne	r3, #64	@ 0x40
 804cad6:	f44f 6380 	moveq.w	r3, #1024	@ 0x400
 804cada:	2000      	movs	r0, #0
 804cadc:	6031      	str	r1, [r6, #0]
 804cade:	602b      	str	r3, [r5, #0]
 804cae0:	b016      	add	sp, #88	@ 0x58
 804cae2:	bd70      	pop	{r4, r5, r6, pc}
 804cae4:	466a      	mov	r2, sp
 804cae6:	f000 f863 	bl	804cbb0 <_fstat_r>
 804caea:	2800      	cmp	r0, #0
 804caec:	dbed      	blt.n	804caca <__swhatbuf_r+0x12>
 804caee:	9901      	ldr	r1, [sp, #4]
 804caf0:	f401 4170 	and.w	r1, r1, #61440	@ 0xf000
 804caf4:	f5a1 5300 	sub.w	r3, r1, #8192	@ 0x2000
 804caf8:	4259      	negs	r1, r3
 804cafa:	4159      	adcs	r1, r3
 804cafc:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 804cb00:	e7eb      	b.n	804cada <__swhatbuf_r+0x22>

0804cb02 <__smakebuf_r>:
 804cb02:	898b      	ldrh	r3, [r1, #12]
 804cb04:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 804cb06:	079d      	lsls	r5, r3, #30
 804cb08:	4606      	mov	r6, r0
 804cb0a:	460c      	mov	r4, r1
 804cb0c:	d507      	bpl.n	804cb1e <__smakebuf_r+0x1c>
 804cb0e:	f104 0347 	add.w	r3, r4, #71	@ 0x47
 804cb12:	6023      	str	r3, [r4, #0]
 804cb14:	6123      	str	r3, [r4, #16]
 804cb16:	2301      	movs	r3, #1
 804cb18:	6163      	str	r3, [r4, #20]
 804cb1a:	b003      	add	sp, #12
 804cb1c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 804cb1e:	ab01      	add	r3, sp, #4
 804cb20:	466a      	mov	r2, sp
 804cb22:	f7ff ffc9 	bl	804cab8 <__swhatbuf_r>
 804cb26:	9f00      	ldr	r7, [sp, #0]
 804cb28:	4605      	mov	r5, r0
 804cb2a:	4630      	mov	r0, r6
 804cb2c:	4639      	mov	r1, r7
 804cb2e:	f7fe fec5 	bl	804b8bc <_malloc_r>
 804cb32:	b948      	cbnz	r0, 804cb48 <__smakebuf_r+0x46>
 804cb34:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 804cb38:	059a      	lsls	r2, r3, #22
 804cb3a:	d4ee      	bmi.n	804cb1a <__smakebuf_r+0x18>
 804cb3c:	f023 0303 	bic.w	r3, r3, #3
 804cb40:	f043 0302 	orr.w	r3, r3, #2
 804cb44:	81a3      	strh	r3, [r4, #12]
 804cb46:	e7e2      	b.n	804cb0e <__smakebuf_r+0xc>
 804cb48:	89a3      	ldrh	r3, [r4, #12]
 804cb4a:	6020      	str	r0, [r4, #0]
 804cb4c:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 804cb50:	81a3      	strh	r3, [r4, #12]
 804cb52:	9b01      	ldr	r3, [sp, #4]
 804cb54:	e9c4 0704 	strd	r0, r7, [r4, #16]
 804cb58:	b15b      	cbz	r3, 804cb72 <__smakebuf_r+0x70>
 804cb5a:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 804cb5e:	4630      	mov	r0, r6
 804cb60:	f000 f838 	bl	804cbd4 <_isatty_r>
 804cb64:	b128      	cbz	r0, 804cb72 <__smakebuf_r+0x70>
 804cb66:	89a3      	ldrh	r3, [r4, #12]
 804cb68:	f023 0303 	bic.w	r3, r3, #3
 804cb6c:	f043 0301 	orr.w	r3, r3, #1
 804cb70:	81a3      	strh	r3, [r4, #12]
 804cb72:	89a3      	ldrh	r3, [r4, #12]
 804cb74:	431d      	orrs	r5, r3
 804cb76:	81a5      	strh	r5, [r4, #12]
 804cb78:	e7cf      	b.n	804cb1a <__smakebuf_r+0x18>

0804cb7a <memmove>:
 804cb7a:	4288      	cmp	r0, r1
 804cb7c:	b510      	push	{r4, lr}
 804cb7e:	eb01 0402 	add.w	r4, r1, r2
 804cb82:	d902      	bls.n	804cb8a <memmove+0x10>
 804cb84:	4284      	cmp	r4, r0
 804cb86:	4623      	mov	r3, r4
 804cb88:	d807      	bhi.n	804cb9a <memmove+0x20>
 804cb8a:	1e43      	subs	r3, r0, #1
 804cb8c:	42a1      	cmp	r1, r4
 804cb8e:	d008      	beq.n	804cba2 <memmove+0x28>
 804cb90:	f811 2b01 	ldrb.w	r2, [r1], #1
 804cb94:	f803 2f01 	strb.w	r2, [r3, #1]!
 804cb98:	e7f8      	b.n	804cb8c <memmove+0x12>
 804cb9a:	4402      	add	r2, r0
 804cb9c:	4601      	mov	r1, r0
 804cb9e:	428a      	cmp	r2, r1
 804cba0:	d100      	bne.n	804cba4 <memmove+0x2a>
 804cba2:	bd10      	pop	{r4, pc}
 804cba4:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
 804cba8:	f802 4d01 	strb.w	r4, [r2, #-1]!
 804cbac:	e7f7      	b.n	804cb9e <memmove+0x24>
	...

0804cbb0 <_fstat_r>:
 804cbb0:	b538      	push	{r3, r4, r5, lr}
 804cbb2:	2300      	movs	r3, #0
 804cbb4:	4d06      	ldr	r5, [pc, #24]	@ (804cbd0 <_fstat_r+0x20>)
 804cbb6:	4604      	mov	r4, r0
 804cbb8:	4608      	mov	r0, r1
 804cbba:	4611      	mov	r1, r2
 804cbbc:	602b      	str	r3, [r5, #0]
 804cbbe:	f7f4 fba7 	bl	8041310 <_fstat>
 804cbc2:	1c43      	adds	r3, r0, #1
 804cbc4:	d102      	bne.n	804cbcc <_fstat_r+0x1c>
 804cbc6:	682b      	ldr	r3, [r5, #0]
 804cbc8:	b103      	cbz	r3, 804cbcc <_fstat_r+0x1c>
 804cbca:	6023      	str	r3, [r4, #0]
 804cbcc:	bd38      	pop	{r3, r4, r5, pc}
 804cbce:	bf00      	nop
 804cbd0:	20018c1c 	.word	0x20018c1c

0804cbd4 <_isatty_r>:
 804cbd4:	b538      	push	{r3, r4, r5, lr}
 804cbd6:	2300      	movs	r3, #0
 804cbd8:	4d05      	ldr	r5, [pc, #20]	@ (804cbf0 <_isatty_r+0x1c>)
 804cbda:	4604      	mov	r4, r0
 804cbdc:	4608      	mov	r0, r1
 804cbde:	602b      	str	r3, [r5, #0]
 804cbe0:	f7f4 fb9c 	bl	804131c <_isatty>
 804cbe4:	1c43      	adds	r3, r0, #1
 804cbe6:	d102      	bne.n	804cbee <_isatty_r+0x1a>
 804cbe8:	682b      	ldr	r3, [r5, #0]
 804cbea:	b103      	cbz	r3, 804cbee <_isatty_r+0x1a>
 804cbec:	6023      	str	r3, [r4, #0]
 804cbee:	bd38      	pop	{r3, r4, r5, pc}
 804cbf0:	20018c1c 	.word	0x20018c1c

0804cbf4 <memchr>:
 804cbf4:	b2c9      	uxtb	r1, r1
 804cbf6:	4603      	mov	r3, r0
 804cbf8:	4402      	add	r2, r0
 804cbfa:	b510      	push	{r4, lr}
 804cbfc:	4293      	cmp	r3, r2
 804cbfe:	4618      	mov	r0, r3
 804cc00:	d101      	bne.n	804cc06 <memchr+0x12>
 804cc02:	2000      	movs	r0, #0
 804cc04:	e003      	b.n	804cc0e <memchr+0x1a>
 804cc06:	7804      	ldrb	r4, [r0, #0]
 804cc08:	3301      	adds	r3, #1
 804cc0a:	428c      	cmp	r4, r1
 804cc0c:	d1f6      	bne.n	804cbfc <memchr+0x8>
 804cc0e:	bd10      	pop	{r4, pc}

0804cc10 <log>:
 804cc10:	b538      	push	{r3, r4, r5, lr}
 804cc12:	ec55 4b10 	vmov	r4, r5, d0
 804cc16:	ed2d 8b02 	vpush	{d8}
 804cc1a:	f000 fa5d 	bl	804d0d8 <__ieee754_log>
 804cc1e:	4622      	mov	r2, r4
 804cc20:	462b      	mov	r3, r5
 804cc22:	4620      	mov	r0, r4
 804cc24:	4629      	mov	r1, r5
 804cc26:	eeb0 8a40 	vmov.f32	s16, s0
 804cc2a:	eef0 8a60 	vmov.f32	s17, s1
 804cc2e:	f7f3 ff59 	bl	8040ae4 <__aeabi_dcmpun>
 804cc32:	b998      	cbnz	r0, 804cc5c <log+0x4c>
 804cc34:	2200      	movs	r2, #0
 804cc36:	2300      	movs	r3, #0
 804cc38:	4620      	mov	r0, r4
 804cc3a:	4629      	mov	r1, r5
 804cc3c:	f7f3 ff48 	bl	8040ad0 <__aeabi_dcmpgt>
 804cc40:	b960      	cbnz	r0, 804cc5c <log+0x4c>
 804cc42:	2200      	movs	r2, #0
 804cc44:	2300      	movs	r3, #0
 804cc46:	4620      	mov	r0, r4
 804cc48:	4629      	mov	r1, r5
 804cc4a:	f7f3 ff19 	bl	8040a80 <__aeabi_dcmpeq>
 804cc4e:	b160      	cbz	r0, 804cc6a <log+0x5a>
 804cc50:	f7ff f9c0 	bl	804bfd4 <__errno>
 804cc54:	2322      	movs	r3, #34	@ 0x22
 804cc56:	ed9f 8b0a 	vldr	d8, [pc, #40]	@ 804cc80 <log+0x70>
 804cc5a:	6003      	str	r3, [r0, #0]
 804cc5c:	eeb0 0a48 	vmov.f32	s0, s16
 804cc60:	eef0 0a68 	vmov.f32	s1, s17
 804cc64:	ecbd 8b02 	vpop	{d8}
 804cc68:	bd38      	pop	{r3, r4, r5, pc}
 804cc6a:	f7ff f9b3 	bl	804bfd4 <__errno>
 804cc6e:	2321      	movs	r3, #33	@ 0x21
 804cc70:	ecbd 8b02 	vpop	{d8}
 804cc74:	6003      	str	r3, [r0, #0]
 804cc76:	4804      	ldr	r0, [pc, #16]	@ (804cc88 <log+0x78>)
 804cc78:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 804cc7c:	f7ff b9e4 	b.w	804c048 <nan>
 804cc80:	00000000 	.word	0x00000000
 804cc84:	fff00000 	.word	0xfff00000
 804cc88:	0804e635 	.word	0x0804e635

0804cc8c <sqrt>:
 804cc8c:	b538      	push	{r3, r4, r5, lr}
 804cc8e:	ec55 4b10 	vmov	r4, r5, d0
 804cc92:	ed2d 8b02 	vpush	{d8}
 804cc96:	f000 f93b 	bl	804cf10 <__ieee754_sqrt>
 804cc9a:	4622      	mov	r2, r4
 804cc9c:	462b      	mov	r3, r5
 804cc9e:	4620      	mov	r0, r4
 804cca0:	4629      	mov	r1, r5
 804cca2:	eeb0 8a40 	vmov.f32	s16, s0
 804cca6:	eef0 8a60 	vmov.f32	s17, s1
 804ccaa:	f7f3 ff1b 	bl	8040ae4 <__aeabi_dcmpun>
 804ccae:	b990      	cbnz	r0, 804ccd6 <sqrt+0x4a>
 804ccb0:	2200      	movs	r2, #0
 804ccb2:	2300      	movs	r3, #0
 804ccb4:	4620      	mov	r0, r4
 804ccb6:	4629      	mov	r1, r5
 804ccb8:	f7f3 feec 	bl	8040a94 <__aeabi_dcmplt>
 804ccbc:	b158      	cbz	r0, 804ccd6 <sqrt+0x4a>
 804ccbe:	f7ff f989 	bl	804bfd4 <__errno>
 804ccc2:	2321      	movs	r3, #33	@ 0x21
 804ccc4:	2200      	movs	r2, #0
 804ccc6:	6003      	str	r3, [r0, #0]
 804ccc8:	2300      	movs	r3, #0
 804ccca:	4610      	mov	r0, r2
 804cccc:	4619      	mov	r1, r3
 804ccce:	f7f3 fd99 	bl	8040804 <__aeabi_ddiv>
 804ccd2:	ec41 0b18 	vmov	d8, r0, r1
 804ccd6:	eeb0 0a48 	vmov.f32	s0, s16
 804ccda:	eef0 0a68 	vmov.f32	s1, s17
 804ccde:	ecbd 8b02 	vpop	{d8}
 804cce2:	bd38      	pop	{r3, r4, r5, pc}

0804cce4 <expf>:
 804cce4:	b508      	push	{r3, lr}
 804cce6:	ed2d 8b02 	vpush	{d8}
 804ccea:	eef0 8a40 	vmov.f32	s17, s0
 804ccee:	f000 fc45 	bl	804d57c <__ieee754_expf>
 804ccf2:	eeb0 8a40 	vmov.f32	s16, s0
 804ccf6:	eeb0 0a68 	vmov.f32	s0, s17
 804ccfa:	f000 f8ff 	bl	804cefc <finitef>
 804ccfe:	b160      	cbz	r0, 804cd1a <expf+0x36>
 804cd00:	eddf 7a0f 	vldr	s15, [pc, #60]	@ 804cd40 <expf+0x5c>
 804cd04:	eef4 8ae7 	vcmpe.f32	s17, s15
 804cd08:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 804cd0c:	dd0a      	ble.n	804cd24 <expf+0x40>
 804cd0e:	f7ff f961 	bl	804bfd4 <__errno>
 804cd12:	ed9f 8a0c 	vldr	s16, [pc, #48]	@ 804cd44 <expf+0x60>
 804cd16:	2322      	movs	r3, #34	@ 0x22
 804cd18:	6003      	str	r3, [r0, #0]
 804cd1a:	eeb0 0a48 	vmov.f32	s0, s16
 804cd1e:	ecbd 8b02 	vpop	{d8}
 804cd22:	bd08      	pop	{r3, pc}
 804cd24:	eddf 7a08 	vldr	s15, [pc, #32]	@ 804cd48 <expf+0x64>
 804cd28:	eef4 8ae7 	vcmpe.f32	s17, s15
 804cd2c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 804cd30:	d5f3      	bpl.n	804cd1a <expf+0x36>
 804cd32:	f7ff f94f 	bl	804bfd4 <__errno>
 804cd36:	2322      	movs	r3, #34	@ 0x22
 804cd38:	ed9f 8a04 	vldr	s16, [pc, #16]	@ 804cd4c <expf+0x68>
 804cd3c:	6003      	str	r3, [r0, #0]
 804cd3e:	e7ec      	b.n	804cd1a <expf+0x36>
 804cd40:	42b17217 	.word	0x42b17217
 804cd44:	7f800000 	.word	0x7f800000
 804cd48:	c2cff1b5 	.word	0xc2cff1b5
 804cd4c:	00000000 	.word	0x00000000

0804cd50 <logf>:
 804cd50:	b508      	push	{r3, lr}
 804cd52:	ed2d 8b02 	vpush	{d8}
 804cd56:	eeb0 8a40 	vmov.f32	s16, s0
 804cd5a:	f000 fcdd 	bl	804d718 <__ieee754_logf>
 804cd5e:	eeb4 8a48 	vcmp.f32	s16, s16
 804cd62:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 804cd66:	d60f      	bvs.n	804cd88 <logf+0x38>
 804cd68:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
 804cd6c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 804cd70:	dc0a      	bgt.n	804cd88 <logf+0x38>
 804cd72:	eeb5 8a40 	vcmp.f32	s16, #0.0
 804cd76:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 804cd7a:	d108      	bne.n	804cd8e <logf+0x3e>
 804cd7c:	f7ff f92a 	bl	804bfd4 <__errno>
 804cd80:	2322      	movs	r3, #34	@ 0x22
 804cd82:	ed9f 0a08 	vldr	s0, [pc, #32]	@ 804cda4 <logf+0x54>
 804cd86:	6003      	str	r3, [r0, #0]
 804cd88:	ecbd 8b02 	vpop	{d8}
 804cd8c:	bd08      	pop	{r3, pc}
 804cd8e:	f7ff f921 	bl	804bfd4 <__errno>
 804cd92:	2321      	movs	r3, #33	@ 0x21
 804cd94:	ecbd 8b02 	vpop	{d8}
 804cd98:	6003      	str	r3, [r0, #0]
 804cd9a:	4803      	ldr	r0, [pc, #12]	@ (804cda8 <logf+0x58>)
 804cd9c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 804cda0:	f7ff b95a 	b.w	804c058 <nanf>
 804cda4:	ff800000 	.word	0xff800000
 804cda8:	0804e635 	.word	0x0804e635

0804cdac <sqrtf>:
 804cdac:	b508      	push	{r3, lr}
 804cdae:	ed2d 8b02 	vpush	{d8}
 804cdb2:	eeb0 8a40 	vmov.f32	s16, s0
 804cdb6:	f000 f989 	bl	804d0cc <__ieee754_sqrtf>
 804cdba:	eeb4 8a48 	vcmp.f32	s16, s16
 804cdbe:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 804cdc2:	d60c      	bvs.n	804cdde <sqrtf+0x32>
 804cdc4:	eddf 8a07 	vldr	s17, [pc, #28]	@ 804cde4 <sqrtf+0x38>
 804cdc8:	eeb4 8ae8 	vcmpe.f32	s16, s17
 804cdcc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 804cdd0:	d505      	bpl.n	804cdde <sqrtf+0x32>
 804cdd2:	f7ff f8ff 	bl	804bfd4 <__errno>
 804cdd6:	ee88 0aa8 	vdiv.f32	s0, s17, s17
 804cdda:	2321      	movs	r3, #33	@ 0x21
 804cddc:	6003      	str	r3, [r0, #0]
 804cdde:	ecbd 8b02 	vpop	{d8}
 804cde2:	bd08      	pop	{r3, pc}
 804cde4:	00000000 	.word	0x00000000

0804cde8 <cosf>:
 804cde8:	ee10 3a10 	vmov	r3, s0
 804cdec:	b507      	push	{r0, r1, r2, lr}
 804cdee:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
 804cdf2:	4a1d      	ldr	r2, [pc, #116]	@ (804ce68 <cosf+0x80>)
 804cdf4:	4293      	cmp	r3, r2
 804cdf6:	d806      	bhi.n	804ce06 <cosf+0x1e>
 804cdf8:	eddf 0a1c 	vldr	s1, [pc, #112]	@ 804ce6c <cosf+0x84>
 804cdfc:	b003      	add	sp, #12
 804cdfe:	f85d eb04 	ldr.w	lr, [sp], #4
 804ce02:	f000 bb1b 	b.w	804d43c <__kernel_cosf>
 804ce06:	f1b3 4fff 	cmp.w	r3, #2139095040	@ 0x7f800000
 804ce0a:	d304      	bcc.n	804ce16 <cosf+0x2e>
 804ce0c:	ee30 0a40 	vsub.f32	s0, s0, s0
 804ce10:	b003      	add	sp, #12
 804ce12:	f85d fb04 	ldr.w	pc, [sp], #4
 804ce16:	4668      	mov	r0, sp
 804ce18:	f000 fd6e 	bl	804d8f8 <__ieee754_rem_pio2f>
 804ce1c:	f000 0003 	and.w	r0, r0, #3
 804ce20:	2801      	cmp	r0, #1
 804ce22:	d009      	beq.n	804ce38 <cosf+0x50>
 804ce24:	2802      	cmp	r0, #2
 804ce26:	d010      	beq.n	804ce4a <cosf+0x62>
 804ce28:	b9b0      	cbnz	r0, 804ce58 <cosf+0x70>
 804ce2a:	eddd 0a01 	vldr	s1, [sp, #4]
 804ce2e:	ed9d 0a00 	vldr	s0, [sp]
 804ce32:	f000 fb03 	bl	804d43c <__kernel_cosf>
 804ce36:	e7eb      	b.n	804ce10 <cosf+0x28>
 804ce38:	eddd 0a01 	vldr	s1, [sp, #4]
 804ce3c:	ed9d 0a00 	vldr	s0, [sp]
 804ce40:	f000 fb54 	bl	804d4ec <__kernel_sinf>
 804ce44:	eeb1 0a40 	vneg.f32	s0, s0
 804ce48:	e7e2      	b.n	804ce10 <cosf+0x28>
 804ce4a:	eddd 0a01 	vldr	s1, [sp, #4]
 804ce4e:	ed9d 0a00 	vldr	s0, [sp]
 804ce52:	f000 faf3 	bl	804d43c <__kernel_cosf>
 804ce56:	e7f5      	b.n	804ce44 <cosf+0x5c>
 804ce58:	2001      	movs	r0, #1
 804ce5a:	eddd 0a01 	vldr	s1, [sp, #4]
 804ce5e:	ed9d 0a00 	vldr	s0, [sp]
 804ce62:	f000 fb43 	bl	804d4ec <__kernel_sinf>
 804ce66:	e7d3      	b.n	804ce10 <cosf+0x28>
 804ce68:	3f490fd8 	.word	0x3f490fd8
 804ce6c:	00000000 	.word	0x00000000

0804ce70 <sinf>:
 804ce70:	ee10 3a10 	vmov	r3, s0
 804ce74:	b507      	push	{r0, r1, r2, lr}
 804ce76:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
 804ce7a:	4a1e      	ldr	r2, [pc, #120]	@ (804cef4 <sinf+0x84>)
 804ce7c:	4293      	cmp	r3, r2
 804ce7e:	d807      	bhi.n	804ce90 <sinf+0x20>
 804ce80:	2000      	movs	r0, #0
 804ce82:	eddf 0a1d 	vldr	s1, [pc, #116]	@ 804cef8 <sinf+0x88>
 804ce86:	b003      	add	sp, #12
 804ce88:	f85d eb04 	ldr.w	lr, [sp], #4
 804ce8c:	f000 bb2e 	b.w	804d4ec <__kernel_sinf>
 804ce90:	f1b3 4fff 	cmp.w	r3, #2139095040	@ 0x7f800000
 804ce94:	d304      	bcc.n	804cea0 <sinf+0x30>
 804ce96:	ee30 0a40 	vsub.f32	s0, s0, s0
 804ce9a:	b003      	add	sp, #12
 804ce9c:	f85d fb04 	ldr.w	pc, [sp], #4
 804cea0:	4668      	mov	r0, sp
 804cea2:	f000 fd29 	bl	804d8f8 <__ieee754_rem_pio2f>
 804cea6:	f000 0003 	and.w	r0, r0, #3
 804ceaa:	2801      	cmp	r0, #1
 804ceac:	d00a      	beq.n	804cec4 <sinf+0x54>
 804ceae:	2802      	cmp	r0, #2
 804ceb0:	d00f      	beq.n	804ced2 <sinf+0x62>
 804ceb2:	b9c0      	cbnz	r0, 804cee6 <sinf+0x76>
 804ceb4:	2001      	movs	r0, #1
 804ceb6:	eddd 0a01 	vldr	s1, [sp, #4]
 804ceba:	ed9d 0a00 	vldr	s0, [sp]
 804cebe:	f000 fb15 	bl	804d4ec <__kernel_sinf>
 804cec2:	e7ea      	b.n	804ce9a <sinf+0x2a>
 804cec4:	eddd 0a01 	vldr	s1, [sp, #4]
 804cec8:	ed9d 0a00 	vldr	s0, [sp]
 804cecc:	f000 fab6 	bl	804d43c <__kernel_cosf>
 804ced0:	e7e3      	b.n	804ce9a <sinf+0x2a>
 804ced2:	2001      	movs	r0, #1
 804ced4:	eddd 0a01 	vldr	s1, [sp, #4]
 804ced8:	ed9d 0a00 	vldr	s0, [sp]
 804cedc:	f000 fb06 	bl	804d4ec <__kernel_sinf>
 804cee0:	eeb1 0a40 	vneg.f32	s0, s0
 804cee4:	e7d9      	b.n	804ce9a <sinf+0x2a>
 804cee6:	eddd 0a01 	vldr	s1, [sp, #4]
 804ceea:	ed9d 0a00 	vldr	s0, [sp]
 804ceee:	f000 faa5 	bl	804d43c <__kernel_cosf>
 804cef2:	e7f5      	b.n	804cee0 <sinf+0x70>
 804cef4:	3f490fd8 	.word	0x3f490fd8
 804cef8:	00000000 	.word	0x00000000

0804cefc <finitef>:
 804cefc:	ee10 3a10 	vmov	r3, s0
 804cf00:	f023 4000 	bic.w	r0, r3, #2147483648	@ 0x80000000
 804cf04:	f1b0 4fff 	cmp.w	r0, #2139095040	@ 0x7f800000
 804cf08:	bfac      	ite	ge
 804cf0a:	2000      	movge	r0, #0
 804cf0c:	2001      	movlt	r0, #1
 804cf0e:	4770      	bx	lr

0804cf10 <__ieee754_sqrt>:
 804cf10:	4a6b      	ldr	r2, [pc, #428]	@ (804d0c0 <__ieee754_sqrt+0x1b0>)
 804cf12:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 804cf16:	ec55 4b10 	vmov	r4, r5, d0
 804cf1a:	43aa      	bics	r2, r5
 804cf1c:	462b      	mov	r3, r5
 804cf1e:	4621      	mov	r1, r4
 804cf20:	d110      	bne.n	804cf44 <__ieee754_sqrt+0x34>
 804cf22:	4622      	mov	r2, r4
 804cf24:	4620      	mov	r0, r4
 804cf26:	4629      	mov	r1, r5
 804cf28:	f7f3 fb42 	bl	80405b0 <__aeabi_dmul>
 804cf2c:	4602      	mov	r2, r0
 804cf2e:	460b      	mov	r3, r1
 804cf30:	4620      	mov	r0, r4
 804cf32:	4629      	mov	r1, r5
 804cf34:	f7f3 f986 	bl	8040244 <__adddf3>
 804cf38:	4604      	mov	r4, r0
 804cf3a:	460d      	mov	r5, r1
 804cf3c:	ec45 4b10 	vmov	d0, r4, r5
 804cf40:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 804cf44:	2d00      	cmp	r5, #0
 804cf46:	dc0e      	bgt.n	804cf66 <__ieee754_sqrt+0x56>
 804cf48:	f025 4200 	bic.w	r2, r5, #2147483648	@ 0x80000000
 804cf4c:	4322      	orrs	r2, r4
 804cf4e:	d0f5      	beq.n	804cf3c <__ieee754_sqrt+0x2c>
 804cf50:	b19d      	cbz	r5, 804cf7a <__ieee754_sqrt+0x6a>
 804cf52:	4622      	mov	r2, r4
 804cf54:	4620      	mov	r0, r4
 804cf56:	4629      	mov	r1, r5
 804cf58:	f7f3 f972 	bl	8040240 <__aeabi_dsub>
 804cf5c:	4602      	mov	r2, r0
 804cf5e:	460b      	mov	r3, r1
 804cf60:	f7f3 fc50 	bl	8040804 <__aeabi_ddiv>
 804cf64:	e7e8      	b.n	804cf38 <__ieee754_sqrt+0x28>
 804cf66:	152a      	asrs	r2, r5, #20
 804cf68:	d115      	bne.n	804cf96 <__ieee754_sqrt+0x86>
 804cf6a:	2000      	movs	r0, #0
 804cf6c:	e009      	b.n	804cf82 <__ieee754_sqrt+0x72>
 804cf6e:	0acb      	lsrs	r3, r1, #11
 804cf70:	3a15      	subs	r2, #21
 804cf72:	0549      	lsls	r1, r1, #21
 804cf74:	2b00      	cmp	r3, #0
 804cf76:	d0fa      	beq.n	804cf6e <__ieee754_sqrt+0x5e>
 804cf78:	e7f7      	b.n	804cf6a <__ieee754_sqrt+0x5a>
 804cf7a:	462a      	mov	r2, r5
 804cf7c:	e7fa      	b.n	804cf74 <__ieee754_sqrt+0x64>
 804cf7e:	005b      	lsls	r3, r3, #1
 804cf80:	3001      	adds	r0, #1
 804cf82:	02dc      	lsls	r4, r3, #11
 804cf84:	d5fb      	bpl.n	804cf7e <__ieee754_sqrt+0x6e>
 804cf86:	1e44      	subs	r4, r0, #1
 804cf88:	1b12      	subs	r2, r2, r4
 804cf8a:	f1c0 0420 	rsb	r4, r0, #32
 804cf8e:	fa21 f404 	lsr.w	r4, r1, r4
 804cf92:	4081      	lsls	r1, r0
 804cf94:	4323      	orrs	r3, r4
 804cf96:	f3c3 0313 	ubfx	r3, r3, #0, #20
 804cf9a:	f2a2 35ff 	subw	r5, r2, #1023	@ 0x3ff
 804cf9e:	07d2      	lsls	r2, r2, #31
 804cfa0:	f04f 0600 	mov.w	r6, #0
 804cfa4:	f443 1380 	orr.w	r3, r3, #1048576	@ 0x100000
 804cfa8:	ea4f 0565 	mov.w	r5, r5, asr #1
 804cfac:	f04f 0016 	mov.w	r0, #22
 804cfb0:	4632      	mov	r2, r6
 804cfb2:	bf58      	it	pl
 804cfb4:	005b      	lslpl	r3, r3, #1
 804cfb6:	f44f 1400 	mov.w	r4, #2097152	@ 0x200000
 804cfba:	bf5c      	itt	pl
 804cfbc:	eb03 73d1 	addpl.w	r3, r3, r1, lsr #31
 804cfc0:	0049      	lslpl	r1, r1, #1
 804cfc2:	005b      	lsls	r3, r3, #1
 804cfc4:	eb03 73d1 	add.w	r3, r3, r1, lsr #31
 804cfc8:	0049      	lsls	r1, r1, #1
 804cfca:	1917      	adds	r7, r2, r4
 804cfcc:	429f      	cmp	r7, r3
 804cfce:	bfde      	ittt	le
 804cfd0:	193a      	addle	r2, r7, r4
 804cfd2:	1bdb      	suble	r3, r3, r7
 804cfd4:	1936      	addle	r6, r6, r4
 804cfd6:	0fcf      	lsrs	r7, r1, #31
 804cfd8:	3801      	subs	r0, #1
 804cfda:	ea4f 0141 	mov.w	r1, r1, lsl #1
 804cfde:	eb07 0343 	add.w	r3, r7, r3, lsl #1
 804cfe2:	ea4f 0454 	mov.w	r4, r4, lsr #1
 804cfe6:	d1f0      	bne.n	804cfca <__ieee754_sqrt+0xba>
 804cfe8:	4604      	mov	r4, r0
 804cfea:	2720      	movs	r7, #32
 804cfec:	f04f 4c00 	mov.w	ip, #2147483648	@ 0x80000000
 804cff0:	429a      	cmp	r2, r3
 804cff2:	eb00 0e0c 	add.w	lr, r0, ip
 804cff6:	db02      	blt.n	804cffe <__ieee754_sqrt+0xee>
 804cff8:	d113      	bne.n	804d022 <__ieee754_sqrt+0x112>
 804cffa:	458e      	cmp	lr, r1
 804cffc:	d811      	bhi.n	804d022 <__ieee754_sqrt+0x112>
 804cffe:	f1be 0f00 	cmp.w	lr, #0
 804d002:	eb0e 000c 	add.w	r0, lr, ip
 804d006:	da43      	bge.n	804d090 <__ieee754_sqrt+0x180>
 804d008:	2800      	cmp	r0, #0
 804d00a:	db41      	blt.n	804d090 <__ieee754_sqrt+0x180>
 804d00c:	f102 0801 	add.w	r8, r2, #1
 804d010:	1a9b      	subs	r3, r3, r2
 804d012:	458e      	cmp	lr, r1
 804d014:	4464      	add	r4, ip
 804d016:	eba1 010e 	sub.w	r1, r1, lr
 804d01a:	bf88      	it	hi
 804d01c:	f103 33ff 	addhi.w	r3, r3, #4294967295
 804d020:	4642      	mov	r2, r8
 804d022:	ea4f 7ed1 	mov.w	lr, r1, lsr #31
 804d026:	3f01      	subs	r7, #1
 804d028:	ea4f 0141 	mov.w	r1, r1, lsl #1
 804d02c:	eb0e 0343 	add.w	r3, lr, r3, lsl #1
 804d030:	ea4f 0c5c 	mov.w	ip, ip, lsr #1
 804d034:	d1dc      	bne.n	804cff0 <__ieee754_sqrt+0xe0>
 804d036:	4319      	orrs	r1, r3
 804d038:	d01b      	beq.n	804d072 <__ieee754_sqrt+0x162>
 804d03a:	f8df a088 	ldr.w	sl, [pc, #136]	@ 804d0c4 <__ieee754_sqrt+0x1b4>
 804d03e:	f8df b088 	ldr.w	fp, [pc, #136]	@ 804d0c8 <__ieee754_sqrt+0x1b8>
 804d042:	e9da 0100 	ldrd	r0, r1, [sl]
 804d046:	e9db 2300 	ldrd	r2, r3, [fp]
 804d04a:	e9da 8900 	ldrd	r8, r9, [sl]
 804d04e:	f7f3 f8f7 	bl	8040240 <__aeabi_dsub>
 804d052:	4602      	mov	r2, r0
 804d054:	460b      	mov	r3, r1
 804d056:	4640      	mov	r0, r8
 804d058:	4649      	mov	r1, r9
 804d05a:	f7f3 fd25 	bl	8040aa8 <__aeabi_dcmple>
 804d05e:	b140      	cbz	r0, 804d072 <__ieee754_sqrt+0x162>
 804d060:	f1b4 3fff 	cmp.w	r4, #4294967295
 804d064:	e9da 0100 	ldrd	r0, r1, [sl]
 804d068:	e9db 2300 	ldrd	r2, r3, [fp]
 804d06c:	d112      	bne.n	804d094 <__ieee754_sqrt+0x184>
 804d06e:	3601      	adds	r6, #1
 804d070:	463c      	mov	r4, r7
 804d072:	1072      	asrs	r2, r6, #1
 804d074:	07f1      	lsls	r1, r6, #31
 804d076:	ea4f 0354 	mov.w	r3, r4, lsr #1
 804d07a:	f102 527f 	add.w	r2, r2, #1069547520	@ 0x3fc00000
 804d07e:	bf48      	it	mi
 804d080:	f043 4300 	orrmi.w	r3, r3, #2147483648	@ 0x80000000
 804d084:	f502 1200 	add.w	r2, r2, #2097152	@ 0x200000
 804d088:	4618      	mov	r0, r3
 804d08a:	eb02 5105 	add.w	r1, r2, r5, lsl #20
 804d08e:	e753      	b.n	804cf38 <__ieee754_sqrt+0x28>
 804d090:	4690      	mov	r8, r2
 804d092:	e7bd      	b.n	804d010 <__ieee754_sqrt+0x100>
 804d094:	e9da 8900 	ldrd	r8, r9, [sl]
 804d098:	f7f3 f8d4 	bl	8040244 <__adddf3>
 804d09c:	4602      	mov	r2, r0
 804d09e:	460b      	mov	r3, r1
 804d0a0:	4640      	mov	r0, r8
 804d0a2:	4649      	mov	r1, r9
 804d0a4:	f7f3 fcf6 	bl	8040a94 <__aeabi_dcmplt>
 804d0a8:	b128      	cbz	r0, 804d0b6 <__ieee754_sqrt+0x1a6>
 804d0aa:	1ca0      	adds	r0, r4, #2
 804d0ac:	f104 0402 	add.w	r4, r4, #2
 804d0b0:	bf08      	it	eq
 804d0b2:	3601      	addeq	r6, #1
 804d0b4:	e7dd      	b.n	804d072 <__ieee754_sqrt+0x162>
 804d0b6:	1c63      	adds	r3, r4, #1
 804d0b8:	f023 0401 	bic.w	r4, r3, #1
 804d0bc:	e7d9      	b.n	804d072 <__ieee754_sqrt+0x162>
 804d0be:	bf00      	nop
 804d0c0:	7ff00000 	.word	0x7ff00000
 804d0c4:	20018198 	.word	0x20018198
 804d0c8:	20018190 	.word	0x20018190

0804d0cc <__ieee754_sqrtf>:
 804d0cc:	eeb1 0ac0 	vsqrt.f32	s0, s0
 804d0d0:	4770      	bx	lr
 804d0d2:	0000      	movs	r0, r0
 804d0d4:	0000      	movs	r0, r0
	...

0804d0d8 <__ieee754_log>:
 804d0d8:	ec51 0b10 	vmov	r0, r1, d0
 804d0dc:	f5b1 1f80 	cmp.w	r1, #1048576	@ 0x100000
 804d0e0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 804d0e4:	460d      	mov	r5, r1
 804d0e6:	b087      	sub	sp, #28
 804d0e8:	da26      	bge.n	804d138 <__ieee754_log+0x60>
 804d0ea:	f021 4300 	bic.w	r3, r1, #2147483648	@ 0x80000000
 804d0ee:	4602      	mov	r2, r0
 804d0f0:	4303      	orrs	r3, r0
 804d0f2:	d10a      	bne.n	804d10a <__ieee754_log+0x32>
 804d0f4:	2200      	movs	r2, #0
 804d0f6:	2300      	movs	r3, #0
 804d0f8:	2000      	movs	r0, #0
 804d0fa:	49cb      	ldr	r1, [pc, #812]	@ (804d428 <__ieee754_log+0x350>)
 804d0fc:	f7f3 fb82 	bl	8040804 <__aeabi_ddiv>
 804d100:	ec41 0b10 	vmov	d0, r0, r1
 804d104:	b007      	add	sp, #28
 804d106:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 804d10a:	2900      	cmp	r1, #0
 804d10c:	da05      	bge.n	804d11a <__ieee754_log+0x42>
 804d10e:	460b      	mov	r3, r1
 804d110:	f7f3 f896 	bl	8040240 <__aeabi_dsub>
 804d114:	2200      	movs	r2, #0
 804d116:	2300      	movs	r3, #0
 804d118:	e7f0      	b.n	804d0fc <__ieee754_log+0x24>
 804d11a:	4bc4      	ldr	r3, [pc, #784]	@ (804d42c <__ieee754_log+0x354>)
 804d11c:	2200      	movs	r2, #0
 804d11e:	f7f3 fa47 	bl	80405b0 <__aeabi_dmul>
 804d122:	f06f 0335 	mvn.w	r3, #53	@ 0x35
 804d126:	460d      	mov	r5, r1
 804d128:	4ac1      	ldr	r2, [pc, #772]	@ (804d430 <__ieee754_log+0x358>)
 804d12a:	4295      	cmp	r5, r2
 804d12c:	dd06      	ble.n	804d13c <__ieee754_log+0x64>
 804d12e:	4602      	mov	r2, r0
 804d130:	460b      	mov	r3, r1
 804d132:	f7f3 f887 	bl	8040244 <__adddf3>
 804d136:	e7e3      	b.n	804d100 <__ieee754_log+0x28>
 804d138:	2300      	movs	r3, #0
 804d13a:	e7f5      	b.n	804d128 <__ieee754_log+0x50>
 804d13c:	152c      	asrs	r4, r5, #20
 804d13e:	f3c5 0513 	ubfx	r5, r5, #0, #20
 804d142:	f2a4 34ff 	subw	r4, r4, #1023	@ 0x3ff
 804d146:	441c      	add	r4, r3
 804d148:	f505 2315 	add.w	r3, r5, #610304	@ 0x95000
 804d14c:	f603 7364 	addw	r3, r3, #3940	@ 0xf64
 804d150:	f403 1380 	and.w	r3, r3, #1048576	@ 0x100000
 804d154:	f083 527f 	eor.w	r2, r3, #1069547520	@ 0x3fc00000
 804d158:	eb04 5413 	add.w	r4, r4, r3, lsr #20
 804d15c:	4bb5      	ldr	r3, [pc, #724]	@ (804d434 <__ieee754_log+0x35c>)
 804d15e:	f482 1240 	eor.w	r2, r2, #3145728	@ 0x300000
 804d162:	ea42 0105 	orr.w	r1, r2, r5
 804d166:	2200      	movs	r2, #0
 804d168:	f7f3 f86a 	bl	8040240 <__aeabi_dsub>
 804d16c:	1cab      	adds	r3, r5, #2
 804d16e:	4682      	mov	sl, r0
 804d170:	468b      	mov	fp, r1
 804d172:	f3c3 0313 	ubfx	r3, r3, #0, #20
 804d176:	2200      	movs	r2, #0
 804d178:	2b02      	cmp	r3, #2
 804d17a:	dc53      	bgt.n	804d224 <__ieee754_log+0x14c>
 804d17c:	2300      	movs	r3, #0
 804d17e:	f7f3 fc7f 	bl	8040a80 <__aeabi_dcmpeq>
 804d182:	b1d0      	cbz	r0, 804d1ba <__ieee754_log+0xe2>
 804d184:	2c00      	cmp	r4, #0
 804d186:	f000 8120 	beq.w	804d3ca <__ieee754_log+0x2f2>
 804d18a:	4620      	mov	r0, r4
 804d18c:	f7f3 f9a6 	bl	80404dc <__aeabi_i2d>
 804d190:	4606      	mov	r6, r0
 804d192:	460f      	mov	r7, r1
 804d194:	a38e      	add	r3, pc, #568	@ (adr r3, 804d3d0 <__ieee754_log+0x2f8>)
 804d196:	e9d3 2300 	ldrd	r2, r3, [r3]
 804d19a:	f7f3 fa09 	bl	80405b0 <__aeabi_dmul>
 804d19e:	4604      	mov	r4, r0
 804d1a0:	460d      	mov	r5, r1
 804d1a2:	4630      	mov	r0, r6
 804d1a4:	4639      	mov	r1, r7
 804d1a6:	a38c      	add	r3, pc, #560	@ (adr r3, 804d3d8 <__ieee754_log+0x300>)
 804d1a8:	e9d3 2300 	ldrd	r2, r3, [r3]
 804d1ac:	f7f3 fa00 	bl	80405b0 <__aeabi_dmul>
 804d1b0:	4602      	mov	r2, r0
 804d1b2:	460b      	mov	r3, r1
 804d1b4:	4620      	mov	r0, r4
 804d1b6:	4629      	mov	r1, r5
 804d1b8:	e7bb      	b.n	804d132 <__ieee754_log+0x5a>
 804d1ba:	a389      	add	r3, pc, #548	@ (adr r3, 804d3e0 <__ieee754_log+0x308>)
 804d1bc:	e9d3 2300 	ldrd	r2, r3, [r3]
 804d1c0:	4650      	mov	r0, sl
 804d1c2:	4659      	mov	r1, fp
 804d1c4:	f7f3 f9f4 	bl	80405b0 <__aeabi_dmul>
 804d1c8:	4602      	mov	r2, r0
 804d1ca:	460b      	mov	r3, r1
 804d1cc:	2000      	movs	r0, #0
 804d1ce:	499a      	ldr	r1, [pc, #616]	@ (804d438 <__ieee754_log+0x360>)
 804d1d0:	f7f3 f836 	bl	8040240 <__aeabi_dsub>
 804d1d4:	4606      	mov	r6, r0
 804d1d6:	460f      	mov	r7, r1
 804d1d8:	4652      	mov	r2, sl
 804d1da:	465b      	mov	r3, fp
 804d1dc:	4650      	mov	r0, sl
 804d1de:	4659      	mov	r1, fp
 804d1e0:	f7f3 f9e6 	bl	80405b0 <__aeabi_dmul>
 804d1e4:	4602      	mov	r2, r0
 804d1e6:	460b      	mov	r3, r1
 804d1e8:	4630      	mov	r0, r6
 804d1ea:	4639      	mov	r1, r7
 804d1ec:	f7f3 f9e0 	bl	80405b0 <__aeabi_dmul>
 804d1f0:	4606      	mov	r6, r0
 804d1f2:	460f      	mov	r7, r1
 804d1f4:	b914      	cbnz	r4, 804d1fc <__ieee754_log+0x124>
 804d1f6:	4632      	mov	r2, r6
 804d1f8:	463b      	mov	r3, r7
 804d1fa:	e0a0      	b.n	804d33e <__ieee754_log+0x266>
 804d1fc:	4620      	mov	r0, r4
 804d1fe:	f7f3 f96d 	bl	80404dc <__aeabi_i2d>
 804d202:	4680      	mov	r8, r0
 804d204:	4689      	mov	r9, r1
 804d206:	a372      	add	r3, pc, #456	@ (adr r3, 804d3d0 <__ieee754_log+0x2f8>)
 804d208:	e9d3 2300 	ldrd	r2, r3, [r3]
 804d20c:	f7f3 f9d0 	bl	80405b0 <__aeabi_dmul>
 804d210:	4604      	mov	r4, r0
 804d212:	460d      	mov	r5, r1
 804d214:	4640      	mov	r0, r8
 804d216:	4649      	mov	r1, r9
 804d218:	a36f      	add	r3, pc, #444	@ (adr r3, 804d3d8 <__ieee754_log+0x300>)
 804d21a:	e9d3 2300 	ldrd	r2, r3, [r3]
 804d21e:	f7f3 f9c7 	bl	80405b0 <__aeabi_dmul>
 804d222:	e0a5      	b.n	804d370 <__ieee754_log+0x298>
 804d224:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 804d228:	f5a5 26c2 	sub.w	r6, r5, #397312	@ 0x61000
 804d22c:	f7f3 f80a 	bl	8040244 <__adddf3>
 804d230:	4602      	mov	r2, r0
 804d232:	460b      	mov	r3, r1
 804d234:	4650      	mov	r0, sl
 804d236:	4659      	mov	r1, fp
 804d238:	f5c5 25d7 	rsb	r5, r5, #440320	@ 0x6b800
 804d23c:	f7f3 fae2 	bl	8040804 <__aeabi_ddiv>
 804d240:	f2a6 467a 	subw	r6, r6, #1146	@ 0x47a
 804d244:	3551      	adds	r5, #81	@ 0x51
 804d246:	e9cd 0100 	strd	r0, r1, [sp]
 804d24a:	4620      	mov	r0, r4
 804d24c:	4335      	orrs	r5, r6
 804d24e:	f7f3 f945 	bl	80404dc <__aeabi_i2d>
 804d252:	e9dd 2300 	ldrd	r2, r3, [sp]
 804d256:	e9cd 0102 	strd	r0, r1, [sp, #8]
 804d25a:	4610      	mov	r0, r2
 804d25c:	4619      	mov	r1, r3
 804d25e:	f7f3 f9a7 	bl	80405b0 <__aeabi_dmul>
 804d262:	4602      	mov	r2, r0
 804d264:	460b      	mov	r3, r1
 804d266:	e9cd 2304 	strd	r2, r3, [sp, #16]
 804d26a:	f7f3 f9a1 	bl	80405b0 <__aeabi_dmul>
 804d26e:	4680      	mov	r8, r0
 804d270:	4689      	mov	r9, r1
 804d272:	a35d      	add	r3, pc, #372	@ (adr r3, 804d3e8 <__ieee754_log+0x310>)
 804d274:	e9d3 2300 	ldrd	r2, r3, [r3]
 804d278:	f7f3 f99a 	bl	80405b0 <__aeabi_dmul>
 804d27c:	a35c      	add	r3, pc, #368	@ (adr r3, 804d3f0 <__ieee754_log+0x318>)
 804d27e:	e9d3 2300 	ldrd	r2, r3, [r3]
 804d282:	f7f2 ffdf 	bl	8040244 <__adddf3>
 804d286:	4642      	mov	r2, r8
 804d288:	464b      	mov	r3, r9
 804d28a:	f7f3 f991 	bl	80405b0 <__aeabi_dmul>
 804d28e:	a35a      	add	r3, pc, #360	@ (adr r3, 804d3f8 <__ieee754_log+0x320>)
 804d290:	e9d3 2300 	ldrd	r2, r3, [r3]
 804d294:	f7f2 ffd6 	bl	8040244 <__adddf3>
 804d298:	4642      	mov	r2, r8
 804d29a:	464b      	mov	r3, r9
 804d29c:	f7f3 f988 	bl	80405b0 <__aeabi_dmul>
 804d2a0:	a357      	add	r3, pc, #348	@ (adr r3, 804d400 <__ieee754_log+0x328>)
 804d2a2:	e9d3 2300 	ldrd	r2, r3, [r3]
 804d2a6:	f7f2 ffcd 	bl	8040244 <__adddf3>
 804d2aa:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 804d2ae:	f7f3 f97f 	bl	80405b0 <__aeabi_dmul>
 804d2b2:	a355      	add	r3, pc, #340	@ (adr r3, 804d408 <__ieee754_log+0x330>)
 804d2b4:	e9d3 2300 	ldrd	r2, r3, [r3]
 804d2b8:	e9cd 0104 	strd	r0, r1, [sp, #16]
 804d2bc:	4640      	mov	r0, r8
 804d2be:	4649      	mov	r1, r9
 804d2c0:	f7f3 f976 	bl	80405b0 <__aeabi_dmul>
 804d2c4:	a352      	add	r3, pc, #328	@ (adr r3, 804d410 <__ieee754_log+0x338>)
 804d2c6:	e9d3 2300 	ldrd	r2, r3, [r3]
 804d2ca:	f7f2 ffbb 	bl	8040244 <__adddf3>
 804d2ce:	4642      	mov	r2, r8
 804d2d0:	464b      	mov	r3, r9
 804d2d2:	f7f3 f96d 	bl	80405b0 <__aeabi_dmul>
 804d2d6:	a350      	add	r3, pc, #320	@ (adr r3, 804d418 <__ieee754_log+0x340>)
 804d2d8:	e9d3 2300 	ldrd	r2, r3, [r3]
 804d2dc:	f7f2 ffb2 	bl	8040244 <__adddf3>
 804d2e0:	4642      	mov	r2, r8
 804d2e2:	464b      	mov	r3, r9
 804d2e4:	f7f3 f964 	bl	80405b0 <__aeabi_dmul>
 804d2e8:	4602      	mov	r2, r0
 804d2ea:	460b      	mov	r3, r1
 804d2ec:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 804d2f0:	f7f2 ffa8 	bl	8040244 <__adddf3>
 804d2f4:	2d00      	cmp	r5, #0
 804d2f6:	4680      	mov	r8, r0
 804d2f8:	4689      	mov	r9, r1
 804d2fa:	dd48      	ble.n	804d38e <__ieee754_log+0x2b6>
 804d2fc:	2200      	movs	r2, #0
 804d2fe:	4b4e      	ldr	r3, [pc, #312]	@ (804d438 <__ieee754_log+0x360>)
 804d300:	4650      	mov	r0, sl
 804d302:	4659      	mov	r1, fp
 804d304:	f7f3 f954 	bl	80405b0 <__aeabi_dmul>
 804d308:	4652      	mov	r2, sl
 804d30a:	465b      	mov	r3, fp
 804d30c:	f7f3 f950 	bl	80405b0 <__aeabi_dmul>
 804d310:	4602      	mov	r2, r0
 804d312:	460b      	mov	r3, r1
 804d314:	4606      	mov	r6, r0
 804d316:	460f      	mov	r7, r1
 804d318:	4640      	mov	r0, r8
 804d31a:	4649      	mov	r1, r9
 804d31c:	f7f2 ff92 	bl	8040244 <__adddf3>
 804d320:	e9dd 2300 	ldrd	r2, r3, [sp]
 804d324:	f7f3 f944 	bl	80405b0 <__aeabi_dmul>
 804d328:	4680      	mov	r8, r0
 804d32a:	4689      	mov	r9, r1
 804d32c:	b964      	cbnz	r4, 804d348 <__ieee754_log+0x270>
 804d32e:	4602      	mov	r2, r0
 804d330:	460b      	mov	r3, r1
 804d332:	4630      	mov	r0, r6
 804d334:	4639      	mov	r1, r7
 804d336:	f7f2 ff83 	bl	8040240 <__aeabi_dsub>
 804d33a:	4602      	mov	r2, r0
 804d33c:	460b      	mov	r3, r1
 804d33e:	4650      	mov	r0, sl
 804d340:	4659      	mov	r1, fp
 804d342:	f7f2 ff7d 	bl	8040240 <__aeabi_dsub>
 804d346:	e6db      	b.n	804d100 <__ieee754_log+0x28>
 804d348:	a321      	add	r3, pc, #132	@ (adr r3, 804d3d0 <__ieee754_log+0x2f8>)
 804d34a:	e9d3 2300 	ldrd	r2, r3, [r3]
 804d34e:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 804d352:	f7f3 f92d 	bl	80405b0 <__aeabi_dmul>
 804d356:	4604      	mov	r4, r0
 804d358:	460d      	mov	r5, r1
 804d35a:	a31f      	add	r3, pc, #124	@ (adr r3, 804d3d8 <__ieee754_log+0x300>)
 804d35c:	e9d3 2300 	ldrd	r2, r3, [r3]
 804d360:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 804d364:	f7f3 f924 	bl	80405b0 <__aeabi_dmul>
 804d368:	4642      	mov	r2, r8
 804d36a:	464b      	mov	r3, r9
 804d36c:	f7f2 ff6a 	bl	8040244 <__adddf3>
 804d370:	4602      	mov	r2, r0
 804d372:	460b      	mov	r3, r1
 804d374:	4630      	mov	r0, r6
 804d376:	4639      	mov	r1, r7
 804d378:	f7f2 ff62 	bl	8040240 <__aeabi_dsub>
 804d37c:	4652      	mov	r2, sl
 804d37e:	465b      	mov	r3, fp
 804d380:	f7f2 ff5e 	bl	8040240 <__aeabi_dsub>
 804d384:	4602      	mov	r2, r0
 804d386:	460b      	mov	r3, r1
 804d388:	4620      	mov	r0, r4
 804d38a:	4629      	mov	r1, r5
 804d38c:	e7d9      	b.n	804d342 <__ieee754_log+0x26a>
 804d38e:	4602      	mov	r2, r0
 804d390:	460b      	mov	r3, r1
 804d392:	4650      	mov	r0, sl
 804d394:	4659      	mov	r1, fp
 804d396:	f7f2 ff53 	bl	8040240 <__aeabi_dsub>
 804d39a:	e9dd 2300 	ldrd	r2, r3, [sp]
 804d39e:	f7f3 f907 	bl	80405b0 <__aeabi_dmul>
 804d3a2:	4606      	mov	r6, r0
 804d3a4:	460f      	mov	r7, r1
 804d3a6:	2c00      	cmp	r4, #0
 804d3a8:	f43f af25 	beq.w	804d1f6 <__ieee754_log+0x11e>
 804d3ac:	a308      	add	r3, pc, #32	@ (adr r3, 804d3d0 <__ieee754_log+0x2f8>)
 804d3ae:	e9d3 2300 	ldrd	r2, r3, [r3]
 804d3b2:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 804d3b6:	f7f3 f8fb 	bl	80405b0 <__aeabi_dmul>
 804d3ba:	4604      	mov	r4, r0
 804d3bc:	460d      	mov	r5, r1
 804d3be:	a306      	add	r3, pc, #24	@ (adr r3, 804d3d8 <__ieee754_log+0x300>)
 804d3c0:	e9d3 2300 	ldrd	r2, r3, [r3]
 804d3c4:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 804d3c8:	e729      	b.n	804d21e <__ieee754_log+0x146>
 804d3ca:	ed9f 0b15 	vldr	d0, [pc, #84]	@ 804d420 <__ieee754_log+0x348>
 804d3ce:	e699      	b.n	804d104 <__ieee754_log+0x2c>
 804d3d0:	fee00000 	.word	0xfee00000
 804d3d4:	3fe62e42 	.word	0x3fe62e42
 804d3d8:	35793c76 	.word	0x35793c76
 804d3dc:	3dea39ef 	.word	0x3dea39ef
 804d3e0:	55555555 	.word	0x55555555
 804d3e4:	3fd55555 	.word	0x3fd55555
 804d3e8:	df3e5244 	.word	0xdf3e5244
 804d3ec:	3fc2f112 	.word	0x3fc2f112
 804d3f0:	96cb03de 	.word	0x96cb03de
 804d3f4:	3fc74664 	.word	0x3fc74664
 804d3f8:	94229359 	.word	0x94229359
 804d3fc:	3fd24924 	.word	0x3fd24924
 804d400:	55555593 	.word	0x55555593
 804d404:	3fe55555 	.word	0x3fe55555
 804d408:	d078c69f 	.word	0xd078c69f
 804d40c:	3fc39a09 	.word	0x3fc39a09
 804d410:	1d8e78af 	.word	0x1d8e78af
 804d414:	3fcc71c5 	.word	0x3fcc71c5
 804d418:	9997fa04 	.word	0x9997fa04
 804d41c:	3fd99999 	.word	0x3fd99999
	...
 804d428:	c3500000 	.word	0xc3500000
 804d42c:	43500000 	.word	0x43500000
 804d430:	7fefffff 	.word	0x7fefffff
 804d434:	3ff00000 	.word	0x3ff00000
 804d438:	3fe00000 	.word	0x3fe00000

0804d43c <__kernel_cosf>:
 804d43c:	ee10 3a10 	vmov	r3, s0
 804d440:	eef0 6a40 	vmov.f32	s13, s0
 804d444:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
 804d448:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
 804d44c:	f1b3 5f48 	cmp.w	r3, #838860800	@ 0x32000000
 804d450:	d204      	bcs.n	804d45c <__kernel_cosf+0x20>
 804d452:	eefd 7ae6 	vcvt.s32.f32	s15, s13
 804d456:	ee17 2a90 	vmov	r2, s15
 804d45a:	b342      	cbz	r2, 804d4ae <__kernel_cosf+0x72>
 804d45c:	ee26 7aa6 	vmul.f32	s14, s13, s13
 804d460:	eddf 7a1a 	vldr	s15, [pc, #104]	@ 804d4cc <__kernel_cosf+0x90>
 804d464:	ed9f 6a1a 	vldr	s12, [pc, #104]	@ 804d4d0 <__kernel_cosf+0x94>
 804d468:	ee60 0ae6 	vnmul.f32	s1, s1, s13
 804d46c:	4a19      	ldr	r2, [pc, #100]	@ (804d4d4 <__kernel_cosf+0x98>)
 804d46e:	eea7 6a27 	vfma.f32	s12, s14, s15
 804d472:	eddf 7a19 	vldr	s15, [pc, #100]	@ 804d4d8 <__kernel_cosf+0x9c>
 804d476:	4293      	cmp	r3, r2
 804d478:	eee6 7a07 	vfma.f32	s15, s12, s14
 804d47c:	ed9f 6a17 	vldr	s12, [pc, #92]	@ 804d4dc <__kernel_cosf+0xa0>
 804d480:	eea7 6a87 	vfma.f32	s12, s15, s14
 804d484:	eddf 7a16 	vldr	s15, [pc, #88]	@ 804d4e0 <__kernel_cosf+0xa4>
 804d488:	eee6 7a07 	vfma.f32	s15, s12, s14
 804d48c:	ed9f 6a15 	vldr	s12, [pc, #84]	@ 804d4e4 <__kernel_cosf+0xa8>
 804d490:	eea7 6a87 	vfma.f32	s12, s15, s14
 804d494:	eef6 7a00 	vmov.f32	s15, #96	@ 0x3f000000  0.5
 804d498:	ee67 7a27 	vmul.f32	s15, s14, s15
 804d49c:	ee26 6a07 	vmul.f32	s12, s12, s14
 804d4a0:	eee7 0a06 	vfma.f32	s1, s14, s12
 804d4a4:	d804      	bhi.n	804d4b0 <__kernel_cosf+0x74>
 804d4a6:	ee77 7ae0 	vsub.f32	s15, s15, s1
 804d4aa:	ee30 0a67 	vsub.f32	s0, s0, s15
 804d4ae:	4770      	bx	lr
 804d4b0:	4a0d      	ldr	r2, [pc, #52]	@ (804d4e8 <__kernel_cosf+0xac>)
 804d4b2:	4293      	cmp	r3, r2
 804d4b4:	bf96      	itet	ls
 804d4b6:	f103 437f 	addls.w	r3, r3, #4278190080	@ 0xff000000
 804d4ba:	eeb5 7a02 	vmovhi.f32	s14, #82	@ 0x3e900000  0.2812500
 804d4be:	ee07 3a10 	vmovls	s14, r3
 804d4c2:	ee30 0a47 	vsub.f32	s0, s0, s14
 804d4c6:	ee77 7ac7 	vsub.f32	s15, s15, s14
 804d4ca:	e7ec      	b.n	804d4a6 <__kernel_cosf+0x6a>
 804d4cc:	ad47d74e 	.word	0xad47d74e
 804d4d0:	310f74f6 	.word	0x310f74f6
 804d4d4:	3e999999 	.word	0x3e999999
 804d4d8:	b493f27c 	.word	0xb493f27c
 804d4dc:	37d00d01 	.word	0x37d00d01
 804d4e0:	bab60b61 	.word	0xbab60b61
 804d4e4:	3d2aaaab 	.word	0x3d2aaaab
 804d4e8:	3f480000 	.word	0x3f480000

0804d4ec <__kernel_sinf>:
 804d4ec:	ee10 3a10 	vmov	r3, s0
 804d4f0:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
 804d4f4:	f1b3 5f48 	cmp.w	r3, #838860800	@ 0x32000000
 804d4f8:	d204      	bcs.n	804d504 <__kernel_sinf+0x18>
 804d4fa:	eefd 7ac0 	vcvt.s32.f32	s15, s0
 804d4fe:	ee17 3a90 	vmov	r3, s15
 804d502:	b35b      	cbz	r3, 804d55c <__kernel_sinf+0x70>
 804d504:	ee20 7a00 	vmul.f32	s14, s0, s0
 804d508:	eddf 7a15 	vldr	s15, [pc, #84]	@ 804d560 <__kernel_sinf+0x74>
 804d50c:	ed9f 6a15 	vldr	s12, [pc, #84]	@ 804d564 <__kernel_sinf+0x78>
 804d510:	eea7 6a27 	vfma.f32	s12, s14, s15
 804d514:	eddf 7a14 	vldr	s15, [pc, #80]	@ 804d568 <__kernel_sinf+0x7c>
 804d518:	ee60 6a07 	vmul.f32	s13, s0, s14
 804d51c:	eee6 7a07 	vfma.f32	s15, s12, s14
 804d520:	ed9f 6a12 	vldr	s12, [pc, #72]	@ 804d56c <__kernel_sinf+0x80>
 804d524:	eea7 6a87 	vfma.f32	s12, s15, s14
 804d528:	eddf 7a11 	vldr	s15, [pc, #68]	@ 804d570 <__kernel_sinf+0x84>
 804d52c:	eee6 7a07 	vfma.f32	s15, s12, s14
 804d530:	b930      	cbnz	r0, 804d540 <__kernel_sinf+0x54>
 804d532:	ed9f 6a10 	vldr	s12, [pc, #64]	@ 804d574 <__kernel_sinf+0x88>
 804d536:	eea7 6a27 	vfma.f32	s12, s14, s15
 804d53a:	eea6 0a26 	vfma.f32	s0, s12, s13
 804d53e:	4770      	bx	lr
 804d540:	ee67 7ae6 	vnmul.f32	s15, s15, s13
 804d544:	eeb6 6a00 	vmov.f32	s12, #96	@ 0x3f000000  0.5
 804d548:	eee0 7a86 	vfma.f32	s15, s1, s12
 804d54c:	eed7 0a87 	vfnms.f32	s1, s15, s14
 804d550:	eddf 7a09 	vldr	s15, [pc, #36]	@ 804d578 <__kernel_sinf+0x8c>
 804d554:	eee6 0aa7 	vfma.f32	s1, s13, s15
 804d558:	ee30 0a60 	vsub.f32	s0, s0, s1
 804d55c:	4770      	bx	lr
 804d55e:	bf00      	nop
 804d560:	2f2ec9d3 	.word	0x2f2ec9d3
 804d564:	b2d72f34 	.word	0xb2d72f34
 804d568:	3638ef1b 	.word	0x3638ef1b
 804d56c:	b9500d01 	.word	0xb9500d01
 804d570:	3c088889 	.word	0x3c088889
 804d574:	be2aaaab 	.word	0xbe2aaaab
 804d578:	3e2aaaab 	.word	0x3e2aaaab

0804d57c <__ieee754_expf>:
 804d57c:	ee10 2a10 	vmov	r2, s0
 804d580:	f022 4300 	bic.w	r3, r2, #2147483648	@ 0x80000000
 804d584:	f1b3 4fff 	cmp.w	r3, #2139095040	@ 0x7f800000
 804d588:	d902      	bls.n	804d590 <__ieee754_expf+0x14>
 804d58a:	ee30 0a00 	vadd.f32	s0, s0, s0
 804d58e:	4770      	bx	lr
 804d590:	ea4f 71d2 	mov.w	r1, r2, lsr #31
 804d594:	d105      	bne.n	804d5a2 <__ieee754_expf+0x26>
 804d596:	2900      	cmp	r1, #0
 804d598:	eddf 7a4d 	vldr	s15, [pc, #308]	@ 804d6d0 <__ieee754_expf+0x154>
 804d59c:	fe00 0a27 	vseleq.f32	s0, s0, s15
 804d5a0:	4770      	bx	lr
 804d5a2:	484c      	ldr	r0, [pc, #304]	@ (804d6d4 <__ieee754_expf+0x158>)
 804d5a4:	4282      	cmp	r2, r0
 804d5a6:	dd02      	ble.n	804d5ae <__ieee754_expf+0x32>
 804d5a8:	2000      	movs	r0, #0
 804d5aa:	f000 baf9 	b.w	804dba0 <__math_oflowf>
 804d5ae:	2a00      	cmp	r2, #0
 804d5b0:	da05      	bge.n	804d5be <__ieee754_expf+0x42>
 804d5b2:	4a49      	ldr	r2, [pc, #292]	@ (804d6d8 <__ieee754_expf+0x15c>)
 804d5b4:	4293      	cmp	r3, r2
 804d5b6:	d902      	bls.n	804d5be <__ieee754_expf+0x42>
 804d5b8:	2000      	movs	r0, #0
 804d5ba:	f000 baeb 	b.w	804db94 <__math_uflowf>
 804d5be:	4a47      	ldr	r2, [pc, #284]	@ (804d6dc <__ieee754_expf+0x160>)
 804d5c0:	eef7 5a00 	vmov.f32	s11, #112	@ 0x3f800000  1.0
 804d5c4:	4293      	cmp	r3, r2
 804d5c6:	d952      	bls.n	804d66e <__ieee754_expf+0xf2>
 804d5c8:	4a45      	ldr	r2, [pc, #276]	@ (804d6e0 <__ieee754_expf+0x164>)
 804d5ca:	4293      	cmp	r3, r2
 804d5cc:	ea4f 0281 	mov.w	r2, r1, lsl #2
 804d5d0:	d834      	bhi.n	804d63c <__ieee754_expf+0xc0>
 804d5d2:	4b44      	ldr	r3, [pc, #272]	@ (804d6e4 <__ieee754_expf+0x168>)
 804d5d4:	4413      	add	r3, r2
 804d5d6:	ed93 7a00 	vldr	s14, [r3]
 804d5da:	4b43      	ldr	r3, [pc, #268]	@ (804d6e8 <__ieee754_expf+0x16c>)
 804d5dc:	ee30 7a47 	vsub.f32	s14, s0, s14
 804d5e0:	4413      	add	r3, r2
 804d5e2:	f1c1 0201 	rsb	r2, r1, #1
 804d5e6:	edd3 7a00 	vldr	s15, [r3]
 804d5ea:	1a52      	subs	r2, r2, r1
 804d5ec:	ee37 0a67 	vsub.f32	s0, s14, s15
 804d5f0:	ee20 6a00 	vmul.f32	s12, s0, s0
 804d5f4:	ed9f 5a3d 	vldr	s10, [pc, #244]	@ 804d6ec <__ieee754_expf+0x170>
 804d5f8:	eddf 6a3d 	vldr	s13, [pc, #244]	@ 804d6f0 <__ieee754_expf+0x174>
 804d5fc:	eee6 6a05 	vfma.f32	s13, s12, s10
 804d600:	ed9f 5a3c 	vldr	s10, [pc, #240]	@ 804d6f4 <__ieee754_expf+0x178>
 804d604:	eea6 5a86 	vfma.f32	s10, s13, s12
 804d608:	eddf 6a3b 	vldr	s13, [pc, #236]	@ 804d6f8 <__ieee754_expf+0x17c>
 804d60c:	eee5 6a06 	vfma.f32	s13, s10, s12
 804d610:	ed9f 5a3a 	vldr	s10, [pc, #232]	@ 804d6fc <__ieee754_expf+0x180>
 804d614:	eea6 5a86 	vfma.f32	s10, s13, s12
 804d618:	eef0 6a40 	vmov.f32	s13, s0
 804d61c:	eee5 6a46 	vfms.f32	s13, s10, s12
 804d620:	eeb0 6a00 	vmov.f32	s12, #0	@ 0x40000000  2.0
 804d624:	ee20 5a26 	vmul.f32	s10, s0, s13
 804d628:	bb92      	cbnz	r2, 804d690 <__ieee754_expf+0x114>
 804d62a:	ee76 6ac6 	vsub.f32	s13, s13, s12
 804d62e:	eec5 7a26 	vdiv.f32	s15, s10, s13
 804d632:	ee37 0ac0 	vsub.f32	s0, s15, s0
 804d636:	ee35 0ac0 	vsub.f32	s0, s11, s0
 804d63a:	4770      	bx	lr
 804d63c:	4b30      	ldr	r3, [pc, #192]	@ (804d700 <__ieee754_expf+0x184>)
 804d63e:	ed9f 7a31 	vldr	s14, [pc, #196]	@ 804d704 <__ieee754_expf+0x188>
 804d642:	4413      	add	r3, r2
 804d644:	eddf 6a30 	vldr	s13, [pc, #192]	@ 804d708 <__ieee754_expf+0x18c>
 804d648:	edd3 7a00 	vldr	s15, [r3]
 804d64c:	eee0 7a07 	vfma.f32	s15, s0, s14
 804d650:	eeb0 7a40 	vmov.f32	s14, s0
 804d654:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 804d658:	ee17 2a90 	vmov	r2, s15
 804d65c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 804d660:	eea7 7ae6 	vfms.f32	s14, s15, s13
 804d664:	eddf 6a29 	vldr	s13, [pc, #164]	@ 804d70c <__ieee754_expf+0x190>
 804d668:	ee67 7aa6 	vmul.f32	s15, s15, s13
 804d66c:	e7be      	b.n	804d5ec <__ieee754_expf+0x70>
 804d66e:	f1b3 5f50 	cmp.w	r3, #872415232	@ 0x34000000
 804d672:	d20b      	bcs.n	804d68c <__ieee754_expf+0x110>
 804d674:	eddf 6a26 	vldr	s13, [pc, #152]	@ 804d710 <__ieee754_expf+0x194>
 804d678:	ee70 6a26 	vadd.f32	s13, s0, s13
 804d67c:	eef4 6ae5 	vcmpe.f32	s13, s11
 804d680:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 804d684:	dd02      	ble.n	804d68c <__ieee754_expf+0x110>
 804d686:	ee30 0a25 	vadd.f32	s0, s0, s11
 804d68a:	4770      	bx	lr
 804d68c:	2200      	movs	r2, #0
 804d68e:	e7af      	b.n	804d5f0 <__ieee754_expf+0x74>
 804d690:	ee36 6a66 	vsub.f32	s12, s12, s13
 804d694:	f112 0f7d 	cmn.w	r2, #125	@ 0x7d
 804d698:	bfb8      	it	lt
 804d69a:	3264      	addlt	r2, #100	@ 0x64
 804d69c:	eec5 6a06 	vdiv.f32	s13, s10, s12
 804d6a0:	ee77 7ae6 	vsub.f32	s15, s15, s13
 804d6a4:	ee77 7ac7 	vsub.f32	s15, s15, s14
 804d6a8:	ee75 7ae7 	vsub.f32	s15, s11, s15
 804d6ac:	ee17 3a90 	vmov	r3, s15
 804d6b0:	bfb5      	itete	lt
 804d6b2:	eddf 7a18 	vldrlt	s15, [pc, #96]	@ 804d714 <__ieee754_expf+0x198>
 804d6b6:	eb03 53c2 	addge.w	r3, r3, r2, lsl #23
 804d6ba:	eb03 53c2 	addlt.w	r3, r3, r2, lsl #23
 804d6be:	ee00 3a10 	vmovge	s0, r3
 804d6c2:	bfbc      	itt	lt
 804d6c4:	ee00 3a10 	vmovlt	s0, r3
 804d6c8:	ee20 0a27 	vmullt.f32	s0, s0, s15
 804d6cc:	4770      	bx	lr
 804d6ce:	bf00      	nop
 804d6d0:	00000000 	.word	0x00000000
 804d6d4:	42b17217 	.word	0x42b17217
 804d6d8:	42cff1b5 	.word	0x42cff1b5
 804d6dc:	3eb17218 	.word	0x3eb17218
 804d6e0:	3f851591 	.word	0x3f851591
 804d6e4:	0804e6e0 	.word	0x0804e6e0
 804d6e8:	0804e6d8 	.word	0x0804e6d8
 804d6ec:	3331bb4c 	.word	0x3331bb4c
 804d6f0:	b5ddea0e 	.word	0xb5ddea0e
 804d6f4:	388ab355 	.word	0x388ab355
 804d6f8:	bb360b61 	.word	0xbb360b61
 804d6fc:	3e2aaaab 	.word	0x3e2aaaab
 804d700:	0804e6e8 	.word	0x0804e6e8
 804d704:	3fb8aa3b 	.word	0x3fb8aa3b
 804d708:	3f317180 	.word	0x3f317180
 804d70c:	3717f7d1 	.word	0x3717f7d1
 804d710:	7149f2ca 	.word	0x7149f2ca
 804d714:	0d800000 	.word	0x0d800000

0804d718 <__ieee754_logf>:
 804d718:	ee10 3a10 	vmov	r3, s0
 804d71c:	f033 4200 	bics.w	r2, r3, #2147483648	@ 0x80000000
 804d720:	d106      	bne.n	804d730 <__ieee754_logf+0x18>
 804d722:	ed9f 7a65 	vldr	s14, [pc, #404]	@ 804d8b8 <__ieee754_logf+0x1a0>
 804d726:	eddf 7a65 	vldr	s15, [pc, #404]	@ 804d8bc <__ieee754_logf+0x1a4>
 804d72a:	ee87 0a27 	vdiv.f32	s0, s14, s15
 804d72e:	4770      	bx	lr
 804d730:	2b00      	cmp	r3, #0
 804d732:	461a      	mov	r2, r3
 804d734:	da02      	bge.n	804d73c <__ieee754_logf+0x24>
 804d736:	ee30 7a40 	vsub.f32	s14, s0, s0
 804d73a:	e7f4      	b.n	804d726 <__ieee754_logf+0xe>
 804d73c:	f1b3 4fff 	cmp.w	r3, #2139095040	@ 0x7f800000
 804d740:	db02      	blt.n	804d748 <__ieee754_logf+0x30>
 804d742:	ee30 0a00 	vadd.f32	s0, s0, s0
 804d746:	4770      	bx	lr
 804d748:	f5b3 0f00 	cmp.w	r3, #8388608	@ 0x800000
 804d74c:	485c      	ldr	r0, [pc, #368]	@ (804d8c0 <__ieee754_logf+0x1a8>)
 804d74e:	bfbb      	ittet	lt
 804d750:	eddf 7a5c 	vldrlt	s15, [pc, #368]	@ 804d8c4 <__ieee754_logf+0x1ac>
 804d754:	f06f 0118 	mvnlt.w	r1, #24
 804d758:	2100      	movge	r1, #0
 804d75a:	ee60 7a27 	vmullt.f32	s15, s0, s15
 804d75e:	bfb8      	it	lt
 804d760:	ee17 2a90 	vmovlt	r2, s15
 804d764:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 804d768:	15d3      	asrs	r3, r2, #23
 804d76a:	f3c2 0216 	ubfx	r2, r2, #0, #23
 804d76e:	3b7f      	subs	r3, #127	@ 0x7f
 804d770:	4410      	add	r0, r2
 804d772:	440b      	add	r3, r1
 804d774:	f400 0100 	and.w	r1, r0, #8388608	@ 0x800000
 804d778:	f081 517e 	eor.w	r1, r1, #1065353216	@ 0x3f800000
 804d77c:	eb03 53d0 	add.w	r3, r3, r0, lsr #23
 804d780:	f102 000f 	add.w	r0, r2, #15
 804d784:	4311      	orrs	r1, r2
 804d786:	ee00 1a10 	vmov	s0, r1
 804d78a:	494f      	ldr	r1, [pc, #316]	@ (804d8c8 <__ieee754_logf+0x1b0>)
 804d78c:	4001      	ands	r1, r0
 804d78e:	ee30 0a67 	vsub.f32	s0, s0, s15
 804d792:	bb89      	cbnz	r1, 804d7f8 <__ieee754_logf+0xe0>
 804d794:	eeb5 0a40 	vcmp.f32	s0, #0.0
 804d798:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 804d79c:	d10f      	bne.n	804d7be <__ieee754_logf+0xa6>
 804d79e:	2b00      	cmp	r3, #0
 804d7a0:	f000 8087 	beq.w	804d8b2 <__ieee754_logf+0x19a>
 804d7a4:	ee07 3a90 	vmov	s15, r3
 804d7a8:	ed9f 0a48 	vldr	s0, [pc, #288]	@ 804d8cc <__ieee754_logf+0x1b4>
 804d7ac:	ed9f 7a48 	vldr	s14, [pc, #288]	@ 804d8d0 <__ieee754_logf+0x1b8>
 804d7b0:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 804d7b4:	ee27 0a80 	vmul.f32	s0, s15, s0
 804d7b8:	eea7 0a87 	vfma.f32	s0, s15, s14
 804d7bc:	4770      	bx	lr
 804d7be:	eef6 7a00 	vmov.f32	s15, #96	@ 0x3f000000  0.5
 804d7c2:	eddf 6a44 	vldr	s13, [pc, #272]	@ 804d8d4 <__ieee754_logf+0x1bc>
 804d7c6:	ee20 7a00 	vmul.f32	s14, s0, s0
 804d7ca:	eee0 7a66 	vfms.f32	s15, s0, s13
 804d7ce:	ee27 7a27 	vmul.f32	s14, s14, s15
 804d7d2:	b913      	cbnz	r3, 804d7da <__ieee754_logf+0xc2>
 804d7d4:	ee30 0a47 	vsub.f32	s0, s0, s14
 804d7d8:	4770      	bx	lr
 804d7da:	ee07 3a90 	vmov	s15, r3
 804d7de:	eddf 6a3b 	vldr	s13, [pc, #236]	@ 804d8cc <__ieee754_logf+0x1b4>
 804d7e2:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 804d7e6:	eea7 7ae6 	vfms.f32	s14, s15, s13
 804d7ea:	ee37 0a40 	vsub.f32	s0, s14, s0
 804d7ee:	ed9f 7a38 	vldr	s14, [pc, #224]	@ 804d8d0 <__ieee754_logf+0x1b8>
 804d7f2:	ee97 0a87 	vfnms.f32	s0, s15, s14
 804d7f6:	4770      	bx	lr
 804d7f8:	eef0 7a00 	vmov.f32	s15, #0	@ 0x40000000  2.0
 804d7fc:	eddf 5a36 	vldr	s11, [pc, #216]	@ 804d8d8 <__ieee754_logf+0x1c0>
 804d800:	eddf 4a36 	vldr	s9, [pc, #216]	@ 804d8dc <__ieee754_logf+0x1c4>
 804d804:	4936      	ldr	r1, [pc, #216]	@ (804d8e0 <__ieee754_logf+0x1c8>)
 804d806:	ee70 7a27 	vadd.f32	s15, s0, s15
 804d80a:	4411      	add	r1, r2
 804d80c:	f5c2 1257 	rsb	r2, r2, #3522560	@ 0x35c000
 804d810:	ee80 6a27 	vdiv.f32	s12, s0, s15
 804d814:	ee07 3a90 	vmov	s15, r3
 804d818:	f502 7222 	add.w	r2, r2, #648	@ 0x288
 804d81c:	430a      	orrs	r2, r1
 804d81e:	eef8 6ae7 	vcvt.f32.s32	s13, s15
 804d822:	eddf 7a30 	vldr	s15, [pc, #192]	@ 804d8e4 <__ieee754_logf+0x1cc>
 804d826:	2a00      	cmp	r2, #0
 804d828:	ee26 5a06 	vmul.f32	s10, s12, s12
 804d82c:	ee25 7a05 	vmul.f32	s14, s10, s10
 804d830:	eee7 7a25 	vfma.f32	s15, s14, s11
 804d834:	eddf 5a2c 	vldr	s11, [pc, #176]	@ 804d8e8 <__ieee754_logf+0x1d0>
 804d838:	eee7 5a87 	vfma.f32	s11, s15, s14
 804d83c:	eddf 7a2b 	vldr	s15, [pc, #172]	@ 804d8ec <__ieee754_logf+0x1d4>
 804d840:	eee7 7a24 	vfma.f32	s15, s14, s9
 804d844:	eddf 4a2a 	vldr	s9, [pc, #168]	@ 804d8f0 <__ieee754_logf+0x1d8>
 804d848:	eee7 4a87 	vfma.f32	s9, s15, s14
 804d84c:	eddf 7a29 	vldr	s15, [pc, #164]	@ 804d8f4 <__ieee754_logf+0x1dc>
 804d850:	eee4 7a87 	vfma.f32	s15, s9, s14
 804d854:	ee67 7a85 	vmul.f32	s15, s15, s10
 804d858:	eee5 7a87 	vfma.f32	s15, s11, s14
 804d85c:	dd1a      	ble.n	804d894 <__ieee754_logf+0x17c>
 804d85e:	eeb6 7a00 	vmov.f32	s14, #96	@ 0x3f000000  0.5
 804d862:	ee20 7a07 	vmul.f32	s14, s0, s14
 804d866:	ee27 7a00 	vmul.f32	s14, s14, s0
 804d86a:	ee77 7a87 	vadd.f32	s15, s15, s14
 804d86e:	ee67 7a86 	vmul.f32	s15, s15, s12
 804d872:	b913      	cbnz	r3, 804d87a <__ieee754_logf+0x162>
 804d874:	ee37 7a67 	vsub.f32	s14, s14, s15
 804d878:	e7ac      	b.n	804d7d4 <__ieee754_logf+0xbc>
 804d87a:	ed9f 6a14 	vldr	s12, [pc, #80]	@ 804d8cc <__ieee754_logf+0x1b4>
 804d87e:	eee6 7a86 	vfma.f32	s15, s13, s12
 804d882:	ee37 7a67 	vsub.f32	s14, s14, s15
 804d886:	ee37 0a40 	vsub.f32	s0, s14, s0
 804d88a:	eddf 7a11 	vldr	s15, [pc, #68]	@ 804d8d0 <__ieee754_logf+0x1b8>
 804d88e:	ee96 0aa7 	vfnms.f32	s0, s13, s15
 804d892:	4770      	bx	lr
 804d894:	ee70 7a67 	vsub.f32	s15, s0, s15
 804d898:	ee67 7a86 	vmul.f32	s15, s15, s12
 804d89c:	b913      	cbnz	r3, 804d8a4 <__ieee754_logf+0x18c>
 804d89e:	ee30 0a67 	vsub.f32	s0, s0, s15
 804d8a2:	4770      	bx	lr
 804d8a4:	ed9f 7a09 	vldr	s14, [pc, #36]	@ 804d8cc <__ieee754_logf+0x1b4>
 804d8a8:	eee6 7ac7 	vfms.f32	s15, s13, s14
 804d8ac:	ee37 0ac0 	vsub.f32	s0, s15, s0
 804d8b0:	e7eb      	b.n	804d88a <__ieee754_logf+0x172>
 804d8b2:	ed9f 0a02 	vldr	s0, [pc, #8]	@ 804d8bc <__ieee754_logf+0x1a4>
 804d8b6:	4770      	bx	lr
 804d8b8:	cc000000 	.word	0xcc000000
 804d8bc:	00000000 	.word	0x00000000
 804d8c0:	004afb20 	.word	0x004afb20
 804d8c4:	4c000000 	.word	0x4c000000
 804d8c8:	007ffff0 	.word	0x007ffff0
 804d8cc:	3717f7d1 	.word	0x3717f7d1
 804d8d0:	3f317180 	.word	0x3f317180
 804d8d4:	3eaaaaab 	.word	0x3eaaaaab
 804d8d8:	3e1cd04f 	.word	0x3e1cd04f
 804d8dc:	3e178897 	.word	0x3e178897
 804d8e0:	ffcf5c30 	.word	0xffcf5c30
 804d8e4:	3e638e29 	.word	0x3e638e29
 804d8e8:	3ecccccd 	.word	0x3ecccccd
 804d8ec:	3e3a3325 	.word	0x3e3a3325
 804d8f0:	3e924925 	.word	0x3e924925
 804d8f4:	3f2aaaab 	.word	0x3f2aaaab

0804d8f8 <__ieee754_rem_pio2f>:
 804d8f8:	b5f0      	push	{r4, r5, r6, r7, lr}
 804d8fa:	ee10 6a10 	vmov	r6, s0
 804d8fe:	4b87      	ldr	r3, [pc, #540]	@ (804db1c <__ieee754_rem_pio2f+0x224>)
 804d900:	b087      	sub	sp, #28
 804d902:	4604      	mov	r4, r0
 804d904:	f026 4500 	bic.w	r5, r6, #2147483648	@ 0x80000000
 804d908:	429d      	cmp	r5, r3
 804d90a:	d805      	bhi.n	804d918 <__ieee754_rem_pio2f+0x20>
 804d90c:	2300      	movs	r3, #0
 804d90e:	ed80 0a00 	vstr	s0, [r0]
 804d912:	6043      	str	r3, [r0, #4]
 804d914:	2000      	movs	r0, #0
 804d916:	e022      	b.n	804d95e <__ieee754_rem_pio2f+0x66>
 804d918:	4b81      	ldr	r3, [pc, #516]	@ (804db20 <__ieee754_rem_pio2f+0x228>)
 804d91a:	429d      	cmp	r5, r3
 804d91c:	d83a      	bhi.n	804d994 <__ieee754_rem_pio2f+0x9c>
 804d91e:	f026 4300 	bic.w	r3, r6, #2147483648	@ 0x80000000
 804d922:	2e00      	cmp	r6, #0
 804d924:	ed9f 7a7f 	vldr	s14, [pc, #508]	@ 804db24 <__ieee754_rem_pio2f+0x22c>
 804d928:	f023 030f 	bic.w	r3, r3, #15
 804d92c:	4a7e      	ldr	r2, [pc, #504]	@ (804db28 <__ieee754_rem_pio2f+0x230>)
 804d92e:	dd18      	ble.n	804d962 <__ieee754_rem_pio2f+0x6a>
 804d930:	4293      	cmp	r3, r2
 804d932:	ee70 7a47 	vsub.f32	s15, s0, s14
 804d936:	bf09      	itett	eq
 804d938:	ed9f 7a7c 	vldreq	s14, [pc, #496]	@ 804db2c <__ieee754_rem_pio2f+0x234>
 804d93c:	eddf 6a7c 	vldrne	s13, [pc, #496]	@ 804db30 <__ieee754_rem_pio2f+0x238>
 804d940:	ee77 7ac7 	vsubeq.f32	s15, s15, s14
 804d944:	eddf 6a7b 	vldreq	s13, [pc, #492]	@ 804db34 <__ieee754_rem_pio2f+0x23c>
 804d948:	ee37 7ae6 	vsub.f32	s14, s15, s13
 804d94c:	ee77 7ac7 	vsub.f32	s15, s15, s14
 804d950:	ed80 7a00 	vstr	s14, [r0]
 804d954:	ee77 7ae6 	vsub.f32	s15, s15, s13
 804d958:	edc0 7a01 	vstr	s15, [r0, #4]
 804d95c:	2001      	movs	r0, #1
 804d95e:	b007      	add	sp, #28
 804d960:	bdf0      	pop	{r4, r5, r6, r7, pc}
 804d962:	4293      	cmp	r3, r2
 804d964:	ee70 7a07 	vadd.f32	s15, s0, s14
 804d968:	bf09      	itett	eq
 804d96a:	ed9f 7a70 	vldreq	s14, [pc, #448]	@ 804db2c <__ieee754_rem_pio2f+0x234>
 804d96e:	eddf 6a70 	vldrne	s13, [pc, #448]	@ 804db30 <__ieee754_rem_pio2f+0x238>
 804d972:	ee77 7a87 	vaddeq.f32	s15, s15, s14
 804d976:	eddf 6a6f 	vldreq	s13, [pc, #444]	@ 804db34 <__ieee754_rem_pio2f+0x23c>
 804d97a:	ee37 7aa6 	vadd.f32	s14, s15, s13
 804d97e:	ee77 7ac7 	vsub.f32	s15, s15, s14
 804d982:	ed80 7a00 	vstr	s14, [r0]
 804d986:	ee77 7aa6 	vadd.f32	s15, s15, s13
 804d98a:	edc0 7a01 	vstr	s15, [r0, #4]
 804d98e:	f04f 30ff 	mov.w	r0, #4294967295
 804d992:	e7e4      	b.n	804d95e <__ieee754_rem_pio2f+0x66>
 804d994:	4b68      	ldr	r3, [pc, #416]	@ (804db38 <__ieee754_rem_pio2f+0x240>)
 804d996:	429d      	cmp	r5, r3
 804d998:	d872      	bhi.n	804da80 <__ieee754_rem_pio2f+0x188>
 804d99a:	f000 f8db 	bl	804db54 <fabsf>
 804d99e:	eef6 7a00 	vmov.f32	s15, #96	@ 0x3f000000  0.5
 804d9a2:	ed9f 7a66 	vldr	s14, [pc, #408]	@ 804db3c <__ieee754_rem_pio2f+0x244>
 804d9a6:	eee0 7a07 	vfma.f32	s15, s0, s14
 804d9aa:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 804d9ae:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 804d9b2:	ee17 0a90 	vmov	r0, s15
 804d9b6:	eddf 7a5b 	vldr	s15, [pc, #364]	@ 804db24 <__ieee754_rem_pio2f+0x22c>
 804d9ba:	281f      	cmp	r0, #31
 804d9bc:	eea7 0a67 	vfms.f32	s0, s14, s15
 804d9c0:	eddf 7a5b 	vldr	s15, [pc, #364]	@ 804db30 <__ieee754_rem_pio2f+0x238>
 804d9c4:	eeb1 6a47 	vneg.f32	s12, s14
 804d9c8:	ee67 7a27 	vmul.f32	s15, s14, s15
 804d9cc:	ee70 6a67 	vsub.f32	s13, s0, s15
 804d9d0:	ee16 1a90 	vmov	r1, s13
 804d9d4:	dc09      	bgt.n	804d9ea <__ieee754_rem_pio2f+0xf2>
 804d9d6:	f026 4300 	bic.w	r3, r6, #2147483648	@ 0x80000000
 804d9da:	1e47      	subs	r7, r0, #1
 804d9dc:	4a58      	ldr	r2, [pc, #352]	@ (804db40 <__ieee754_rem_pio2f+0x248>)
 804d9de:	f023 03ff 	bic.w	r3, r3, #255	@ 0xff
 804d9e2:	f852 2027 	ldr.w	r2, [r2, r7, lsl #2]
 804d9e6:	4293      	cmp	r3, r2
 804d9e8:	d106      	bne.n	804d9f8 <__ieee754_rem_pio2f+0x100>
 804d9ea:	f3c1 52c7 	ubfx	r2, r1, #23, #8
 804d9ee:	15eb      	asrs	r3, r5, #23
 804d9f0:	ebc2 52d5 	rsb	r2, r2, r5, lsr #23
 804d9f4:	2a08      	cmp	r2, #8
 804d9f6:	dc14      	bgt.n	804da22 <__ieee754_rem_pio2f+0x12a>
 804d9f8:	6021      	str	r1, [r4, #0]
 804d9fa:	ed94 7a00 	vldr	s14, [r4]
 804d9fe:	2e00      	cmp	r6, #0
 804da00:	ee30 0a47 	vsub.f32	s0, s0, s14
 804da04:	ee30 0a67 	vsub.f32	s0, s0, s15
 804da08:	ed84 0a01 	vstr	s0, [r4, #4]
 804da0c:	daa7      	bge.n	804d95e <__ieee754_rem_pio2f+0x66>
 804da0e:	eeb1 7a47 	vneg.f32	s14, s14
 804da12:	eeb1 0a40 	vneg.f32	s0, s0
 804da16:	ed84 7a00 	vstr	s14, [r4]
 804da1a:	ed84 0a01 	vstr	s0, [r4, #4]
 804da1e:	4240      	negs	r0, r0
 804da20:	e79d      	b.n	804d95e <__ieee754_rem_pio2f+0x66>
 804da22:	eef0 6a40 	vmov.f32	s13, s0
 804da26:	eddf 5a41 	vldr	s11, [pc, #260]	@ 804db2c <__ieee754_rem_pio2f+0x234>
 804da2a:	eee6 6a25 	vfma.f32	s13, s12, s11
 804da2e:	ee70 7a66 	vsub.f32	s15, s0, s13
 804da32:	eee6 7a25 	vfma.f32	s15, s12, s11
 804da36:	eddf 5a3f 	vldr	s11, [pc, #252]	@ 804db34 <__ieee754_rem_pio2f+0x23c>
 804da3a:	eed7 7a25 	vfnms.f32	s15, s14, s11
 804da3e:	ee76 5ae7 	vsub.f32	s11, s13, s15
 804da42:	ee15 2a90 	vmov	r2, s11
 804da46:	f3c2 51c7 	ubfx	r1, r2, #23, #8
 804da4a:	1a5b      	subs	r3, r3, r1
 804da4c:	2b19      	cmp	r3, #25
 804da4e:	dc04      	bgt.n	804da5a <__ieee754_rem_pio2f+0x162>
 804da50:	eeb0 0a66 	vmov.f32	s0, s13
 804da54:	edc4 5a00 	vstr	s11, [r4]
 804da58:	e7cf      	b.n	804d9fa <__ieee754_rem_pio2f+0x102>
 804da5a:	eeb0 0a66 	vmov.f32	s0, s13
 804da5e:	eddf 5a39 	vldr	s11, [pc, #228]	@ 804db44 <__ieee754_rem_pio2f+0x24c>
 804da62:	eea6 0a25 	vfma.f32	s0, s12, s11
 804da66:	ee76 7ac0 	vsub.f32	s15, s13, s0
 804da6a:	eddf 6a37 	vldr	s13, [pc, #220]	@ 804db48 <__ieee754_rem_pio2f+0x250>
 804da6e:	eee6 7a25 	vfma.f32	s15, s12, s11
 804da72:	eed7 7a26 	vfnms.f32	s15, s14, s13
 804da76:	ee30 7a67 	vsub.f32	s14, s0, s15
 804da7a:	ed84 7a00 	vstr	s14, [r4]
 804da7e:	e7bc      	b.n	804d9fa <__ieee754_rem_pio2f+0x102>
 804da80:	f1b5 4fff 	cmp.w	r5, #2139095040	@ 0x7f800000
 804da84:	d306      	bcc.n	804da94 <__ieee754_rem_pio2f+0x19c>
 804da86:	ee70 7a40 	vsub.f32	s15, s0, s0
 804da8a:	edc0 7a01 	vstr	s15, [r0, #4]
 804da8e:	edc0 7a00 	vstr	s15, [r0]
 804da92:	e73f      	b.n	804d914 <__ieee754_rem_pio2f+0x1c>
 804da94:	15ea      	asrs	r2, r5, #23
 804da96:	eddf 6a2d 	vldr	s13, [pc, #180]	@ 804db4c <__ieee754_rem_pio2f+0x254>
 804da9a:	3a86      	subs	r2, #134	@ 0x86
 804da9c:	eba5 53c2 	sub.w	r3, r5, r2, lsl #23
 804daa0:	ee07 3a90 	vmov	s15, r3
 804daa4:	eebd 7ae7 	vcvt.s32.f32	s14, s15
 804daa8:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 804daac:	ee77 7ac7 	vsub.f32	s15, s15, s14
 804dab0:	ed8d 7a03 	vstr	s14, [sp, #12]
 804dab4:	ee67 7aa6 	vmul.f32	s15, s15, s13
 804dab8:	eebd 7ae7 	vcvt.s32.f32	s14, s15
 804dabc:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 804dac0:	ee77 7ac7 	vsub.f32	s15, s15, s14
 804dac4:	ed8d 7a04 	vstr	s14, [sp, #16]
 804dac8:	ee67 7aa6 	vmul.f32	s15, s15, s13
 804dacc:	eef5 7a40 	vcmp.f32	s15, #0.0
 804dad0:	edcd 7a05 	vstr	s15, [sp, #20]
 804dad4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 804dad8:	d11e      	bne.n	804db18 <__ieee754_rem_pio2f+0x220>
 804dada:	eeb5 7a40 	vcmp.f32	s14, #0.0
 804dade:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 804dae2:	bf0c      	ite	eq
 804dae4:	2301      	moveq	r3, #1
 804dae6:	2302      	movne	r3, #2
 804dae8:	4919      	ldr	r1, [pc, #100]	@ (804db50 <__ieee754_rem_pio2f+0x258>)
 804daea:	a803      	add	r0, sp, #12
 804daec:	9101      	str	r1, [sp, #4]
 804daee:	2102      	movs	r1, #2
 804daf0:	9100      	str	r1, [sp, #0]
 804daf2:	4621      	mov	r1, r4
 804daf4:	f000 f85a 	bl	804dbac <__kernel_rem_pio2f>
 804daf8:	2e00      	cmp	r6, #0
 804dafa:	f6bf af30 	bge.w	804d95e <__ieee754_rem_pio2f+0x66>
 804dafe:	edd4 7a00 	vldr	s15, [r4]
 804db02:	eef1 7a67 	vneg.f32	s15, s15
 804db06:	edc4 7a00 	vstr	s15, [r4]
 804db0a:	edd4 7a01 	vldr	s15, [r4, #4]
 804db0e:	eef1 7a67 	vneg.f32	s15, s15
 804db12:	edc4 7a01 	vstr	s15, [r4, #4]
 804db16:	e782      	b.n	804da1e <__ieee754_rem_pio2f+0x126>
 804db18:	2303      	movs	r3, #3
 804db1a:	e7e5      	b.n	804dae8 <__ieee754_rem_pio2f+0x1f0>
 804db1c:	3f490fd8 	.word	0x3f490fd8
 804db20:	4016cbe3 	.word	0x4016cbe3
 804db24:	3fc90f80 	.word	0x3fc90f80
 804db28:	3fc90fd0 	.word	0x3fc90fd0
 804db2c:	37354400 	.word	0x37354400
 804db30:	37354443 	.word	0x37354443
 804db34:	2e85a308 	.word	0x2e85a308
 804db38:	43490f80 	.word	0x43490f80
 804db3c:	3f22f984 	.word	0x3f22f984
 804db40:	0804e6f0 	.word	0x0804e6f0
 804db44:	2e85a300 	.word	0x2e85a300
 804db48:	248d3132 	.word	0x248d3132
 804db4c:	43800000 	.word	0x43800000
 804db50:	0804e770 	.word	0x0804e770

0804db54 <fabsf>:
 804db54:	ee10 3a10 	vmov	r3, s0
 804db58:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
 804db5c:	ee00 3a10 	vmov	s0, r3
 804db60:	4770      	bx	lr

0804db62 <with_errnof>:
 804db62:	b510      	push	{r4, lr}
 804db64:	ed2d 8b02 	vpush	{d8}
 804db68:	eeb0 8a40 	vmov.f32	s16, s0
 804db6c:	4604      	mov	r4, r0
 804db6e:	f7fe fa31 	bl	804bfd4 <__errno>
 804db72:	6004      	str	r4, [r0, #0]
 804db74:	eeb0 0a48 	vmov.f32	s0, s16
 804db78:	ecbd 8b02 	vpop	{d8}
 804db7c:	bd10      	pop	{r4, pc}

0804db7e <xflowf>:
 804db7e:	b130      	cbz	r0, 804db8e <xflowf+0x10>
 804db80:	eef1 7a40 	vneg.f32	s15, s0
 804db84:	ee27 0a80 	vmul.f32	s0, s15, s0
 804db88:	2022      	movs	r0, #34	@ 0x22
 804db8a:	f7ff bfea 	b.w	804db62 <with_errnof>
 804db8e:	eef0 7a40 	vmov.f32	s15, s0
 804db92:	e7f7      	b.n	804db84 <xflowf+0x6>

0804db94 <__math_uflowf>:
 804db94:	ed9f 0a01 	vldr	s0, [pc, #4]	@ 804db9c <__math_uflowf+0x8>
 804db98:	f7ff bff1 	b.w	804db7e <xflowf>
 804db9c:	10000000 	.word	0x10000000

0804dba0 <__math_oflowf>:
 804dba0:	ed9f 0a01 	vldr	s0, [pc, #4]	@ 804dba8 <__math_oflowf+0x8>
 804dba4:	f7ff bfeb 	b.w	804db7e <xflowf>
 804dba8:	70000000 	.word	0x70000000

0804dbac <__kernel_rem_pio2f>:
 804dbac:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 804dbb0:	4690      	mov	r8, r2
 804dbb2:	4abc      	ldr	r2, [pc, #752]	@ (804dea4 <__kernel_rem_pio2f+0x2f8>)
 804dbb4:	460f      	mov	r7, r1
 804dbb6:	f103 3bff 	add.w	fp, r3, #4294967295
 804dbba:	f118 0f04 	cmn.w	r8, #4
 804dbbe:	ed2d 8b04 	vpush	{d8-d9}
 804dbc2:	b0d9      	sub	sp, #356	@ 0x164
 804dbc4:	9001      	str	r0, [sp, #4]
 804dbc6:	9866      	ldr	r0, [sp, #408]	@ 0x198
 804dbc8:	f852 a020 	ldr.w	sl, [r2, r0, lsl #2]
 804dbcc:	db27      	blt.n	804dc1e <__kernel_rem_pio2f+0x72>
 804dbce:	f1b8 0203 	subs.w	r2, r8, #3
 804dbd2:	bf48      	it	mi
 804dbd4:	f108 0204 	addmi.w	r2, r8, #4
 804dbd8:	10d2      	asrs	r2, r2, #3
 804dbda:	1c55      	adds	r5, r2, #1
 804dbdc:	eba2 060b 	sub.w	r6, r2, fp
 804dbe0:	9967      	ldr	r1, [sp, #412]	@ 0x19c
 804dbe2:	eb0a 0c0b 	add.w	ip, sl, fp
 804dbe6:	00e8      	lsls	r0, r5, #3
 804dbe8:	ac1c      	add	r4, sp, #112	@ 0x70
 804dbea:	eba8 05c5 	sub.w	r5, r8, r5, lsl #3
 804dbee:	ed9f 7ab1 	vldr	s14, [pc, #708]	@ 804deb4 <__kernel_rem_pio2f+0x308>
 804dbf2:	9002      	str	r0, [sp, #8]
 804dbf4:	eb01 0e86 	add.w	lr, r1, r6, lsl #2
 804dbf8:	2000      	movs	r0, #0
 804dbfa:	4560      	cmp	r0, ip
 804dbfc:	dd11      	ble.n	804dc22 <__kernel_rem_pio2f+0x76>
 804dbfe:	a91c      	add	r1, sp, #112	@ 0x70
 804dc00:	f50d 7988 	add.w	r9, sp, #272	@ 0x110
 804dc04:	f04f 0c00 	mov.w	ip, #0
 804dc08:	eb01 0083 	add.w	r0, r1, r3, lsl #2
 804dc0c:	45d4      	cmp	ip, sl
 804dc0e:	dc29      	bgt.n	804dc64 <__kernel_rem_pio2f+0xb8>
 804dc10:	f8dd e004 	ldr.w	lr, [sp, #4]
 804dc14:	4606      	mov	r6, r0
 804dc16:	eddf 7aa7 	vldr	s15, [pc, #668]	@ 804deb4 <__kernel_rem_pio2f+0x308>
 804dc1a:	2400      	movs	r4, #0
 804dc1c:	e018      	b.n	804dc50 <__kernel_rem_pio2f+0xa4>
 804dc1e:	2200      	movs	r2, #0
 804dc20:	e7db      	b.n	804dbda <__kernel_rem_pio2f+0x2e>
 804dc22:	42c6      	cmn	r6, r0
 804dc24:	bf54      	ite	pl
 804dc26:	f85e 1020 	ldrpl.w	r1, [lr, r0, lsl #2]
 804dc2a:	eef0 7a47 	vmovmi.f32	s15, s14
 804dc2e:	f100 0001 	add.w	r0, r0, #1
 804dc32:	bf5c      	itt	pl
 804dc34:	ee07 1a90 	vmovpl	s15, r1
 804dc38:	eef8 7ae7 	vcvtpl.f32.s32	s15, s15
 804dc3c:	ece4 7a01 	vstmia	r4!, {s15}
 804dc40:	e7db      	b.n	804dbfa <__kernel_rem_pio2f+0x4e>
 804dc42:	ecfe 6a01 	vldmia	lr!, {s13}
 804dc46:	3401      	adds	r4, #1
 804dc48:	ed96 7a00 	vldr	s14, [r6]
 804dc4c:	eee6 7a87 	vfma.f32	s15, s13, s14
 804dc50:	455c      	cmp	r4, fp
 804dc52:	f1a6 0604 	sub.w	r6, r6, #4
 804dc56:	ddf4      	ble.n	804dc42 <__kernel_rem_pio2f+0x96>
 804dc58:	f10c 0c01 	add.w	ip, ip, #1
 804dc5c:	3004      	adds	r0, #4
 804dc5e:	ece9 7a01 	vstmia	r9!, {s15}
 804dc62:	e7d3      	b.n	804dc0c <__kernel_rem_pio2f+0x60>
 804dc64:	a908      	add	r1, sp, #32
 804dc66:	4654      	mov	r4, sl
 804dc68:	eddf 8a91 	vldr	s17, [pc, #580]	@ 804deb0 <__kernel_rem_pio2f+0x304>
 804dc6c:	eb01 018a 	add.w	r1, r1, sl, lsl #2
 804dc70:	ed9f 9a8e 	vldr	s18, [pc, #568]	@ 804deac <__kernel_rem_pio2f+0x300>
 804dc74:	9104      	str	r1, [sp, #16]
 804dc76:	9967      	ldr	r1, [sp, #412]	@ 0x19c
 804dc78:	eb01 0282 	add.w	r2, r1, r2, lsl #2
 804dc7c:	9203      	str	r2, [sp, #12]
 804dc7e:	00a2      	lsls	r2, r4, #2
 804dc80:	a944      	add	r1, sp, #272	@ 0x110
 804dc82:	4626      	mov	r6, r4
 804dc84:	9205      	str	r2, [sp, #20]
 804dc86:	aa58      	add	r2, sp, #352	@ 0x160
 804dc88:	eb01 0084 	add.w	r0, r1, r4, lsl #2
 804dc8c:	eb02 0284 	add.w	r2, r2, r4, lsl #2
 804dc90:	ed12 0a14 	vldr	s0, [r2, #-80]	@ 0xffffffb0
 804dc94:	aa08      	add	r2, sp, #32
 804dc96:	4694      	mov	ip, r2
 804dc98:	2e00      	cmp	r6, #0
 804dc9a:	f1a0 0004 	sub.w	r0, r0, #4
 804dc9e:	dc4c      	bgt.n	804dd3a <__kernel_rem_pio2f+0x18e>
 804dca0:	4628      	mov	r0, r5
 804dca2:	e9cd 2306 	strd	r2, r3, [sp, #24]
 804dca6:	f000 f9f5 	bl	804e094 <scalbnf>
 804dcaa:	eeb0 8a40 	vmov.f32	s16, s0
 804dcae:	eeb4 0a00 	vmov.f32	s0, #64	@ 0x3e000000  0.125
 804dcb2:	ee28 0a00 	vmul.f32	s0, s16, s0
 804dcb6:	f000 fa51 	bl	804e15c <floorf>
 804dcba:	eef2 7a00 	vmov.f32	s15, #32	@ 0x41000000  8.0
 804dcbe:	2d00      	cmp	r5, #0
 804dcc0:	eea0 8a67 	vfms.f32	s16, s0, s15
 804dcc4:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
 804dcc8:	eefd 7ac8 	vcvt.s32.f32	s15, s16
 804dccc:	ee17 9a90 	vmov	r9, s15
 804dcd0:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 804dcd4:	ee38 8a67 	vsub.f32	s16, s16, s15
 804dcd8:	dd41      	ble.n	804dd5e <__kernel_rem_pio2f+0x1b2>
 804dcda:	f104 3cff 	add.w	ip, r4, #4294967295
 804dcde:	a908      	add	r1, sp, #32
 804dce0:	f1c5 0e08 	rsb	lr, r5, #8
 804dce4:	f851 602c 	ldr.w	r6, [r1, ip, lsl #2]
 804dce8:	fa46 f00e 	asr.w	r0, r6, lr
 804dcec:	4481      	add	r9, r0
 804dcee:	fa00 f00e 	lsl.w	r0, r0, lr
 804dcf2:	1a36      	subs	r6, r6, r0
 804dcf4:	f1c5 0007 	rsb	r0, r5, #7
 804dcf8:	f841 602c 	str.w	r6, [r1, ip, lsl #2]
 804dcfc:	4106      	asrs	r6, r0
 804dcfe:	2e00      	cmp	r6, #0
 804dd00:	dd3c      	ble.n	804dd7c <__kernel_rem_pio2f+0x1d0>
 804dd02:	f04f 0e00 	mov.w	lr, #0
 804dd06:	f109 0901 	add.w	r9, r9, #1
 804dd0a:	4670      	mov	r0, lr
 804dd0c:	4574      	cmp	r4, lr
 804dd0e:	dc68      	bgt.n	804dde2 <__kernel_rem_pio2f+0x236>
 804dd10:	2d00      	cmp	r5, #0
 804dd12:	dd03      	ble.n	804dd1c <__kernel_rem_pio2f+0x170>
 804dd14:	2d01      	cmp	r5, #1
 804dd16:	d074      	beq.n	804de02 <__kernel_rem_pio2f+0x256>
 804dd18:	2d02      	cmp	r5, #2
 804dd1a:	d07d      	beq.n	804de18 <__kernel_rem_pio2f+0x26c>
 804dd1c:	2e02      	cmp	r6, #2
 804dd1e:	d12d      	bne.n	804dd7c <__kernel_rem_pio2f+0x1d0>
 804dd20:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
 804dd24:	ee30 8a48 	vsub.f32	s16, s0, s16
 804dd28:	b340      	cbz	r0, 804dd7c <__kernel_rem_pio2f+0x1d0>
 804dd2a:	4628      	mov	r0, r5
 804dd2c:	9306      	str	r3, [sp, #24]
 804dd2e:	f000 f9b1 	bl	804e094 <scalbnf>
 804dd32:	9b06      	ldr	r3, [sp, #24]
 804dd34:	ee38 8a40 	vsub.f32	s16, s16, s0
 804dd38:	e020      	b.n	804dd7c <__kernel_rem_pio2f+0x1d0>
 804dd3a:	ee60 7a28 	vmul.f32	s15, s0, s17
 804dd3e:	3e01      	subs	r6, #1
 804dd40:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 804dd44:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 804dd48:	eea7 0ac9 	vfms.f32	s0, s15, s18
 804dd4c:	eebd 0ac0 	vcvt.s32.f32	s0, s0
 804dd50:	ecac 0a01 	vstmia	ip!, {s0}
 804dd54:	ed90 0a00 	vldr	s0, [r0]
 804dd58:	ee37 0a80 	vadd.f32	s0, s15, s0
 804dd5c:	e79c      	b.n	804dc98 <__kernel_rem_pio2f+0xec>
 804dd5e:	d105      	bne.n	804dd6c <__kernel_rem_pio2f+0x1c0>
 804dd60:	1e60      	subs	r0, r4, #1
 804dd62:	a908      	add	r1, sp, #32
 804dd64:	f851 6020 	ldr.w	r6, [r1, r0, lsl #2]
 804dd68:	11f6      	asrs	r6, r6, #7
 804dd6a:	e7c8      	b.n	804dcfe <__kernel_rem_pio2f+0x152>
 804dd6c:	eef6 7a00 	vmov.f32	s15, #96	@ 0x3f000000  0.5
 804dd70:	eeb4 8ae7 	vcmpe.f32	s16, s15
 804dd74:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 804dd78:	da31      	bge.n	804ddde <__kernel_rem_pio2f+0x232>
 804dd7a:	2600      	movs	r6, #0
 804dd7c:	eeb5 8a40 	vcmp.f32	s16, #0.0
 804dd80:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 804dd84:	f040 8098 	bne.w	804deb8 <__kernel_rem_pio2f+0x30c>
 804dd88:	1e60      	subs	r0, r4, #1
 804dd8a:	2200      	movs	r2, #0
 804dd8c:	4550      	cmp	r0, sl
 804dd8e:	da4b      	bge.n	804de28 <__kernel_rem_pio2f+0x27c>
 804dd90:	2a00      	cmp	r2, #0
 804dd92:	d065      	beq.n	804de60 <__kernel_rem_pio2f+0x2b4>
 804dd94:	3c01      	subs	r4, #1
 804dd96:	ab08      	add	r3, sp, #32
 804dd98:	3d08      	subs	r5, #8
 804dd9a:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
 804dd9e:	2b00      	cmp	r3, #0
 804dda0:	d0f8      	beq.n	804dd94 <__kernel_rem_pio2f+0x1e8>
 804dda2:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
 804dda6:	4628      	mov	r0, r5
 804dda8:	f000 f974 	bl	804e094 <scalbnf>
 804ddac:	1c63      	adds	r3, r4, #1
 804ddae:	aa44      	add	r2, sp, #272	@ 0x110
 804ddb0:	ed9f 7a3f 	vldr	s14, [pc, #252]	@ 804deb0 <__kernel_rem_pio2f+0x304>
 804ddb4:	0099      	lsls	r1, r3, #2
 804ddb6:	eb02 0283 	add.w	r2, r2, r3, lsl #2
 804ddba:	4623      	mov	r3, r4
 804ddbc:	2b00      	cmp	r3, #0
 804ddbe:	f280 80a9 	bge.w	804df14 <__kernel_rem_pio2f+0x368>
 804ddc2:	4623      	mov	r3, r4
 804ddc4:	2b00      	cmp	r3, #0
 804ddc6:	f2c0 80c7 	blt.w	804df58 <__kernel_rem_pio2f+0x3ac>
 804ddca:	aa44      	add	r2, sp, #272	@ 0x110
 804ddcc:	f8df c0d8 	ldr.w	ip, [pc, #216]	@ 804dea8 <__kernel_rem_pio2f+0x2fc>
 804ddd0:	eddf 7a38 	vldr	s15, [pc, #224]	@ 804deb4 <__kernel_rem_pio2f+0x308>
 804ddd4:	2000      	movs	r0, #0
 804ddd6:	eb02 0583 	add.w	r5, r2, r3, lsl #2
 804ddda:	1ae2      	subs	r2, r4, r3
 804dddc:	e0b1      	b.n	804df42 <__kernel_rem_pio2f+0x396>
 804ddde:	2602      	movs	r6, #2
 804dde0:	e78f      	b.n	804dd02 <__kernel_rem_pio2f+0x156>
 804dde2:	f852 1b04 	ldr.w	r1, [r2], #4
 804dde6:	b948      	cbnz	r0, 804ddfc <__kernel_rem_pio2f+0x250>
 804dde8:	b121      	cbz	r1, 804ddf4 <__kernel_rem_pio2f+0x248>
 804ddea:	f5c1 7180 	rsb	r1, r1, #256	@ 0x100
 804ddee:	f842 1c04 	str.w	r1, [r2, #-4]
 804ddf2:	2101      	movs	r1, #1
 804ddf4:	f10e 0e01 	add.w	lr, lr, #1
 804ddf8:	4608      	mov	r0, r1
 804ddfa:	e787      	b.n	804dd0c <__kernel_rem_pio2f+0x160>
 804ddfc:	f1c1 01ff 	rsb	r1, r1, #255	@ 0xff
 804de00:	e7f5      	b.n	804ddee <__kernel_rem_pio2f+0x242>
 804de02:	f104 3cff 	add.w	ip, r4, #4294967295
 804de06:	aa08      	add	r2, sp, #32
 804de08:	f852 202c 	ldr.w	r2, [r2, ip, lsl #2]
 804de0c:	f002 027f 	and.w	r2, r2, #127	@ 0x7f
 804de10:	a908      	add	r1, sp, #32
 804de12:	f841 202c 	str.w	r2, [r1, ip, lsl #2]
 804de16:	e781      	b.n	804dd1c <__kernel_rem_pio2f+0x170>
 804de18:	f104 3cff 	add.w	ip, r4, #4294967295
 804de1c:	aa08      	add	r2, sp, #32
 804de1e:	f852 202c 	ldr.w	r2, [r2, ip, lsl #2]
 804de22:	f002 023f 	and.w	r2, r2, #63	@ 0x3f
 804de26:	e7f3      	b.n	804de10 <__kernel_rem_pio2f+0x264>
 804de28:	a908      	add	r1, sp, #32
 804de2a:	f851 1020 	ldr.w	r1, [r1, r0, lsl #2]
 804de2e:	3801      	subs	r0, #1
 804de30:	430a      	orrs	r2, r1
 804de32:	e7ab      	b.n	804dd8c <__kernel_rem_pio2f+0x1e0>
 804de34:	3201      	adds	r2, #1
 804de36:	f850 6d04 	ldr.w	r6, [r0, #-4]!
 804de3a:	2e00      	cmp	r6, #0
 804de3c:	d0fa      	beq.n	804de34 <__kernel_rem_pio2f+0x288>
 804de3e:	9905      	ldr	r1, [sp, #20]
 804de40:	18e6      	adds	r6, r4, r3
 804de42:	f104 0c01 	add.w	ip, r4, #1
 804de46:	4422      	add	r2, r4
 804de48:	f501 71b0 	add.w	r1, r1, #352	@ 0x160
 804de4c:	eb0d 0001 	add.w	r0, sp, r1
 804de50:	a91c      	add	r1, sp, #112	@ 0x70
 804de52:	384c      	subs	r0, #76	@ 0x4c
 804de54:	eb01 0686 	add.w	r6, r1, r6, lsl #2
 804de58:	4562      	cmp	r2, ip
 804de5a:	da04      	bge.n	804de66 <__kernel_rem_pio2f+0x2ba>
 804de5c:	4614      	mov	r4, r2
 804de5e:	e70e      	b.n	804dc7e <__kernel_rem_pio2f+0xd2>
 804de60:	9804      	ldr	r0, [sp, #16]
 804de62:	2201      	movs	r2, #1
 804de64:	e7e7      	b.n	804de36 <__kernel_rem_pio2f+0x28a>
 804de66:	9903      	ldr	r1, [sp, #12]
 804de68:	2400      	movs	r4, #0
 804de6a:	f8dd e004 	ldr.w	lr, [sp, #4]
 804de6e:	f851 102c 	ldr.w	r1, [r1, ip, lsl #2]
 804de72:	ee07 1a90 	vmov	s15, r1
 804de76:	9105      	str	r1, [sp, #20]
 804de78:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 804de7c:	ece6 7a01 	vstmia	r6!, {s15}
 804de80:	46b1      	mov	r9, r6
 804de82:	eddf 7a0c 	vldr	s15, [pc, #48]	@ 804deb4 <__kernel_rem_pio2f+0x308>
 804de86:	455c      	cmp	r4, fp
 804de88:	dd04      	ble.n	804de94 <__kernel_rem_pio2f+0x2e8>
 804de8a:	f10c 0c01 	add.w	ip, ip, #1
 804de8e:	ece0 7a01 	vstmia	r0!, {s15}
 804de92:	e7e1      	b.n	804de58 <__kernel_rem_pio2f+0x2ac>
 804de94:	ecfe 6a01 	vldmia	lr!, {s13}
 804de98:	3401      	adds	r4, #1
 804de9a:	ed39 7a01 	vldmdb	r9!, {s14}
 804de9e:	eee6 7a87 	vfma.f32	s15, s13, s14
 804dea2:	e7f0      	b.n	804de86 <__kernel_rem_pio2f+0x2da>
 804dea4:	0804eab4 	.word	0x0804eab4
 804dea8:	0804ea88 	.word	0x0804ea88
 804deac:	43800000 	.word	0x43800000
 804deb0:	3b800000 	.word	0x3b800000
 804deb4:	00000000 	.word	0x00000000
 804deb8:	9b02      	ldr	r3, [sp, #8]
 804deba:	eeb0 0a48 	vmov.f32	s0, s16
 804debe:	eba3 0008 	sub.w	r0, r3, r8
 804dec2:	f000 f8e7 	bl	804e094 <scalbnf>
 804dec6:	ed1f 7a07 	vldr	s14, [pc, #-28]	@ 804deac <__kernel_rem_pio2f+0x300>
 804deca:	eeb4 0ac7 	vcmpe.f32	s0, s14
 804dece:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 804ded2:	db19      	blt.n	804df08 <__kernel_rem_pio2f+0x35c>
 804ded4:	ed5f 7a0a 	vldr	s15, [pc, #-40]	@ 804deb0 <__kernel_rem_pio2f+0x304>
 804ded8:	aa08      	add	r2, sp, #32
 804deda:	3508      	adds	r5, #8
 804dedc:	ee60 7a27 	vmul.f32	s15, s0, s15
 804dee0:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 804dee4:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 804dee8:	eea7 0ac7 	vfms.f32	s0, s15, s14
 804deec:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 804def0:	eebd 0ac0 	vcvt.s32.f32	s0, s0
 804def4:	ee10 3a10 	vmov	r3, s0
 804def8:	f842 3024 	str.w	r3, [r2, r4, lsl #2]
 804defc:	3401      	adds	r4, #1
 804defe:	ee17 3a90 	vmov	r3, s15
 804df02:	f842 3024 	str.w	r3, [r2, r4, lsl #2]
 804df06:	e74c      	b.n	804dda2 <__kernel_rem_pio2f+0x1f6>
 804df08:	eebd 0ac0 	vcvt.s32.f32	s0, s0
 804df0c:	aa08      	add	r2, sp, #32
 804df0e:	ee10 3a10 	vmov	r3, s0
 804df12:	e7f6      	b.n	804df02 <__kernel_rem_pio2f+0x356>
 804df14:	a808      	add	r0, sp, #32
 804df16:	f850 0023 	ldr.w	r0, [r0, r3, lsl #2]
 804df1a:	3b01      	subs	r3, #1
 804df1c:	ee07 0a90 	vmov	s15, r0
 804df20:	9001      	str	r0, [sp, #4]
 804df22:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 804df26:	ee67 7a80 	vmul.f32	s15, s15, s0
 804df2a:	ee20 0a07 	vmul.f32	s0, s0, s14
 804df2e:	ed62 7a01 	vstmdb	r2!, {s15}
 804df32:	e743      	b.n	804ddbc <__kernel_rem_pio2f+0x210>
 804df34:	ecfc 6a01 	vldmia	ip!, {s13}
 804df38:	3001      	adds	r0, #1
 804df3a:	ecb5 7a01 	vldmia	r5!, {s14}
 804df3e:	eee6 7a87 	vfma.f32	s15, s13, s14
 804df42:	4550      	cmp	r0, sl
 804df44:	dc01      	bgt.n	804df4a <__kernel_rem_pio2f+0x39e>
 804df46:	4282      	cmp	r2, r0
 804df48:	daf4      	bge.n	804df34 <__kernel_rem_pio2f+0x388>
 804df4a:	a858      	add	r0, sp, #352	@ 0x160
 804df4c:	3b01      	subs	r3, #1
 804df4e:	eb00 0282 	add.w	r2, r0, r2, lsl #2
 804df52:	ed42 7a28 	vstr	s15, [r2, #-160]	@ 0xffffff60
 804df56:	e735      	b.n	804ddc4 <__kernel_rem_pio2f+0x218>
 804df58:	9b66      	ldr	r3, [sp, #408]	@ 0x198
 804df5a:	2b02      	cmp	r3, #2
 804df5c:	dc09      	bgt.n	804df72 <__kernel_rem_pio2f+0x3c6>
 804df5e:	2b00      	cmp	r3, #0
 804df60:	dc2b      	bgt.n	804dfba <__kernel_rem_pio2f+0x40e>
 804df62:	d044      	beq.n	804dfee <__kernel_rem_pio2f+0x442>
 804df64:	f009 0007 	and.w	r0, r9, #7
 804df68:	b059      	add	sp, #356	@ 0x164
 804df6a:	ecbd 8b04 	vpop	{d8-d9}
 804df6e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 804df72:	9b66      	ldr	r3, [sp, #408]	@ 0x198
 804df74:	2b03      	cmp	r3, #3
 804df76:	d1f5      	bne.n	804df64 <__kernel_rem_pio2f+0x3b8>
 804df78:	aa30      	add	r2, sp, #192	@ 0xc0
 804df7a:	1f0b      	subs	r3, r1, #4
 804df7c:	4620      	mov	r0, r4
 804df7e:	4413      	add	r3, r2
 804df80:	461a      	mov	r2, r3
 804df82:	2800      	cmp	r0, #0
 804df84:	f1a2 0204 	sub.w	r2, r2, #4
 804df88:	dc52      	bgt.n	804e030 <__kernel_rem_pio2f+0x484>
 804df8a:	4622      	mov	r2, r4
 804df8c:	2a01      	cmp	r2, #1
 804df8e:	f1a3 0304 	sub.w	r3, r3, #4
 804df92:	dc5d      	bgt.n	804e050 <__kernel_rem_pio2f+0x4a4>
 804df94:	ab30      	add	r3, sp, #192	@ 0xc0
 804df96:	ed5f 7a39 	vldr	s15, [pc, #-228]	@ 804deb4 <__kernel_rem_pio2f+0x308>
 804df9a:	440b      	add	r3, r1
 804df9c:	2c01      	cmp	r4, #1
 804df9e:	dc67      	bgt.n	804e070 <__kernel_rem_pio2f+0x4c4>
 804dfa0:	eddd 6a30 	vldr	s13, [sp, #192]	@ 0xc0
 804dfa4:	ed9d 7a31 	vldr	s14, [sp, #196]	@ 0xc4
 804dfa8:	2e00      	cmp	r6, #0
 804dfaa:	d167      	bne.n	804e07c <__kernel_rem_pio2f+0x4d0>
 804dfac:	edc7 6a00 	vstr	s13, [r7]
 804dfb0:	ed87 7a01 	vstr	s14, [r7, #4]
 804dfb4:	edc7 7a02 	vstr	s15, [r7, #8]
 804dfb8:	e7d4      	b.n	804df64 <__kernel_rem_pio2f+0x3b8>
 804dfba:	ab30      	add	r3, sp, #192	@ 0xc0
 804dfbc:	4622      	mov	r2, r4
 804dfbe:	ed1f 7a43 	vldr	s14, [pc, #-268]	@ 804deb4 <__kernel_rem_pio2f+0x308>
 804dfc2:	440b      	add	r3, r1
 804dfc4:	2a00      	cmp	r2, #0
 804dfc6:	da24      	bge.n	804e012 <__kernel_rem_pio2f+0x466>
 804dfc8:	b34e      	cbz	r6, 804e01e <__kernel_rem_pio2f+0x472>
 804dfca:	eef1 7a47 	vneg.f32	s15, s14
 804dfce:	edc7 7a00 	vstr	s15, [r7]
 804dfd2:	aa31      	add	r2, sp, #196	@ 0xc4
 804dfd4:	eddd 7a30 	vldr	s15, [sp, #192]	@ 0xc0
 804dfd8:	2301      	movs	r3, #1
 804dfda:	ee77 7ac7 	vsub.f32	s15, s15, s14
 804dfde:	429c      	cmp	r4, r3
 804dfe0:	da20      	bge.n	804e024 <__kernel_rem_pio2f+0x478>
 804dfe2:	b10e      	cbz	r6, 804dfe8 <__kernel_rem_pio2f+0x43c>
 804dfe4:	eef1 7a67 	vneg.f32	s15, s15
 804dfe8:	edc7 7a01 	vstr	s15, [r7, #4]
 804dfec:	e7ba      	b.n	804df64 <__kernel_rem_pio2f+0x3b8>
 804dfee:	ab30      	add	r3, sp, #192	@ 0xc0
 804dff0:	ed5f 7a50 	vldr	s15, [pc, #-320]	@ 804deb4 <__kernel_rem_pio2f+0x308>
 804dff4:	440b      	add	r3, r1
 804dff6:	2c00      	cmp	r4, #0
 804dff8:	da05      	bge.n	804e006 <__kernel_rem_pio2f+0x45a>
 804dffa:	b10e      	cbz	r6, 804e000 <__kernel_rem_pio2f+0x454>
 804dffc:	eef1 7a67 	vneg.f32	s15, s15
 804e000:	edc7 7a00 	vstr	s15, [r7]
 804e004:	e7ae      	b.n	804df64 <__kernel_rem_pio2f+0x3b8>
 804e006:	ed33 7a01 	vldmdb	r3!, {s14}
 804e00a:	3c01      	subs	r4, #1
 804e00c:	ee77 7a87 	vadd.f32	s15, s15, s14
 804e010:	e7f1      	b.n	804dff6 <__kernel_rem_pio2f+0x44a>
 804e012:	ed73 7a01 	vldmdb	r3!, {s15}
 804e016:	3a01      	subs	r2, #1
 804e018:	ee37 7a27 	vadd.f32	s14, s14, s15
 804e01c:	e7d2      	b.n	804dfc4 <__kernel_rem_pio2f+0x418>
 804e01e:	eef0 7a47 	vmov.f32	s15, s14
 804e022:	e7d4      	b.n	804dfce <__kernel_rem_pio2f+0x422>
 804e024:	ecb2 7a01 	vldmia	r2!, {s14}
 804e028:	3301      	adds	r3, #1
 804e02a:	ee77 7a87 	vadd.f32	s15, s15, s14
 804e02e:	e7d6      	b.n	804dfde <__kernel_rem_pio2f+0x432>
 804e030:	edd2 7a00 	vldr	s15, [r2]
 804e034:	3801      	subs	r0, #1
 804e036:	edd2 6a01 	vldr	s13, [r2, #4]
 804e03a:	ee37 7aa6 	vadd.f32	s14, s15, s13
 804e03e:	ee77 7ac7 	vsub.f32	s15, s15, s14
 804e042:	ed82 7a00 	vstr	s14, [r2]
 804e046:	ee77 7aa6 	vadd.f32	s15, s15, s13
 804e04a:	edc2 7a01 	vstr	s15, [r2, #4]
 804e04e:	e798      	b.n	804df82 <__kernel_rem_pio2f+0x3d6>
 804e050:	edd3 7a00 	vldr	s15, [r3]
 804e054:	3a01      	subs	r2, #1
 804e056:	edd3 6a01 	vldr	s13, [r3, #4]
 804e05a:	ee37 7aa6 	vadd.f32	s14, s15, s13
 804e05e:	ee77 7ac7 	vsub.f32	s15, s15, s14
 804e062:	ed83 7a00 	vstr	s14, [r3]
 804e066:	ee77 7aa6 	vadd.f32	s15, s15, s13
 804e06a:	edc3 7a01 	vstr	s15, [r3, #4]
 804e06e:	e78d      	b.n	804df8c <__kernel_rem_pio2f+0x3e0>
 804e070:	ed33 7a01 	vldmdb	r3!, {s14}
 804e074:	3c01      	subs	r4, #1
 804e076:	ee77 7a87 	vadd.f32	s15, s15, s14
 804e07a:	e78f      	b.n	804df9c <__kernel_rem_pio2f+0x3f0>
 804e07c:	eef1 6a66 	vneg.f32	s13, s13
 804e080:	eeb1 7a47 	vneg.f32	s14, s14
 804e084:	eef1 7a67 	vneg.f32	s15, s15
 804e088:	edc7 6a00 	vstr	s13, [r7]
 804e08c:	ed87 7a01 	vstr	s14, [r7, #4]
 804e090:	e790      	b.n	804dfb4 <__kernel_rem_pio2f+0x408>
 804e092:	bf00      	nop

0804e094 <scalbnf>:
 804e094:	ee10 3a10 	vmov	r3, s0
 804e098:	f033 4200 	bics.w	r2, r3, #2147483648	@ 0x80000000
 804e09c:	d02a      	beq.n	804e0f4 <scalbnf+0x60>
 804e09e:	f1b2 4fff 	cmp.w	r2, #2139095040	@ 0x7f800000
 804e0a2:	d302      	bcc.n	804e0aa <scalbnf+0x16>
 804e0a4:	ee30 0a00 	vadd.f32	s0, s0, s0
 804e0a8:	4770      	bx	lr
 804e0aa:	f013 4fff 	tst.w	r3, #2139095040	@ 0x7f800000
 804e0ae:	d122      	bne.n	804e0f6 <scalbnf+0x62>
 804e0b0:	4b23      	ldr	r3, [pc, #140]	@ (804e140 <scalbnf+0xac>)
 804e0b2:	eddf 7a24 	vldr	s15, [pc, #144]	@ 804e144 <scalbnf+0xb0>
 804e0b6:	4298      	cmp	r0, r3
 804e0b8:	ee20 0a27 	vmul.f32	s0, s0, s15
 804e0bc:	db16      	blt.n	804e0ec <scalbnf+0x58>
 804e0be:	ee10 3a10 	vmov	r3, s0
 804e0c2:	f3c3 52c7 	ubfx	r2, r3, #23, #8
 804e0c6:	3a19      	subs	r2, #25
 804e0c8:	f24c 3150 	movw	r1, #50000	@ 0xc350
 804e0cc:	4288      	cmp	r0, r1
 804e0ce:	dd14      	ble.n	804e0fa <scalbnf+0x66>
 804e0d0:	eddf 7a1d 	vldr	s15, [pc, #116]	@ 804e148 <scalbnf+0xb4>
 804e0d4:	ee10 3a10 	vmov	r3, s0
 804e0d8:	eddf 6a1c 	vldr	s13, [pc, #112]	@ 804e14c <scalbnf+0xb8>
 804e0dc:	eeb0 7a67 	vmov.f32	s14, s15
 804e0e0:	2b00      	cmp	r3, #0
 804e0e2:	fe67 7aa6 	vselge.f32	s15, s15, s13
 804e0e6:	ee27 0a87 	vmul.f32	s0, s15, s14
 804e0ea:	4770      	bx	lr
 804e0ec:	eddf 7a18 	vldr	s15, [pc, #96]	@ 804e150 <scalbnf+0xbc>
 804e0f0:	ee27 0a80 	vmul.f32	s0, s15, s0
 804e0f4:	4770      	bx	lr
 804e0f6:	0dd2      	lsrs	r2, r2, #23
 804e0f8:	e7e6      	b.n	804e0c8 <scalbnf+0x34>
 804e0fa:	4410      	add	r0, r2
 804e0fc:	28fe      	cmp	r0, #254	@ 0xfe
 804e0fe:	dce7      	bgt.n	804e0d0 <scalbnf+0x3c>
 804e100:	2800      	cmp	r0, #0
 804e102:	dd06      	ble.n	804e112 <scalbnf+0x7e>
 804e104:	f023 43ff 	bic.w	r3, r3, #2139095040	@ 0x7f800000
 804e108:	ea43 53c0 	orr.w	r3, r3, r0, lsl #23
 804e10c:	ee00 3a10 	vmov	s0, r3
 804e110:	4770      	bx	lr
 804e112:	f110 0f16 	cmn.w	r0, #22
 804e116:	da09      	bge.n	804e12c <scalbnf+0x98>
 804e118:	eddf 7a0d 	vldr	s15, [pc, #52]	@ 804e150 <scalbnf+0xbc>
 804e11c:	ee10 3a10 	vmov	r3, s0
 804e120:	eddf 6a0c 	vldr	s13, [pc, #48]	@ 804e154 <scalbnf+0xc0>
 804e124:	eeb0 7a67 	vmov.f32	s14, s15
 804e128:	2b00      	cmp	r3, #0
 804e12a:	e7da      	b.n	804e0e2 <scalbnf+0x4e>
 804e12c:	3019      	adds	r0, #25
 804e12e:	f023 43ff 	bic.w	r3, r3, #2139095040	@ 0x7f800000
 804e132:	ed9f 0a09 	vldr	s0, [pc, #36]	@ 804e158 <scalbnf+0xc4>
 804e136:	ea43 53c0 	orr.w	r3, r3, r0, lsl #23
 804e13a:	ee07 3a90 	vmov	s15, r3
 804e13e:	e7d7      	b.n	804e0f0 <scalbnf+0x5c>
 804e140:	ffff3cb0 	.word	0xffff3cb0
 804e144:	4c000000 	.word	0x4c000000
 804e148:	7149f2ca 	.word	0x7149f2ca
 804e14c:	f149f2ca 	.word	0xf149f2ca
 804e150:	0da24260 	.word	0x0da24260
 804e154:	8da24260 	.word	0x8da24260
 804e158:	33000000 	.word	0x33000000

0804e15c <floorf>:
 804e15c:	febb 0a40 	vrintm.f32	s0, s0
 804e160:	4770      	bx	lr
	...

0804e164 <_gettimeofday>:
 804e164:	4b02      	ldr	r3, [pc, #8]	@ (804e170 <_gettimeofday+0xc>)
 804e166:	2258      	movs	r2, #88	@ 0x58
 804e168:	f04f 30ff 	mov.w	r0, #4294967295
 804e16c:	601a      	str	r2, [r3, #0]
 804e16e:	4770      	bx	lr
 804e170:	20018c1c 	.word	0x20018c1c

0804e174 <_init>:
 804e174:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 804e176:	bf00      	nop
 804e178:	bcf8      	pop	{r3, r4, r5, r6, r7}
 804e17a:	bc08      	pop	{r3}
 804e17c:	469e      	mov	lr, r3
 804e17e:	4770      	bx	lr

0804e180 <_fini>:
 804e180:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 804e182:	bf00      	nop
 804e184:	bcf8      	pop	{r3, r4, r5, r6, r7}
 804e186:	bc08      	pop	{r3}
 804e188:	469e      	mov	lr, r3
 804e18a:	4770      	bx	lr
 804e18c:	0000      	movs	r0, r0
	...

0804e190 <__SECURE_send_veneer>:
 804e190:	f85f f000 	ldr.w	pc, [pc]	@ 804e194 <__SECURE_send_veneer+0x4>
 804e194:	0c03e021 	.word	0x0c03e021

0804e198 <__SECURE_pox_veneer>:
 804e198:	f85f f000 	ldr.w	pc, [pc]	@ 804e19c <__SECURE_pox_veneer+0x4>
 804e19c:	0c03e029 	.word	0x0c03e029

0804e1a0 <__SECURE_checkState_veneer>:
 804e1a0:	f85f f000 	ldr.w	pc, [pc]	@ 804e1a4 <__SECURE_checkState_veneer+0x4>
 804e1a4:	0c03e031 	.word	0x0c03e031

0804e1a8 <__SECURE_recv_veneer>:
 804e1a8:	f85f f000 	ldr.w	pc, [pc]	@ 804e1ac <__SECURE_recv_veneer+0x4>
 804e1ac:	0c03e009 	.word	0x0c03e009

0804e1b0 <__SECURE_SystemCoreClockUpdate_veneer>:
 804e1b0:	f85f f000 	ldr.w	pc, [pc]	@ 804e1b4 <__SECURE_SystemCoreClockUpdate_veneer+0x4>
 804e1b4:	0c03e001 	.word	0x0c03e001

0804e1b8 <__SECURE_RegisterCallback_veneer>:
 804e1b8:	f85f f000 	ldr.w	pc, [pc]	@ 804e1bc <__SECURE_RegisterCallback_veneer+0x4>
 804e1bc:	0c03e019 	.word	0x0c03e019

0804e1c0 <__SECURE_setState_veneer>:
 804e1c0:	f85f f000 	ldr.w	pc, [pc]	@ 804e1c4 <__SECURE_setState_veneer+0x4>
 804e1c4:	0c03e011 	.word	0x0c03e011
