/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file           : main.c
  * @brief          : Main program body
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2022 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "main.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include "application.h"
#include <string.h>
#include <stdbool.h>
#include <stdlib.h>
#include "gpio.h"
#include "secure_nsc.h"
#include "arm_cmse.h"
#include "core_cm33.h"

/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */

/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */
/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/

/* USER CODE BEGIN PV */

/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
/* USER CODE BEGIN PFP */

/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */
//this function will raise secure fault by access secure area directly.
void RaiseSecureFault(void)
{
  //read secure SRAM address
  *(volatile uint32_t *)0x30000000UL = 0;
}

//secure fault generated by IDAU/SAU check */
void SecureFault_Callback(void)
{
  HAL_GPIO_WritePin(LED_RED_GPIO_Port, LED_RED_Pin, GPIO_PIN_SET);
  Error_Handler();
}

//secure error generated by GTZC check
void SecureError_Callback(void)
{
  HAL_GPIO_WritePin(LED_RED_GPIO_Port, LED_RED_Pin, GPIO_PIN_SET);
  Error_Handler();
}

/* USER CODE END 0 */

/**
  * @brief  The application entry point.
  * @retval int
  */

//#define ATTACK_A1
//#define ATTACK_A2
#define ATTACK_A3


#define CRYPTO_HMAC_SHA256
//#define CRYPTO_ED25519 // TODO: other crypto are not supported in case studies yet

#define POX_INPUT_SIZE 12
#define POX_OUTPUT_SIZE 32

#define SHA256_DIGEST_SIZE 32

#define TOKEN_SIZE SHA256_DIGEST_SIZE


#define PLAINTEXT_SIZE 5+4*5
#define REQUEST_SIZE PLAINTEXT_SIZE+TOKEN_SIZE

uint8_t pox_input[POX_INPUT_SIZE] = {0};
uint8_t pox_output[POX_OUTPUT_SIZE] = {0};

void sendline(char* s) {
	int i=0;
	while(s[i] != '\n') i++;
	SECURE_send((uint8_t*)s, (i+1));

}

void printBits(uint8_t num)
{
   for(int bit=0;bit<(sizeof(uint8_t) * 8); bit++)
   {
      printf("%i", num & 0x01);
      num = num >> 1;
   }
    printf(" ");
}

void printVector(const uint8_t b[32], char *meta) {
    printf("%s: ", meta);
    for(int i=0; i<32; i++) printBits(b[i]);
    printf("\n");
}

bool is_bit_set(uint8_t num, int n) {
	// Create a mask with only the nth bit set
	uint8_t mask = 1 << n;
	// Perform a bitwise AND operation with the original number
	// If the result is non-zero, then the nth bit is set
	return (num & mask) != 0;
}

uint8_t set_bit(uint8_t num, int n) {
	// Left shift 1 by n to create a mask with the nth bit set
	uint8_t mask = 1 << n;
	// Perform bitwise OR operation to set the nth bit
	return num | mask;
}

uint8_t clear_bit(uint8_t num, int n) {
	// Create a mask with only the nth bit set to 1
	uint8_t mask = ~(1 << n);
	// Perform a bitwise AND operation with the original number
	// This will clear the nth bit while leaving other bits unchanged
	return num & mask;
}

#define MAP_SIZE 20 // Maximum number of elements in the map

// Define a structure to represent key-value pair
typedef struct {
	uint8_t key[32];
	uint8_t value[32];
} KeyValuePair;

// Define a map data structure
typedef struct {
	KeyValuePair pairs[MAP_SIZE];
	size_t size; // Current number of elements in the map
} Map;

Map B;

// Function to initialize the map
void initialize_map(Map *map) {
	map->size = 0;
}

// Function to insert a key-value pair into the map
void insert(Map *map, const uint8_t key[32], const uint8_t value[32]) {
	if (map->size < MAP_SIZE) {
		KeyValuePair *pair = &map->pairs[map->size];
		for (int i = 0; i < 32; i++) {
			pair->key[i] = key[i];
			pair->value[i] = value[i];
		}
		map->size++;
	} else {
		sendline("Map is full. Cannot insert.\n");
	}
}

// Function to retrieve a value given a key
uint8_t* get(Map *map, const uint8_t key[32]) {
	for (size_t i = 0; i < map->size; i++) {
		int found = 1;
		for (int j = 0; j < 32; j++) {
			if (map->pairs[i].key[j] != key[j]) {
				found = 0;
				break;
			}
		}
		if (found) {
			return map->pairs[i].value;
		}
	}
	return NULL; // Key not found
}

void UE(uint8_t O_prime, uint8_t *b) {
    uint8_t bin = O_prime/8;
	uint8_t bit = O_prime%8;
	b[bin] = 1<<bit;
}

uint8_t* PRR(const uint8_t *b, float f, Map *B, uint8_t *b_prime) {
    memset(b_prime, 0, 32);
	uint8_t *cache = get(B, b);
	if(cache == NULL) {
		for(int i=0; i<256; i++) {
			float r = (float) rand()/(float) RAND_MAX;
			bool isOne = false;
			uint8_t bin = i/8;
			uint8_t bit = i%8;
			if(r<=f/2) {
				b_prime[bin] = set_bit(b[bin], bit);
			} else if(r<=f) {
				b_prime[bin] = clear_bit(b[bin], bit);
			} else if(is_bit_set(b[bin], bit)) {
				b_prime[bin] = set_bit(b[bin], bit);
			} else {
				b_prime[bin] = set_bit(b[bin], bit);
			}
		}
		insert(B, b, b_prime);
        return b_prime;
	} else {
        return cache;
    }

}

void IRR(const uint8_t *b_prime, float p, float q, uint8_t *O) {
	for(int i=0; i<256; i++) {
		uint8_t bin = i/8;
		uint8_t bit = i%8;
		float r = (float) rand()/(float) RAND_MAX;
		bool bit_set = is_bit_set(b_prime[bin], bit);
		if((r <= p && bit_set) || (r <= q && bit_set)) {
			O[bin] = set_bit(b_prime[bin], bit);
		} else {
			O[bin] = clear_bit(b_prime[bin], bit);
		}
	}

}

void initB() {
	memset(&B, 0, sizeof(Map));
	#ifdef ATTACK_A1
	memset(B.pairs[0].key, 1, 32);
	memset(B.pairs[0].value, 1, 32);
	#endif
}

void LDP_DC(uint8_t inp, float f, float p, float q) {
	uint8_t O_prime = inp;
	uint8_t b[32] = {0}, b_prime[32] = {0}, O[32] = {0};
	uint8_t bin, bit;
	// 256-bit vector since O_prime ranges from 0 to 2^8-1=255
	// b <- UE(O_prime)
    UE(O_prime, b);

	// b' <- PRR(b, f, B)
    uint8_t *b_prime_out = PRR(b, f, &B, b_prime);

    // O <- IRR(b', p, q)
    IRR(b_prime_out, p, q, O);

    memcpy(pox_output, O, 32);
}

void LDP_energy(float f, float p, float q) {
	char arr[5];
	//for(;;) {

		// TODO: get actual value from PZEM sensor
		uint8_t energy = SECURE_energy_read();
		//uint8_t energy = (uint8_t)(((float) rand()/RAND_MAX)*255 + 1);
		char buf[20] = {0};
		sprintf(buf, "Energy:%d\n", energy);
		sendline(buf);

		#ifdef ATTACK_A2
		energy += 23;
		#endif

		LDP_DC(energy, f, p, q);

		//break;
	//}

}

void wrapper_LDP_energy() {
	sendline("Running wrapper_LDP_energy\n");
	SECURE_checkState(&B, sizeof(Map));
	float f = *(float*)(pox_input);
	float p = *(float*)(pox_input+4);
	float q = *(float*)(pox_input+4*2);
	LDP_energy(f,p,q);
	SECURE_setState(&B, sizeof(Map));
}

void wrapper_initB() {
	sendline("Running wrapper_initB\n");
	SECURE_checkState(&B, sizeof(Map));
	initB();
	SECURE_setState(&B, sizeof(Map));
}

void print_token(uint8_t *token, int size) {
	char hex[3]={0};
	SECURE_send("0x",2);
	for(int i=0; i<size; i++) {
		sprintf(hex, "%.2x", token[i]);
		SECURE_send(hex, 2);
	}
	SECURE_send("\n", 1);
}

void pox_wrapper() {
	//for(volatile int i=0; i<10000; i++);
	uint8_t req[100]={};
	uint8_t buff[100]={};
	SECURE_recv(req, REQUEST_SIZE);


	sprintf(buff, "wrapper_initB=%p, wrapper_LDP_energy=%p\n", &wrapper_initB, &wrapper_LDP_energy);
	sendline(buff);

	pox_call_t pc;
	pc.input = pox_input;
	pc.output = pox_output;
	pc.command_size = 5; // assume to be fixed
	pc.command = req; // either [stp] or [clt]
	if(memcmp(pc.command, "[stp]", pc.command_size) == 0) {
		uint32_t counter = *((uint32_t*)(req+5));
		uint32_t func = *((uint32_t*)(req+5+4));

		SECURE_send("Rqst ",5);
		SECURE_send(req, REQUEST_SIZE);

		sendline("\n");
		sprintf(buff, "[Test] Setup: counter=%d, func=%x, done [/Test]\n", counter, func);
		sendline(buff);

		uint8_t *token = (uint8_t*) (req+PLAINTEXT_SIZE);

		pc.counter = counter;
		pc.addr = func;
		pc.input_size = 12;
		pc.output_size = 32;
		// pox_input = b'\x00'*12
		memcpy(pc.input, req+5+4*2, pc.input_size);

		SECURE_pox(&pc, token);

		// fault tolerance
		//for(int i=0; i<10; i++) {
		SECURE_send("[OS]", 4);
		SECURE_send(pox_output, 32);
		SECURE_send(" ", 1);
		SECURE_send(token, 32);
		sendline("[OE]\n");
		//}
		sendline("[Over]\n");

		#ifdef ATTACK_A3
		memset(&B, 1, sizeof(Map));
		#endif

	} else if(memcmp(pc.command, "[clt]", pc.command_size) == 0) {
		uint32_t counter = *((uint32_t*)(req+5));
		uint32_t func = *((uint32_t*)(req+5+4));
		float f = *((float*)(req+5+4*2));
		float p = *((float*)(req+5+4*3));
		float q = *((float*)(req+5+4*4));

		sprintf(buff, "[Test] Collect: counter=%d, func=%x, f=%d, p=%d, q=%d done [/Test]\n",
				counter, func, (int) (f*10000), (int) (p*10000), (int) (q*10000));
		sendline(buff);

		uint8_t *token = (uint8_t*) (req+PLAINTEXT_SIZE);

		pc.counter = counter;
		pc.addr = func;
		pc.input_size = 12;
		pc.output_size = 32;
		// pox_input = f, p, q
		memcpy(pox_input, req+5+4*2, 12);

		SECURE_pox(&pc, token);

		// fault tolerance
		//for(int i=0; i<10; i++) {
		SECURE_send("[OS]", 4);
		SECURE_send(pox_output, 32);
		SECURE_send(" ", 1);
		SECURE_send(token, 32);
		sendline("[OE]\n");
		//}
		sendline("[Over]\n");
	} else {
		sprintf(buff, "failed to parse command: %s\n", req);
		sendline(buff);
	}

}


int main(void)
{
  /* USER CODE BEGIN 1 */
  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();

  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Initialize all configured peripherals */
   MX_GPIO_Init();

  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  /* USER CODE BEGIN 2 */
  //register error callbacks
  SECURE_RegisterCallback(SECURE_FAULT_CB_ID, (void *)SecureFault_Callback);
  SECURE_RegisterCallback(GTZC_ERROR_CB_ID, (void *)SecureError_Callback);
  /* USER CODE END 2 */

  uint8_t msg[40] = {0};

  /*for(int i=0; i<numIter; i++) {
	  sprintf(msg, "From NS World: %d/%d\n", i, numIter);
	  print_str(msg);
	  //SECURE_send(msg, sizeof(msg));
  }*/
  srand(time(NULL));

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
  {
    /* USER CODE END WHILE */
	  pox_wrapper();
    /* USER CODE BEGIN 3 */
  }
  /* USER CODE END 3 */
}

/* USER CODE BEGIN 4 */
/* USER CODE END 4 */

/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
  {
  }
  /* USER CODE END Error_Handler_Debug */
}

#ifdef  USE_FULL_ASSERT
/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t *file, uint32_t line)
{
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
     ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */
